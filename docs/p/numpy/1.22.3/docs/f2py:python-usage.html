<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Using F2PY bindings in Python</h1>
               <p>In this page, you can find a full description and a few examples of common usage patterns for F2PY with Python and different argument types. For more examples and use cases, see         <code class='verbatim'>f2py-examples</code>
.</p>


<h1>Fortran type objects</h1>
               <p>All wrappers for Fortran/C routines, common blocks, or for Fortran 90 module data generated by F2PY are exposed to Python as         <code class='verbatim'>fortran</code>
 type objects. Routine wrappers are callable         <code class='verbatim'>fortran</code>
 type objects while wrappers to Fortran data have attributes referring to data objects.</p>

               <p>All         <code class='verbatim'>fortran</code>
 type objects have an attribute         <code class='verbatim'>_cpointer</code>
 that contains a         <code class='verbatim'>CObject</code>
 referring to the C pointer of the corresponding Fortran/C function or variable at the C level. Such         <code class='verbatim'>CObjects</code>
 can be used as callback arguments for F2PY generated functions to bypass the Python C/API layer for calling Python functions from Fortran or C. This can be useful when the computational aspects of such functions are implemented in C or Fortran and wrapped with F2PY (or any other tool capable of providing the         <code class='verbatim'>CObject</code>
 of a function).</p>

               <p>Consider a Fortran 77 file         <code class='verbatim'>`ftype.f</code>
:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/ftype.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and a wrapper built using         <code class='verbatim'>f2py -c ftype.f -m ftype</code>
.</p>

               <p>In Python, you can observe the types of         <code class='verbatim'>foo</code>
 and         <code class='verbatim'>data</code>
, and how to access individual objects of the wrapped Fortran code.</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/ftype_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Scalar arguments</h1>
               <p>In general, a scalar argument for a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to the Fortran routine as a scalar argument.</p>

                           <div class='admonition'>
    <div>note</div>
        <p>* When type - casting is required and there is possible loss of information via narrowing e.g. when type - casting float to integer or complex to float, F2PY *does not* raise an exception. * For complex to real type - casting only the real part of a complex number is used. * ``intent ( inout)`` scalar arguments are assumed to be array objects in order to have *in situ* changes be effective. It is recommended to use arrays with proper type but also other types work. : ref : `Read more about the intent attribute &lt; f2py - attributes&gt;`. </p>

</div>


               <p>Consider the following Fortran 77 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/scalar.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m scalar scalar.f</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/scalar_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>String arguments</h1>
               <p>F2PY generated wrapper functions accept almost any Python object as a string argument, since         <code class='verbatim'>str</code>
 is applied for non-string objects. Exceptions are NumPy arrays that must have type code         <code class='verbatim'>&#39;S1&#39;</code>
 or         <code class='verbatim'>&#39;b&#39;</code>
 (corresponding to the outdated         <code class='verbatim'>&#39;c&#39;</code>
 or         <code class='verbatim'>&#39;1&#39;</code>
 typecodes, respectively) when used as string arguments. See         <code class='verbatim'>arrays.scalars</code>
 for more information on these typecodes.</p>

               <p>A string can have an arbitrary length when used as a string argument for an F2PY generated wrapper function. If the length is greater than expected, the string is truncated silently. If the length is smaller than expected, additional memory is allocated and filled with         <code class='verbatim'>\0</code>
.</p>

                          <code class='not-implemented'>Type Comment (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Comment: 
   |value: &#39;.. TODO: review this section once https://github.com/numpy/numpy/pull/19388 is merged.&#39;
   |&gt;</pre>
               <p>Because Python strings are immutable, an         <code class='verbatim'>intent(inout)</code>
 argument expects an array version of a string in order to have <em>in situ</em> changes be effective.</p>

               <p>Consider the following Fortran 77 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/string.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m mystring string.f</code>
.</p>

               <p>Python session:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/string_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Array arguments</h1>
               <p>In general, array arguments for F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. There are two notable exceptions:</p>

                          <ul>               <li>               <p>        <code class='verbatim'>intent(inout)</code>
 array arguments must always be           <code class='verbatim'>proper-contiguous &lt;contiguous&gt;</code>
 and have a compatible         <code class='verbatim'>dtype</code>
,   otherwise an exception is raised.</p>

</li>
               <li>               <p>        <code class='verbatim'>intent(inplace)</code>
 array arguments  will be changed <em>in situ</em> if the argument   has a different type than expected (see the         <code class='verbatim'>intent(inplace)</code>
           <code class='verbatim'>attribute &lt;f2py-attributes&gt;</code>
 for more information).</p>

</li>
            </ul>

               <p>In general, if a NumPy array is         <code class='verbatim'>proper-contiguous &lt;contiguous&gt;</code>
 and has a proper type then it is directly passed to the wrapped Fortran/C function. Otherwise, an element-wise copy of the input array is made and the copy, being proper-contiguous and with proper type, is used as the array argument.</p>

               <p>Usually there is no need to worry about how the arrays are stored in memory and whether the wrapped functions, being either Fortran or C functions, assume one or another storage order. F2PY automatically ensures that wrapped functions get arguments with the proper storage order; the underlying algorithm is designed to make copies of arrays only when absolutely necessary. However, when dealing with very large multidimensional input arrays with sizes close to the size of the physical memory in your computer, then care must be taken to ensure the usage of proper-contiguous and proper type arguments.</p>

               <p>To transform input arrays to column major storage order before passing them to Fortran routines, use the function <code><a link href="/p/numpy/*/api/numpy.asfortranarray.html" class='exists'>numpy.asfortranarray</a></code>
.</p>

               <p>Consider the following Fortran 77 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/array.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m arr array.f -DF2PY_REPORT_ON_ARRAY_COPY=1</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/array_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _Call-back arguments:&#39;&gt;</pre>

<h1>Call-back arguments</h1>
               <p>F2PY supports calling Python functions from Fortran or C codes.</p>

               <p>Consider the following Fortran 77 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/callback.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m callback callback.f</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/callback_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>In the above example F2PY was able to guess accurately the signature of the call-back function. However, sometimes F2PY cannot establish the appropriate signature; in these cases the signature of the call-back function must be explicitly defined in the signature file.</p>

               <p>To facilitate this, signature files may contain special modules (the names of these modules contain the special         <code class='verbatim'>__user__</code>
 sub-string) that define the various signatures for call-back functions.  Callback arguments in routine signatures have the         <code class='verbatim'>external</code>
 attribute (see also the         <code class='verbatim'>intent(callback)</code>
         <code class='verbatim'>attribute &lt;f2py-attributes&gt;</code>
). To relate a callback argument with its signature in a         <code class='verbatim'>__user__</code>
 module block, a         <code class='verbatim'>use</code>
 statement can be utilized as illustrated below. The same signature for a callback argument can be referred to in different routine signatures.</p>

               <p>We use the same Fortran 77 code as in the previous example but now we will pretend that F2PY was not able to guess the signatures of call-back arguments correctly. First, we create an initial signature file         <code class='verbatim'>callback2.pyf</code>
 using F2PY::      </p>

               <pre>f2py -m callback2 -h callback2.pyf callback.f</pre>
               <p>Then modify it as follows</p>

               <div class='block_directive'>
    <div class='head'>.. include:: [&#39;./code/callback2.pyf&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>Finally, we build the extension module using         <code class='verbatim'>f2py -c callback2.pyf callback.f</code>
.</p>

               <p>An example Python session for this snippet would be identical to the previous example except that the argument names would differ.</p>

               <p>Sometimes a Fortran package may require that users provide routines that the package will use. F2PY can construct an interface to such routines so that Python functions can be called from Fortran.</p>

               <p>Consider the following Fortran 77 subroutine that takes an array as its input and applies a function         <code class='verbatim'>func</code>
 to its elements.</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/calculate.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>The Fortran code expects that the function         <code class='verbatim'>func</code>
 has been defined externally. In order to use a Python function for         <code class='verbatim'>func</code>
, it must have an attribute         <code class='verbatim'>intent(callback)</code>
 and it must be specified before the         <code class='verbatim'>external</code>
 statement.</p>

               <p>Finally, build an extension module using         <code class='verbatim'>f2py -c -m foo calculate.f</code>
</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/calculate_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>The function is included as an argument to the python function call to the Fortran subroutine even though it was <em>not</em> in the Fortran subroutine argument list. The &#34;external&#34; keyword refers to the C function generated by f2py, not the Python function itself. The python function is essentially being supplied to the C function.</p>

               <p>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the Python callback function is itself called by another Fortran function.</p>

               <p>Consider the following Fortran 77 subroutine:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/extcallback.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m pfromf extcallback.f</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/extcallback_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Resolving arguments to call-back functions</h1>
               <p>F2PY generated interfaces are very flexible with respect to call-back arguments.  For each call-back argument an additional optional argument         <code class='verbatim'>&lt;name&gt;_extra_args</code>
 is introduced by F2PY. This argument can be used to pass extra arguments to user provided call-back functions.</p>

               <p>If a F2PY generated wrapper function expects the following call-back argument::    </p>

               <pre>def fun(a_1,...,a_n):
   ...
   return x_1,...,x_k</pre>
               <p>but the following Python function</p>

               <pre>def gun(b_1,...,b_m):
   ...
   return y_1,...,y_l</pre>
               <p>is provided by a user, and in addition,</p>

               <pre>fun_extra_args = (e_1,...,e_p)</pre>
               <p>is used, then the following rules are applied when a Fortran or C function evaluates the call-back argument         <code class='verbatim'>gun</code>
:</p>

                          <ul>               <li>               <p>If         <code class='verbatim'>p == 0</code>
 then         <code class='verbatim'>gun(a_1, ..., a_q)</code>
 is called, here           <code class='verbatim'>q = min(m, n)</code>
.</p>

</li>
               <li>               <p>If         <code class='verbatim'>n + p &lt;= m</code>
 then         <code class='verbatim'>gun(a_1, ..., a_n, e_1, ..., e_p)</code>
 is called.</p>

</li>
               <li>               <p>If         <code class='verbatim'>p &lt;= m &lt; n + p</code>
 then         <code class='verbatim'>gun(a_1, ..., a_q, e_1, ..., e_p)</code>
 is called,   and here         <code class='verbatim'>q=m-p</code>
.</p>

</li>
               <li>               <p>If         <code class='verbatim'>p &gt; m</code>
 then         <code class='verbatim'>gun(e_1, ..., e_m)</code>
 is called.</p>

</li>
               <li>               <p>If         <code class='verbatim'>n + p</code>
 is less than the number of required arguments to         <code class='verbatim'>gun</code>
 then an   exception is raised.</p>

</li>
            </ul>

               <p>If the function         <code class='verbatim'>gun</code>
 may return any number of objects as a tuple; then the following rules are applied:</p>

                          <ul>               <li>               <p>If         <code class='verbatim'>k &lt; l</code>
, then         <code class='verbatim'>y_{k + 1}, ..., y_l</code>
 are ignored.</p>

</li>
               <li>               <p>If         <code class='verbatim'>k &gt; l</code>
, then only         <code class='verbatim'>x_1, ..., x_l</code>
 are set.</p>

</li>
            </ul>


<h1>Common blocks</h1>
               <p>F2PY generates wrappers to         <code class='verbatim'>common</code>
 blocks defined in a routine signature block. Common blocks are visible to all Fortran codes linked to the current extension module, but not to other extension modules (this restriction is due to the way Python imports shared libraries). In Python, the F2PY wrappers to         <code class='verbatim'>common</code>
 blocks are         <code class='verbatim'>fortran</code>
 type objects that have (dynamic) attributes related to the data members of the common blocks. When accessed, these attributes return as NumPy array objects (multidimensional arrays are Fortran-contiguous) which directly link to data members in common blocks. Data members can be changed by direct assignment or by in-place changes to the corresponding array objects.</p>

               <p>Consider the following Fortran 77 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/common.f&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m common common.f</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/common_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Fortran 90 module data</h1>
               <p>The F2PY interface to Fortran 90 module data is similar to the handling of Fortran 77 common blocks.</p>

               <p>Consider the following Fortran 90 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/moddata.f90&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m moddata moddata.f90</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/moddata_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Allocatable arrays</h1>
               <p>F2PY has basic support for Fortran 90 module allocatable arrays.</p>

               <p>Consider the following Fortran 90 code:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/allocarr.f90&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <p>and wrap it using         <code class='verbatim'>f2py -c -m allocarr allocarr.f90</code>
.</p>

               <p>In Python:</p>

               <div class='block_directive'>
    <div class='head'>.. literalinclude:: [&#39;./code/results/allocarr_session.dat&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. currentmodule:: numpy.random
    </pre>



<h1>Bit Generators</h1>
               <p>The random values produced by         <code class='verbatim'>~Generator</code>
 originate in a BitGenerator.  The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., <a link href="https://numba.pydata.org" class='external'>numba</a>.</p>


<h1>Supported BitGenerators</h1>
               <p>The included BitGenerators are:</p>

                          <ul>               <li>               <p>PCG-64 - The default. A fast generator that can be advanced by an arbitrary   amount. See the documentation for         <code class='verbatim'>~.PCG64.advance</code>
. PCG-64 has   a period of         <span class="tex2jax_process">$2^{128}$</span>
. See the <code class='not-implemented'>:None:None:`PCG author&#39;s page`</code> for more details   about this class of PRNG.</p>

</li>
               <li>               <p>PCG-64 DXSM - An upgraded version of PCG-64 with better statistical   properties in parallel contexts. See         <code class='verbatim'>upgrading-pcg64</code>
 for more   information on these improvements.</p>

</li>
               <li>               <p>MT19937 - The standard Python BitGenerator. Adds a <code class='not-implemented'>:None:None:`MT19937.jumped`</code>   function that returns a new generator with state as-if         <span class="tex2jax_process">$2^{128}$</span>
 draws have   been made.</p>

</li>
               <li>               <p>Philox - A counter-based generator capable of being advanced an   arbitrary number of steps or generating independent streams. See the   <code class='not-implemented'>:None:None:`Random123`</code> page for more details about this class of bit generators.</p>

</li>
               <li>               <p>SFC64 - A fast generator based on random invertible mappings. Usually the   fastest generator of the four. See the <code class='not-implemented'>:None:None:`SFC author&#39;s page`</code> for (a little)   more detail.</p>

</li>
            </ul>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#34;.. _`PCG author&#39;s page`: http://www.pcg-random.org/&#34;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`Random123`: https://www.deshawresearch.com/resources_random123.html&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#34;.. _`SFC author&#39;s page`: http://pracrand.sourceforge.net/RNG_engines.txt&#34;&gt;
           </pre>

               <pre>.. autosummary:: 
    :toctree:generated/
    BitGenerator</pre>
               <pre class='not-implemented'>
.. toctree:: 
    (&#39;maxdepth&#39;, &#39;1&#39;)
    MT19937 &lt;mt19937&gt;
    PCG64 &lt;pcg64&gt;
    PCG64DXSM &lt;pcg64dxsm&gt;
    Philox &lt;philox&gt;
    SFC64 &lt;sfc64&gt;</pre>



<h1>Seeding and Entropy</h1>
               <p>A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to <code class='not-implemented'>:None:None:`SeedSequence`</code>, which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states.</p>

               <pre class='not-implemented'>
.. code-block:: python
    from numpy.random import PCG64

    bg = PCG64(12345678903141592653589793)</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;.. end_block&#39;
   |&gt;
           </pre>

               <p><code class='not-implemented'>:None:None:`~SeedSequence`</code> is designed to be convenient for implementing best practices. We recommend that a stochastic program defaults to using entropy from the OS so that each run is different. The program should print out or log that entropy. In order to reproduce a past value, the program should allow the user to provide that value through some mechanism, a command-line argument is common, so that the user can then re-enter that entropy to reproduce the result. <code class='not-implemented'>:None:None:`~SeedSequence`</code> can take care of everything except for communicating with the user, which is up to you.</p>

               <pre class='not-implemented'>
.. code-block:: python
    from numpy.random import PCG64, SeedSequence

    # Get the user&#39;s seed somehow, maybe through `argparse`.
    # If the user did not provide a seed, it should return `None`.
    seed = get_user_seed()
    ss = SeedSequence(seed)
    print(&#39;seed = {}&#39;.format(ss.entropy))
    bg = PCG64(ss)</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;.. end_block&#39;
   |&gt;
           </pre>

               <p>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</p>

               <p>There will not be anything <em>wrong</em> with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that <code class='not-implemented'>:None:None:`~SeedSequence`</code> does. If you just need <em>some</em> fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</p>

               <p>If you need to generate a good seed &#34;offline&#34;, then         <code class='verbatim'>SeedSequence().entropy</code>
 or using         <code class='verbatim'>secrets.randbits(128)</code>
 from the standard library are both convenient ways.</p>

               <p>If you need to run several stochastic simulations in parallel, best practice is to construct a random generator instance for each simulation.  To make sure that the random streams have distinct initial states, you can use the <code class='not-implemented'>:None:None:`spawn`</code> method of <code class='not-implemented'>:None:None:`~SeedSequence`</code>. For instance, here we construct a list of 12 instances:</p>

               <pre class='not-implemented'>
.. code-block:: python
    from numpy.random import PCG64, SeedSequence

    # High quality initial entropy
    entropy = 0x87351080e25cb0fad77a44a3be03b491
    base_seq = SeedSequence(entropy)
    child_seqs = base_seq.spawn(12)    # a list of 12 SeedSequences
    generators = [PCG64(seq) for seq in child_seqs]</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;.. end_block&#39;
   |&gt;
           </pre>

               <p>An alternative way is to use the fact that a <code class='not-implemented'>:None:None:`~SeedSequence`</code> can be initialized by a tuple of elements. Here we use a base entropy value and an integer         <code class='verbatim'>worker_id</code>
</p>

               <pre class='not-implemented'>
.. code-block:: python
    from numpy.random import PCG64, SeedSequence

    # High quality initial entropy
    entropy = 0x87351080e25cb0fad77a44a3be03b491    
    sequences = [SeedSequence((entropy, worker_id)) for worker_id in range(12)]
    generators = [PCG64(seq) for seq in sequences]</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;.. end_block&#39;
   |&gt;
           </pre>

               <p>Note that the sequences produced by the latter method will be distinct from those constructed via <code class='not-implemented'>:None:None:`~SeedSequence.spawn`</code>.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    SeedSequence</pre>

<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
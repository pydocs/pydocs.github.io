<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <div class='block_directive'>
    <div class='head'>.. currentmodule:: []
    </div>
    <pre class='not-implemented'><p>numpy </p>
</pre>
</div>



<h1>NumPy 1.20.0 Release Notes</h1>
               <p>This NumPy release is the largest so made to date, some 684 PRs contributed by 184 people have been merged. See the list of highlights below for more details. The Python versions supported for this release are 3.7-3.9, support for Python 3.6 has been dropped. Highlights are</p>

                          <ul>               <li>               <p>Annotations for NumPy functions. This work is ongoing and improvements can   be expected pending feedback from users.</p>

</li>
            </ul>

                          <ul>               <li>               <p>Wider use of SIMD to increase execution speed of ufuncs. Much work has been   done in introducing universal functions that will ease use of modern   features across different hardware platforms. This work is ongoing.</p>

</li>
            </ul>

                          <ul>               <li>               <p>Preliminary work in changing the dtype and casting implementations in order to   provide an easier path to extending dtypes. This work is ongoing but enough   has been done to allow experimentation and feedback.</p>

</li>
            </ul>

                          <ul>               <li>               <p>Extensive documentation improvements comprising some 185 PR merges. This work   is ongoing and part of the larger project to improve NumPy&#39;s online presence   and usefulness to new users.</p>

</li>
            </ul>

                          <ul>               <li>               <p>Further cleanups related to removing Python 2.7. This improves code   readability and removes technical debt.</p>

</li>
            </ul>

                          <ul>               <li>               <p>Preliminary support for the upcoming Cython 3.0.</p>

</li>
            </ul>


<h1>New functions</h1>

<h1>The random.Generator class has a new ``permuted`` function.</h1>
               <p>The new function differs from         <code class='verbatim'>shuffle</code>
 and         <code class='verbatim'>permutation</code>
 in that the subarrays indexed by an axis are permuted rather than the axis being treated as a separate 1-D array for every combination of the other indexes. For example, it is now possible to permute the rows or columns of a 2-D array.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15121" class='external'>gh-15121</a>)</p>


<h1>``sliding_window_view`` provides a sliding window view for numpy arrays</h1>
               <p><code><a link href="/p/numpy/*/api/numpy.lib.stride_tricks.sliding_window_view.html" class='exists'>numpy.lib.stride_tricks.sliding_window_view</a></code>
 constructs views on numpy arrays that offer a sliding or moving window access to the array. This allows for the simple implementation of certain algorithms, such as running means.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17394" class='external'>gh-17394</a>)</p>


<h1>`numpy.broadcast_shapes` is a new user-facing function</h1>
               <p><code><a link href="/p/numpy/*/api/numpy.broadcast_shapes.html" class='exists'>broadcast_shapes</a></code>
 gets the resulting shape from broadcasting the given shape tuples against each other.</p>

               <div class='block_directive'>
    <div class='head'>.. code:: [&#39;python&#39;]
    </div>
    <pre class='not-implemented'><p>&gt;&gt;&gt; np.broadcast_shapes ( ( 1, 2), ( 3, 1)) ( 3, 2) &gt;&gt;&gt; np.broadcast_shapes ( 2, ( 3, 1)) ( 3, 2) &gt;&gt;&gt; np.broadcast_shapes ( ( 6, 7), ( 5, 6, 1), ( 7,), ( 5, 1, 7)) ( 5, 6, 7) </p>
</pre>
</div>


               <p>(<a link href="https://github.com/numpy/numpy/pull/17535" class='external'>gh-17535</a>)</p>


<h1>Deprecations</h1>

<h1>Using the aliases of builtin types like ``np.int`` is deprecated</h1>
               <p>For a long time,         <code class='verbatim'>np.int</code>
 has been an alias of the builtin         <code class='verbatim'>int</code>
. This is repeatedly a cause of confusion for newcomers, and existed mainly for historic reasons.</p>

               <p>These aliases have been deprecated. The table below shows the full list of deprecated aliases, along with their exact meaning. Replacing uses of items in the first column with the contents of the second column will work identically and silence the deprecation warning.</p>

               <p>The third column lists alternative NumPy names which may occasionally be preferential. See also         <code class='verbatim'>basics.types</code>
 for additional details.</p>

               <p>=================  ============  ================================================================== Deprecated name    Identical to  NumPy scalar type names =================  ============  ==================================================================         <code class='verbatim'>numpy.bool</code>
             <code class='verbatim'>bool</code>
      <code><a link href="/p/numpy/*/api/numpy.bool_.html" class='exists'>numpy.bool_</a></code>
         <code class='verbatim'>numpy.int</code>
              <code class='verbatim'>int</code>
       <code><a link href="/p/numpy/*/api/numpy.int64.html" class='exists'>numpy.int_</a></code>
 (default),         <code class='verbatim'>numpy.int64</code>
, or         <code class='verbatim'>numpy.int32</code>
         <code class='verbatim'>numpy.float</code>
            <code class='verbatim'>float</code>
     <code><a link href="/p/numpy/*/api/numpy.float64.html" class='exists'>numpy.float64</a></code>
, <code><a link href="/p/numpy/*/api/numpy.float64.html" class='exists'>numpy.float_</a></code>
, <code><a link href="/p/numpy/*/api/numpy.float64.html" class='exists'>numpy.double</a></code>
 (equivalent)         <code class='verbatim'>numpy.complex</code>
          <code class='verbatim'>complex</code>
   <code><a link href="/p/numpy/*/api/numpy.complex128.html" class='exists'>numpy.complex128</a></code>
, <code><a link href="/p/numpy/*/api/numpy.complex128.html" class='exists'>numpy.complex_</a></code>
, <code><a link href="/p/numpy/*/api/numpy.complex128.html" class='exists'>numpy.cdouble</a></code>
 (equivalent)         <code class='verbatim'>numpy.object</code>
           <code class='verbatim'>object</code>
    <code><a link href="/p/numpy/*/api/numpy.object_.html" class='exists'>numpy.object_</a></code>
         <code class='verbatim'>numpy.str</code>
              <code class='verbatim'>str</code>
       <code><a link href="/p/numpy/*/api/numpy.str_.html" class='exists'>numpy.str_</a></code>
         <code class='verbatim'>numpy.long</code>
             <code class='verbatim'>int</code>
       <code><a link href="/p/numpy/*/api/numpy.int64.html" class='exists'>numpy.int_</a></code>
 (C         <code class='verbatim'>long</code>
), <code><a link href="/p/numpy/*/api/numpy.longlong.html" class='exists'>numpy.longlong</a></code>
 (largest integer type)         <code class='verbatim'>numpy.unicode</code>
          <code class='verbatim'>str</code>
       <code><a link href="/p/numpy/*/api/numpy.str_.html" class='exists'>numpy.unicode_</a></code>
 =================  ============  ==================================================================</p>

               <p>To give a clear guideline for the vast majority of cases, for the types         <code class='verbatim'>bool</code>
,         <code class='verbatim'>object</code>
,         <code class='verbatim'>str</code>
 (and         <code class='verbatim'>unicode</code>
) using the plain version is shorter and clear, and generally a good replacement. For         <code class='verbatim'>float</code>
 and         <code class='verbatim'>complex</code>
 you can use         <code class='verbatim'>float64</code>
 and         <code class='verbatim'>complex128</code>
 if you wish to be more explicit about the precision.</p>

               <p>For         <code class='verbatim'>np.int</code>
 a direct replacement with         <code class='verbatim'>np.int_</code>
 or         <code class='verbatim'>int</code>
 is also good and will not change behavior, but the precision will continue to depend on the computer and operating system. If you want to be more explicit and review the current use, you have the following alternatives:</p>

                          <ul>               <li>               <p>        <code class='verbatim'>np.int64</code>
 or         <code class='verbatim'>np.int32</code>
 to specify the precision exactly.   This ensures that results cannot depend on the computer or operating system.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.int_</code>
 or         <code class='verbatim'>int</code>
 (the default), but be aware that it depends on   the computer and operating system.</p>

</li>
               <li>               <p>The C types:         <code class='verbatim'>np.cint</code>
 (int),         <code class='verbatim'>np.int_</code>
 (long),         <code class='verbatim'>np.longlong</code>
.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.intp</code>
 which is 32bit on 32bit machines 64bit on 64bit machines.   This can be the best type to use for indexing.</p>

</li>
            </ul>

               <p>When used with         <code class='verbatim'>np.dtype(...)</code>
 or         <code class='verbatim'>dtype=...</code>
 changing it to the NumPy name as mentioned above will have no effect on the output. If used as a scalar with::      </p>

               <pre>np.float(123)</pre>
               <p>changing it can subtly change the result.  In this case, the Python version         <code class='verbatim'>float(123)</code>
 or         <code class='verbatim'>int(12.)</code>
 is normally preferable, although the NumPy version may be useful for consistency with NumPy arrays (for example, NumPy behaves differently for things like division by zero).</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/14882" class='external'>gh-14882</a>)</p>


<h1>Passing ``shape=None`` to functions with a non-optional shape argument is deprecated</h1>
               <p>Previously, this was an alias for passing         <code class='verbatim'>shape=()</code>
. This deprecation is emitted by <code>:None:None:`PyArray_IntpConverter`</code> in the C API. If your API is intended to support passing         <code class='verbatim'>None</code>
, then you should check for         <code class='verbatim'>None</code>
 prior to invoking the converter, so as to be able to distinguish         <code class='verbatim'>None</code>
 and         <code class='verbatim'>()</code>
.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15886" class='external'>gh-15886</a>)</p>


<h1>Indexing errors will be reported even when index result is empty</h1>
               <p>In the future, NumPy will raise an IndexError when an integer array index contains out of bound values even if a non-indexed dimension is of length 0. This will now emit a DeprecationWarning. This can happen when the array is previously empty, or an empty slice is involved::      </p>

               <pre>arr1 = np.zeros((5, 0))
arr1[[20]]
arr2 = np.zeros((5, 5))
arr2[[20], :0]</pre>
               <p>Previously the non-empty index         <code class='verbatim'>[20]</code>
 was not checked for correctness. It will now be checked causing a deprecation warning which will be turned into an error. This also applies to assignments.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15900" class='external'>gh-15900</a>)</p>


<h1>Inexact matches for ``mode`` and ``searchside`` are deprecated</h1>
               <p>Inexact and case insensitive matches for         <code class='verbatim'>mode</code>
 and         <code class='verbatim'>searchside</code>
 were valid inputs earlier and will give a DeprecationWarning now.  For example, below are some example usages which are now deprecated and will give a DeprecationWarning::      </p>

               <pre>import numpy as np
arr = np.array([[3, 6, 6], [4, 5, 1]])
# mode: inexact match
np.ravel_multi_index(arr, (7, 6), mode=&#34;clap&#34;)  # should be &#34;clip&#34;
# searchside: inexact match
np.searchsorted(arr[0], 4, side=&#39;random&#39;)  # should be &#34;right&#34;</pre>
               <p>(<a link href="https://github.com/numpy/numpy/pull/16056" class='external'>gh-16056</a>)</p>


<h1>Deprecation of `numpy.dual`</h1>
               <p>The module <code><a link href="/p/numpy/*/api/numpy.dual.html" class='exists'>numpy.dual</a></code>
 is deprecated.  Instead of importing functions from <code><a link href="/p/numpy/*/api/numpy.dual.html" class='exists'>numpy.dual</a></code>
, the functions should be imported directly from NumPy or SciPy.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16156" class='external'>gh-16156</a>)</p>


<h1>``outer`` and ``ufunc.outer`` deprecated for matrix</h1>
               <p>        <code class='verbatim'>np.matrix</code>
 use with <code><a link href="/p/numpy/*/api/numpy.outer.html" class='exists'>outer</a></code>
 or generic ufunc outer calls such as         <code class='verbatim'>numpy.add.outer</code>
. Previously, matrix was converted to an array here. This will not be done in the future requiring a manual conversion to arrays.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16232" class='external'>gh-16232</a>)</p>


<h1>Further Numeric Style types Deprecated</h1>
               <p>The remaining numeric-style type codes         <code class='verbatim'>Bytes0</code>
,         <code class='verbatim'>Str0</code>
,         <code class='verbatim'>Uint32</code>
,         <code class='verbatim'>Uint64</code>
, and         <code class='verbatim'>Datetime64</code>
 have been deprecated.  The lower-case variants should be used instead.  For bytes and string         <code class='verbatim'>&#34;S&#34;</code>
 and         <code class='verbatim'>&#34;U&#34;</code>
 are further alternatives.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16554" class='external'>gh-16554</a>)</p>


<h1>The ``ndincr`` method of ``ndindex`` is deprecated</h1>
               <p>The documentation has warned against using this function since NumPy 1.8. Use         <code class='verbatim'>next(it)</code>
 instead of         <code class='verbatim'>it.ndincr()</code>
.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17233" class='external'>gh-17233</a>)</p>


<h1>ArrayLike objects which do not define ``__len__`` and ``__getitem__``</h1>
               <p>Objects which define one of the protocols         <code class='verbatim'>__array__</code>
,         <code class='verbatim'>__array_interface__</code>
, or         <code class='verbatim'>__array_struct__</code>
 but are not sequences (usually defined by having a         <code class='verbatim'>__len__</code>
 and         <code class='verbatim'>__getitem__</code>
) will behave differently during array-coercion in the future.</p>

               <p>When nested inside sequences, such as         <code class='verbatim'>np.array([array_like])</code>
, these were handled as a single Python object rather than an array. In the future they will behave identically to::      </p>

               <pre>np.array([np.array(array_like)])</pre>
               <p>This change should only have an effect if         <code class='verbatim'>np.array(array_like)</code>
 is not 0-D. The solution to this warning may depend on the object:</p>

                          <ul>               <li>               <p>Some array-likes may expect the new behaviour, and users can ignore the   warning.  The object can choose to expose the sequence protocol to opt-in   to the new behaviour.</p>

</li>
               <li>               <p>For example,         <code class='verbatim'>shapely</code>
 will allow conversion to an array-like using           <code class='verbatim'>line.coords</code>
 rather than         <code class='verbatim'>np.asarray(line)</code>
. Users may work around   the warning, or use the new convention when it becomes available.</p>

</li>
            </ul>

               <p>Unfortunately, using the new behaviour can only be achieved by calling         <code class='verbatim'>np.array(array_like)</code>
.</p>

               <p>If you wish to ensure that the old behaviour remains unchanged, please create an object array and then fill it explicitly, for example::      </p>

               <pre>arr = np.empty(3, dtype=object)
arr[:] = [array_like1, array_like2, array_like3]</pre>
               <p>This will ensure NumPy knows to not enter the array-like and use it as a object instead.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17973" class='external'>gh-17973</a>)</p>


<h1>Future Changes</h1>

<h1>Arrays cannot be using subarray dtypes</h1>
               <p>Array creation and casting using         <code class='verbatim'>np.array(arr, dtype)</code>
 and         <code class='verbatim'>arr.astype(dtype)</code>
 will use different logic when         <code class='verbatim'>dtype</code>
 is a subarray dtype such as         <code class='verbatim'>np.dtype(&#34;(2)i,&#34;)</code>
.</p>

               <p>For such a         <code class='verbatim'>dtype</code>
 the following behaviour is true::      </p>

               <pre>res = np.array(arr, dtype)

res.dtype is not dtype
res.dtype is dtype.base
res.shape == arr.shape + dtype.shape</pre>
               <p>But         <code class='verbatim'>res</code>
 is filled using the logic::      </p>

               <pre>res = np.empty(arr.shape + dtype.shape, dtype=dtype.base)
res[...] = arr</pre>
               <p>which uses incorrect broadcasting (and often leads to an error). In the future, this will instead cast each element individually, leading to the same result as::      </p>

               <pre>res = np.array(arr, dtype=np.dtype([&#34;f&#34;, dtype]))[&#34;f&#34;]</pre>
               <p>Which can normally be used to opt-in to the new behaviour.</p>

               <p>This change does not affect         <code class='verbatim'>np.array(list, dtype=&#34;(2)i,&#34;)</code>
 unless the         <code class='verbatim'>list</code>
 itself includes at least one array.  In particular, the behaviour is unchanged for a list of tuples.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17596" class='external'>gh-17596</a>)</p>


<h1>Expired deprecations</h1>
                          <ul>               <li>               <p>The deprecation of numeric style type-codes         <code class='verbatim'>np.dtype(&#34;Complex64&#34;)</code>
   (with upper case spelling), is expired.          <code class='verbatim'>&#34;Complex64&#34;</code>
 corresponded to           <code class='verbatim'>&#34;complex128&#34;</code>
 and         <code class='verbatim'>&#34;Complex32&#34;</code>
 corresponded to         <code class='verbatim'>&#34;complex64&#34;</code>
.</p>

</li>
               <li>               <p>The deprecation of         <code class='verbatim'>np.sctypeNA</code>
 and         <code class='verbatim'>np.typeNA</code>
 is expired. Both   have been removed from the public API. Use         <code class='verbatim'>np.typeDict</code>
 instead.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16554" class='external'>gh-16554</a>)</p>

</li>
            </ul>

                          <ul>               <li>               <p>The 14-year deprecation of         <code class='verbatim'>np.ctypeslib.ctypes_load_library</code>
 is expired.   Use         <code class='verbatim'>~numpy.ctypeslib.load_library</code>
 instead, which is identical.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17116" class='external'>gh-17116</a>)</p>

</li>
            </ul>


<h1>Financial functions removed</h1>
               <p>In accordance with NEP 32, the financial functions are removed from NumPy 1.20. The functions that have been removed are         <code class='verbatim'>fv</code>
,         <code class='verbatim'>ipmt</code>
,         <code class='verbatim'>irr</code>
,         <code class='verbatim'>mirr</code>
,         <code class='verbatim'>nper</code>
,         <code class='verbatim'>npv</code>
,         <code class='verbatim'>pmt</code>
,         <code class='verbatim'>ppmt</code>
,         <code class='verbatim'>pv</code>
, and         <code class='verbatim'>rate</code>
.  These functions are available in the <a link href="https://pypi.org/project/numpy-financial" class='external'>numpy_financial</a> library.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17067" class='external'>gh-17067</a>)</p>


<h1>Compatibility notes</h1>

<h1>``isinstance(dtype, np.dtype)`` and not ``type(dtype) is not np.dtype``</h1>
               <p>NumPy dtypes are not direct instances of         <code class='verbatim'>np.dtype</code>
 anymore.  Code that may have used         <code class='verbatim'>type(dtype) is np.dtype</code>
 will always return         <code class='verbatim'>False</code>
 and must be updated to use the correct version         <code class='verbatim'>isinstance(dtype, np.dtype)</code>
.</p>

               <p>This change also affects the C-side macro         <code class='verbatim'>PyArray_DescrCheck</code>
 if compiled against a NumPy older than 1.16.6. If code uses this macro and wishes to compile against an older version of NumPy, it must replace the macro (see also <code>:None:None:`C API changes`</code> section).</p>


<h1>Same kind casting in concatenate with ``axis=None``</h1>
               <p>When <code><a link href="/p/numpy/*/api/numpy.concatenate.html" class='exists'>concatenate</a></code>
 is called with         <code class='verbatim'>axis=None</code>
, the flattened arrays were cast with         <code class='verbatim'>unsafe</code>
. Any other axis choice uses &#34;same kind&#34;. That different default has been deprecated and &#34;same kind&#34; casting will be used instead. The new         <code class='verbatim'>casting</code>
 keyword argument can be used to retain the old behaviour.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16134" class='external'>gh-16134</a>)</p>


<h1>NumPy Scalars are cast when assigned to arrays</h1>
               <p>When creating or assigning to arrays, in all relevant cases NumPy scalars will now be cast identically to NumPy arrays.  In particular this changes the behaviour in some cases which previously raised an error::      </p>

               <pre>np.array([np.float64(np.nan)], dtype=np.int64)</pre>
               <p>will succeed and return an undefined result (usually the smallest possible integer).  This also affects assignments::      </p>

               <pre>arr[0] = np.float64(np.nan)</pre>
               <p>At this time, NumPy retains the behaviour for::      </p>

               <pre>np.array(np.float64(np.nan), dtype=np.int64)</pre>
               <p>The above changes do not affect Python scalars::      </p>

               <pre>np.array([float(&#34;NaN&#34;)], dtype=np.int64)</pre>
               <p>remains unaffected (        <code class='verbatim'>np.nan</code>
 is a Python         <code class='verbatim'>float</code>
, not a NumPy one). Unlike signed integers, unsigned integers do not retain this special case, since they always behaved more like casting. The following code stops raising an error::      </p>

               <pre>np.array([np.float64(np.nan)], dtype=np.uint64)</pre>
               <p>To avoid backward compatibility issues, at this time assignment from         <code class='verbatim'>datetime64</code>
 scalar to strings of too short length remains supported. This means that         <code class='verbatim'>np.asarray(np.datetime64(&#34;2020-10-10&#34;), dtype=&#34;S5&#34;)</code>
 succeeds now, when it failed before.  In the long term this may be deprecated or the unsafe cast may be allowed generally to make assignment of arrays and scalars behave consistently.</p>


<h1>Array coercion changes when Strings and other types are mixed</h1>
               <p>When strings and other types are mixed, such as::      </p>

               <pre>np.array([&#34;string&#34;, np.float64(3.)], dtype=&#34;S&#34;)</pre>
               <p>The results will change, which may lead to string dtypes with longer strings in some cases.  In particularly, if         <code class='verbatim'>dtype=&#34;S&#34;</code>
 is not provided any numerical value will lead to a string results long enough to hold all possible numerical values. (e.g. &#34;S32&#34; for floats).  Note that you should always provide         <code class='verbatim'>dtype=&#34;S&#34;</code>
 when converting non-strings to strings.</p>

               <p>If         <code class='verbatim'>dtype=&#34;S&#34;</code>
 is provided the results will be largely identical to before, but NumPy scalars (not a Python float like         <code class='verbatim'>1.0</code>
), will still enforce a uniform string length::      </p>

               <pre>np.array([np.float64(3.)], dtype=&#34;S&#34;)  # gives &#34;S32&#34;
np.array([3.0], dtype=&#34;S&#34;)  # gives &#34;S3&#34;</pre>
               <p>Previously the first version gave the same result as the second.</p>


<h1>Array coercion restructure</h1>
               <p>Array coercion has been restructured.  In general, this should not affect users.  In extremely rare corner cases where array-likes are nested::      </p>

               <pre>np.array([array_like1])</pre>
               <p>Things will now be more consistent with::      </p>

               <pre>np.array([np.array(array_like1)])</pre>
               <p>This can subtly change output for some badly defined array-likes. One example for this are array-like objects which are not also sequences of matching shape. In NumPy 1.20, a warning will be given when an array-like is not also a sequence (but behaviour remains identical, see deprecations). If an array like is also a sequence (defines         <code class='verbatim'>__getitem__</code>
 and         <code class='verbatim'>__len__</code>
) NumPy will now only use the result given by         <code class='verbatim'>__array__</code>
,         <code class='verbatim'>__array_interface__</code>
, or         <code class='verbatim'>__array_struct__</code>
. This will result in differences when the (nested) sequence describes a different shape.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16200" class='external'>gh-16200</a>)</p>


<h1>Writing to the result of `numpy.broadcast_arrays` will export readonly buffers</h1>
               <p>In NumPy 1.17 <code><a link href="/p/numpy/*/api/numpy.broadcast_arrays.html" class='exists'>numpy.broadcast_arrays</a></code>
 started warning when the resulting array was written to. This warning was skipped when the array was used through the buffer interface (e.g.         <code class='verbatim'>memoryview(arr)</code>
). The same thing will now occur for the two protocols         <code class='verbatim'>__array_interface__</code>
, and         <code class='verbatim'>__array_struct__</code>
 returning read-only buffers instead of giving a warning.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16350" class='external'>gh-16350</a>)</p>


<h1>Numeric-style type names have been removed from type dictionaries</h1>
               <p>To stay in sync with the deprecation for         <code class='verbatim'>np.dtype(&#34;Complex64&#34;)</code>
 and other numeric-style (capital case) types.  These were removed from         <code class='verbatim'>np.sctypeDict</code>
 and         <code class='verbatim'>np.typeDict</code>
.  You should use the lower case versions instead.  Note that         <code class='verbatim'>&#34;Complex64&#34;</code>
 corresponds to         <code class='verbatim'>&#34;complex128&#34;</code>
 and         <code class='verbatim'>&#34;Complex32&#34;</code>
 corresponds to         <code class='verbatim'>&#34;complex64&#34;</code>
.  The numpy style (new) versions, denote the full size and not the size of the real/imaginary part.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16554" class='external'>gh-16554</a>)</p>


<h1>The ``operator.concat`` function now raises TypeError for array arguments</h1>
               <p>The previous behavior was to fall back to addition and add the two arrays, which was thought to be unexpected behavior for a concatenation function.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16570" class='external'>gh-16570</a>)</p>


<h1>``nickname`` attribute removed from ABCPolyBase</h1>
               <p>An abstract property         <code class='verbatim'>nickname</code>
 has been removed from          <code class='verbatim'>ABCPolyBase</code>
 as it was no longer used in the derived convenience classes. This may affect users who have derived classes from         <code class='verbatim'>ABCPolyBase</code>
 and overridden the methods for representation and display, e.g.         <code class='verbatim'>__str__</code>
,         <code class='verbatim'>__repr__</code>
,         <code class='verbatim'>_repr_latex</code>
, etc.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16589" class='external'>gh-16589</a>)</p>


<h1>``float-&gt;timedelta`` and ``uint64-&gt;timedelta`` promotion will raise a TypeError</h1>
               <p>Float and timedelta promotion consistently raises a TypeError.         <code class='verbatim'>np.promote_types(&#34;float32&#34;, &#34;m8&#34;)</code>
 aligns with         <code class='verbatim'>np.promote_types(&#34;m8&#34;, &#34;float32&#34;)</code>
 now and both raise a TypeError. Previously,         <code class='verbatim'>np.promote_types(&#34;float32&#34;, &#34;m8&#34;)</code>
 returned         <code class='verbatim'>&#34;m8&#34;</code>
 which was considered a bug.</p>

               <p>Uint64 and timedelta promotion consistently raises a TypeError.         <code class='verbatim'>np.promote_types(&#34;uint64&#34;, &#34;m8&#34;)</code>
 aligns with         <code class='verbatim'>np.promote_types(&#34;m8&#34;, &#34;uint64&#34;)</code>
 now and both raise a TypeError. Previously,         <code class='verbatim'>np.promote_types(&#34;uint64&#34;, &#34;m8&#34;)</code>
 returned         <code class='verbatim'>&#34;m8&#34;</code>
 which was considered a bug.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16592" class='external'>gh-16592</a>)</p>


<h1>``numpy.genfromtxt`` now correctly unpacks structured arrays</h1>
               <p>Previously, <code><a link href="/p/numpy/*/api/numpy.genfromtxt.html" class='exists'>numpy.genfromtxt</a></code>
 failed to unpack if it was called with         <code class='verbatim'>unpack=True</code>
 and a structured datatype was passed to the         <code class='verbatim'>dtype</code>
 argument (or         <code class='verbatim'>dtype=None</code>
 was passed and a structured datatype was inferred). For example::      </p>

               <pre>&gt;&gt;&gt; data = StringIO(&#34;21 58.0\n35 72.0&#34;)
&gt;&gt;&gt; np.genfromtxt(data, dtype=None, unpack=True)
array([(21, 58.), (35, 72.)], dtype=[(&#39;f0&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;)])</pre>
               <p>Structured arrays will now correctly unpack into a list of arrays, one for each column::      </p>

               <pre>&gt;&gt;&gt; np.genfromtxt(data, dtype=None, unpack=True)
[array([21, 35]), array([58., 72.])]</pre>
               <p>(<a link href="https://github.com/numpy/numpy/pull/16650" class='external'>gh-16650</a>)</p>


<h1>``mgrid``, ``r_``, etc. consistently return correct outputs for non-default precision input</h1>
               <p>Previously,         <code class='verbatim'>np.mgrid[np.float32(0.1):np.float32(0.35):np.float32(0.1),]</code>
 and         <code class='verbatim'>np.r_[0:10:np.complex64(3j)]</code>
 failed to return meaningful output. This bug potentially affects <code>:None:None:`~numpy.mgrid`</code>, <code>:None:None:`~numpy.ogrid`</code>, <code>:None:None:`~numpy.r_`</code>, and <code>:None:None:`~numpy.c_`</code> when an input with dtype other than the default         <code class='verbatim'>float64</code>
 and         <code class='verbatim'>complex128</code>
 and equivalent Python types were used. The methods have been fixed to handle varying precision correctly.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16815" class='external'>gh-16815</a>)</p>


<h1>Boolean array indices with mismatching shapes now properly give ``IndexError``</h1>
               <p>Previously, if a boolean array index matched the size of the indexed array but not the shape, it was incorrectly allowed in some cases. In other cases, it gave an error, but the error was incorrectly a         <code class='verbatim'>ValueError</code>
 with a message about broadcasting instead of the correct         <code class='verbatim'>IndexError</code>
.</p>

               <p>For example, the following used to incorrectly give         <code class='verbatim'>ValueError: operands
could not be broadcast together with shapes (2,2) (1,4)</code>
:</p>

               <div class='block_directive'>
    <div class='head'>.. code:: [&#39;python&#39;]
    </div>
    <pre class='not-implemented'><p>np.empty ( ( 2, 2)) [ np.array ( [ [ True, False, False, False]])] </p>
</pre>
</div>


               <p>And the following used to incorrectly return         <code class='verbatim'>array([], dtype=float64)</code>
:</p>

               <div class='block_directive'>
    <div class='head'>.. code:: [&#39;python&#39;]
    </div>
    <pre class='not-implemented'><p>np.empty ( ( 2, 2)) [ np.array ( [ [ False, False, False, False]])] </p>
</pre>
</div>


               <p>Both now correctly give         <code class='verbatim'>IndexError: boolean index did not match indexed
array along dimension 0; dimension is 2 but corresponding boolean dimension is
1</code>
.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17010" class='external'>gh-17010</a>)</p>


<h1>Casting errors interrupt Iteration</h1>
               <p>When iterating while casting values, an error may stop the iteration earlier than before. In any case, a failed casting operation always returned undefined, partial results. Those may now be even more undefined and partial. For users of the         <code class='verbatim'>NpyIter</code>
 C-API such cast errors will now cause the <code>:None:None:`iternext()`</code> function to return 0 and thus abort iteration. Currently, there is no API to detect such an error directly. It is necessary to check         <code class='verbatim'>PyErr_Occurred()</code>
, which may be problematic in combination with         <code class='verbatim'>NpyIter_Reset</code>
. These issues always existed, but new API could be added if required by users.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17029" class='external'>gh-17029</a>)</p>


<h1>f2py generated code may return unicode instead of byte strings</h1>
               <p>Some byte strings previously returned by f2py generated code may now be unicode strings. This results from the ongoing Python2 -&gt; Python3 cleanup.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17068" class='external'>gh-17068</a>)</p>


<h1>The first element of the ``__array_interface__[&#34;data&#34;]`` tuple  must be an integer</h1>
               <p>This has been the documented interface for many years, but there was still code that would accept a byte string representation of the pointer address. That code has been removed, passing the address as a byte string will now raise an error.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17241" class='external'>gh-17241</a>)</p>


<h1>poly1d respects the dtype of all-zero argument</h1>
               <p>Previously, constructing an instance of         <code class='verbatim'>poly1d</code>
 with all-zero coefficients would cast the coefficients to         <code class='verbatim'>np.float64</code>
. This affected the output dtype of methods which construct         <code class='verbatim'>poly1d</code>
 instances internally, such as         <code class='verbatim'>np.polymul</code>
.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17577" class='external'>gh-17577</a>)</p>


<h1>The numpy.i file for swig is Python 3 only.</h1>
               <p>Uses of Python 2.7 C-API functions have been updated to Python 3 only. Users who need the old version should take it from an older version of NumPy.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17580" class='external'>gh-17580</a>)</p>


<h1>Void dtype discovery in ``np.array``</h1>
               <p>In calls using         <code class='verbatim'>np.array(..., dtype=&#34;V&#34;)</code>
,         <code class='verbatim'>arr.astype(&#34;V&#34;)</code>
, and similar a TypeError will now be correctly raised unless all elements have the identical void length. An example for this is::       </p>

               <pre>np.array([b&#34;1&#34;, b&#34;12&#34;], dtype=&#34;V&#34;)</pre>
               <p>Which previously returned an array with dtype         <code class='verbatim'>&#34;V2&#34;</code>
 which cannot represent         <code class='verbatim'>b&#34;1&#34;</code>
 faithfully.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17706" class='external'>gh-17706</a>)</p>


<h1>C API changes</h1>

<h1>The ``PyArray_DescrCheck`` macro is modified</h1>
               <p>The         <code class='verbatim'>PyArray_DescrCheck</code>
 macro has been updated since NumPy 1.16.6 to be::      </p>

               <pre>#define PyArray_DescrCheck(op) PyObject_TypeCheck(op, &amp;PyArrayDescr_Type)</pre>
               <p>Starting with NumPy 1.20 code that is compiled against an earlier version will be API incompatible with NumPy 1.20. The fix is to either compile against 1.16.6 (if the NumPy 1.16 release is the oldest release you wish to support), or manually inline the macro by replacing it with the new definition::      </p>

               <pre>PyObject_TypeCheck(op, &amp;PyArrayDescr_Type)</pre>
               <p>which is compatible with all NumPy versions.</p>


<h1>Size of ``np.ndarray`` and ``np.void_`` changed</h1>
               <p>The size of the         <code class='verbatim'>PyArrayObject</code>
 and         <code class='verbatim'>PyVoidScalarObject</code>
 structures have changed.  The following header definition has been removed::      </p>

               <pre>#define NPY_SIZEOF_PYARRAYOBJECT (sizeof(PyArrayObject_fields))</pre>
               <p>since the size must not be considered a compile time constant: it will change for different runtime versions of NumPy.</p>

               <p>The most likely relevant use are potential subclasses written in C which will have to be recompiled and should be updated.  Please see the documentation for         <code class='verbatim'>PyArrayObject</code>
 for more details and contact the NumPy developers if you are affected by this change.</p>

               <p>NumPy will attempt to give a graceful error but a program expecting a fixed structure size may have undefined behaviour and likely crash.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16938" class='external'>gh-16938</a>)</p>


<h1>New Features</h1>

<h1>``where`` keyword argument for ``numpy.all`` and ``numpy.any`` functions</h1>
               <p>The keyword argument         <code class='verbatim'>where</code>
 is added and allows to only consider specified elements or subaxes from an array in the Boolean evaluation of         <code class='verbatim'>all</code>
 and         <code class='verbatim'>any</code>
. This new keyword is available to the functions         <code class='verbatim'>all</code>
 and         <code class='verbatim'>any</code>
 both via         <code class='verbatim'>numpy</code>
 directly or in the methods of         <code class='verbatim'>numpy.ndarray</code>
.</p>

               <p>Any broadcastable Boolean array or a scalar can be set as         <code class='verbatim'>where</code>
. It defaults to         <code class='verbatim'>True</code>
 to evaluate the functions for all elements in an array if         <code class='verbatim'>where</code>
 is not set by the user. Examples are given in the documentation of the functions.</p>


<h1>``where`` keyword argument for ``numpy`` functions ``mean``, ``std``, ``var``</h1>
               <p>The keyword argument         <code class='verbatim'>where</code>
 is added and allows to limit the scope in the calculation of         <code class='verbatim'>mean</code>
,         <code class='verbatim'>std</code>
 and         <code class='verbatim'>var</code>
 to only a subset of elements. It is available both via         <code class='verbatim'>numpy</code>
 directly or in the methods of         <code class='verbatim'>numpy.ndarray</code>
.</p>

               <p>Any broadcastable Boolean array or a scalar can be set as         <code class='verbatim'>where</code>
. It defaults to         <code class='verbatim'>True</code>
 to evaluate the functions for all elements in an array if         <code class='verbatim'>where</code>
 is not set by the user. Examples are given in the documentation of the functions.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15852" class='external'>gh-15852</a>)</p>


<h1>``norm=backward``, ``forward`` keyword options for ``numpy.fft`` functions</h1>
               <p>The keyword argument option         <code class='verbatim'>norm=backward</code>
 is added as an alias for         <code class='verbatim'>None</code>
 and acts as the default option; using it has the direct transforms unscaled and the inverse transforms scaled by         <code class='verbatim'>1/n</code>
.</p>

               <p>Using the new keyword argument option         <code class='verbatim'>norm=forward</code>
 has the direct transforms scaled by         <code class='verbatim'>1/n</code>
 and the inverse transforms unscaled (i.e. exactly opposite to the default option         <code class='verbatim'>norm=backward</code>
).</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16476" class='external'>gh-16476</a>)</p>


<h1>NumPy is now typed</h1>
               <p>Type annotations have been added for large parts of NumPy. There is also a new <code><a link href="/p/numpy/*/api/numpy.typing.html" class='exists'>numpy.typing</a></code>
 module that contains useful types for end-users. The currently available types are</p>

                          <ul>               <li>               <p>        <code class='verbatim'>ArrayLike</code>
: for objects that can be coerced to an array</p>

</li>
               <li>               <p>        <code class='verbatim'>DtypeLike</code>
: for objects that can be coerced to a dtype</p>

</li>
            </ul>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16515" class='external'>gh-16515</a>)</p>


<h1>``numpy.typing`` is accessible at runtime</h1>
               <p>The types in         <code class='verbatim'>numpy.typing</code>
 can now be imported at runtime. Code like the following will now work:</p>

               <div class='block_directive'>
    <div class='head'>.. code:: [&#39;python&#39;]
    </div>
    <pre class='not-implemented'><p>from numpy.typing import ArrayLike x : ArrayLike = [ 1, 2, 3, 4] </p>
</pre>
</div>


               <p>(<a link href="https://github.com/numpy/numpy/pull/16558" class='external'>gh-16558</a>)</p>


<h1>New ``__f2py_numpy_version__`` attribute for f2py generated modules.</h1>
               <p>Because f2py is released together with NumPy,         <code class='verbatim'>__f2py_numpy_version__</code>
 provides a way to track the version f2py used to generate the module.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16594" class='external'>gh-16594</a>)</p>


<h1>``mypy`` tests can be run via runtests.py</h1>
               <p>Currently running mypy with the NumPy stubs configured requires either:</p>

                          <ul>               <li>               <p>Installing NumPy</p>

</li>
               <li>               <p>Adding the source directory to MYPYPATH and linking to the         <code class='verbatim'>mypy.ini</code>
</p>

</li>
            </ul>

               <p>Both options are somewhat inconvenient, so add a         <code class='verbatim'>--mypy</code>
 option to runtests that handles setting things up for you. This will also be useful in the future for any typing codegen since it will ensure the project is built before type checking.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17123" class='external'>gh-17123</a>)</p>


<h1>Negation of user defined BLAS/LAPACK detection order</h1>
               <p><code><a link href="/p/numpy/*/api/numpy.distutils.html" class='exists'>distutils</a></code>
 allows negation of libraries when determining BLAS/LAPACK libraries. This may be used to remove an item from the library resolution phase, i.e. to disallow NetLIB libraries one could do:</p>

               <div class='block_directive'>
    <div class='head'>.. code:: [&#39;bash&#39;]
    </div>
    <pre class='not-implemented'><p>NPY_BLAS_ORDER= &#39; ^blas &#39; NPY_LAPACK_ORDER= &#39; ^lapack &#39; python setup.py build </p>
</pre>
</div>


               <p>That will use any of the accelerated libraries instead.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17219" class='external'>gh-17219</a>)</p>


<h1>Allow passing optimizations arguments to asv build</h1>
               <p>It is now possible to pass          <code class='verbatim'>-j</code>
,         <code class='verbatim'>--cpu-baseline</code>
,         <code class='verbatim'>--cpu-dispatch</code>
 and         <code class='verbatim'>--disable-optimization</code>
 flags to ASV build when the         <code class='verbatim'>--bench-compare</code>
 argument is used.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17284" class='external'>gh-17284</a>)</p>


<h1>The NVIDIA HPC SDK nvfortran compiler is now supported</h1>
               <p>Support for the nvfortran compiler, a version of pgfortran, has been added.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17344" class='external'>gh-17344</a>)</p>


<h1>``dtype`` option for ``cov`` and ``corrcoef``</h1>
               <p>The         <code class='verbatim'>dtype</code>
 option is now available for <code><a link href="/p/numpy/*/api/numpy.cov.html" class='exists'>numpy.cov</a></code>
 and <code><a link href="/p/numpy/*/api/numpy.corrcoef.html" class='exists'>numpy.corrcoef</a></code>
. It specifies which data-type the returned result should have. By default the functions still return a <code><a link href="/p/numpy/*/api/numpy.float64.html" class='exists'>numpy.float64</a></code>
 result.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17456" class='external'>gh-17456</a>)</p>


<h1>Improvements</h1>

<h1>Improved string representation for polynomials (``__str__``)</h1>
               <p>The string representation (        <code class='verbatim'>__str__</code>
) of all six polynomial types in <code><a link href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
 has been updated to give the polynomial as a mathematical expression instead of an array of coefficients. Two package-wide formats for the polynomial expressions are available - one using Unicode characters for superscripts and subscripts, and another using only ASCII characters.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15666" class='external'>gh-15666</a>)</p>


<h1>Remove the Accelerate library as a candidate LAPACK library</h1>
               <p>Apple no longer supports Accelerate. Remove it.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/15759" class='external'>gh-15759</a>)</p>


<h1>Object arrays containing multi-line objects have a more readable ``repr``</h1>
               <p>If elements of an object array have a         <code class='verbatim'>repr</code>
 containing new lines, then the wrapped lines will be aligned by column. Notably, this improves the         <code class='verbatim'>repr</code>
 of nested arrays::      </p>

               <pre>&gt;&gt;&gt; np.array([np.eye(2), np.eye(3)], dtype=object)
array([array([[1., 0.],
              [0., 1.]]),
       array([[1., 0., 0.],
              [0., 1., 0.],
              [0., 0., 1.]])], dtype=object)</pre>
               <p>(<a link href="https://github.com/numpy/numpy/pull/15997" class='external'>gh-15997</a>)</p>


<h1>Concatenate supports providing an output dtype</h1>
               <p>Support was added to <code><a link href="/p/numpy/*/api/numpy.concatenate.html" class='exists'>concatenate</a></code>
 to provide an output         <code class='verbatim'>dtype</code>
 and         <code class='verbatim'>casting</code>
 using keyword arguments. The         <code class='verbatim'>dtype</code>
 argument cannot be provided in conjunction with the         <code class='verbatim'>out</code>
 one.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16134" class='external'>gh-16134</a>)</p>


<h1>Thread safe f2py callback functions</h1>
               <p>Callback functions in f2py are now thread safe.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16519" class='external'>gh-16519</a>)</p>


<h1>`numpy.core.records.fromfile` now supports file-like objects</h1>
               <p><code><a link href="/p/numpy/*/api/numpy.rec.fromfile.html" class='exists'>numpy.rec.fromfile</a></code>
 can now use file-like objects, for instance         <code class='verbatim'>io.BytesIO</code>
</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16675" class='external'>gh-16675</a>)</p>


<h1>RPATH support on AIX added to distutils</h1>
               <p>This allows SciPy to be built on AIX.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16710" class='external'>gh-16710</a>)</p>


<h1>Use f90 compiler specified by the command line args</h1>
               <p>The compiler command selection for Fortran Portland Group Compiler is changed in <code><a link href="/p/numpy/*/api/numpy.distutils.fcompiler.html" class='exists'>numpy.distutils.fcompiler</a></code>
.  This only affects the linking command.  This forces the use of the executable provided by the command line option (if provided) instead of the pgfortran executable.  If no executable is provided to the command line option it defaults to the pgf90 executable, which is an alias for pgfortran according to the PGI documentation.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16730" class='external'>gh-16730</a>)</p>


<h1>Add NumPy declarations for Cython 3.0 and later</h1>
               <p>The pxd declarations for Cython 3.0 were improved to avoid using deprecated NumPy C-API features.  Extension modules built with Cython 3.0+ that use NumPy can now set the C macro         <code class='verbatim'>NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION</code>
 to avoid C compiler warnings about deprecated API usage.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/16986" class='external'>gh-16986</a>)</p>


<h1>Make the window functions exactly symmetric</h1>
               <p>Make sure the window functions provided by NumPy are symmetric. There were previously small deviations from symmetry due to numerical precision that are now avoided by better arrangement of the computation.</p>

               <p>(<a link href="https://github.com/numpy/numpy/pull/17195" class='external'>gh-17195</a>)</p>


<h1>Performance improvements and changes</h1>

<h1>Enable multi-platform SIMD compiler optimizations</h1>
               <p>A series of improvements for NumPy infrastructure to pave the way to <strong>NEP-38</strong>, that can be summarized as follow:</p>

                          <ul>               <li>               <p><strong>New Build Arguments</strong></p>

                          <ul>               <li>               <p>        <code class='verbatim'>--cpu-baseline</code>
 to specify the minimal set of required       optimizations, default value is         <code class='verbatim'>min</code>
 which provides the minimum       CPU features that can safely run on a wide range of users       platforms.</p>

</li>
            </ul>

                          <ul>               <li>               <p>        <code class='verbatim'>--cpu-dispatch</code>
 to specify the dispatched set of additional       optimizations, default value is         <code class='verbatim'>max -xop -fma4</code>
 which enables       all CPU features, except for AMD legacy features.</p>

</li>
            </ul>

                          <ul>               <li>               <p>        <code class='verbatim'>--disable-optimization</code>
 to explicitly disable the whole new       improvements, It also adds a new <strong>C</strong> compiler #definition       called         <code class='verbatim'>NPY_DISABLE_OPTIMIZATION</code>
 which it can be used as       guard for any SIMD code.</p>

</li>
            </ul>

</li>
            </ul>

                          <ul>               <li>               <p><strong>Advanced CPU dispatcher</strong></p>

               <p>A flexible cross-architecture CPU dispatcher built on the top of    Python/Numpy distutils, support all common compilers with a wide range of    CPU features.</p>

               <p>The new dispatcher requires a special file extension         <code class='verbatim'>*.dispatch.c</code>
 to    mark the dispatch-able <strong>C</strong> sources. These sources have the ability to be    compiled multiple times so that each compilation process represents certain    CPU features and provides different #definitions and flags that affect the    code paths.</p>

</li>
            </ul>

                          <ul>               <li>               <p><strong>New auto-generated C header ``core/src/common/_cpu_dispatch.h``</strong></p>

               <p>This header is generated by the distutils module         <code class='verbatim'>ccompiler_opt</code>
, and    contains all the #definitions and headers of instruction sets, that had been    configured through command arguments &#39;--cpu-baseline&#39; and &#39;--cpu-dispatch&#39;.</p>

</li>
            </ul>

                          <ul>               <li>               <p><strong>New C header ``core/src/common/npy_cpu_dispatch.h``</strong></p>

               <p>This header contains all utilities that required for the whole CPU    dispatching process, it also can be considered as a bridge linking the new    infrastructure work with NumPy CPU runtime detection.</p>

</li>
            </ul>

                          <ul>               <li>               <p><strong>Add new attributes to NumPy umath module(Python level)</strong></p>

                          <ul>               <li>               <p>        <code class='verbatim'>__cpu_baseline__</code>
 a list contains the minimal set of required      optimizations that supported by the compiler and platform according to the      specified values to command argument &#39;--cpu-baseline&#39;.</p>

</li>
            </ul>

                          <ul>               <li>               <p>        <code class='verbatim'>__cpu_dispatch__</code>
 a list contains the dispatched set of additional      optimizations that supported by the compiler and platform according to the      specified values to command argument &#39;--cpu-dispatch&#39;.</p>

</li>
            </ul>

</li>
            </ul>

                          <ul>               <li>               <p><strong>Print the supported CPU features during the run of PytestTester</strong></p>

</li>
            </ul>

               <p>(<a link href="https://github.com/numpy/numpy/pull/13516" class='external'>gh-13516</a>)</p>


<h1>Changes</h1>

<h1>Changed behavior of ``divmod(1., 0.)`` and related functions</h1>
               <p>The changes also assure that different compiler versions have the same behavior for nan or inf usages in these operations. This was previously compiler dependent, we now force the invalid and divide by zero flags, making the results the same across compilers. For example, gcc-5, gcc-8, or gcc-9 now result in the same behavior. The changes are tabulated below:</p>

               <div class='block_directive'>
    <div class='head'>.. list-table:: []
    </div>
    <pre class='not-implemented'><p>* - Operator - Old Warning - New Warning - Old Result - New Result - Works on MacOS * - np.divmod ( 1.0, 0.0) - Invalid - Invalid and Dividebyzero - nan, nan - inf, nan - Yes * - np.fmod ( 1.0, 0.0) - Invalid - Invalid - nan - nan - No? Yes * - np.floor_divide ( 1.0, 0.0) - Invalid - Dividebyzero - nan - inf - Yes * - np.remainder ( 1.0, 0.0) - Invalid - Invalid - nan - nan - Yes </p>
</pre>
</div>


               <p>(<a link href="https://github.com/numpy/numpy/pull/16161" class='external'>gh-16161</a>)</p>


<h1>``np.linspace`` on integers now uses floor</h1>
               <p>When using a         <code class='verbatim'>int</code>
 dtype in <code><a link href="/p/numpy/*/api/numpy.linspace.html" class='exists'>numpy.linspace</a></code>
, previously float values would be rounded towards zero. Now <code>:None:None:`numpy.floor`</code> is used instead, which rounds toward         <code class='verbatim'>-inf</code>
. This changes the results for negative values. For example, the following would previously give::      </p>

               <pre>&gt;&gt;&gt; np.linspace(-3, 1, 8, dtype=int)
array([-3, -2, -1, -1,  0,  0,  0,  1])</pre>
               <p>and now results in::      </p>

               <pre>&gt;&gt;&gt; np.linspace(-3, 1, 8, dtype=int)
array([-3, -3, -2, -2, -1, -1,  0,  1])</pre>
               <p>The former result can still be obtained with::      </p>

               <pre>&gt;&gt;&gt; np.linspace(-3, 1, 8).astype(int)
array([-3, -2, -1, -1,  0,  0,  0,  1])</pre>
               <p>(<a link href="https://github.com/numpy/numpy/pull/16841" class='external'>gh-16841</a>)</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
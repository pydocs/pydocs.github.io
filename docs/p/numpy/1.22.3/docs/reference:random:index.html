<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _numpyrandom:&#39;&gt;
           </pre>

               <pre class='not-implemented'>
.. py:module:: numpy.random
    </pre>


               <pre class='not-implemented'>
.. currentmodule:: numpy.random
    </pre>



<h1>Random sampling (:mod:`numpy.random`)</h1>
               <p>Numpy&#39;s random number routines produce pseudo random numbers using combinations of a <code class='not-implemented'>:None:None:`BitGenerator`</code> to create sequences and a <code class='not-implemented'>:None:None:`Generator`</code> to use those sequences to sample from different statistical distributions:</p>

                          <ul>               <li>               <p>BitGenerators: Objects that generate random numbers. These are typically   unsigned integer words filled with sequences of either 32 or 64 random bits.</p>

</li>
               <li>               <p>Generators: Objects that transform sequences of random bits from a   BitGenerator into sequences of numbers that follow a specific probability   distribution (such as uniform, Normal or Binomial) within a specified   interval.</p>

</li>
            </ul>

               <p>Since Numpy version 1.17.0 the Generator can be initialized with a number of different BitGenerators. It exposes many different probability distributions. See <a link href="https://www.numpy.org/neps/
nep-0019-rng-policy.html" class='external'>NEP 19</a> for context on the updated random Numpy number routines. The legacy <code class='not-implemented'>:None:None:`RandomState`</code> random number routines are still available, but limited to a single BitGenerator. See         <code class='verbatim'>new-or-different</code>
  for a complete list of improvements and differences from the legacy         <code class='verbatim'>RandomState</code>
.</p>

               <p>For convenience and backward compatibility, a single <code class='not-implemented'>:None:None:`RandomState`</code> instance&#39;s methods are imported into the numpy.random namespace, see         <code class='verbatim'>legacy</code>
 for the complete list.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _random-quick-start:&#39;&gt;
           </pre>


<h1>Quick Start</h1>
               <p>Call <code class='not-implemented'>:None:None:`default_rng`</code> to get a new instance of a <code class='not-implemented'>:None:None:`Generator`</code>, then call its methods to obtain samples from different distributions.  By default, <code class='not-implemented'>:None:None:`Generator`</code> uses bits provided by <code class='not-implemented'>:None:None:`PCG64`</code> which has better statistical properties than the legacy <code class='not-implemented'>:None:None:`MT19937`</code> used in <code class='not-implemented'>:None:None:`RandomState`</code>.</p>

               <pre class='not-implemented'>
.. code-block:: python
    # Do this (new version)
    from numpy.random import default_rng
    rng = default_rng()
    vals = rng.standard_normal(10)
    more_vals = rng.standard_normal(10)

    # instead of this (legacy version)
    from numpy import random
    vals = random.standard_normal(10)
    more_vals = random.standard_normal(10)</pre>


               <p><code class='not-implemented'>:None:None:`Generator`</code> can be used as a replacement for <code class='not-implemented'>:None:None:`RandomState`</code>. Both class instances hold an internal <code class='not-implemented'>:None:None:`BitGenerator`</code> instance to provide the bit stream, it is accessible as         <code class='verbatim'>gen.bit_generator</code>
. Some long-overdue API cleanup means that legacy and compatibility methods have been removed from <code class='not-implemented'>:None:None:`Generator`</code></p>

               <p>=================== ============== ============ <code class='not-implemented'>:None:None:`RandomState`</code>       <code class='not-implemented'>:None:None:`Generator`</code>    Notes ------------------- -------------- ------------         <code class='verbatim'>random_sample</code>
,          <code class='verbatim'>random</code>
     Compatible with <code class='not-implemented'>:None:None:`random.random`</code>         <code class='verbatim'>rand</code>
 ------------------- -------------- ------------         <code class='verbatim'>randint</code>
,                <code class='verbatim'>integers</code>
   Add an         <code class='verbatim'>endpoint</code>
 kwarg         <code class='verbatim'>random_integers</code>
 ------------------- -------------- ------------         <code class='verbatim'>tomaxint</code>
        removed        Use         <code class='verbatim'>integers(0, np.iinfo(np.int_).max,</code>
                                            <code class='verbatim'>endpoint=False)</code>
 ------------------- -------------- ------------         <code class='verbatim'>seed</code>
            removed        Use <code class='not-implemented'>:None:None:`SeedSequence.spawn`</code> =================== ============== ============</p>

               <p>See         <code class='verbatim'>new-or-different</code>
 for more information.</p>

               <p>Something like the following code can be used to support both         <code class='verbatim'>RandomState</code>
 and         <code class='verbatim'>Generator</code>
, with the understanding that the interfaces are slightly different</p>

               <pre class='not-implemented'>
.. code-block:: python
    try:
        rng_integers = rng.integers
    except AttributeError:
        rng_integers = rng.randint
    a = rng_integers(1000)</pre>


               <p>Seeds can be passed to any of the BitGenerators. The provided value is mixed via <code class='not-implemented'>:None:None:`SeedSequence`</code> to spread a possible sequence of seeds across a wider range of initialization states for the BitGenerator. Here <code class='not-implemented'>:None:None:`PCG64`</code> is used and is wrapped with a <code class='not-implemented'>:None:None:`Generator`</code>.</p>

               <pre class='not-implemented'>
.. code-block:: python
    from numpy.random import Generator, PCG64
    rng = Generator(PCG64(12345))
    rng.standard_normal()</pre>


               <p>Here we use <code class='not-implemented'>:None:None:`default_rng`</code> to create an instance of <code class='not-implemented'>:None:None:`Generator`</code> to generate a  random float:</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng(12345)
&gt;&gt;&gt; print(rng)
Generator(PCG64)
&gt;&gt;&gt; rfloat = rng.random()
&gt;&gt;&gt; rfloat
0.22733602246716966
&gt;&gt;&gt; type(rfloat)
&lt;class &#39;float&#39;&gt;</pre>
               <p>Here we use <code class='not-implemented'>:None:None:`default_rng`</code> to create an instance of <code class='not-implemented'>:None:None:`Generator`</code> to generate 3  random integers between 0 (inclusive) and 10 (exclusive):</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng(12345)
&gt;&gt;&gt; rints = rng.integers(low=0, high=10, size=3)
&gt;&gt;&gt; rints
array([6, 2, 7])
&gt;&gt;&gt; type(rints[0])
&lt;class &#39;numpy.int64&#39;&gt;</pre>

<h1>Introduction</h1>
               <p>The new infrastructure takes a different approach to producing random numbers from the <code class='not-implemented'>:None:None:`RandomState`</code> object.  Random number generation is separated into two components, a bit generator and a random generator.</p>

               <p>The <code class='not-implemented'>:None:None:`BitGenerator`</code> has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</p>

               <p>The <code class='not-implemented'>:None:None:`random generator &lt;Generator&gt;`</code> takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</p>

               <p>The <code class='not-implemented'>:None:None:`Generator`</code> is the user-facing object that is nearly identical to the legacy <code class='not-implemented'>:None:None:`RandomState`</code>. It accepts a bit generator instance as an argument. The default is currently <code class='not-implemented'>:None:None:`PCG64`</code> but this may change in future versions.  As a convenience NumPy  provides the <code class='not-implemented'>:None:None:`default_rng`</code> function to hide these  details:</p>

               <pre>&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng(12345)
&gt;&gt;&gt; print(rng)
Generator(PCG64)
&gt;&gt;&gt; print(rng.random())
0.22733602246716966</pre>
               <p>One can also instantiate <code class='not-implemented'>:None:None:`Generator`</code> directly with a <code class='not-implemented'>:None:None:`BitGenerator`</code> instance.</p>

               <p>To use the default <code class='not-implemented'>:None:None:`PCG64`</code> bit generator, one can instantiate it directly and  pass it to <code class='not-implemented'>:None:None:`Generator`</code>:</p>

               <pre>&gt;&gt;&gt; from numpy.random import Generator, PCG64
&gt;&gt;&gt; rng = Generator(PCG64(12345))
&gt;&gt;&gt; print(rng)
Generator(PCG64)</pre>
               <p>Similarly to use the older <code class='not-implemented'>:None:None:`MT19937`</code> bit generator (not recommended), one can instantiate it directly and pass it to <code class='not-implemented'>:None:None:`Generator`</code>:</p>

               <pre>&gt;&gt;&gt; from numpy.random import Generator, MT19937
&gt;&gt;&gt; rng = Generator(MT19937(12345))
&gt;&gt;&gt; print(rng)
Generator(MT19937)</pre>

<h1>What&#39;s New or Different</h1>
                           <div class='admonition'>
    <div>warning</div>
        <p>The Box-Muller method used to produce NumPy&#39;s normals is no longer available in <code class='not-implemented'>:None:None:`Generator`</code>.  It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the <code class='not-implemented'>:None:None:`RandomState.gamma`</code> or <code class='not-implemented'>:None:None:`RandomState.standard_t`</code>. If you require bitwise backward compatible streams, use <code class='not-implemented'>:None:None:`RandomState`</code>.</p>

</div>


                          <ul>               <li>               <p>The Generator&#39;s normal, exponential and gamma functions use 256-step Ziggurat   methods which are 2-10 times faster than NumPy&#39;s Box-Muller or inverse CDF   implementations.</p>

</li>
               <li>               <p>Optional         <code class='verbatim'>dtype</code>
 argument that accepts         <code class='verbatim'>np.float32</code>
 or         <code class='verbatim'>np.float64</code>
   to produce either single or double precision uniform random variables for   select distributions</p>

</li>
               <li>               <p>Optional         <code class='verbatim'>out</code>
 argument that allows existing arrays to be filled for   select distributions</p>

</li>
               <li>               <p>All BitGenerators can produce doubles, uint64s and uint32s via CTypes   (<code class='not-implemented'>:None:None:`PCG64.ctypes`</code>) and CFFI (<code class='not-implemented'>:None:None:`PCG64.cffi`</code>). This allows the bit generators   to be used in numba.</p>

</li>
               <li>               <p>The bit generators can be used in downstream projects via           <code class='verbatim'>Cython &lt;random_cython&gt;</code>
.</p>

</li>
               <li>               <p><code class='not-implemented'>:None:None:`Generator.integers`</code> is now the canonical way to generate integer   random numbers from a discrete uniform distribution. The         <code class='verbatim'>rand</code>
 and           <code class='verbatim'>randn</code>
 methods are only available through the legacy <code class='not-implemented'>:None:None:`RandomState`</code>.   The         <code class='verbatim'>endpoint</code>
 keyword can be used to specify open or closed intervals.   This replaces both         <code class='verbatim'>randint</code>
 and the deprecated         <code class='verbatim'>random_integers</code>
.</p>

</li>
               <li>               <p><code class='not-implemented'>:None:None:`Generator.random`</code> is now the canonical way to generate floating-point   random numbers, which replaces <code class='not-implemented'>:None:None:`RandomState.random_sample`</code>,   <code class='not-implemented'>:None:None:`RandomState.sample`</code>, and <code class='not-implemented'>:None:None:`RandomState.ranf`</code>. This is consistent with   Python&#39;s <code class='not-implemented'>:None:None:`random.random`</code>.</p>

</li>
               <li>               <p>All BitGenerators in numpy use <code class='not-implemented'>:None:None:`SeedSequence`</code> to convert seeds into   initialized states.</p>

</li>
               <li>               <p>The addition of an         <code class='verbatim'>axis</code>
 keyword argument to methods such as    <code class='not-implemented'>:None:None:`Generator.choice`</code>, <code class='not-implemented'>:None:None:`Generator.permutation`</code>,  and <code class='not-implemented'>:None:None:`Generator.shuffle`</code>    improves support for sampling from and shuffling multi-dimensional arrays.</p>

</li>
            </ul>

               <p>See         <code class='verbatim'>new-or-different</code>
 for a complete list of improvements and differences from the traditional         <code class='verbatim'>Randomstate</code>
.</p>


<h1>Parallel Generation</h1>
               <p>The included generators can be used in parallel, distributed applications in one of three ways:</p>

                          <ul>               <li>               <p>        <code class='verbatim'>seedsequence-spawn</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>independent-streams</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>parallel-jumped</code>
</p>

</li>
            </ul>

               <p>Users with a very large amount of parallelism will want to consult         <code class='verbatim'>upgrading-pcg64</code>
.</p>


<h1>Concepts</h1>
               <pre class='not-implemented'>
.. toctree:: 
    [&#39;maxdepth&#39;, &#39;1&#39;]
    generator
    Legacy Generator (RandomState) &lt;legacy&gt;
    BitGenerators, SeedSequences &lt;bit_generators/index&gt;
    Upgrading PCG64 with PCG64DXSM &lt;upgrading-pcg64&gt;</pre>



<h1>Features</h1>
               <pre class='not-implemented'>
.. toctree:: 
    [&#39;maxdepth&#39;, &#39;2&#39;]
    Parallel Applications &lt;parallel&gt;
    Multithreaded Generation &lt;multithreading&gt;
    new-or-different
    Comparing Performance &lt;performance&gt;
    c-api
    Examples of using Numba, Cython, CFFI &lt;extending&gt;</pre>



<h1>Original Source of the Generator and BitGenerators</h1>
               <p>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at https://github.com/bashtage/randomgen.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
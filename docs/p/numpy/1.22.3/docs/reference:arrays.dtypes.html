<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. currentmodule:: numpy
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.dtypes:&#39;&gt;
           </pre>


<h1>Data type objects (:class:`dtype`)</h1>
               <p>A data type object (an instance of         <code class='verbatim'>numpy.dtype</code>
 class) describes how the bytes in the fixed-size block of memory corresponding to an array item should be interpreted. It describes the following aspects of the data:</p>

                          <ol>               <li>               <p>Type of the data (integer, float, Python object, etc.)</p>

</li>
               <li>               <p>Size of the data (how many bytes is in <em>e.g.</em> the integer)</p>

</li>
               <li>               <p>Byte order of the data (        <code class='verbatim'>little-endian</code>
 or         <code class='verbatim'>big-endian</code>
)</p>

</li>
               <li>               <p>If the data type is         <code class='verbatim'>structured data type</code>
, an aggregate of other    data types, (<em>e.g.</em>, describing an array item consisting of    an integer and a float),</p>

                          <ol>               <li>               <p>what are the names of the &#34;        <code class='verbatim'>fields &lt;field&gt;</code>
&#34; of the structure,       by which they can be         <code class='verbatim'>accessed &lt;arrays.indexing.fields&gt;</code>
,</p>

</li>
               <li>               <p>what is the data-type of each         <code class='verbatim'>field</code>
, and</p>

</li>
               <li>               <p>which part of the memory block each field takes.</p>

</li>
            </ol>

</li>
               <li>               <p>If the data type is a sub-array, what is its shape and data type.</p>

</li>
            </ol>

               <pre class='not-implemented'>
.. index:: 
    pair: dtype; scalar</pre>


               <p>To describe the type of scalar data, there are several         <code class='verbatim'>built-in
scalar types &lt;arrays.scalars.built-in&gt;</code>
 in NumPy for various precision of integers, floating-point numbers, <em>etc</em>. An item extracted from an array, <em>e.g.</em>, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</p>

               <p>Note that the scalar types are not         <code class='verbatim'>dtype</code>
 objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</p>

               <pre class='not-implemented'>
.. index:: 
    pair: dtype; field</pre>


               <p>Structured data types are formed by creating a data type whose         <code class='verbatim'>field</code>
 contain other data types. Each field has a name by which it can be         <code class='verbatim'>accessed &lt;arrays.indexing.fields&gt;</code>
. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the         <code class='verbatim'>void</code>
 type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</p>

               <pre class='not-implemented'>
.. index:: 
    pair: dtype; sub-array</pre>


               <p>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</p>

               <p>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see         <code class='verbatim'>arrays.indexing.fields</code>
.</p>

               <p>Sub-arrays always have a C-contiguous memory layout.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    A simple data type containing a 32-bit big-endian integer:
    (see :ref:`arrays.dtypes.constructing` for details on construction)

    &gt;&gt;&gt; dt = np.dtype(&#39;&gt;i4&#39;)
    &gt;&gt;&gt; dt.byteorder
    &#39;&gt;&#39;
    &gt;&gt;&gt; dt.itemsize
    4
    &gt;&gt;&gt; dt.name
    &#39;int32&#39;
    &gt;&gt;&gt; dt.type is np.int32
    True

    The corresponding array scalar type is :class:`int32`.</pre>


               <pre class='not-implemented'>
.. admonition:: Example
    A structured data type containing a 16-character string (in field &#39;name&#39;)
    and a sub-array of two 64-bit floating-point number (in field &#39;grades&#39;):

    &gt;&gt;&gt; dt = np.dtype([(&#39;name&#39;, np.unicode_, 16), (&#39;grades&#39;, np.float64, (2,))])
    &gt;&gt;&gt; dt[&#39;name&#39;]
    dtype(&#39;&lt;U16&#39;)
    &gt;&gt;&gt; dt[&#39;grades&#39;]
    dtype((&#39;&lt;f8&#39;, (2,)))

    Items of an array of this data type are wrapped in an :ref:`array
    scalar &lt;arrays.scalars&gt;` type that also has two fields:

    &gt;&gt;&gt; x = np.array([(&#39;Sarah&#39;, (8.0, 7.0)), (&#39;John&#39;, (6.0, 7.0))], dtype=dt)
    &gt;&gt;&gt; x[1]
    (&#39;John&#39;, [6., 7.])
    &gt;&gt;&gt; x[1][&#39;grades&#39;]
    array([6.,  7.])
    &gt;&gt;&gt; type(x[1])
    &lt;class &#39;numpy.void&#39;&gt;
    &gt;&gt;&gt; type(x[1][&#39;grades&#39;])
    &lt;class &#39;numpy.ndarray&#39;&gt;</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.dtypes.constructing:&#39;&gt;
           </pre>


<h1>Specifying and constructing data types</h1>
               <p>Whenever a data-type is required in a NumPy function or method, either a         <code class='verbatim'>dtype</code>
 object or something that can be converted to one can be supplied.  Such conversions are done by the         <code class='verbatim'>dtype</code>
 constructor:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype</pre>
               <p>What can be converted to a data-type object is described below:</p>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>dtype</code>
 object</p>
</dt>
               <dd><pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from dtype</pre>

<p>Used as-is.</p>
</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>None</p>
</dt>
               <dd><pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from None</pre>

<p>The default data type:         <code class='verbatim'>float_</code>
.</p>
</dd>
           </dl>

               <pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from type</pre>


               <!-- deflist -->
           <dl>
               <dt><p>Array-scalar types</p>
</dt>
               <dd><p>The 24 built-in         <code class='verbatim'>array scalar type objects
    &lt;arrays.scalars.built-in&gt;</code>
 all convert to an associated data-type object.     This is true for their sub-classes as well.</p>
<p>Note that not all data-type information can be supplied with a     type-object: for example, <code>:None:None:`flexible`</code> data-types have     a default <em>itemsize</em> of 0, and require an explicitly given size     to be useful.</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype(np.int32)      # 32-bit integer
        &gt;&gt;&gt; dt = np.dtype(np.complex128) # 128-bit complex floating-point number</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>Generic types</p>
</dt>
               <dd><p>The generic hierarchical type objects convert to corresponding     type objects according to the associations:</p>
<p>=====================================================  ===============             <code class='verbatim'>number</code>
,         <code class='verbatim'>inexact</code>
,         <code class='verbatim'>floating</code>
           <code class='verbatim'>float</code>
             <code class='verbatim'>complexfloating</code>
                                       <code class='verbatim'>cfloat</code>
             <code class='verbatim'>integer</code>
,         <code class='verbatim'>signedinteger</code>
                       <code class='verbatim'>int\_</code>
             <code class='verbatim'>unsignedinteger</code>
                                       <code class='verbatim'>uint</code>
             <code class='verbatim'>character</code>
                                             <code class='verbatim'>string</code>
             <code class='verbatim'>generic</code>
,         <code class='verbatim'>flexible</code>
                            <code class='verbatim'>void</code>
     =====================================================  ===============</p>
            <div class='admonition'>
    <div>deprecated</div>
        <!-- deflist -->
           <dl>
               <dt><p>This conversion of generic scalar types is deprecated.</p>
</dt>
               <dd><p>This is because it can be unexpected in a context such as             <code class='verbatim'>arr.astype(dtype=np.floating)</code>
, which casts an array of         <code class='verbatim'>float32</code>
     to an array of         <code class='verbatim'>float64</code>
, even though         <code class='verbatim'>float32</code>
 is a subdtype of             <code class='verbatim'>np.floating</code>
.</p>
</dd>
           </dl>

</div>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>Built-in Python types</p>
</dt>
               <dd><p>Several python types are equivalent to a corresponding     array scalar when used to generate a         <code class='verbatim'>dtype</code>
 object:</p>
<p>================  ===============             <code class='verbatim'>int</code>
              <code class='verbatim'>int\_</code>
             <code class='verbatim'>bool</code>
             <code class='verbatim'>bool\_</code>
             <code class='verbatim'>float</code>
            <code class='verbatim'>float\_</code>
             <code class='verbatim'>complex</code>
          <code class='verbatim'>cfloat</code>
             <code class='verbatim'>bytes</code>
            <code class='verbatim'>bytes\_</code>
             <code class='verbatim'>str</code>
              <code class='verbatim'>str\_</code>
             <code class='verbatim'>buffer</code>
           <code class='verbatim'>void</code>
     (all others)              <code class='verbatim'>object_</code>
     ================  ===============</p>
<p>Note that         <code class='verbatim'>str</code>
 refers to either null terminated bytes or unicode strings     depending on the Python version. In code targeting both Python 2 and 3             <code class='verbatim'>np.unicode_</code>
 should be used as a dtype for strings.     See         <code class='verbatim'>Note on string types&lt;string-dtype-note&gt;</code>
.</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype(float)   # Python-compatible floating-point number
        &gt;&gt;&gt; dt = np.dtype(int)     # Python-compatible integer
        &gt;&gt;&gt; dt = np.dtype(object)  # Python object</pre>

            <div class='admonition'>
    <div>note</div>
        <!-- deflist -->
           <dl>
               <dt><p>All other types map to         <code class='verbatim'>object_</code>
 for convenience. Code should expect</p>
</dt>
               <dd><p>that such types may map to a specific (new) dtype in the future.</p>
</dd>
           </dl>

</div>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>Types with         <code class='verbatim'>.dtype</code>
</p>
</dt>
               <dd><p>Any type object with a         <code class='verbatim'>dtype</code>
 attribute: The attribute will be     accessed and used directly. The attribute must return something     that is convertible into a dtype object.</p>
</dd>
           </dl>

               <pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from string</pre>


               <p>Several kinds of strings can be converted. Recognized strings can be prepended with         <code class='verbatim'>&#39;&gt;&#39;</code>
 (        <code class='verbatim'>big-endian</code>
),         <code class='verbatim'>&#39;&lt;&#39;</code>
 (        <code class='verbatim'>little-endian</code>
), or         <code class='verbatim'>&#39;=&#39;</code>
 (hardware-native, the default), to specify the byte order.</p>

               <!-- deflist -->
           <dl>
               <dt><p>One-character strings</p>
</dt>
               <dd><p>Each built-in data-type has a character code     (the updated Numeric typecodes), that uniquely identifies it.</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype(&#39;b&#39;)  # byte, native byte order
        &gt;&gt;&gt; dt = np.dtype(&#39;&gt;H&#39;) # big-endian unsigned short
        &gt;&gt;&gt; dt = np.dtype(&#39;&lt;f&#39;) # little-endian single-precision float
        &gt;&gt;&gt; dt = np.dtype(&#39;d&#39;)  # double-precision floating-point number</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>Array-protocol type strings (see         <code class='verbatim'>arrays.interface</code>
)</p>
</dt>
               <dd><p>The first character specifies the kind of data and the remaining    characters specify the number of bytes per item, except for Unicode,    where it is interpreted as the number of characters.  The item size    must correspond to an existing type, or an error will be raised.  The    supported kinds are</p>
<p>================   ========================            <code class='verbatim'>&#39;?&#39;</code>
            boolean            <code class='verbatim'>&#39;b&#39;</code>
            (signed) byte            <code class='verbatim'>&#39;B&#39;</code>
            unsigned byte            <code class='verbatim'>&#39;i&#39;</code>
            (signed) integer            <code class='verbatim'>&#39;u&#39;</code>
            unsigned integer            <code class='verbatim'>&#39;f&#39;</code>
            floating-point            <code class='verbatim'>&#39;c&#39;</code>
            complex-floating point            <code class='verbatim'>&#39;m&#39;</code>
            timedelta            <code class='verbatim'>&#39;M&#39;</code>
            datetime            <code class='verbatim'>&#39;O&#39;</code>
            (Python) objects            <code class='verbatim'>&#39;S&#39;</code>
,         <code class='verbatim'>&#39;a&#39;</code>
   zero-terminated bytes (not recommended)            <code class='verbatim'>&#39;U&#39;</code>
            Unicode string            <code class='verbatim'>&#39;V&#39;</code>
            raw data (        <code class='verbatim'>void</code>
)    ================   ========================</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype(&#39;i4&#39;)   # 32-bit signed integer
       &gt;&gt;&gt; dt = np.dtype(&#39;f8&#39;)   # 64-bit floating-point number
       &gt;&gt;&gt; dt = np.dtype(&#39;c16&#39;)  # 128-bit complex floating-point number
       &gt;&gt;&gt; dt = np.dtype(&#39;a25&#39;)  # 25-length zero-terminated bytes
       &gt;&gt;&gt; dt = np.dtype(&#39;U25&#39;)  # 25-character string</pre>

           <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _string-dtype-note:&#39;&gt;
           </pre>
<pre class='not-implemented'>
.. admonition:: Note on string types
    For backward compatibility with Python 2 the ``S`` and ``a`` typestrings
       remain zero-terminated bytes and `numpy.string_` continues to alias
       `numpy.bytes_`. To use actual strings in Python 3 use ``U`` or `numpy.str_`.
       For signed bytes that do not need zero-termination ``b`` or ``i1`` can be
       used.</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>String with comma-separated fields</p>
</dt>
               <dd><p>A short-hand notation for specifying the format of a structured data type is    a comma-separated string of basic formats.</p>
<p>A basic format in this context is an optional shape specifier    followed by an array-protocol type string. Parenthesis are required    on the shape if it has more than one dimension. NumPy allows a modification    on the format in that any string that can uniquely identify the    type can be used to specify the data-type in a field.    The generated data-type fields are named         <code class='verbatim'>&#39;f0&#39;</code>
,         <code class='verbatim'>&#39;f1&#39;</code>
, ...,            <code class='verbatim'>&#39;f&lt;N-1&gt;&#39;</code>
 where N (&gt;1) is the number of comma-separated basic    formats in the string. If the optional shape specifier is provided,    then the data-type for the corresponding field describes a sub-array.</p>
<pre class='not-implemented'>
.. admonition:: Example
    - field named ``f0`` containing a 32-bit integer
       - field named ``f1`` containing a 2 x 3 sub-array
         of 64-bit floating-point numbers
       - field named ``f2`` containing a 32-bit floating-point number

       &gt;&gt;&gt; dt = np.dtype(&#34;i4, (2,3)f8, f4&#34;)

       - field named ``f0`` containing a 3-character string
       - field named ``f1`` containing a sub-array of shape (3,)
         containing 64-bit unsigned integers
       - field named ``f2`` containing a 3 x 4 sub-array
         containing 10-character strings

       &gt;&gt;&gt; dt = np.dtype(&#34;a3, 3u8, (3,4)a10&#34;)</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>Type strings</p>
</dt>
               <dd><p>Any string in         <code class='verbatim'>numpy.sctypeDict</code>
.keys():</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype(&#39;uint32&#39;)   # 32-bit unsigned integer
       &gt;&gt;&gt; dt = np.dtype(&#39;float64&#39;)  # 64-bit floating-point number</pre>

</dd>
           </dl>

               <pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from tuple</pre>


               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>(flexible_dtype, itemsize)</code>
</p>
</dt>
               <dd><p>The first argument must be an object that is converted to a     zero-sized flexible data-type object, the second argument is     an integer providing the desired itemsize.</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype((np.void, 10))  # 10-byte wide data block
        &gt;&gt;&gt; dt = np.dtype((&#39;U&#39;, 10))   # 10-character unicode string</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>(fixed_dtype, shape)</code>
</p>
</dt>
               <dd><pre class='not-implemented'>
.. index:: 
    pair: dtype; sub-array</pre>

<p>The first argument is any object that can be converted into a     fixed-size data-type object. The second argument is the desired     shape of this type. If the shape parameter is 1, then the     data-type object used to be equivalent to fixed dtype. This behaviour is     deprecated since NumPy 1.17 and will raise an error in the future.     If <em>shape</em> is a tuple, then the new dtype defines a sub-array of the given     shape.</p>
<pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; dt = np.dtype((np.int32, (2,2)))          # 2 x 2 integer sub-array
        &gt;&gt;&gt; dt = np.dtype((&#39;i4, (2,3)f8, f4&#39;, (2,3))) # 2 x 3 structured sub-array</pre>

</dd>
           </dl>

               <pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from list</pre>


               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>[(field_name, field_dtype, field_shape), ...]</code>
</p>
</dt>
               <dd><p><em>obj</em> should be a list of fields where each field is described by a    tuple of length 2 or 3. (Equivalent to the         <code class='verbatim'>descr</code>
 item in the            <code class='verbatim'>~object.__array_interface__</code>
 attribute.)</p>
<p>The first element, <em>field_name</em>, is the field name (if this is            <code class='verbatim'>&#39;&#39;</code>
 then a standard field name,         <code class='verbatim'>&#39;f#&#39;</code>
, is assigned).  The    field name may also be a 2-tuple of strings where the first string    is either a &#34;title&#34; (which may be any string or unicode string) or    meta-data for the field which can be any object, and the second    string is the &#34;name&#34; which must be a valid Python identifier.</p>
<p>The second element, <em>field_dtype</em>, can be anything that can be    interpreted as a data-type.</p>
<p>The optional third element <em>field_shape</em> contains the shape if this    field represents an array of the data-type in the second    element. Note that a 3-tuple with a third argument equal to 1 is    equivalent to a 2-tuple.</p>
<p>This style does not accept <em>align</em> in the         <code class='verbatim'>dtype</code>
    constructor as it is assumed that all of the memory is accounted    for by the array interface description.</p>
<pre class='not-implemented'>
.. admonition:: Example
    Data-type with fields ``big`` (big-endian 32-bit integer) and
       ``little`` (little-endian 32-bit integer):

       &gt;&gt;&gt; dt = np.dtype([(&#39;big&#39;, &#39;&gt;i4&#39;), (&#39;little&#39;, &#39;&lt;i4&#39;)])

       Data-type with fields ``R``, ``G``, ``B``, ``A``, each being an
       unsigned 8-bit integer:

       &gt;&gt;&gt; dt = np.dtype([(&#39;R&#39;,&#39;u1&#39;), (&#39;G&#39;,&#39;u1&#39;), (&#39;B&#39;,&#39;u1&#39;), (&#39;A&#39;,&#39;u1&#39;)])</pre>

</dd>
           </dl>

               <pre class='not-implemented'>
.. index:: 
    triple: dtype; construction; from dict</pre>


               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>{&#39;names&#39;: ..., &#39;formats&#39;: ..., &#39;offsets&#39;: ..., &#39;titles&#39;: ..., &#39;itemsize&#39;: ...}</code>
</p>
</dt>
               <dd><p>This style has two required and three optional keys.  The <em>names</em>     and <em>formats</em> keys are required. Their respective values are     equal-length lists with the field names and the field formats.     The field names must be strings and the field formats can be any     object accepted by         <code class='verbatim'>dtype</code>
 constructor.</p>
<p>When the optional keys <em>offsets</em> and <em>titles</em> are provided,     their values must each be lists of the same length as the <em>names</em>     and <em>formats</em> lists. The <em>offsets</em> value is a list of byte offsets     (limited to <code><a href="/p/ctypes/*/api/ctypes.c_int.html" class='exists'>ctypes.c_int</a></code>
) for each field, while the <em>titles</em> value is a     list of titles for each field (        <code class='verbatim'>None</code>
 can be used if no title is     desired for that field). The <em>titles</em> can be any object, but when a             <code class='verbatim'>str</code>
 object will add another entry to the     fields dictionary keyed by the title and referencing the same     field tuple which will contain the title as an additional tuple     member.</p>
<p>The <em>itemsize</em> key allows the total size of the dtype to be     set, and must be an integer large enough so all the fields     are within the dtype. If the dtype being constructed is aligned,     the <em>itemsize</em> must also be divisible by the struct alignment. Total dtype     <em>itemsize</em> is limited to <code><a href="/p/ctypes/*/api/ctypes.c_int.html" class='exists'>ctypes.c_int</a></code>
.</p>
<pre class='not-implemented'>
.. admonition:: Example
    Data type with fields ``r``, ``g``, ``b``, ``a``, each being
        an 8-bit unsigned integer:

        &gt;&gt;&gt; dt = np.dtype({&#39;names&#39;: [&#39;r&#39;,&#39;g&#39;,&#39;b&#39;,&#39;a&#39;],
        ...                &#39;formats&#39;: [np.uint8, np.uint8, np.uint8, np.uint8]})

        Data type with fields ``r`` and ``b`` (with the given titles),
        both being 8-bit unsigned integers, the first at byte position
        0 from the start of the field and the second at position 2:

        &gt;&gt;&gt; dt = np.dtype({&#39;names&#39;: [&#39;r&#39;,&#39;b&#39;], &#39;formats&#39;: [&#39;u1&#39;, &#39;u1&#39;],
        ...                &#39;offsets&#39;: [0, 2],
        ...                &#39;titles&#39;: [&#39;Red pixel&#39;, &#39;Blue pixel&#39;]})</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>{&#39;field1&#39;: ..., &#39;field2&#39;: ..., ...}</code>
</p>
</dt>
               <dd><p>This usage is discouraged, because it is ambiguous with the     other dict-based construction method. If you have a field     called &#39;names&#39; and a field called &#39;formats&#39; there will be     a conflict.</p>
<p>This style allows passing in the         <code class='verbatim'>fields &lt;dtype.fields&gt;</code>
     attribute of a data-type object.</p>
<p><em>obj</em> should contain string or unicode keys that refer to             <code class='verbatim'>(data-type, offset)</code>
 or         <code class='verbatim'>(data-type, offset, title)</code>
 tuples.</p>
<pre class='not-implemented'>
.. admonition:: Example
    Data type containing field ``col1`` (10-character string at
        byte position 0), ``col2`` (32-bit float at byte position 10),
        and ``col3`` (integers at byte position 14):

        &gt;&gt;&gt; dt = np.dtype({&#39;col1&#39;: (&#39;U10&#39;, 0), &#39;col2&#39;: (np.float32, 10),
        ...                &#39;col3&#39;: (int, 14)})</pre>

</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>(base_dtype, new_dtype)</code>
</p>
</dt>
               <dd><p>In NumPy 1.7 and later, this form allows <code>:None:None:`base_dtype`</code> to be interpreted as     a structured dtype. Arrays created with this dtype will have underlying     dtype <code>:None:None:`base_dtype`</code> but will have fields and flags taken from <code>:None:None:`new_dtype`</code>.     This is useful for creating custom structured dtypes, as done in             <code class='verbatim'>record arrays &lt;arrays.classes.rec&gt;</code>
.</p>
<p>This form also makes it possible to specify struct dtypes with overlapping     fields, functioning like the &#39;union&#39; type in C. This usage is discouraged,     however, and the union mechanism is preferred.</p>
<p>Both arguments must be convertible to data-type objects with the same total     size.</p>
<pre class='not-implemented'>
.. admonition:: Example
    32-bit integer, whose first two bytes are interpreted as an integer
        via field ``real``, and the following two bytes via field ``imag``.

        &gt;&gt;&gt; dt = np.dtype((np.int32,{&#39;real&#39;:(np.int16, 0),&#39;imag&#39;:(np.int16, 2)}))

        32-bit integer, which is interpreted as consisting of a sub-array
        of shape ``(4,)`` containing 8-bit integers:

        &gt;&gt;&gt; dt = np.dtype((np.int32, (np.int8, 4)))

        32-bit integer, containing fields ``r``, ``g``, ``b``, ``a`` that
        interpret the 4 bytes in the integer as four unsigned integers:

        &gt;&gt;&gt; dt = np.dtype((&#39;i4&#39;, [(&#39;r&#39;,&#39;u1&#39;),(&#39;g&#39;,&#39;u1&#39;),(&#39;b&#39;,&#39;u1&#39;),(&#39;a&#39;,&#39;u1&#39;)]))</pre>

</dd>
           </dl>


<h1>:class:`dtype`</h1>
               <p>NumPy data type descriptions are instances of the         <code class='verbatim'>dtype</code>
 class.</p>


<h1>Attributes</h1>
               <p>The type of the data is described by the following         <code class='verbatim'>dtype</code>
  attributes:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.type
    dtype.kind
    dtype.char
    dtype.num
    dtype.str</pre>
               <p>Size of the data is in turn described by:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.name
    dtype.itemsize</pre>
               <p>Endianness of this data:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.byteorder</pre>
               <p>Information about sub-data-types in a         <code class='verbatim'>structured data type</code>
:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.fields
    dtype.names</pre>
               <p>For data types that describe sub-arrays:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.subdtype
    dtype.shape</pre>
               <p>Attributes providing additional information:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.hasobject
    dtype.flags
    dtype.isbuiltin
    dtype.isnative
    dtype.descr
    dtype.alignment
    dtype.base</pre>
               <p>Metadata attached by the user:</p>

               <pre>.. autosummary:: 
    :toctree:generated/

    dtype.metadata
</pre>

<h1>Methods</h1>
               <p>Data types have the following method for changing the byte order:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.newbyteorder</pre>
               <p>The following methods implement the pickle protocol:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.__reduce__
    dtype.__setstate__</pre>
               <p>Utility method for typing:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.__class_getitem__</pre>
               <p>Comparison operations:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    dtype.__ge__
    dtype.__gt__
    dtype.__le__
    dtype.__lt__</pre>

<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
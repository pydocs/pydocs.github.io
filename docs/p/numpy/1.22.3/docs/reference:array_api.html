<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api:&#39;&gt;
           </pre>


<h1>Array API Standard Compatibility</h1>
                           <div class='admonition'>
    <div>note</div>
        <p>The         <code class='verbatim'>numpy.array_api</code>
 module is still experimental. See <code class='not-implemented'>:None:None:`NEP 47
&lt;https://numpy.org/neps/nep-0047-array-api-standard.html&gt;`</code>.</p>

</div>


               <p>NumPy includes a reference implementation of the <code class='not-implemented'>:None:None:`array API standard
&lt;https://data-apis.org/array-api/latest/&gt;`</code> in         <code class='verbatim'>numpy.array_api</code>
. <code class='not-implemented'>:None:None:`NEP 47
&lt;https://numpy.org/neps/nep-0047-array-api-standard.html&gt;`</code> describes the motivation and scope for implementing the array API standard in NumPy.</p>

               <p>The         <code class='verbatim'>numpy.array_api</code>
 module serves as a minimal, reference implementation of the array API standard. In being minimal, the module only implements those things that are explicitly required by the specification. Certain things are allowed by the specification but are explicitly disallowed in         <code class='verbatim'>numpy.array_api</code>
. This is so that the module can serve as a reference implementation for users of the array API standard. Any consumer of the array API can test their code against         <code class='verbatim'>numpy.array_api</code>
 and be sure that they aren&#39;t using any features that aren&#39;t guaranteed by the spec, and which may not be present in other conforming libraries.</p>

               <p>The         <code class='verbatim'>numpy.array_api</code>
 module is not documented here. For a listing of the functions present in the array API specification, refer to the <a link href="https://data-apis.org/array-api/latest/" class='external'>array API
standard</a>. The         <code class='verbatim'>numpy.array_api</code>
 implementation is functionally complete, so all functionality described in the standard is implemented.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-differences:&#39;&gt;
           </pre>


<h1>Table of Differences between ``numpy.array_api`` and ``numpy``</h1>
               <p>This table outlines the primary differences between         <code class='verbatim'>numpy.array_api</code>
 from the main         <code class='verbatim'>numpy</code>
 namespace. There are three types of differences:</p>

                          <ol>               <li>               <p><strong>Strictness</strong>. Things that are only done so that         <code class='verbatim'>numpy.array_api</code>
 is a    strict, minimal implementation. They aren&#39;t actually required by the spec,    and other conforming libraries may not follow them. In most cases, spec    does not specify or require any behavior outside of the given domain. The    main         <code class='verbatim'>numpy</code>
 namespace would not need to change in any way to be    spec-compatible for these.</p>

</li>
               <li>               <p><strong>Compatible</strong>. Things that could be added to the main         <code class='verbatim'>numpy</code>
 namespace    without breaking backwards compatibility.</p>

</li>
               <li>               <p><strong>Breaking</strong>. Things that would break backwards compatibility if    implemented in the main         <code class='verbatim'>numpy</code>
 namespace.</p>

</li>
            </ol>


<h1>Name Differences</h1>
               <p>Many functions have been renamed in the spec from NumPy. These are otherwise identical in behavior, and are thus all <strong>compatible</strong> changes, unless otherwise noted.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-name-changes:&#39;&gt;
           </pre>


<h1>Function Name Changes</h1>
               <p>The following functions are named differently in the array API</p>

               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Array API name
      - NumPy namespace name
      - Notes
    * - ``acos``
      - ``arccos``
      -
    * - ``acosh``
      - ``arccosh``
      -
    * - ``asin``
      - ``arcsin``
      -
    * - ``asinh``
      - ``arcsinh``
      -
    * - ``atan``
      - ``arctan``
      -
    * - ``atan2``
      - ``arctan2``
      -
    * - ``atanh``
      - ``arctanh``
      -
    * - ``bitwise_left_shift``
      - ``left_shift``
      -
    * - ``bitwise_invert``
      - ``invert``
      -
    * - ``bitwise_right_shift``
      - ``right_shift``
      -
    * - ``bool``
      - ``bool_``
      - This is **breaking** because ``np.bool`` is currently a deprecated
        alias for the built-in ``bool``.
    * - ``concat``
      - ``concatenate``
      -
    * - ``matrix_norm`` and ``vector_norm``
      - ``norm``
      - ``matrix_norm`` and ``vector_norm`` each do a limited subset of what
        ``np.norm`` does.
    * - ``permute_dims``
      - ``transpose``
      - Unlike ``np.transpose``, the ``axis`` keyword-argument to
        ``permute_dims`` is required.
    * - ``pow``
      - ``power``
      -
    * - ``unique_all``, ``unique_counts``, ``unique_inverse``, and
        ``unique_values``
      - ``unique``
      - Each is equivalent to ``np.unique`` with certain flags set.</pre>



<h1>Function instead of method</h1>
                          <ul>               <li>               <p>        <code class='verbatim'>astype</code>
 is a function in the array API, whereas it is a method on           <code class='verbatim'>ndarray</code>
 in         <code class='verbatim'>numpy</code>
.</p>

</li>
            </ul>


<h1>``linalg`` Namespace Differences</h1>
               <p>These functions are in the         <code class='verbatim'>linalg</code>
 sub-namespace in the array API, but are only in the top-level namespace in NumPy:</p>

                          <ul>               <li>               <p>        <code class='verbatim'>cross</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>diagonal</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>matmul</code>
 (*)</p>

</li>
               <li>               <p>        <code class='verbatim'>outer</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>tensordot</code>
 (*)</p>

</li>
               <li>               <p>        <code class='verbatim'>trace</code>
</p>

</li>
            </ul>

               <p>(*): These functions are also in the top-level namespace in the array API.</p>


<h1>Keyword Argument Renames</h1>
               <p>The following functions have keyword arguments that have been renamed. The functionality of the keyword argument is identical unless otherwise stated. Each new keyword argument is not already present on the given function in         <code class='verbatim'>numpy</code>
, so the changes are <strong>compatible</strong>.</p>

               <p>Note, this page does not list function keyword arguments that are in the main         <code class='verbatim'>numpy</code>
 namespace but not in the array API. Such keyword arguments are omitted from         <code class='verbatim'>numpy.array_api</code>
 for <strong>strictness</strong>, as the spec allows functions to include additional keyword arguments from those required.</p>

               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Function
      - Array API keyword name
      - NumPy keyword name
      - Notes
    * - ``argsort`` and ``sort``
      - ``stable``
      - ``kind``
      - The definitions of ``stable`` and ``kind`` differ, as do the default
        values. The change of the default value makes this **breaking**. See
        :ref:`array_api-set-functions-differences`.
    * - ``matrix_rank``
      - ``rtol``
      - ``tol``
      - The definitions of ``rtol`` and ``tol`` differ, as do the default
        values. The change of the default value makes this **breaking**. See
        :ref:`array_api-linear-algebra-differences`.
    * - ``pinv``
      - ``rtol``
      - ``rcond``
      - The definitions of ``rtol`` and ``rcond`` are the same, but their
        default values differ, making this **breaking**. See
        :ref:`array_api-linear-algebra-differences`.
    * - ``std`` and ``var``
      - ``correction``
      - ``ddof``
      -</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-type-promotion-differences:&#39;&gt;
           </pre>


<h1>Type Promotion Differences</h1>
               <p>Type promotion is the biggest area where NumPy deviates from the spec. The most notable difference is that NumPy does value-based casting in many cases. The spec explicitly disallows value-based casting. In the array API, the result type of any operation is always determined entirely by the input types, independently of values or shapes.</p>

               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - Limited set of dtypes.
      - **Strictness**
      - ``numpy.array_api`` only implements those `dtypes that are required by
        the spec
        &lt;https://data-apis.org/array-api/latest/API_specification/data_types.html&gt;`__.
    * - Operators (like ``+``) with Python scalars only accept matching
        scalar types.
      - **Strictness**
      - For example, ``&lt;int32 array&gt; + 1.0`` is not allowed. See `the spec
        rules for mixing arrays and Python scalars
        &lt;https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars&gt;`__.
    * - Operators (like ``+``) with Python scalars always return the same dtype
        as the array.
      - **Breaking**
      - For example, ``numpy.array_api.asarray(0., dtype=float32) + 1e64`` is a
        ``float32`` array.
    * - In-place operators are disallowed when the left-hand side would be
        promoted.
      - **Breaking**
      - Example: ``a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)``. The spec explicitly disallows this.
    * - ``int`` promotion for operators is only specified for integers within
        the bounds of the dtype.
      - **Strictness**
      - ``numpy.array_api`` fallsback to ``np.ndarray`` behavior (either
        cast or raise ``OverflowError``).
    * - ``__pow__`` and ``__rpow__`` do not do value-based casting for 0-D
        arrays.
      - **Breaking**
      - For example, ``np.array(0., dtype=float32)**np.array(0.,
        dtype=float64)`` is ``float32``. Note that this is value-based casting
        on 0-D arrays, not scalars.
    * - No cross-kind casting.
      - **Strictness**
      - Namely, boolean, integer, and floating-point data types do not cast to
        each other, except explicitly with ``astype`` (this is separate from
        the behavior with Python scalars).
    * - No casting unsigned integer dtypes to floating dtypes (e.g., ``int64 +
        uint64 -&gt; float64``.
      - **Strictness**
      -
    * - ``can_cast`` and ``result_type`` are restricted.
      - **Strictness**
      - The ``numpy.array_api`` implementations disallow cross-kind casting.
    * - ``sum`` and ``prod`` always upcast ``float32`` to ``float64`` when
        ``dtype=None``.
      - **Breaking**
      -</pre>



<h1>Indexing Differences</h1>
               <p>The spec requires only a subset of indexing, but all indexing rules in the spec are compatible with NumPy&#39;s more broad indexing rules.</p>

               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - No implicit ellipses (``...``).
      - **Strictness**
      - If an index does not include an ellipsis, all axes must be indexed.
    * - The start and stop of a slice may not be out of bounds.
      - **Strictness**
      - For a slice ``i:j:k``, only the following are allowed:

        - ``i`` or ``j`` omitted (``None``).
        - ``-n &lt;= i &lt;= max(0, n - 1)``.
        - For ``k &gt; 0`` or ``k`` omitted (``None``), ``-n &lt;= j &lt;= n``.
        - For ``k &lt; 0``, ``-n - 1 &lt;= j &lt;= max(0, n - 1)``.
    * - Boolean array indices are only allowed as the sole index.
      - **Strictness**
      -
    * - Integer array indices are not allowed at all.
      - **Strictness**
      - With the exception of 0-D arrays, which are treated like integers.</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-type-strictness:&#39;&gt;
           </pre>


<h1>Type Strictness</h1>
               <p>Functions in         <code class='verbatim'>numpy.array_api</code>
 restrict their inputs to only those dtypes that are explicitly required by the spec, even when the wrapped corresponding NumPy function would allow a broader set. Here, we list each function and the dtypes that are allowed in         <code class='verbatim'>numpy.array_api</code>
. These are <strong>strictness</strong> differences because the spec does not require that other dtypes result in an error. The categories here are defined as follows:</p>

                          <ul>               <li>               <p><strong>Floating-point</strong>:         <code class='verbatim'>float32</code>
 or         <code class='verbatim'>float64</code>
.</p>

</li>
               <li>               <p><strong>Integer</strong>: Any signed or unsigned integer dtype (        <code class='verbatim'>int8</code>
,         <code class='verbatim'>int16</code>
,           <code class='verbatim'>int32</code>
,         <code class='verbatim'>int64</code>
,         <code class='verbatim'>uint8</code>
,         <code class='verbatim'>uint16</code>
,         <code class='verbatim'>uint32</code>
, or         <code class='verbatim'>uint64</code>
).</p>

</li>
               <li>               <p><strong>Boolean</strong>:         <code class='verbatim'>bool</code>
.</p>

</li>
               <li>               <p><strong>Integer or boolean</strong>: Any signed or unsigned integer dtype, or         <code class='verbatim'>bool</code>
.   For two-argument functions, both arguments must be integer or both must be           <code class='verbatim'>bool</code>
.</p>

</li>
               <li>               <p><strong>Numeric</strong>: Any integer or floating-point dtype. For two-argument   functions, both arguments must be integer or both must be   floating-point.</p>

</li>
               <li>               <p><strong>All</strong>: Any of the above dtype categories. For two-argument functions, both   arguments must be the same kind (integer, floating-point, or boolean).</p>

</li>
            </ul>

               <p>In all cases, the return dtype is chosen according to <code class='not-implemented'>:None:None:`the rules outlined in
the spec
&lt;https://data-apis.org/array-api/latest/API_specification/type_promotion.html&gt;`</code>, and does not differ from NumPy&#39;s return dtype for any of the allowed input dtypes, except in the cases mentioned specifically in the subsections below.</p>


<h1>Elementwise Functions</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Function Name
      - Dtypes
    * - ``abs``
      - Numeric
    * - ``acos``
      - Floating-point
    * - ``acosh``
      - Floating-point
    * - ``add``
      - Numeric
    * - ``asin`` (*)
      - Floating-point
    * - ``asinh`` (*)
      - Floating-point
    * - ``atan`` (*)
      - Floating-point
    * - ``atan2`` (*)
      - Floating-point
    * - ``atanh`` (*)
      - Floating-point
    * - ``bitwise_and``
      - Integer or boolean
    * - ``bitwise_invert``
      - Integer or boolean
    * - ``bitwise_left_shift`` (*)
      - Integer
    * - ``bitwise_or``
      - Integer or boolean
    * - ``bitwise_right_shift`` (*)
      - Integer
    * - ``bitwise_xor``
      - Integer or boolean
    * - ``ceil``
      - Numeric
    * - ``cos``
      - Floating-point
    * - ``cosh``
      - Floating-point
    * - ``divide``
      - Floating-point
    * - ``equal``
      - All
    * - ``exp``
      - Floating-point
    * - ``expm1``
      - Floating-point
    * - ``floor``
      - Numeric
    * - ``floor_divide``
      - Numeric
    * - ``greater``
      - Numeric
    * - ``greater_equal``
      - Numeric
    * - ``isfinite``
      - Numeric
    * - ``isinf``
      - Numeric
    * - ``isnan``
      - Numeric
    * - ``less``
      - Numeric
    * - ``less_equal``
      - Numeric
    * - ``log``
      - Floating-point
    * - ``logaddexp``
      - Floating-point
    * - ``log10``
      - Floating-point
    * - ``log1p``
      - Floating-point
    * - ``log2``
      - Floating-point
    * - ``logical_and``
      - Boolean
    * - ``logical_not``
      - Boolean
    * - ``logical_or``
      - Boolean
    * - ``logical_xor``
      - Boolean
    * - ``multiply``
      - Numeric
    * - ``negative``
      - Numeric
    * - ``not_equal``
      - All
    * - ``positive``
      - Numeric
    * - ``pow`` (*)
      - Numeric
    * - ``remainder``
      - Numeric
    * - ``round``
      - Numeric
    * - ``sign``
      - Numeric
    * - ``sin``
      - Floating-point
    * - ``sinh``
      - Floating-point
    * - ``sqrt``
      - Floating-point
    * - ``square``
      - Numeric
    * - ``subtract``
      - Numeric
    * - ``tan``
      - Floating-point
    * - ``tanh``
      - Floating-point
    * - ``trunc``
      - Numeric</pre>


               <p>(*) These functions have different names from the main         <code class='verbatim'>numpy</code>
 namespace. See         <code class='verbatim'>array_api-name-changes</code>
.</p>


<h1>Creation Functions</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Function Name
      - Dtypes
    * - ``meshgrid``
      - Any (all input dtypes must be the same)</pre>



<h1>Linear Algebra Functions</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Function Name
      - Dtypes
    * - ``cholesky``
      - Floating-point
    * - ``cross``
      - Numeric
    * - ``det``
      - Floating-point
    * - ``diagonal``
      - Any
    * - ``eigh``
      - Floating-point
    * - ``eighvals``
      - Floating-point
    * - ``inv``
      - Floating-point
    * - ``matmul``
      - Numeric
    * - ``matrix_norm`` (*)
      - Floating-point
    * - ``matrix_power``
      - Floating-point
    * - ``matrix_rank``
      - Floating-point
    * - ``matrix_transpose`` (**)
      - Any
    * - ``outer``
      - Numeric
    * - ``pinv``
      - Floating-point
    * - ``qr``
      - Floating-point
    * - ``slogdet``
      - Floating-point
    * - ``solve``
      - Floating-point
    * - ``svd``
      - Floating-point
    * - ``svdvals`` (**)
      - Floating-point
    * - ``tensordot``
      - Numeric
    * - ``trace``
      - Numeric
    * - ``vecdot`` (**)
      - Numeric
    * - ``vector_norm`` (*)
      - Floating-point</pre>


               <p>(*) Thes functions are split from         <code class='verbatim'>norm</code>
 from the main         <code class='verbatim'>numpy</code>
 namespace. See         <code class='verbatim'>array_api-name-changes</code>
.</p>

               <p>(**) These functions are new in the array API and are not in the main         <code class='verbatim'>numpy</code>
 namespace.</p>


<h1>Array Object</h1>
               <p>All the special         <code class='verbatim'>__operator__</code>
 methods on the array object behave identically to their corresponding functions (see <code class='not-implemented'>:None:None:`the spec
&lt;https://data-apis.org/array-api/latest/API_specification/array_object.html#methods&gt;`</code> for a list of which methods correspond to which functions). The exception is that operators explicitly allow Python scalars according to the <code class='not-implemented'>:None:None:`rules
outlined in the spec
&lt;https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars&gt;`</code> (see         <code class='verbatim'>array_api-type-promotion-differences</code>
).</p>


<h1>Array Object Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - No array scalars
      - **Strictness**
      - The spec does not have array scalars, only 0-D arrays. However, other
        than the promotion differences outlined in
        :ref:`array_api-type-promotion-differences`, scalars duck type as 0-D
        arrays for the purposes of the spec. The are immutable, but the spec
        `does not require mutability
        &lt;https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html&gt;`__.
    * - ``bool()``, ``int()``, and ``float()`` only work on 0-D arrays.
      - **Strictness**
      - See https://github.com/numpy/numpy/issues/10404.
    * - ``__imatmul__``
      - **Compatible**
      - ``np.ndarray`` does not currently implement ``__imatmul``. Note that
        ``a @= b`` should only defined when it does not change the shape of
        ``a``.
    * - The ``mT`` attribute for matrix transpose.
      - **Compatible**
      - See `the spec definition
        &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html&gt;`__
        for ``mT``.
    * - The ``T`` attribute should error if the input is not 2-dimensional.
      - **Breaking**
      - See `the note in the spec
        &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html&gt;`__.
    * - New method ``to_device`` and attribute ``device``
      - **Compatible**
      - The methods would effectively not do anything since NumPy is CPU only</pre>



<h1>Creation Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - ``copy`` keyword argument to ``asarray``
      - **Compatible**
      -
    * - New ``device`` keyword argument to all array creation functions
        (``asarray``, ``arange``, ``empty``, ``empty_like``, ``eye``, ``full``,
        ``full_like``, ``linspace``, ``ones``, ``ones_like``, ``zeros``, and
        ``zeros_like``).
      - **Compatible**
      - ``device`` would effectively do nothing, since NumPy is CPU only.</pre>



<h1>Elementwise Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - Various functions have been renamed.
      - **Compatible**
      - See :ref:`array_api-name-changes`.
    * - Elementwise functions are only defined for given input type
        combinations.
      - **Strictness**
      - See :ref:`array_api-type-strictness`.
    * - ``bitwise_left_shift`` and ``bitwise_right_shift`` are only defined for
        ``x2`` nonnegative.
      - **Strictness**
      -
    * - ``ceil``, ``floor``, and ``trunc`` return an integer with integer
        input.
      - **Breaking**
      - ``np.ceil``, ``np.floor``, and ``np.trunc`` return a floating-point
        dtype on integer dtype input.</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-linear-algebra-differences:&#39;&gt;
           </pre>


<h1>Linear Algebra Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - ``cholesky`` includes an ``upper`` keyword argument.
      - **Compatible**
      -
    * - ``cross`` does not allow size 2 vectors (only size 3).
      - **Breaking**
      -
    * - ``diagonal`` operates on the last two axes.
      - **Breaking**
      - Strictly speaking this can be **compatible** because ``diagonal`` is
        moved to the ``linalg`` namespace.
    * - ``eigh``, ``qr``, ``slogdet`` and ``svd`` return a named tuple.
      - **Compatible**
      - The corresponding ``numpy`` functions return a ``tuple``, with the
        resulting arrays in the same order.
    * - New functions ``matrix_norm`` and ``vector_norm``.
      - **Compatible**
      - The ``norm`` function has been omitted from the array API and split
        into ``matrix_norm`` for matrix norms and ``vector_norm`` for vector
        norms. Note that ``vector_norm`` supports any number of axes, whereas
        ``np.linalg.norm`` only supports a single axis for vector norms.
    * - ``matrix_rank`` has an ``rtol`` keyword argument instead of ``tol``.
      - **Breaking**
      - In the array API, ``rtol`` filters singular values smaller than
        ``rtol * largest_singular_value``. In ``np.linalg.matrix_rank``,
        ``tol`` filters singular values smaller than ``tol``. Furthermore, the
        default value for ``rtol`` is ``max(M, N) * eps``, whereas the default
        value of ``tol`` in ``np.linalg.matrix_rank`` is ``S.max() *
        max(M, N) * eps``, where ``S`` is the singular values of the input. The
        new flag name is compatible but the default change is breaking
    * - ``matrix_rank`` does not support 1-dimensional arrays.
      - **Breaking**
      -
    * - New function ``matrix_transpose``.
      - **Compatible**
      - Unlike ``np.transpose``, ``matrix_transpose`` only transposes the last
        two axes. See `the spec definition
        &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose&gt;`__
    * - ``outer`` only supports 1-dimensional arrays.
      - **Breaking**
      - The spec currently only specifies behavior on 1-D arrays but future
        behavior will likely be to broadcast, rather than flatten, which is
        what ``np.outer`` does.
    * - ``pinv`` has an ``rtol`` keyword argument instead of ``rcond``
      - **Breaking**
      - The meaning of ``rtol`` and ``rcond`` is the same, but the default
        value for ``rtol`` is ``max(M, N) * eps``, whereas the default value
        for ``rcond`` is ``1e-15``. The new flag name is compatible but the
        default change is breaking.
    * - ``solve`` only accepts ``x2`` as a vector when it is exactly
        1-dimensional.
      - **Breaking**
      - The ``np.linalg.solve`` behavior is ambiguous. See `this numpy issue
        &lt;https://github.com/numpy/numpy/issues/15349&gt;`__ and `this array API
        specification issue
        &lt;https://github.com/data-apis/array-api/issues/285&gt;`__ for more
        details.
    * - New function ``svdvals``.
      - **Compatible**
      - Equivalent to ``np.linalg.svd(compute_uv=False)``.
    * - The ``axis`` keyword to ``tensordot`` must be a tuple.
      - **Compatible**
      - In ``np.tensordot``, it can also be an array or array-like.
    * - ``trace`` operates on the last two axes.
      - **Breaking**
      - ``np.trace`` operates on the first two axes by default. Note that the
        array API ``trace`` does not allow specifying which axes to operate on.</pre>



<h1>Manipulation Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - Various functions have been renamed
      - **Compatible**
      - See :ref:`array_api-name-changes`.
    * - ``concat`` has different default casting rules from ``np.concatenate``
      - **Strictness**
      - No cross-kind casting. No value-based casting on scalars (when axis=None).
    * - ``stack`` has different default casting rules from ``np.stack``
      - **Strictness**
      - No cross-kind casting.
    * - New function ``permute_dims``.
      - **Compatible**
      - Unlike ``np.transpose``, the ``axis`` keyword argument to
        ``permute_dims`` is required.
    * - ``reshape`` function has a ``copy`` keyword argument
      - **Compatible**
      - See https://github.com/numpy/numpy/issues/9818.</pre>



<h1>Set Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - New functions ``unique_all``, ``unique_counts``, ``unique_inverse``,
        and ``unique_values``.
      - **Compatible**
      - See :ref:`array_api-name-changes`.
    * - The four ``unique_*`` functions return a named tuple.
      - **Compatible**
      -
    * - ``unique_all`` and ``unique_indices`` return indices with the same
        shape as ``x``.
      - **Compatible**
      - See https://github.com/numpy/numpy/issues/20638.</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array_api-set-functions-differences:&#39;&gt;
           </pre>


<h1>Set Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - ``argsort`` and ``sort`` have a ``stable`` keyword argument instead of
        ``kind``.
      - **Breaking**
      - ``stable`` is a boolean keyword argument, defaulting to ``True``.
        ``kind`` takes a string, defaulting to ``&#34;quicksort&#34;``. ``stable=True``
        is equivalent to ``kind=&#34;stable&#34;`` and ``kind=False`` is equivalent to
        ``kind=&#34;quicksort&#34;``, although any sorting algorithm is allowed by the
        spec when ``stable=False``. The new flag name is compatible but the
        default change is breaking.
    * - ``argsort`` and ``sort`` have a ``descending`` keyword argument.
      - **Compatible**
      -</pre>



<h1>Statistical Functions Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - ``sum`` and ``prod`` always upcast ``float32`` to ``float64`` when
        ``dtype=None``.
      - **Breaking**
      -
    * - The ``std`` and ``var`` functions have a ``correction`` keyword
        argument instead of ``ddof``.
      - **Compatible**
      -</pre>



<h1>Other Differences</h1>
               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Feature
      - Type
      - Notes
    * - Dtypes can only be spelled as dtype objects.
      - **Strictness**
      - For example, ``numpy.array_api.asarray([0], dtype=&#39;int32&#39;)`` is not
        allowed.
    * - ``asarray`` is not implicitly called in any function.
      - **Strictness**
      - The exception is Python operators, which accept Python scalars in
        certain cases (see :ref:`array_api-type-promotion-differences`).
    * - ``tril`` and ``triu`` require the input to be at least 2-D.
      - **Strictness**
      -
    * - finfo() return type uses ``float`` for the various attributes.
      - **Strictness**
      - The spec allows duck typing, so ``finfo`` returning dtype
        scalars is considered type compatible with ``float``.</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _basics.types:&#39;&gt;
           </pre>


<h1>Data types</h1>
               <pre class='not-implemented'>
.. seealso:: :ref:`Data type objects &lt;arrays.dtypes&gt;`
    </pre>



<h1>Array types and conversions between types</h1>
               <p>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array&#39;s data-type.</p>

               <p>The primitive types supported are tied closely to those in C:</p>

               <pre class='not-implemented'>
.. list-table:: 
    [&#39;header-rows&#39;, &#39;1&#39;]
    * - Numpy type
      - C type
      - Description

    * - `numpy.bool_`
      - ``bool``
      - Boolean (True or False) stored as a byte

    * - `numpy.byte`
      - ``signed char``
      - Platform-defined

    * - `numpy.ubyte`
      - ``unsigned char``
      - Platform-defined

    * - `numpy.short`
      - ``short``
      - Platform-defined

    * - `numpy.ushort`
      - ``unsigned short``
      - Platform-defined

    * - `numpy.intc`
      - ``int``
      - Platform-defined

    * - `numpy.uintc`
      - ``unsigned int``
      - Platform-defined

    * - `numpy.int_`
      - ``long``
      - Platform-defined

    * - `numpy.uint`
      - ``unsigned long``
      - Platform-defined

    * - `numpy.longlong`
      - ``long long``
      - Platform-defined

    * - `numpy.ulonglong`
      - ``unsigned long long``
      - Platform-defined

    * - `numpy.half` / `numpy.float16`
      -
      - Half precision float:
        sign bit, 5 bits exponent, 10 bits mantissa

    * - `numpy.single`
      - ``float``
      - Platform-defined single precision float:
        typically sign bit, 8 bits exponent, 23 bits mantissa

    * - `numpy.double`
      - ``double``
      - Platform-defined double precision float:
        typically sign bit, 11 bits exponent, 52 bits mantissa.

    * - `numpy.longdouble`
      - ``long double``
      - Platform-defined extended-precision float

    * - `numpy.csingle`
      - ``float complex``
      - Complex number, represented by two single-precision floats (real and imaginary components)

    * - `numpy.cdouble`
      - ``double complex``
      - Complex number, represented by two double-precision floats (real and imaginary components).

    * - `numpy.clongdouble`
      - ``long double complex``
      - Complex number, represented by two extended-precision floats (real and imaginary components).</pre>


               <p>Since many of these have platform-dependent definitions, a set of fixed-size aliases are provided (See         <code class='verbatim'>sized-aliases</code>
).</p>

               <p>NumPy numerical types are instances of         <code class='verbatim'>dtype</code>
 (data-type) objects, each having unique characteristics.  Once you have imported NumPy using         <code class='verbatim'>&gt;&gt;&gt; import numpy as np</code>
 the dtypes are available as         <code class='verbatim'>np.bool_</code>
,         <code class='verbatim'>np.float32</code>
, etc.</p>

               <p>Advanced types, not listed above, are explored in section         <code class='verbatim'>structured_arrays</code>
.</p>

               <p>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory).  Some types, such as         <code class='verbatim'>int</code>
 and         <code class='verbatim'>intp</code>
, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines).  This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</p>

               <p>Data-types can be used as functions to convert python numbers to array scalars (see the array scalar section for an explanation), python sequences of numbers to arrays of that type, or as arguments to the dtype keyword that many numpy functions or methods accept. Some examples::      </p>

               <pre>&gt;&gt;&gt; x = np.float32(1.0)
&gt;&gt;&gt; x
1.0
&gt;&gt;&gt; y = np.int_([1,2,4])
&gt;&gt;&gt; y
array([1, 2, 4])
&gt;&gt;&gt; z = np.arange(3, dtype=np.uint8)
&gt;&gt;&gt; z
array([0, 1, 2], dtype=uint8)</pre>
               <p>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric.  Some documentation may still refer to these, for example::    </p>

               <pre>&gt;&gt;&gt; np.array([1, 2, 3], dtype=&#39;f&#39;)
array([1.,  2.,  3.], dtype=float32)</pre>
               <p>We recommend using dtype objects instead.</p>

               <p>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example: ::      </p>

               <pre>&gt;&gt;&gt; z.astype(float)                 #doctest: +NORMALIZE_WHITESPACE
array([0.,  1.,  2.])
&gt;&gt;&gt; np.int8(z)
array([0, 1, 2], dtype=int8)</pre>
               <p>Note that, above, we use the <em>Python</em> float object as a dtype.  NumPy knows that         <code class='verbatim'>int</code>
 refers to         <code class='verbatim'>np.int_</code>
,         <code class='verbatim'>bool</code>
 means         <code class='verbatim'>np.bool_</code>
, that         <code class='verbatim'>float</code>
 is         <code class='verbatim'>np.float_</code>
 and         <code class='verbatim'>complex</code>
 is         <code class='verbatim'>np.complex_</code>
. The other data-types do not have Python equivalents.</p>

               <p>To determine the type of an array, look at the dtype attribute::      </p>

               <pre>&gt;&gt;&gt; z.dtype
dtype(&#39;uint8&#39;)</pre>
               <p>dtype objects also contain information about the type, such as its bit-width and its byte-order.  The data type can also be used indirectly to query properties of the type, such as whether it is an integer::      </p>

               <pre>&gt;&gt;&gt; d = np.dtype(int)
&gt;&gt;&gt; d #doctest: +SKIP
dtype(&#39;int32&#39;)

&gt;&gt;&gt; np.issubdtype(d, np.integer)
True

&gt;&gt;&gt; np.issubdtype(d, np.floating)
False</pre>

<h1>Array Scalars</h1>
               <p>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype).  Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples).  There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g.,         <code class='verbatim'>int</code>
,         <code class='verbatim'>float</code>
,         <code class='verbatim'>complex</code>
,         <code class='verbatim'>str</code>
,         <code class='verbatim'>unicode</code>
).</p>

               <p>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g.         <code class='verbatim'>int16</code>
).  Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not.  NumPy scalars also have many of the same methods arrays do.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _overflow-errors:&#39;&gt;
           </pre>


<h1>Overflow Errors</h1>
               <p>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example,  <code>:None:None:`numpy.power`</code> evaluates         <code class='verbatim'>100 ** 8</code>
 correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</p>

                           <pre>&gt;&gt;&gt; np.power(100, 8, dtype=np.int64)
10000000000000000
&gt;&gt;&gt; np.power(100, 8, dtype=np.int32)
1874919424
</pre>

               <p>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&#39;s         <code class='verbatim'>int</code>
. Unlike NumPy, the size of Python&#39;s         <code class='verbatim'>int</code>
 is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</p>

               <p>NumPy provides <code><a href="/p/numpy/*/api/numpy.iinfo.html" class='exists'>numpy.iinfo</a></code>
 and <code><a href="/p/numpy/*/api/numpy.finfo.html" class='exists'>numpy.finfo</a></code>
 to verify the minimum or maximum values of NumPy integer and floating point values respectively ::      </p>

               <pre>&gt;&gt;&gt; np.iinfo(int) # Bounds of the default integer on this system.
iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)
&gt;&gt;&gt; np.iinfo(np.int32) # Bounds of a 32-bit integer
iinfo(min=-2147483648, max=2147483647, dtype=int32)
&gt;&gt;&gt; np.iinfo(np.int64) # Bounds of a 64-bit integer
iinfo(min=-9223372036854775808, max=9223372036854775807, dtype=int64)</pre>
               <p>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</p>

                           <pre>&gt;&gt;&gt; np.power(100, 100, dtype=np.int64) # Incorrect even with 64-bit int
0
&gt;&gt;&gt; np.power(100, 100, dtype=np.float64)
1e+200
</pre>


<h1>Extended Precision</h1>
               <p>Python&#39;s floating-point numbers are usually 64-bit floating-point numbers, nearly equivalent to         <code class='verbatim'>np.float64</code>
. In some unusual situations it may be useful to use floating-point numbers with more precision. Whether this is possible in numpy depends on the hardware and on the development environment: specifically, x86 machines provide hardware floating-point with 80-bit precision, and while most C compilers provide this as their         <code class='verbatim'>long double</code>
 type, MSVC (standard for Windows builds) makes         <code class='verbatim'>long double</code>
 identical to         <code class='verbatim'>double</code>
 (64 bits). NumPy makes the compiler&#39;s         <code class='verbatim'>long double</code>
 available as         <code class='verbatim'>np.longdouble</code>
 (and         <code class='verbatim'>np.clongdouble</code>
 for the complex numbers). You can find out what your numpy provides with         <code class='verbatim'>np.finfo(np.longdouble)</code>
.</p>

               <p>NumPy does not provide a dtype with more precision than C&#39;s         <code class='verbatim'>long double</code>
; in particular, the 128-bit IEEE quad precision data type (FORTRAN&#39;s         <code class='verbatim'>REAL*16</code>
) is not available.</p>

               <p>For efficient memory alignment,         <code class='verbatim'>np.longdouble</code>
 is usually stored padded with zero bits, either to 96 or 128 bits. Which is more efficient depends on hardware and development environment; typically on 32-bit systems they are padded to 96 bits, while on 64-bit systems they are typically padded to 128 bits.         <code class='verbatim'>np.longdouble</code>
 is padded to the system default;         <code class='verbatim'>np.float96</code>
 and         <code class='verbatim'>np.float128</code>
 are provided for users who want specific padding. In spite of the names,         <code class='verbatim'>np.float96</code>
 and         <code class='verbatim'>np.float128</code>
 provide only as much precision as         <code class='verbatim'>np.longdouble</code>
, that is, 80 bits on most x86 machines and 64 bits in standard Windows builds.</p>

               <p>Be warned that even if         <code class='verbatim'>np.longdouble</code>
 offers more precision than python         <code class='verbatim'>float</code>
, it is easy to lose that extra precision, since python often forces values to pass through         <code class='verbatim'>float</code>
. For example, the         <code class='verbatim'>%</code>
 formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value         <code class='verbatim'>1 + np.finfo(np.longdouble).eps</code>
.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
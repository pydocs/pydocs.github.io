<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>NumPy core libraries</h1>
               <pre class='not-implemented'>
.. sectionauthor:: David Cournapeau
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Starting from numpy 1.3.0, we are working on separating the pure C, &#34;computational&#34; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc...).</p>


<h1>NumPy core math library</h1>
               <p>The numpy core math library (&#39;npymath&#39;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</p>

               <p>The available functions are defined in &lt;numpy/npy_math.h&gt; - please refer to this header when in doubt.</p>


<h1>Floating point classification</h1>
               <pre class='not-implemented'>
.. c:macro:: NPY_NAN
    This macro is defined to a NaN (Not a Number), and is guaranteed to have
    the signbit unset (&#39;positive&#39; NaN). The corresponding single and extension
    precision macro are available with the suffix F and L.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_INFINITY
    This macro is defined to a positive inf. The corresponding single and
    extension precision macro are available with the suffix F and L.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_PZERO
    This macro is defined to positive zero. The corresponding single and
    extension precision macro are available with the suffix F and L.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_NZERO
    This macro is defined to negative zero (that is with the sign bit set). The
    corresponding single and extension precision macro are available with the
    suffix F and L.</pre>


               <pre class='not-implemented'>
.. c:macro:: npy_isnan(x)
    This is a macro, and is equivalent to C99 isnan: works for single, double
    and extended precision, and return a non 0 value if x is a NaN.</pre>


               <pre class='not-implemented'>
.. c:macro:: npy_isfinite(x)
    This is a macro, and is equivalent to C99 isfinite: works for single,
    double and extended precision, and return a non 0 value if x is neither a
    NaN nor an infinity.</pre>


               <pre class='not-implemented'>
.. c:macro:: npy_isinf(x)
    This is a macro, and is equivalent to C99 isinf: works for single, double
    and extended precision, and return a non 0 value if x is infinite (positive
    and negative).</pre>


               <pre class='not-implemented'>
.. c:macro:: npy_signbit(x)
    This is a macro, and is equivalent to C99 signbit: works for single, double
    and extended precision, and return a non 0 value if x has the signbit set
    (that is the number is negative).</pre>


               <pre class='not-implemented'>
.. c:macro:: npy_copysign(x, y)
    This is a function equivalent to C99 copysign: return x with the same sign
    as y. Works for any value, including inf and nan. Single and extended
    precisions are available with suffix f and l.

    .. versionadded:: 1.4.0</pre>



<h1>Useful math constants</h1>
               <p>The following math constants are available in         <code class='verbatim'>npy_math.h</code>
. Single and extended precision are also available by adding the         <code class='verbatim'>f</code>
 and         <code class='verbatim'>l</code>
 suffixes respectively.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_E
    Base of natural logarithm (:math:`e`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_LOG2E
    Logarithm to base 2 of the Euler constant (:math:`\frac{\ln(e)}{\ln(2)}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_LOG10E
    Logarithm to base 10 of the Euler constant (:math:`\frac{\ln(e)}{\ln(10)}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_LOGE2
    Natural logarithm of 2 (:math:`\ln(2)`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_LOGE10
    Natural logarithm of 10 (:math:`\ln(10)`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_PI
    Pi (:math:`\pi`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_PI_2
    Pi divided by 2 (:math:`\frac{\pi}{2}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_PI_4
    Pi divided by 4 (:math:`\frac{\pi}{4}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_1_PI
    Reciprocal of pi (:math:`\frac{1}{\pi}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_2_PI
    Two times the reciprocal of pi (:math:`\frac{2}{\pi}`)</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_EULER
    The Euler constant
        :math:`\lim_{n\rightarrow\infty}({\sum_{k=1}^n{\frac{1}{k}}-\ln n})`</pre>



<h1>Low-level floating point manipulation</h1>
               <p>Those can be useful for precise floating point comparison.</p>

               <pre class='not-implemented'>
.. c:function:: double npy_nextafter(double x, double y)
    This is a function equivalent to C99 nextafter: return next representable
    floating point value from x in the direction of y. Single and extended
    precisions are available with suffix f and l.

    .. versionadded:: 1.4.0</pre>


               <pre class='not-implemented'>
.. c:function:: double npy_spacing(double x)
    This is a function equivalent to Fortran intrinsic. Return distance between
    x and next representable floating point value from x, e.g. spacing(1) ==
    eps. spacing of nan and +/- inf return nan. Single and extended precisions
    are available with suffix f and l.

    .. versionadded:: 1.4.0</pre>


               <pre class='not-implemented'>
.. c:function:: void npy_set_floatstatus_divbyzero()
    Set the divide by zero floating point exception

    .. versionadded:: 1.6.0</pre>


               <pre class='not-implemented'>
.. c:function:: void npy_set_floatstatus_overflow()
    Set the overflow floating point exception

    .. versionadded:: 1.6.0</pre>


               <pre class='not-implemented'>
.. c:function:: void npy_set_floatstatus_underflow()
    Set the underflow floating point exception

    .. versionadded:: 1.6.0</pre>


               <pre class='not-implemented'>
.. c:function:: void npy_set_floatstatus_invalid()
    Set the invalid floating point exception

    .. versionadded:: 1.6.0</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_get_floatstatus()
    Get floating point status. Returns a bitmask with following possible flags:

    * NPY_FPE_DIVIDEBYZERO
    * NPY_FPE_OVERFLOW
    * NPY_FPE_UNDERFLOW
    * NPY_FPE_INVALID

    Note that :c:func:`npy_get_floatstatus_barrier` is preferable as it prevents
    aggressive compiler optimizations reordering the call relative to
    the code setting the status, which could lead to incorrect results.

    .. versionadded:: 1.9.0</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_get_floatstatus_barrier(char*)
    Get floating point status. A pointer to a local variable is passed in to
    prevent aggressive compiler optimizations from reordering this function call
    relative to the code setting the status, which could lead to incorrect
    results.

    Returns a bitmask with following possible flags:

    * NPY_FPE_DIVIDEBYZERO
    * NPY_FPE_OVERFLOW
    * NPY_FPE_UNDERFLOW
    * NPY_FPE_INVALID

    .. versionadded:: 1.15.0</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_clear_floatstatus()
    Clears the floating point status. Returns the previous status mask.

    Note that :c:func:`npy_clear_floatstatus_barrier` is preferable as it
    prevents aggressive compiler optimizations reordering the call relative to
    the code setting the status, which could lead to incorrect results.

    .. versionadded:: 1.9.0</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_clear_floatstatus_barrier(char*)
    Clears the floating point status. A pointer to a local variable is passed in to
    prevent aggressive compiler optimizations from reordering this function call.
    Returns the previous status mask.

    .. versionadded:: 1.15.0</pre>



<h1>Complex functions</h1>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</p>

               <pre class='not-implemented'>
.. code-block:: c
    /* a = 1 + 2i \*/
    npy_complex a = npy_cpack(1, 2);
    npy_complex b;

    b = npy_log(a);</pre>



<h1>Linking against the core math library in an extension</h1>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</p>

                           <pre>.. hidden in a comment so as to be included in refguide but not rendered documentation
        &gt;&gt;&gt; import numpy.distutils.misc_util
        &gt;&gt;&gt; config = np.distutils.misc_util.Configuration(None, &#39;&#39;, &#39;.&#39;)
        &gt;&gt;&gt; with open(&#39;foo.c&#39;, &#39;w&#39;) as f: pass

&gt;&gt;&gt; from numpy.distutils.misc_util import get_info
&gt;&gt;&gt; info = get_info(&#39;npymath&#39;)
&gt;&gt;&gt; _ = config.add_extension(&#39;foo&#39;, sources=[&#39;foo.c&#39;], extra_info=info)
</pre>

               <p>In other words, the usage of info is exactly the same as when using blas_info and co.</p>


<h1>Half-precision functions</h1>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>The header file &lt;numpy/halffloat.h&gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</p>

               <p>Like for other types, NumPy includes a typedef npy_half for the 16 bit float.  Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16.  For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</p>

               <p>For these reasons, NumPy provides an API to work with npy_half values accessible by including &lt;numpy/halffloat.h&gt; and linking to &#39;npymath&#39;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</p>

               <pre class='not-implemented'>
.. code-block:: c
    npy_half sum(int n, npy_half *array) {
        float ret = 0;
        while(n--) {
            ret += npy_half_to_float(*array++);
        }
        return npy_float_to_half(ret);
    }</pre>


               <p>External Links:</p>

                          <ul>               <li>               <p><code>:None:None:`754-2008 IEEE Standard for Floating-Point Arithmetic`</code></p>

</li>
               <li>               <p><code>:None:None:`Half-precision Float Wikipedia Article`</code>.</p>

</li>
               <li>               <p><code>:None:None:`OpenGL Half Float Pixel Support`</code></p>

</li>
               <li>               <p><code>:None:None:`The OpenEXR image format`</code>.</p>

</li>
            </ul>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;__ https://ieeexplore.ieee.org/document/4610935/&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;__ https://en.wikipedia.org/wiki/Half-precision_floating-point_format&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;__ https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_half_float_pixel.txt&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;__ https://www.openexr.com/about.html&#39;&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_ZERO
    This macro is defined to positive zero.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_PZERO
    This macro is defined to positive zero.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_NZERO
    This macro is defined to negative zero.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_ONE
    This macro is defined to 1.0.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_NEGONE
    This macro is defined to -1.0.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_PINF
    This macro is defined to +inf.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_NINF
    This macro is defined to -inf.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_HALF_NAN
    This macro is defined to a NaN value, guaranteed to have its sign bit unset.</pre>


               <pre class='not-implemented'>
.. c:function:: float npy_half_to_float(npy_half h)
    Converts a half-precision float to a single-precision float.</pre>


               <pre class='not-implemented'>
.. c:function:: double npy_half_to_double(npy_half h)
    Converts a half-precision float to a double-precision float.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_half npy_float_to_half(float f)
    Converts a single-precision float to a half-precision float.  The
    value is rounded to the nearest representable half, with ties going
    to the nearest even.  If the value is too small or too big, the
    system&#39;s floating point underflow or overflow bit will be set.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_half npy_double_to_half(double d)
    Converts a double-precision float to a half-precision float.  The
    value is rounded to the nearest representable half, with ties going
    to the nearest even.  If the value is too small or too big, the
    system&#39;s floating point underflow or overflow bit will be set.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_eq(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 == h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_ne(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 != h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_le(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 &lt;= h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_lt(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 &lt; h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_ge(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 &gt;= h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_gt(npy_half h1, npy_half h2)
    Compares two half-precision floats (h1 &gt; h2).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_eq_nonan(npy_half h1, npy_half h2)
    Compares two half-precision floats that are known to not be NaN (h1 == h2).  If
    a value is NaN, the result is undefined.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_lt_nonan(npy_half h1, npy_half h2)
    Compares two half-precision floats that are known to not be NaN (h1 &lt; h2).  If
    a value is NaN, the result is undefined.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_le_nonan(npy_half h1, npy_half h2)
    Compares two half-precision floats that are known to not be NaN (h1 &lt;= h2).  If
    a value is NaN, the result is undefined.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_iszero(npy_half h)
    Tests whether the half-precision float has a value equal to zero.  This may be slightly
    faster than calling npy_half_eq(h, NPY_ZERO).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_isnan(npy_half h)
    Tests whether the half-precision float is a NaN.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_isinf(npy_half h)
    Tests whether the half-precision float is plus or minus Inf.</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_isfinite(npy_half h)
    Tests whether the half-precision float is finite (not NaN or Inf).</pre>


               <pre class='not-implemented'>
.. c:function:: int npy_half_signbit(npy_half h)
    Returns 1 is h is negative, 0 otherwise.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_half npy_half_copysign(npy_half x, npy_half y)
    Returns the value of x with the sign bit copied from y.  Works for any value,
    including Inf and NaN.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_half npy_half_spacing(npy_half h)
    This is the same for half-precision float as npy_spacing and npy_spacingf
    described in the low-level floating point section.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_half npy_half_nextafter(npy_half x, npy_half y)
    This is the same for half-precision float as npy_nextafter and npy_nextafterf
    described in the low-level floating point section.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_uint16 npy_floatbits_to_halfbits(npy_uint32 f)
    Low-level function which converts a 32-bit single-precision float, stored
    as a uint32, into a 16-bit half-precision float.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_uint16 npy_doublebits_to_halfbits(npy_uint64 d)
    Low-level function which converts a 64-bit double-precision float, stored
    as a uint64, into a 16-bit half-precision float.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_uint32 npy_halfbits_to_floatbits(npy_uint16 h)
    Low-level function which converts a 16-bit half-precision float
    into a 32-bit single-precision float, stored as a uint32.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_uint64 npy_halfbits_to_doublebits(npy_uint16 h)
    Low-level function which converts a 16-bit half-precision float
    into a 64-bit double-precision float, stored as a uint64.</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
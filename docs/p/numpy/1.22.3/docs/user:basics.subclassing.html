<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _basics.subclassing:&#39;&gt;
           </pre>


<h1>Subclassing ndarray</h1>

<h1>Introduction</h1>
               <p>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects.  On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</p>


<h1>ndarrays and object creation</h1>
               <p>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways.  These are:</p>

                          <ol>               <li>               <p>Explicit constructor call - as in         <code class='verbatim'>MySubClass(params)</code>
.  This is    the usual route to Python instance creation.</p>

</li>
               <li>               <p>View casting - casting an existing ndarray as a given subclass</p>

</li>
               <li>               <p>New from template - creating a new instance from a template    instance. Examples include returning slices from a subclassed array,    creating return types from ufuncs, and copying arrays.  See            <code class='verbatim'>new-from-template</code>
 for more details</p>

</li>
            </ol>

               <p>The last two are characteristics of ndarrays - in order to support things like array slicing.  The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _view-casting:&#39;&gt;
           </pre>


<h1>View casting</h1>
               <p><em>View casting</em> is the standard ndarray mechanism by which you take an ndarray of any subclass, and return a view of the array as another (specified) subclass:</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; # create a completely useless ndarray subclass
&gt;&gt;&gt; class C(np.ndarray): pass
&gt;&gt;&gt; # create a standard ndarray
&gt;&gt;&gt; arr = np.zeros((3,))
&gt;&gt;&gt; # take a view of it, as our useless subclass
&gt;&gt;&gt; c_arr = arr.view(C)
&gt;&gt;&gt; type(c_arr)
&lt;class &#39;__main__.C&#39;&gt;</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _new-from-template:&#39;&gt;
           </pre>


<h1>Creating new from template</h1>
               <p>New instances of an ndarray subclass can also come about by a very similar mechanism to         <code class='verbatim'>view-casting</code>
, when numpy finds it needs to create a new instance from a template instance.  The most obvious place this has to happen is when you are taking slices of subclassed arrays. For example:</p>

               <pre>&gt;&gt;&gt; v = c_arr[1:]
&gt;&gt;&gt; type(v) # the view is of type &#39;C&#39;
&lt;class &#39;__main__.C&#39;&gt;
&gt;&gt;&gt; v is c_arr # but it&#39;s a new instance
False</pre>
               <p>The slice is a <em>view</em> onto the original         <code class='verbatim'>c_arr</code>
 data.  So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</p>

               <p>There are other points in the use of ndarrays where we need such views, such as copying arrays (        <code class='verbatim'>c_arr.copy()</code>
), creating ufunc output arrays (see also         <code class='verbatim'>array-wrap</code>
), and reducing methods (like         <code class='verbatim'>c_arr.mean()</code>
).</p>


<h1>Relationship of view casting and new-from-template</h1>
               <p>These paths both use the same machinery.  We make the distinction here, because they result in different input to your methods.  Specifically,         <code class='verbatim'>view-casting</code>
 means you have created a new instance of your array type from any potential subclass of ndarray.          <code class='verbatim'>new-from-template</code>
 means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</p>


<h1>Implications for subclassing</h1>
               <p>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also         <code class='verbatim'>view-casting</code>
 or         <code class='verbatim'>new-from-template</code>
.  NumPy has the machinery to do this, and it is this machinery that makes subclassing slightly non-standard.</p>

               <p>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</p>

               <p>The first is the use of the         <code class='verbatim'>ndarray.__new__</code>
 method for the main work of object initialization, rather then the more usual         <code class='verbatim'>__init__</code>
 method.  The second is the use of the         <code class='verbatim'>__array_finalize__</code>
 method to allow subclasses to clean up after the creation of views and new instances from templates.</p>


<h1>A brief Python primer on ``__new__`` and ``__init__``</h1>
               <p>        <code class='verbatim'>__new__</code>
 is a standard Python method, and, if present, is called before         <code class='verbatim'>__init__</code>
 when we create a class instance. See the <code>:None:None:`python
__new__ documentation
&lt;https://docs.python.org/reference/datamodel.html#object.__new__&gt;`</code> for more detail.</p>

               <p>For example, consider the following Python code:</p>

               <pre>&gt;&gt;&gt; class C:
&gt;&gt;&gt;     def __new__(cls, *args):
&gt;&gt;&gt;         print(&#39;Cls in __new__:&#39;, cls)
&gt;&gt;&gt;         print(&#39;Args in __new__:&#39;, args)
&gt;&gt;&gt;         # The `object` type __new__ method takes a single argument.
&gt;&gt;&gt;         return object.__new__(cls)
&gt;&gt;&gt;     def __init__(self, *args):
&gt;&gt;&gt;         print(&#39;type(self) in __init__:&#39;, type(self))
&gt;&gt;&gt;         print(&#39;Args in __init__:&#39;, args)</pre>
               <p>meaning that we get:</p>

               <pre>&gt;&gt;&gt; c = C(&#39;hello&#39;)
Cls in __new__: &lt;class &#39;C&#39;&gt;
Args in __new__: (&#39;hello&#39;,)
type(self) in __init__: &lt;class &#39;C&#39;&gt;
Args in __init__: (&#39;hello&#39;,)</pre>
               <p>When we call         <code class='verbatim'>C(&#39;hello&#39;)</code>
, the         <code class='verbatim'>__new__</code>
 method gets its own class as first argument, and the passed argument, which is the string         <code class='verbatim'>&#39;hello&#39;</code>
.  After python calls         <code class='verbatim'>__new__</code>
, it usually (see below) calls our         <code class='verbatim'>__init__</code>
 method, with the output of         <code class='verbatim'>__new__</code>
 as the first argument (now a class instance), and the passed arguments following.</p>

               <p>As you can see, the object can be initialized in the         <code class='verbatim'>__new__</code>
 method or the         <code class='verbatim'>__init__</code>
 method, or both, and in fact ndarray does not have an         <code class='verbatim'>__init__</code>
 method, because all the initialization is done in the         <code class='verbatim'>__new__</code>
 method.</p>

               <p>Why use         <code class='verbatim'>__new__</code>
 rather than just the usual         <code class='verbatim'>__init__</code>
?  Because in some cases, as for ndarray, we want to be able to return an object of some other class.  Consider the following:</p>

               <pre class='not-implemented'>
.. testcode:: 
    class D(C):
        def __new__(cls, *args):
            print(&#39;D cls is:&#39;, cls)
            print(&#39;D args in __new__:&#39;, args)
            return C.__new__(C, *args)

        def __init__(self, *args):
            # we never get here
            print(&#39;In D __init__&#39;)</pre>


               <p>meaning that:</p>

               <pre>&gt;&gt;&gt; obj = D(&#39;hello&#39;)
D cls is: &lt;class &#39;D&#39;&gt;
D args in __new__: (&#39;hello&#39;,)
Cls in __new__: &lt;class &#39;C&#39;&gt;
Args in __new__: (&#39;hello&#39;,)
&gt;&gt;&gt; type(obj)
&lt;class &#39;C&#39;&gt;</pre>
               <p>The definition of         <code class='verbatim'>C</code>
 is the same as before, but for         <code class='verbatim'>D</code>
, the         <code class='verbatim'>__new__</code>
 method returns an instance of class         <code class='verbatim'>C</code>
 rather than         <code class='verbatim'>D</code>
.  Note that the         <code class='verbatim'>__init__</code>
 method of         <code class='verbatim'>D</code>
 does not get called.  In general, when the         <code class='verbatim'>__new__</code>
 method returns an object of class other than the class in which it is defined, the         <code class='verbatim'>__init__</code>
 method of that class is not called.</p>

               <p>This is how subclasses of the ndarray class are able to return views that preserve the class type.  When taking a view, the standard ndarray machinery creates the new ndarray object with something like::    </p>

               <pre>obj = ndarray.__new__(subtype, shape, ...</pre>
               <p>where         <code class='verbatim'>subdtype</code>
 is the subclass.  Thus the returned view is of the same class as the subclass, rather than being of class         <code class='verbatim'>ndarray</code>
.</p>

               <p>That solves the problem of returning views of the same type, but now we have a new problem.  The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray         <code class='verbatim'>__new__</code>
 method knows nothing of what we have done in our own         <code class='verbatim'>__new__</code>
 method in order to set attributes, and so on.  (Aside - why not call         <code class='verbatim'>obj = subdtype.__new__(...</code>
 then?  Because we may not have a         <code class='verbatim'>__new__</code>
 method with the same call signature).</p>


<h1>The role of ``__array_finalize__``</h1>
               <p>        <code class='verbatim'>__array_finalize__</code>
 is the mechanism that numpy provides to allow subclasses to handle the various ways that new instances get created.</p>

               <p>Remember that subclass instances can come about in these three ways:</p>

                          <ol>               <li>               <p>explicit constructor call (        <code class='verbatim'>obj = MySubClass(params)</code>
).  This will    call the usual sequence of         <code class='verbatim'>MySubClass.__new__</code>
 then (if it exists)            <code class='verbatim'>MySubClass.__init__</code>
.</p>

</li>
               <li>               <p>        <code class='verbatim'>view-casting</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>new-from-template</code>
</p>

</li>
            </ol>

               <p>Our         <code class='verbatim'>MySubClass.__new__</code>
 method only gets called in the case of the explicit constructor call, so we can&#39;t rely on         <code class='verbatim'>MySubClass.__new__</code>
 or         <code class='verbatim'>MySubClass.__init__</code>
 to deal with the view casting and new-from-template.  It turns out that         <code class='verbatim'>MySubClass.__array_finalize__</code>
 <em>does</em> get called for all three methods of object creation, so this is where our object creation housekeeping usually goes.</p>

                          <ul>               <li>               <p>For the explicit constructor call, our subclass will need to create a   new ndarray instance of its own class.  In practice this means that   we, the authors of the code, will need to make a call to           <code class='verbatim'>ndarray.__new__(MySubClass,...)</code>
, a class-hierarchy prepared call to           <code class='verbatim'>super().__new__(cls, ...)</code>
, or do view casting of an existing array   (see below)</p>

</li>
               <li>               <p>For view casting and new-from-template, the equivalent of           <code class='verbatim'>ndarray.__new__(MySubClass,...</code>
 is called, at the C level.</p>

</li>
            </ul>

               <p>The arguments that         <code class='verbatim'>__array_finalize__</code>
 receives differ for the three methods of instance creation above.</p>

               <p>The following code allows us to look at the call sequences and arguments:</p>

               <pre class='not-implemented'>
.. testcode:: 
    import numpy as np

    class C(np.ndarray):
        def __new__(cls, *args, **kwargs):
            print(&#39;In __new__ with class %s&#39; % cls)
            return super().__new__(cls, *args, **kwargs)

        def __init__(self, *args, **kwargs):
            # in practice you probably will not need or want an __init__
            # method for your subclass
            print(&#39;In __init__ with class %s&#39; % self.__class__)

        def __array_finalize__(self, obj):
            print(&#39;In array_finalize:&#39;)
            print(&#39;   self type is %s&#39; % type(self))
            print(&#39;   obj type is %s&#39; % type(obj))</pre>


               <p>Now:</p>

               <pre>&gt;&gt;&gt; # Explicit constructor
&gt;&gt;&gt; c = C((10,))
In __new__ with class &lt;class &#39;C&#39;&gt;
In array_finalize:
   self type is &lt;class &#39;C&#39;&gt;
   obj type is &lt;type &#39;NoneType&#39;&gt;
In __init__ with class &lt;class &#39;C&#39;&gt;
&gt;&gt;&gt; # View casting
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; cast_a = a.view(C)
In array_finalize:
   self type is &lt;class &#39;C&#39;&gt;
   obj type is &lt;type &#39;numpy.ndarray&#39;&gt;
&gt;&gt;&gt; # Slicing (example of new-from-template)
&gt;&gt;&gt; cv = c[:1]
In array_finalize:
   self type is &lt;class &#39;C&#39;&gt;
   obj type is &lt;class &#39;C&#39;&gt;</pre>
               <p>The signature of         <code class='verbatim'>__array_finalize__</code>
 is::      </p>

               <pre>def __array_finalize__(self, obj):</pre>
               <p>One sees that the         <code class='verbatim'>super</code>
 call, which goes to         <code class='verbatim'>ndarray.__new__</code>
, passes         <code class='verbatim'>__array_finalize__</code>
 the new object, of our own class (        <code class='verbatim'>self</code>
) as well as the object from which the view has been taken (        <code class='verbatim'>obj</code>
).  As you can see from the output above, the         <code class='verbatim'>self</code>
 is always a newly created instance of our subclass, and the type of         <code class='verbatim'>obj</code>
 differs for the three instance creation methods:</p>

                          <ul>               <li>               <p>When called from the explicit constructor,         <code class='verbatim'>obj</code>
 is         <code class='verbatim'>None</code>
</p>

</li>
               <li>               <p>When called from view casting,         <code class='verbatim'>obj</code>
 can be an instance of any   subclass of ndarray, including our own.</p>

</li>
               <li>               <p>When called in new-from-template,         <code class='verbatim'>obj</code>
 is another instance of our   own subclass, that we might use to update the new         <code class='verbatim'>self</code>
 instance.</p>

</li>
            </ul>

               <p>Because         <code class='verbatim'>__array_finalize__</code>
 is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</p>

               <p>This may be clearer with an example.</p>


<h1>Simple example - adding an extra attribute to ndarray</h1>
               <pre class='not-implemented'>
.. testcode:: 
    import numpy as np

    class InfoArray(np.ndarray):

        def __new__(subtype, shape, dtype=float, buffer=None, offset=0,
                    strides=None, order=None, info=None):
            # Create the ndarray instance of our type, given the usual
            # ndarray input arguments.  This will call the standard
            # ndarray constructor, but return an object of our type.
            # It also triggers a call to InfoArray.__array_finalize__
            obj = super().__new__(subtype, shape, dtype,
                                  buffer, offset, strides, order)
            # set the new &#39;info&#39; attribute to the value passed
            obj.info = info
            # Finally, we must return the newly created object:
            return obj

        def __array_finalize__(self, obj):
            # ``self`` is a new object resulting from
            # ndarray.__new__(InfoArray, ...), therefore it only has
            # attributes that the ndarray.__new__ constructor gave it -
            # i.e. those of a standard ndarray.
            #
            # We could have got to the ndarray.__new__ call in 3 ways:
            # From an explicit constructor - e.g. InfoArray():
            #    obj is None
            #    (we&#39;re in the middle of the InfoArray.__new__
            #    constructor, and self.info will be set when we return to
            #    InfoArray.__new__)
            if obj is None: return
            # From view casting - e.g arr.view(InfoArray):
            #    obj is arr
            #    (type(obj) can be InfoArray)
            # From new-from-template - e.g infoarr[:3]
            #    type(obj) is InfoArray
            #
            # Note that it is here, rather than in the __new__ method,
            # that we set the default value for &#39;info&#39;, because this
            # method sees all creation of default objects - with the
            # InfoArray.__new__ constructor, but also with
            # arr.view(InfoArray).
            self.info = getattr(obj, &#39;info&#39;, None)
            # We do not need to return anything</pre>


               <p>Using the object looks like this:</p>

                           <pre>&gt;&gt;&gt; obj = InfoArray(shape=(3,)) # explicit constructor
&gt;&gt;&gt; type(obj)
&lt;class &#39;InfoArray&#39;&gt;
&gt;&gt;&gt; obj.info is None
True
&gt;&gt;&gt; obj = InfoArray(shape=(3,), info=&#39;information&#39;)
&gt;&gt;&gt; obj.info
&#39;information&#39;
&gt;&gt;&gt; v = obj[1:] # new-from-template - here - slicing
&gt;&gt;&gt; type(v)
&lt;class &#39;InfoArray&#39;&gt;
&gt;&gt;&gt; v.info
&#39;information&#39;
&gt;&gt;&gt; arr = np.arange(10)
&gt;&gt;&gt; cast_arr = arr.view(InfoArray) # view casting
&gt;&gt;&gt; type(cast_arr)
&lt;class &#39;InfoArray&#39;&gt;
&gt;&gt;&gt; cast_arr.info is None
True
</pre>

               <p>This class isn&#39;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to         <code class='verbatim'>np.array</code>
 and return an object.</p>


<h1>Slightly more realistic example - attribute added to existing array</h1>
               <p>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</p>

               <pre class='not-implemented'>
.. testcode:: 
    import numpy as np

    class RealisticInfoArray(np.ndarray):

        def __new__(cls, input_array, info=None):
            # Input array is an already formed ndarray instance
            # We first cast to be our class type
            obj = np.asarray(input_array).view(cls)
            # add the new attribute to the created instance
            obj.info = info
            # Finally, we must return the newly created object:
            return obj

        def __array_finalize__(self, obj):
            # see InfoArray.__array_finalize__ for comments
            if obj is None: return
            self.info = getattr(obj, &#39;info&#39;, None)</pre>


               <p>So:</p>

                           <pre>&gt;&gt;&gt; arr = np.arange(5)
&gt;&gt;&gt; obj = RealisticInfoArray(arr, info=&#39;information&#39;)
&gt;&gt;&gt; type(obj)
&lt;class &#39;RealisticInfoArray&#39;&gt;
&gt;&gt;&gt; obj.info
&#39;information&#39;
&gt;&gt;&gt; v = obj[1:]
&gt;&gt;&gt; type(v)
&lt;class &#39;RealisticInfoArray&#39;&gt;
&gt;&gt;&gt; v.info
&#39;information&#39;
</pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array-ufunc:&#39;&gt;
           </pre>


<h1>``__array_ufunc__`` for ufuncs</h1>
                           <pre>.. versionadded:: 1.13
</pre>

               <p>A subclass can override what happens when executing numpy ufuncs on it by overriding the default         <code class='verbatim'>ndarray.__array_ufunc__</code>
 method. This method is executed <em>instead</em> of the ufunc and should return either the result of the operation, or         <code class='verbatim'>NotImplemented</code>
 if the operation requested is not implemented.</p>

               <p>The signature of         <code class='verbatim'>__array_ufunc__</code>
 is::      </p>

               <pre>def __array_ufunc__(ufunc, method, *inputs, **kwargs):

- *ufunc* is the ufunc object that was called.
- *method* is a string indicating how the Ufunc was called, either
  ``&#34;__call__&#34;`` to indicate it was called directly, or one of its
  :ref:`methods&lt;ufuncs.methods&gt;`: ``&#34;reduce&#34;``, ``&#34;accumulate&#34;``,
  ``&#34;reduceat&#34;``, ``&#34;outer&#34;``, or ``&#34;at&#34;``.
- *inputs* is a tuple of the input arguments to the ``ufunc``
- *kwargs* contains any optional or keyword arguments passed to the
  function. This includes any ``out`` arguments, which are always
  contained in a tuple.</pre>
               <p>A typical implementation would convert any inputs or outputs that are instances of one&#39;s own class, pass everything on to a superclass using         <code class='verbatim'>super()</code>
, and finally return the results after possible back-conversion. An example, taken from the test case         <code class='verbatim'>test_ufunc_override_with_super</code>
 in         <code class='verbatim'>core/tests/test_umath.py</code>
, is the following.</p>

               <pre class='not-implemented'>
.. testcode:: 
    input numpy as np

    class A(np.ndarray):
        def __array_ufunc__(self, ufunc, method, *inputs, out=None, **kwargs):
            args = []
            in_no = []
            for i, input_ in enumerate(inputs):
                if isinstance(input_, A):
                    in_no.append(i)
                    args.append(input_.view(np.ndarray))
                else:
                    args.append(input_)

            outputs = out
            out_no = []
            if outputs:
                out_args = []
                for j, output in enumerate(outputs):
                    if isinstance(output, A):
                        out_no.append(j)
                        out_args.append(output.view(np.ndarray))
                    else:
                        out_args.append(output)
                kwargs[&#39;out&#39;] = tuple(out_args)
            else:
                outputs = (None,) * ufunc.nout

            info = {}
            if in_no:
                info[&#39;inputs&#39;] = in_no
            if out_no:
                info[&#39;outputs&#39;] = out_no

            results = super().__array_ufunc__(ufunc, method, *args, **kwargs)
            if results is NotImplemented:
                return NotImplemented

            if method == &#39;at&#39;:
                if isinstance(inputs[0], A):
                    inputs[0].info = info
                return

            if ufunc.nout == 1:
                results = (results,)

            results = tuple((np.asarray(result).view(A)
                             if output is None else output)
                            for result, output in zip(results, outputs))
            if results and isinstance(results[0], A):
                results[0].info = info

            return results[0] if len(results) == 1 else results</pre>


               <p>So, this class does not actually do anything interesting: it just converts any instances of its own to regular ndarray (otherwise, we&#39;d get infinite recursion!), and adds an         <code class='verbatim'>info</code>
 dictionary that tells which inputs and outputs it converted. Hence, e.g.,</p>

               <pre>&gt;&gt;&gt; a = np.arange(5.).view(A)
&gt;&gt;&gt; b = np.sin(a)
&gt;&gt;&gt; b.info
{&#39;inputs&#39;: [0]}
&gt;&gt;&gt; b = np.sin(np.arange(5.), out=(a,))
&gt;&gt;&gt; b.info
{&#39;outputs&#39;: [0]}
&gt;&gt;&gt; a = np.arange(5.).view(A)
&gt;&gt;&gt; b = np.ones(1).view(A)
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c.info
{&#39;inputs&#39;: [0, 1]}
&gt;&gt;&gt; a += b
&gt;&gt;&gt; a.info
{&#39;inputs&#39;: [0, 1], &#39;outputs&#39;: [0]}</pre>
               <p>Note that another approach would be to use         <code class='verbatim'>getattr(ufunc,
methods)(*inputs, **kwargs)</code>
 instead of the         <code class='verbatim'>super</code>
 call. For this example, the result would be identical, but there is a difference if another operand also defines         <code class='verbatim'>__array_ufunc__</code>
. E.g., lets assume that we evalulate         <code class='verbatim'>np.add(a, b)</code>
, where         <code class='verbatim'>b</code>
 is an instance of another class         <code class='verbatim'>B</code>
 that has an override.  If you use         <code class='verbatim'>super</code>
 as in the example,         <code class='verbatim'>ndarray.__array_ufunc__</code>
 will notice that         <code class='verbatim'>b</code>
 has an override, which means it cannot evaluate the result itself. Thus, it will return <code>:None:None:`NotImplemented`</code> and so will our class         <code class='verbatim'>A</code>
. Then, control will be passed over to         <code class='verbatim'>b</code>
, which either knows how to deal with us and produces a result, or does not and returns <code>:None:None:`NotImplemented`</code>, raising a         <code class='verbatim'>TypeError</code>
.</p>

               <p>If instead, we replace our         <code class='verbatim'>super</code>
 call with         <code class='verbatim'>getattr(ufunc, method)</code>
, we effectively do         <code class='verbatim'>np.add(a.view(np.ndarray), b)</code>
. Again,         <code class='verbatim'>B.__array_ufunc__</code>
 will be called, but now it sees an         <code class='verbatim'>ndarray</code>
 as the other argument. Likely, it will know how to handle this, and return a new instance of the         <code class='verbatim'>B</code>
 class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement         <code class='verbatim'>MaskedArray</code>
 using         <code class='verbatim'>__array_ufunc__</code>
.</p>

               <p>As a final note: if the         <code class='verbatim'>super</code>
 route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class         <code class='verbatim'>B</code>
 also used the         <code class='verbatim'>super</code>
 in its         <code class='verbatim'>__array_ufunc__</code>
 implementation, and we created a class         <code class='verbatim'>C</code>
 that depended on both, i.e.,         <code class='verbatim'>class C(A, B)</code>
 (with, for simplicity, not another         <code class='verbatim'>__array_ufunc__</code>
 override). Then any ufunc on an instance of         <code class='verbatim'>C</code>
 would pass on to         <code class='verbatim'>A.__array_ufunc__</code>
, the         <code class='verbatim'>super</code>
 call in         <code class='verbatim'>A</code>
 would go to         <code class='verbatim'>B.__array_ufunc__</code>
, and the         <code class='verbatim'>super</code>
 call in         <code class='verbatim'>B</code>
 would go to         <code class='verbatim'>ndarray.__array_ufunc__</code>
, thus allowing         <code class='verbatim'>A</code>
 and         <code class='verbatim'>B</code>
 to collaborate.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array-wrap:&#39;&gt;
           </pre>


<h1>``__array_wrap__`` for ufuncs and other functions</h1>
               <p>Prior to numpy 1.13, the behaviour of ufuncs could only be tuned using         <code class='verbatim'>__array_wrap__</code>
 and         <code class='verbatim'>__array_prepare__</code>
. These two allowed one to change the output type of a ufunc, but, in contrast to         <code class='verbatim'>__array_ufunc__</code>
, did not allow one to make any changes to the inputs. It is hoped to eventually deprecate these, but         <code class='verbatim'>__array_wrap__</code>
 is also used by other numpy functions and methods, such as         <code class='verbatim'>squeeze</code>
, so at the present time is still needed for full functionality.</p>

               <p>Conceptually,         <code class='verbatim'>__array_wrap__</code>
 &#34;wraps up the action&#34; in the sense of allowing a subclass to set the type of the return value and update attributes and metadata.  Let&#39;s show how this works with an example.  First we return to the simpler example subclass, but with a different name and some print statements:</p>

               <pre class='not-implemented'>
.. testcode:: 
    import numpy as np

    class MySubClass(np.ndarray):

        def __new__(cls, input_array, info=None):
            obj = np.asarray(input_array).view(cls)
            obj.info = info
            return obj

        def __array_finalize__(self, obj):
            print(&#39;In __array_finalize__:&#39;)
            print(&#39;   self is %s&#39; % repr(self))
            print(&#39;   obj is %s&#39; % repr(obj))
            if obj is None: return
            self.info = getattr(obj, &#39;info&#39;, None)

        def __array_wrap__(self, out_arr, context=None):
            print(&#39;In __array_wrap__:&#39;)
            print(&#39;   self is %s&#39; % repr(self))
            print(&#39;   arr is %s&#39; % repr(out_arr))
            # then just call the parent
            return super().__array_wrap__(self, out_arr, context)</pre>


               <p>We run a ufunc on an instance of our new array:</p>

               <pre>&gt;&gt;&gt; obj = MySubClass(np.arange(5), info=&#39;spam&#39;)
In __array_finalize__:
   self is MySubClass([0, 1, 2, 3, 4])
   obj is array([0, 1, 2, 3, 4])
&gt;&gt;&gt; arr2 = np.arange(5)+1
&gt;&gt;&gt; ret = np.add(arr2, obj)
In __array_wrap__:
   self is MySubClass([0, 1, 2, 3, 4])
   arr is array([1, 3, 5, 7, 9])
In __array_finalize__:
   self is MySubClass([1, 3, 5, 7, 9])
   obj is MySubClass([0, 1, 2, 3, 4])
&gt;&gt;&gt; ret
MySubClass([1, 3, 5, 7, 9])
&gt;&gt;&gt; ret.info
&#39;spam&#39;</pre>
               <p>Note that the ufunc (        <code class='verbatim'>np.add</code>
) has called the         <code class='verbatim'>__array_wrap__</code>
 method with arguments         <code class='verbatim'>self</code>
 as         <code class='verbatim'>obj</code>
, and         <code class='verbatim'>out_arr</code>
 as the (ndarray) result of the addition.  In turn, the default         <code class='verbatim'>__array_wrap__</code>
 (        <code class='verbatim'>ndarray.__array_wrap__</code>
) has cast the result to class         <code class='verbatim'>MySubClass</code>
, and called         <code class='verbatim'>__array_finalize__</code>
 - hence the copying of the         <code class='verbatim'>info</code>
 attribute.  This has all happened at the C level.</p>

               <p>But, we could do anything we wanted:</p>

               <pre class='not-implemented'>
.. testcode:: 
    class SillySubClass(np.ndarray):

        def __array_wrap__(self, arr, context=None):
            return &#39;I lost your data&#39;</pre>


               <pre>&gt;&gt;&gt; arr1 = np.arange(5)
&gt;&gt;&gt; obj = arr1.view(SillySubClass)
&gt;&gt;&gt; arr2 = np.arange(5)
&gt;&gt;&gt; ret = np.multiply(obj, arr2)
&gt;&gt;&gt; ret
&#39;I lost your data&#39;</pre>
               <p>So, by defining a specific         <code class='verbatim'>__array_wrap__</code>
 method for our subclass, we can tweak the output from ufuncs. The         <code class='verbatim'>__array_wrap__</code>
 method requires         <code class='verbatim'>self</code>
, then an argument - which is the result of the ufunc - and an optional parameter <em>context</em>. This parameter is returned by ufuncs as a 3-element tuple: (name of the ufunc, arguments of the ufunc, domain of the ufunc), but is not set by other numpy functions. Though, as seen above, it is possible to do otherwise,         <code class='verbatim'>__array_wrap__</code>
 should return an instance of its containing class.  See the masked array subclass for an implementation.</p>

               <p>In addition to         <code class='verbatim'>__array_wrap__</code>
, which is called on the way out of the ufunc, there is also an         <code class='verbatim'>__array_prepare__</code>
 method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array.         <code class='verbatim'>__array_prepare__</code>
 should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like         <code class='verbatim'>__array_wrap__</code>
,         <code class='verbatim'>__array_prepare__</code>
 must return an ndarray or subclass thereof or raise an error.</p>


<h1>Extra gotchas - custom ``__del__`` methods and ndarray.base</h1>
               <p>One of the problems that ndarray solves is keeping track of memory ownership of ndarrays and their views.  Consider the case where we have created an ndarray,         <code class='verbatim'>arr</code>
 and have taken a slice with         <code class='verbatim'>v = arr[1:]</code>
. The two objects are looking at the same memory.  NumPy keeps track of where the data came from for a particular array or view, with the         <code class='verbatim'>base</code>
 attribute:</p>

               <pre>&gt;&gt;&gt; # A normal ndarray, that owns its own data
&gt;&gt;&gt; arr = np.zeros((4,))
&gt;&gt;&gt; # In this case, base is None
&gt;&gt;&gt; arr.base is None
True
&gt;&gt;&gt; # We take a view
&gt;&gt;&gt; v1 = arr[1:]
&gt;&gt;&gt; # base now points to the array that it derived from
&gt;&gt;&gt; v1.base is arr
True
&gt;&gt;&gt; # Take a view of a view
&gt;&gt;&gt; v2 = v1[1:]
&gt;&gt;&gt; # base points to the original array that it was derived from
&gt;&gt;&gt; v2.base is arr
True</pre>
               <p>In general, if the array owns its own memory, as for         <code class='verbatim'>arr</code>
 in this case, then         <code class='verbatim'>arr.base</code>
 will be None - there are some exceptions to this - see the numpy book for more details.</p>

               <p>The         <code class='verbatim'>base</code>
 attribute is useful in being able to tell whether we have a view or the original array.  This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted.  For example, we may only want to do the cleanup if the original array is deleted, but not the views.  For an example of how this can work, have a look at the         <code class='verbatim'>memmap</code>
 class in         <code class='verbatim'>numpy.core</code>
.</p>


<h1>Subclassing and Downstream Compatibility</h1>
               <p>When sub-classing         <code class='verbatim'>ndarray</code>
 or creating duck-types that mimic the         <code class='verbatim'>ndarray</code>
 interface, it is your responsibility to decide how aligned your APIs will be with those of numpy. For convenience, many numpy functions that have a corresponding         <code class='verbatim'>ndarray</code>
 method (e.g.,         <code class='verbatim'>sum</code>
,         <code class='verbatim'>mean</code>
,         <code class='verbatim'>take</code>
,         <code class='verbatim'>reshape</code>
) work by checking if the first argument to a function has a method of the same name. If it exists, the method is called instead of coercing the arguments to a numpy array.</p>

               <p>For example, if you want your sub-class or duck-type to be compatible with numpy&#39;s         <code class='verbatim'>sum</code>
 function, the method signature for this object&#39;s         <code class='verbatim'>sum</code>
 method should be the following:</p>

               <pre class='not-implemented'>
.. testcode:: 
    def sum(self, axis=None, dtype=None, out=None, keepdims=False):
    ...</pre>


               <p>This is the exact same method signature for         <code class='verbatim'>np.sum</code>
, so now if a user calls         <code class='verbatim'>np.sum</code>
 on this object, numpy will call the object&#39;s own         <code class='verbatim'>sum</code>
 method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</p>

               <p>If, however, you decide to deviate from this signature and do something like this:</p>

               <pre class='not-implemented'>
.. testcode:: 
    def sum(self, axis=None, dtype=None):
    ...</pre>


               <p>This object is no longer compatible with         <code class='verbatim'>np.sum</code>
 because if you call         <code class='verbatim'>np.sum</code>
, it will pass in unexpected arguments         <code class='verbatim'>out</code>
 and         <code class='verbatim'>keepdims</code>
, causing a TypeError to be raised.</p>

               <p>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&#39;s arguments, your function&#39;s signature should accept         <code class='verbatim'>**kwargs</code>
. For example:</p>

               <pre class='not-implemented'>
.. testcode:: 
    def sum(self, axis=None, dtype=None, **unused_kwargs):
    ...</pre>


               <p>This object is now compatible with         <code class='verbatim'>np.sum</code>
 again because any extraneous arguments (i.e. keywords that are not         <code class='verbatim'>axis</code>
 or         <code class='verbatim'>dtype</code>
) will be hidden away in the         <code class='verbatim'>**unused_kwargs</code>
 parameter.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
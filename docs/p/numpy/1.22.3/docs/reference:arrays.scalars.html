<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _arrays.scalars:&#39;&gt;</pre>

<h1>Scalars</h1>
               <div class='block_directive'>
    <div class='head'>.. currentmodule:: []
    </div>
    <pre class='not-implemented'><p>numpy </p>
</pre>
</div>


               <p>Python defines only one type of a particular data class (there is only one integer type, one floating-point type, etc.). This can be convenient in applications that don&#39;t need to be concerned with all the ways data can be represented in a computer.  For scientific computing, however, more control is often needed.</p>

               <p>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&#39;s types.</p>

               <p>Array scalars have the same attributes and methods as         <code class='verbatim'>ndarrays
&lt;ndarray&gt;</code>
.  This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</p>

               <p>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example,         <code class='verbatim'>isinstance(val, np.generic)</code>
 will return         <code class='verbatim'>True</code>
 if <em>val</em> is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example         <code class='verbatim'>isinstance(val, np.complexfloating)</code>
 will return         <code class='verbatim'>True</code>
 if <em>val</em> is a complex valued type, while         <code class='verbatim'>isinstance(val, np.flexible)</code>
 will return true if <em>val</em> is one of the flexible itemsize array types (        <code class='verbatim'>str_</code>
,         <code class='verbatim'>bytes_</code>
,         <code class='verbatim'>void</code>
).</p>

               <div class='block_directive'>
    <div class='head'>.. figure:: [&#39;figures/dtype-hierarchy.png&#39;]
    </div>
    <pre class='not-implemented'><p>**Figure : ** Hierarchy of type objects representing the array data types. Not shown are the two integer types : class : `intp` and : class : `uintp` which just point to the integer type that holds a pointer for the platform. All the number types can be obtained using bit - width names as well. </p>
</pre>
</div>


                          <code class='not-implemented'>Type Comment (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Comment: 
   |value: &#39;.. TODO - use something like this instead of the diagram above, as it generates\n   links to the classes and is a vector graphic. Unfortunately it looks worse\n   and the html &lt;map&gt; element providing the linked regions is misaligned.\n\n   .. inheritance-diagram:: byte short intc int_ longlong ubyte ushort uintc uint ulonglong half single double longdouble csingle cdouble clongdouble bool_ datetime64 timedelta64 object_ bytes_ str_ void&#39;
   |&gt;</pre>
                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;footnote&#39; &#39;.. [#] However, array scalars are immutable, so none of the array\n       scalar attributes are settable.&#39;&gt;</pre>
                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _arrays.scalars.character-codes:&#39;&gt;</pre>
                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _arrays.scalars.built-in:&#39;&gt;</pre>

<h1>Built-in scalar types</h1>
               <p>The built-in scalar types are shown below. The C-like names are associated with character codes, which are shown in their descriptions. Use of the character codes, however, is discouraged.</p>

               <p>Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:</p>

               <p>====================  ===========================  ============= Array scalar type     Related Python type          Inherits? ====================  ===========================  =============         <code class='verbatim'>int_</code>
                 <code class='verbatim'>int</code>
                 Python 2 only         <code class='verbatim'>float_</code>
               <code class='verbatim'>float</code>
               yes         <code class='verbatim'>complex_</code>
             <code class='verbatim'>complex</code>
             yes         <code class='verbatim'>bytes_</code>
               <code class='verbatim'>bytes</code>
               yes         <code class='verbatim'>str_</code>
                 <code class='verbatim'>str</code>
                 yes         <code class='verbatim'>bool_</code>
                <code class='verbatim'>bool</code>
                no         <code class='verbatim'>datetime64</code>
           <code class='verbatim'>datetime.datetime</code>
   no         <code class='verbatim'>timedelta64</code>
          <code class='verbatim'>datetime.timedelta</code>
  no ====================  ===========================  =============</p>

               <p>The         <code class='verbatim'>bool_</code>
 data type is very similar to the Python         <code class='verbatim'>bool</code>
 but does not inherit from it because Python&#39;s         <code class='verbatim'>bool</code>
 does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>The : class : `int_` type does **not** inherit from the : class : `int` built - in under Python 3, because type : class : `int` is no longer a fixed - width integer type. </p>

</div>


               <div class='block_directive'>
    <div class='head'>.. tip:: []
    </div>
    <pre class='not-implemented'><p>The default data type in NumPy is : class : `float_`. </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.generic&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.number&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Integer types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.integer&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


                           <div class='admonition'>
    <div>note</div>
        <p>The numpy integer types mirror the behavior of C integers, and can therefore be subject to : ref : `overflow - errors`. </p>

</div>



<h1>Signed integer types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.signedinteger&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.byte&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.short&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.intc&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.int_&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.longlong&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Unsigned integer types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.unsignedinteger&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.ubyte&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.ushort&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.uintc&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.uint&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.ulonglong&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Inexact types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.inexact&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


                           <div class='admonition'>
    <div>note</div>
        <p>Inexact scalars are printed using the fewest decimal digits needed to distinguish their value from other values of the same datatype, by judicious rounding. See the ``unique`` parameter of `format_float_positional` and `format_float_scientific`. This means that variables with equal binary values but whose datatypes are of different precisions may display differently : : &gt;&gt;&gt; f16 = np.float16 ( &#34; 0.1 &#34; ) &gt;&gt;&gt; f32 = np.float32 ( f16) &gt;&gt;&gt; f64 = np.float64 ( f32) &gt;&gt;&gt; f16 == f32 == f64 True &gt;&gt;&gt; f16, f32, f64 ( 0.1, 0.099975586, 0.0999755859375) Note that none of these floats hold the exact value : math : `\frac { 1} { 10}`; ``f16`` prints as ``0.1`` because it is as close to that value as possible, whereas the other types do not as they have more precision and therefore have closer values. Conversely, floating - point scalars of different precisions which approximate the same decimal value may compare unequal despite printing identically : &gt;&gt;&gt; f16 = np.float16 ( &#34; 0.1 &#34; ) &gt;&gt;&gt; f32 = np.float32 ( &#34; 0.1 &#34; ) &gt;&gt;&gt; f64 = np.float64 ( &#34; 0.1 &#34; ) &gt;&gt;&gt; f16 == f32 == f64 False &gt;&gt;&gt; f16, f32, f64 ( 0.1, 0.1, 0.1) </p>

</div>



<h1>Floating-point types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.floating&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.half&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.single&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.double&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.longdouble&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Complex floating-point types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.complexfloating&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.csingle&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.cdouble&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.clongdouble&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>



<h1>Other types</h1>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.bool_&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.datetime64&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.timedelta64&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.object_&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


                           <div class='admonition'>
    <div>note</div>
        <p>The data actually stored in object arrays ( *i.e.*, arrays having dtype : class : `object_`) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python : class : `lists &lt; list&gt;`, in the sense that their contents need not be of the same Python type. The object type is also special because an array containing : class : `object_` items does not return an : class : `object_` object on item access, but instead returns the actual object that the array item refers to. </p>

</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>flexible </p>
</pre>
</div>


               <p>The following data types are <strong>flexible</strong>: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes         <code class='verbatim'>#</code>
 is an integer denoting how many elements the data type consists of.)</p>

               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.flexible&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.bytes_&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.str_&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: [&#39;numpy.void&#39;]
    </div>
    <pre class='not-implemented'><p></p>
</pre>
</div>


                           <div class='admonition'>
    <div>warning</div>
        <p>See : ref : `Note on string types &lt; string - dtype - note&gt;`. Numeric Compatibility : If you used old typecode characters in your Numeric code ( which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are ``c - &gt; S1``, ``b - &gt; B``, ``1 - &gt; b``, ``s - &gt; h``, ``w - &gt; H``, and ``u - &gt; I``. These changes make the type character convention more consistent with other Python modules such as the : mod : `struct` module. </p>

</div>


                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _sized-aliases:&#39;&gt;</pre>

<h1>Sized aliases</h1>
               <p>Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured. Two aliases (        <code class='verbatim'>numpy.intp</code>
 and         <code class='verbatim'>numpy.uintp</code>
) pointing to the integer type that is sufficiently large to hold a C pointer are also provided.</p>

                          <code class='not-implemented'>Type Comment (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Comment: 
   |value: &#39;.. note that these are documented with ..attribute because that is what\n   autoclass does for aliases under the hood.&#39;
   |&gt;</pre>
               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.bool8 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;int8&#39;]
    </div>
    <pre class='not-implemented'><p>int16 int32 int64 </p>
</pre>
</div>


                           <pre>Aliases for the signed integer types (one of `numpy.byte`, `numpy.short`,
`numpy.intc`, `numpy.int_` and `numpy.longlong`) with the specified number
of bits.

Compatible with the C99 ``int8_t``, ``int16_t``, ``int32_t``, and
``int64_t``, respectively.
</pre>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;uint8&#39;]
    </div>
    <pre class='not-implemented'><p>uint16 uint32 uint64 </p>
</pre>
</div>


                           <pre>Alias for the unsigned integer types (one of `numpy.ubyte`, `numpy.ushort`,
`numpy.uintc`, `numpy.uint` and `numpy.ulonglong`) with the specified number
of bits.

Compatible with the C99 ``uint8_t``, ``uint16_t``, ``uint32_t``, and
``uint64_t``, respectively.
</pre>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;intp&#39;]
    </div>
    <pre class='not-implemented'><p>Alias for the signed integer type ( one of `numpy.byte`, `numpy.short`, `numpy.intc`, `numpy.int_` and `np.longlong`) that is the same size as a pointer. Compatible with the C ``intptr_t``. : Character code : `` &#39; p &#39; `` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;uintp&#39;]
    </div>
    <pre class='not-implemented'><p>Alias for the unsigned integer type ( one of `numpy.ubyte`, `numpy.ushort`, `numpy.uintc`, `numpy.uint` and `np.ulonglong`) that is the same size as a pointer. Compatible with the C ``uintptr_t``. : Character code : `` &#39; P &#39; `` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.float16 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.float32 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.float64 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;float96&#39;]
    </div>
    <pre class='not-implemented'><p>float128 </p>
</pre>
</div>


                           <pre>Alias for `numpy.longdouble`, named after its size in bits.
The existence of these aliases depends on the platform.
</pre>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.complex64 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.complex128 </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. attribute:: [&#39;complex192&#39;]
    </div>
    <pre class='not-implemented'><p>complex256 </p>
</pre>
</div>


                           <pre>Alias for `numpy.clongdouble`, named after its size in bits.
The existence of these aliases depends on the platform.
</pre>



<h1>Other aliases</h1>
               <p>The first two of these are conveniences which resemble the names of the builtin types, in the same style as <code>:None:None:`bool_`</code>, <code>:None:None:`int_`</code>, <code>:None:None:`str_`</code>, <code>:None:None:`bytes_`</code>, and <code>:None:None:`object_`</code>:</p>

               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.float_ </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.complex_ </p>
</pre>
</div>


               <p>Some more use alternate naming conventions for extended-precision floats and complex numbers:</p>

               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.longfloat </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.singlecomplex </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.cfloat </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.longcomplex </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.clongfloat </p>
</pre>
</div>


               <p>The following aliases originate from Python 2, and it is recommended that they not be used in new code.</p>

               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.string_ </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. autoclass:: []
    </div>
    <pre class='not-implemented'><p>numpy.unicode_ </p>
</pre>
</div>



<h1>Attributes</h1>
               <p>The array scalar objects have an         <code class='verbatim'>array priority
&lt;class.__array_priority__&gt;</code>
 of         <code class='verbatim'>NPY_SCALAR_PRIORITY</code>
 (-1,000,000.0). They also do not (yet) have a         <code class='verbatim'>ctypes &lt;ndarray.ctypes&gt;</code>
 attribute. Otherwise, they share the same attributes as arrays:</p>

               <div class='block_directive'>
    <div class='head'>.. autosummary:: [&#39;:toctree: generated/&#39;]
    </div>
    <pre class='not-implemented'><p>generic.flags generic.shape generic.strides generic.ndim generic.data generic.size generic.itemsize generic.base generic.dtype generic.real generic.imag generic.flat generic.T generic.__array_interface__ generic.__array_struct__ generic.__array_priority__ generic.__array_wrap__ </p>
</pre>
</div>



<h1>Indexing</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `arrays.indexing`, : ref : `arrays.dtypes` </p>
</pre>
</div>


               <p>Array scalars can be indexed like 0-dimensional arrays: if <em>x</em> is an array scalar,</p>

                          <ul>               <li>               <p>        <code class='verbatim'>x[()]</code>
 returns a copy of array scalar</p>

</li>
               <li>               <p>        <code class='verbatim'>x[...]</code>
 returns a 0-dimensional         <code class='verbatim'>ndarray</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>x[&#39;field-name&#39;]</code>
 returns the array scalar in the field <em>field-name</em>.   (<em>x</em> can have fields, for example, when it corresponds to a structured data type.)</p>

</li>
            </ul>


<h1>Methods</h1>
               <p>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for         <code class='verbatim'>ufunc &lt;ufuncs&gt;</code>
, so that the error state used for ufuncs also carries over to the math on array scalars.</p>

               <p>The exceptions to the above rules are given below:</p>

               <div class='block_directive'>
    <div class='head'>.. autosummary:: [&#39;:toctree: generated/&#39;]
    </div>
    <pre class='not-implemented'><p>generic.__array__ generic.__array_wrap__ generic.squeeze generic.byteswap generic.__reduce__ generic.__setstate__ generic.setflags </p>
</pre>
</div>


               <p>Utility method for typing:</p>

               <div class='block_directive'>
    <div class='head'>.. autosummary:: [&#39;:toctree: generated/&#39;]
    </div>
    <pre class='not-implemented'><p>number.__class_getitem__ </p>
</pre>
</div>



<h1>Defining new types</h1>
               <p>There are two ways to effectively define a new array scalar type (apart from composing structured types         <code class='verbatim'>dtypes &lt;arrays.dtypes&gt;</code>
 from the built-in scalar types): One way is to simply subclass the         <code class='verbatim'>ndarray</code>
 and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array.  To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the         <code class='verbatim'>NumPy C-API &lt;c-api&gt;</code>
.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
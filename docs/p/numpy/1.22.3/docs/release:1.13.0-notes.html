<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>NumPy 1.13.0 Release Notes</h1>
               <p>This release supports Python 2.7 and 3.4 - 3.6.</p>


<h1>Highlights</h1>
                           <blockquote>           <ul>               <li>               <p>Operations like         <code class='verbatim'>a + b + c</code>
 will reuse temporaries on some platforms,    resulting in less memory use and faster execution.</p>

</li>
               <li>               <p>Inplace operations check if inputs overlap outputs and create temporaries    to avoid problems.</p>

</li>
               <li>               <p>New         <code class='verbatim'>__array_ufunc__</code>
 attribute provides improved ability for classes to    override default ufunc behavior.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.block</code>
 function for creating blocked arrays.</p>

</li>
            </ul>
</blockquote>


<h1>New functions</h1>
                          <ul>               <li>               <p>New         <code class='verbatim'>np.positive</code>
 ufunc.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.divmod</code>
 ufunc provides more efficient divmod.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.isnat</code>
 ufunc tests for NaT special values.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.heaviside</code>
 ufunc computes the Heaviside function.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.isin</code>
 function, improves on         <code class='verbatim'>in1d</code>
.</p>

</li>
               <li>               <p>New         <code class='verbatim'>np.block</code>
 function for creating blocked arrays.</p>

</li>
               <li>               <p>New         <code class='verbatim'>PyArray_MapIterArrayCopyIfOverlap</code>
 added to NumPy C-API.</p>

</li>
            </ul>

               <p>See below for details.</p>


<h1>Deprecations</h1>
                          <ul>               <li>               <p>Calling         <code class='verbatim'>np.fix</code>
,         <code class='verbatim'>np.isposinf</code>
, and         <code class='verbatim'>np.isneginf</code>
 with         <code class='verbatim'>f(x, y=out)</code>
   is deprecated - the argument should be passed as         <code class='verbatim'>f(x, out=out)</code>
, which   matches other ufunc-like interfaces.</p>

</li>
               <li>               <p>Use of the C-API         <code class='verbatim'>NPY_CHAR</code>
 type number deprecated since version 1.7 will   now raise deprecation warnings at runtime. Extensions built with older f2py   versions need to be recompiled to remove the warning.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.ma.argsort</code>
,         <code class='verbatim'>np.ma.minimum.reduce</code>
, and         <code class='verbatim'>np.ma.maximum.reduce</code>
   should be called with an explicit <code class='not-implemented'>:None:None:`axis`</code> argument when applied to arrays with   more than 2 dimensions, as the default value of this argument (        <code class='verbatim'>None</code>
) is   inconsistent with the rest of numpy (        <code class='verbatim'>-1</code>
,         <code class='verbatim'>0</code>
, and         <code class='verbatim'>0</code>
, respectively).</p>

</li>
               <li>               <p>        <code class='verbatim'>np.ma.MaskedArray.mini</code>
 is deprecated, as it almost duplicates the   functionality of         <code class='verbatim'>np.MaskedArray.min</code>
. Exactly equivalent behaviour   can be obtained with         <code class='verbatim'>np.ma.minimum.reduce</code>
.</p>

</li>
               <li>               <p>The single-argument form of         <code class='verbatim'>np.ma.minimum</code>
 and         <code class='verbatim'>np.ma.maximum</code>
 is   deprecated.         <code class='verbatim'>np.maximum</code>
.         <code class='verbatim'>np.ma.minimum(x)</code>
 should now be spelt           <code class='verbatim'>np.ma.minimum.reduce(x)</code>
, which is consistent with how this would be done   with         <code class='verbatim'>np.minimum</code>
.</p>

</li>
               <li>               <p>Calling         <code class='verbatim'>ndarray.conjugate</code>
 on non-numeric dtypes is deprecated (it   should match the behavior of         <code class='verbatim'>np.conjugate</code>
, which throws an error).</p>

</li>
               <li>               <p>Calling         <code class='verbatim'>expand_dims</code>
 when the         <code class='verbatim'>axis</code>
 keyword does not satisfy           <code class='verbatim'>-a.ndim - 1 &lt;= axis &lt;= a.ndim</code>
, where         <code class='verbatim'>a</code>
 is the array being reshaped,   is deprecated.</p>

</li>
            </ul>


<h1>Future Changes</h1>
                          <ul>               <li>               <p>Assignment between structured arrays with different field names will change   in NumPy 1.14. Previously, fields in the dst would be set to the value of the   identically-named field in the src. In numpy 1.14 fields will instead be   assigned &#39;by position&#39;: The n-th field of the dst will be set to the n-th   field of the src array. Note that the         <code class='verbatim'>FutureWarning</code>
 raised in NumPy 1.12   incorrectly reported this change as scheduled for NumPy 1.13 rather than   NumPy 1.14.</p>

</li>
            </ul>


<h1>Build System Changes</h1>
                          <ul>               <li>               <p>        <code class='verbatim'>numpy.distutils</code>
 now automatically determines C-file dependencies with   GCC compatible compilers.</p>

</li>
            </ul>


<h1>Compatibility notes</h1>

<h1>Error type changes</h1>
                          <ul>               <li>               <p>        <code class='verbatim'>numpy.hstack()</code>
 now throws         <code class='verbatim'>ValueError</code>
 instead of         <code class='verbatim'>IndexError</code>
 when   input is empty.</p>

</li>
               <li>               <p>Functions taking an axis argument, when that argument is out of range, now   throw         <code class='verbatim'>np.AxisError</code>
 instead of a mixture of         <code class='verbatim'>IndexError</code>
 and           <code class='verbatim'>ValueError</code>
. For backwards compatibility,         <code class='verbatim'>AxisError</code>
 subclasses both of   these.</p>

</li>
            </ul>


<h1>Tuple object dtypes</h1>
               <p>Support has been removed for certain obscure dtypes that were unintentionally allowed, of the form         <code class='verbatim'>(old_dtype, new_dtype)</code>
, where either of the dtypes is or contains the         <code class='verbatim'>object</code>
 dtype. As an exception, dtypes of the form         <code class='verbatim'>(object, [(&#39;name&#39;, object)])</code>
 are still supported due to evidence of existing use.</p>


<h1>DeprecationWarning to error</h1>
               <p>See Changes section for more detail.</p>

                          <ul>               <li>               <p>        <code class='verbatim'>partition</code>
, TypeError when non-integer partition index is used.</p>

</li>
               <li>               <p>        <code class='verbatim'>NpyIter_AdvancedNew</code>
, ValueError when         <code class='verbatim'>oa_ndim == 0</code>
 and         <code class='verbatim'>op_axes</code>
 is NULL</p>

</li>
               <li>               <p>        <code class='verbatim'>negative(bool_)</code>
, TypeError when negative applied to booleans.</p>

</li>
               <li>               <p>        <code class='verbatim'>subtract(bool_, bool_)</code>
, TypeError when subtracting boolean from boolean.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.equal, np.not_equal</code>
, object identity doesn&#39;t override failed comparison.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.equal, np.not_equal</code>
, object identity doesn&#39;t override non-boolean comparison.</p>

</li>
               <li>               <p>Deprecated boolean indexing behavior dropped. See Changes below for details.</p>

</li>
               <li>               <p>Deprecated         <code class='verbatim'>np.alterdot()</code>
 and         <code class='verbatim'>np.restoredot()</code>
 removed.</p>

</li>
            </ul>


<h1>FutureWarning to changed behavior</h1>
               <p>See Changes section for more detail.</p>

                          <ul>               <li>               <p>        <code class='verbatim'>numpy.average</code>
 preserves subclasses</p>

</li>
               <li>               <p>        <code class='verbatim'>array == None</code>
 and         <code class='verbatim'>array != None</code>
 do element-wise comparison.</p>

</li>
               <li>               <p>        <code class='verbatim'>np.equal, np.not_equal</code>
, object identity doesn&#39;t override comparison result.</p>

</li>
            </ul>


<h1>dtypes are now always true</h1>
               <p>Previously         <code class='verbatim'>bool(dtype)</code>
 would fall back to the default python implementation, which checked if         <code class='verbatim'>len(dtype) &gt; 0</code>
. Since         <code class='verbatim'>dtype</code>
 objects implement         <code class='verbatim'>__len__</code>
 as the number of record fields,         <code class='verbatim'>bool</code>
 of scalar dtypes would evaluate to         <code class='verbatim'>False</code>
, which was unintuitive. Now         <code class='verbatim'>bool(dtype) == True</code>
 for all dtypes.</p>


<h1>``__getslice__`` and ``__setslice__`` are no longer needed in ``ndarray`` subclasses</h1>
               <p>When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement         <code class='verbatim'>__*slice__</code>
 on the derived class, as         <code class='verbatim'>__*item__</code>
 will intercept these calls correctly.</p>

               <p>Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__`` (e.g. through         <code class='verbatim'>super(...).__getslice__</code>
) will now issue a DeprecationWarning -         <code class='verbatim'>.__getitem__(slice(start, end))</code>
 should be used instead.</p>


<h1>Indexing MaskedArrays/Constants with ``...`` (ellipsis) now returns MaskedArray</h1>
               <p>This behavior mirrors that of np.ndarray, and accounts for nested arrays in MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.</p>


<h1>C API changes</h1>

<h1>GUfuncs on empty arrays and NpyIter axis removal</h1>
               <p>It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that code removing axes from NpyIter has to add an additional check when accessing the removed dimensions later on.</p>

               <p>The largest followup change is that gufuncs are now allowed to have zero-sized inner dimensions. This means that a gufunc now has to anticipate an empty inner dimension, while this was never possible and an error raised instead.</p>

               <p>For most gufuncs no change should be necessary. However, it is now possible for gufuncs with a signature such as         <code class='verbatim'>(..., N, M) -&gt; (..., M)</code>
 to return a valid result if         <code class='verbatim'>N=0</code>
 without further wrapping code.</p>


<h1>``PyArray_MapIterArrayCopyIfOverlap`` added to NumPy C-API</h1>
               <p>Similar to         <code class='verbatim'>PyArray_MapIterArray</code>
 but with an additional         <code class='verbatim'>copy_if_overlap</code>
 argument. If         <code class='verbatim'>copy_if_overlap != 0</code>
,  checks if input has memory overlap with any of the other arrays and make copies as appropriate to avoid problems if the input is modified during the iteration. See the documentation for more complete documentation.</p>


<h1>New Features</h1>

<h1>``__array_ufunc__`` added</h1>
               <p>This is the renamed and redesigned         <code class='verbatim'>__numpy_ufunc__</code>
. Any class, ndarray subclass or not, can define this method or set it to         <code class='verbatim'>None</code>
 in order to override the behavior of NumPy&#39;s ufuncs. This works quite similarly to Python&#39;s         <code class='verbatim'>__mul__</code>
 and other binary operation routines. See the documentation for a more detailed description of the implementation and behavior of this new option. The API is provisional, we do not yet guarantee backward compatibility as modifications may be made pending feedback. See <code class='not-implemented'>:None:None:`NEP 13`</code>  and <code class='not-implemented'>:None:None:`documentation_`</code> for more details.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`NEP 13`: http://www.numpy.org/neps/nep-0013-ufunc-overrides.html&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _documentation: https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst&#39;&gt;
           </pre>


<h1>New ``positive`` ufunc</h1>
               <p>This ufunc corresponds to unary <code class='not-implemented'>:None:None:`+`</code>, but unlike <code class='not-implemented'>:None:None:`+`</code> on an ndarray it will raise an error if array values do not support numeric operations.</p>


<h1>New ``divmod`` ufunc</h1>
               <p>This ufunc corresponds to the Python builtin <code class='not-implemented'>:None:None:`divmod`</code>, and is used to implement <code class='not-implemented'>:None:None:`divmod`</code> when called on numpy arrays.         <code class='verbatim'>np.divmod(x, y)</code>
 calculates a result equivalent to         <code class='verbatim'>(np.floor_divide(x, y), np.remainder(x, y))</code>
 but is approximately twice as fast as calling the functions separately.</p>


<h1>``np.isnat`` ufunc tests for NaT special datetime and timedelta values</h1>
               <p>The new ufunc         <code class='verbatim'>np.isnat</code>
 finds the positions of special NaT values within datetime and timedelta arrays. This is analogous to         <code class='verbatim'>np.isnan</code>
.</p>


<h1>``np.heaviside`` ufunc computes the Heaviside function</h1>
               <p>The new function         <code class='verbatim'>np.heaviside(x, h0)</code>
 (a ufunc) computes the Heaviside function:</p>

               <pre>{ 0   if x &lt; 0,</pre>
               <!-- deflist -->
           <dl>
               <dt><p>heaviside(x, h0) = { h0  if x == 0,</p>
</dt>
               <dd><p>{ 1   if x &gt; 0.</p>
</dd>
           </dl>


<h1>``np.block`` function for creating blocked arrays</h1>
               <p>Add a new         <code class='verbatim'>block</code>
 function to the current stacking functions         <code class='verbatim'>vstack</code>
,         <code class='verbatim'>hstack</code>
, and         <code class='verbatim'>stack</code>
. This allows concatenation across multiple axes simultaneously, with a similar syntax to array creation, but where elements can themselves be arrays. For instance::      </p>

               <pre>&gt;&gt;&gt; A = np.eye(2) * 2
&gt;&gt;&gt; B = np.eye(3) * 3
&gt;&gt;&gt; np.block([
...     [A,               np.zeros((2, 3))],
...     [np.ones((3, 2)), B               ]
... ])
array([[ 2.,  0.,  0.,  0.,  0.],
       [ 0.,  2.,  0.,  0.,  0.],
       [ 1.,  1.,  3.,  0.,  0.],
       [ 1.,  1.,  0.,  3.,  0.],
       [ 1.,  1.,  0.,  0.,  3.]])</pre>
               <p>While primarily useful for block matrices, this works for arbitrary dimensions of arrays.</p>

               <p>It is similar to Matlab&#39;s square bracket notation for creating block matrices.</p>


<h1>``isin`` function, improving on ``in1d``</h1>
               <p>The new function         <code class='verbatim'>isin</code>
 tests whether each element of an N-dimensional array is present anywhere within a second array. It is an enhancement of         <code class='verbatim'>in1d</code>
 that preserves the shape of the first array.</p>


<h1>Temporary elision</h1>
               <p>On platforms providing the         <code class='verbatim'>backtrace</code>
 function NumPy will try to avoid creating temporaries in expression involving basic numeric types. For example         <code class='verbatim'>d = a + b + c</code>
 is transformed to         <code class='verbatim'>d = a + b; d += c</code>
 which can improve performance for large arrays as less memory bandwidth is required to perform the operation.</p>


<h1>``axes`` argument for ``unique``</h1>
               <p>In an N-dimensional array, the user can now choose the axis along which to look for duplicate N-1-dimensional elements using         <code class='verbatim'>numpy.unique</code>
. The original behaviour is recovered if         <code class='verbatim'>axis=None</code>
 (default).</p>


<h1>``np.gradient`` now supports unevenly spaced data</h1>
               <p>Users can now specify a not-constant spacing for data. In particular         <code class='verbatim'>np.gradient</code>
 can now take:</p>

                          <ol>               <li>               <p>A single scalar to specify a sample distance for all dimensions.</p>

</li>
               <li>               <p>N scalars to specify a constant sample distance for each dimension.    i.e.         <code class='verbatim'>dx</code>
,         <code class='verbatim'>dy</code>
,         <code class='verbatim'>dz</code>
, ...</p>

</li>
               <li>               <p>N arrays to specify the coordinates of the values along each dimension of F.    The length of the array must match the size of the corresponding dimension</p>

</li>
               <li>               <p>Any combination of N scalars/arrays with the meaning of 2. and 3.</p>

</li>
            </ol>

               <p>This means that, e.g., it is now possible to do the following::      </p>

               <pre>&gt;&gt;&gt; f = np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float_)
&gt;&gt;&gt; dx = 2.
&gt;&gt;&gt; y = [1., 1.5, 3.5]
&gt;&gt;&gt; np.gradient(f, dx, y)
[array([[ 1. ,  1. , -0.5], [ 1. ,  1. , -0.5]]),
 array([[ 2. ,  2. ,  2. ], [ 2. ,  1.7,  0.5]])]</pre>

<h1>Support for returning arrays of arbitrary dimensions in ``apply_along_axis``</h1>
               <p>Previously, only scalars or 1D arrays could be returned by the function passed to         <code class='verbatim'>apply_along_axis</code>
. Now, it can return an array of any dimensionality (including 0D), and the shape of this array replaces the axis of the array being iterated over.</p>


<h1>``.ndim`` property added to ``dtype`` to complement ``.shape``</h1>
               <p>For consistency with         <code class='verbatim'>ndarray</code>
 and         <code class='verbatim'>broadcast</code>
,         <code class='verbatim'>d.ndim</code>
 is a shorthand for         <code class='verbatim'>len(d.shape)</code>
.</p>


<h1>Support for tracemalloc in Python 3.6</h1>
               <p>NumPy now supports memory tracing with <code class='not-implemented'>:None:None:`tracemalloc_`</code> module of Python 3.6 or newer. Memory allocations from NumPy are placed into the domain defined by         <code class='verbatim'>numpy.lib.tracemalloc_domain</code>
. Note that NumPy allocation will not show up in <code class='not-implemented'>:None:None:`tracemalloc_`</code> of earlier Python versions.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _tracemalloc: https://docs.python.org/3/library/tracemalloc.html&#39;&gt;
           </pre>


<h1>NumPy may be built with relaxed stride checking debugging</h1>
               <p>Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking is enabled will cause NumPy to be compiled with the affected strides set to the maximum value of npy_intp in order to help detect invalid usage of the strides in downstream projects. When enabled, invalid usage often results in an error being raised, but the exact type of error depends on the details of the code. TypeError and OverflowError have been observed in the wild.</p>

               <p>It was previously the case that this option was disabled for releases and enabled in master and changing between the two required editing the code. It is now disabled by default but can be enabled for test builds.</p>


<h1>Improvements</h1>

<h1>Ufunc behavior for overlapping inputs</h1>
               <p>Operations where ufunc input and output operands have memory overlap produced undefined results in previous NumPy versions, due to data dependency issues. In NumPy 1.13.0, results from such operations are now defined to be the same as for equivalent operations where there is no memory overlap.</p>

               <p>Operations affected now make temporary copies, as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result to needless temporary copies.  For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary.  As an example,``np.add(a, b, out=a)`` will not involve copies.</p>

               <p>To illustrate a previously undefined operation::      </p>

               <pre>&gt;&gt;&gt; x = np.arange(16).astype(float)
&gt;&gt;&gt; np.add(x[1:], x[:-1], out=x[1:])</pre>
               <p>In NumPy 1.13.0 the last line is guaranteed to be equivalent to::      </p>

               <pre>&gt;&gt;&gt; np.add(x[1:].copy(), x[:-1].copy(), out=x[1:])</pre>
               <p>A similar operation with simple non-problematic data dependence is::      </p>

               <pre>&gt;&gt;&gt; x = np.arange(16).astype(float)
&gt;&gt;&gt; np.add(x[1:], x[:-1], out=x[:-1])</pre>
               <p>It will continue to produce the same results as in previous NumPy versions, and will not involve unnecessary temporary copies.</p>

               <p>The change applies also to in-place binary operations, for example::      </p>

               <pre>&gt;&gt;&gt; x = np.random.rand(500, 500)
&gt;&gt;&gt; x += x.T</pre>
               <p>This statement is now guaranteed to be equivalent to         <code class='verbatim'>x[...] = x + x.T</code>
, whereas in previous NumPy versions the results were undefined.</p>


<h1>Partial support for 64-bit f2py extensions with MinGW</h1>
               <p>Extensions that incorporate Fortran libraries can now be built using the free <code class='not-implemented'>:None:None:`MinGW_`</code> toolset, also under Python 3.5. This works best for extensions that only do calculations and uses the runtime modestly (reading and writing from files, for instance). Note that this does not remove the need for Mingwpy; if you make extensive use of the runtime, you will most likely run into <code class='not-implemented'>:None:None:`issues_`</code>. Instead, it should be regarded as a band-aid until Mingwpy is fully functional.</p>

               <p>Extensions can also be compiled using the MinGW toolset using the runtime library from the (moveable) WinPython 3.4 distribution, which can be useful for programs with a PySide1/Qt4 front-end.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _MinGW: https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _issues: https://mingwpy.github.io/issues.html&#39;&gt;
           </pre>


<h1>Performance improvements for ``packbits`` and ``unpackbits``</h1>
               <p>The functions         <code class='verbatim'>numpy.packbits</code>
 with boolean input and         <code class='verbatim'>numpy.unpackbits</code>
 have been optimized to be a significantly faster for contiguous data.</p>


<h1>Fix for PPC long double floating point information</h1>
               <p>In previous versions of NumPy, the         <code class='verbatim'>finfo</code>
 function returned invalid information about the <code class='not-implemented'>:None:None:`double double`</code> format of the         <code class='verbatim'>longdouble</code>
 float type on Power PC (PPC).  The invalid values resulted from the failure of the NumPy algorithm to deal with the variable number of digits in the significand that are a feature of <code class='not-implemented'>:None:None:`PPC long doubles`</code>.  This release by-passes the failing algorithm by using heuristics to detect the presence of the PPC double double format.  A side-effect of using these heuristics is that the         <code class='verbatim'>finfo</code>
 function is faster than previous releases.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _PPC long doubles: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/com.ibm.aix.genprogc/128bit_long_double_floating-point_datatype.htm&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _double double: https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic&#39;&gt;
           </pre>


<h1>Better default repr for ``ndarray`` subclasses</h1>
               <p>Subclasses of ndarray with no         <code class='verbatim'>repr</code>
 specialization now correctly indent their data and type lines.</p>


<h1>More reliable comparisons of masked arrays</h1>
               <p>Comparisons of masked arrays were buggy for masked scalars and failed for structured arrays with dimension higher than one. Both problems are now solved. In the process, it was ensured that in getting the result for a structured array, masked fields are properly ignored, i.e., the result is equal if all fields that are non-masked in both are equal, thus making the behaviour identical to what one gets by comparing an unstructured masked array and then doing         <code class='verbatim'>.all()</code>
 over some axis.</p>


<h1>np.matrix with booleans elements can now be created using the string syntax</h1>
               <p>        <code class='verbatim'>np.matrix</code>
 failed whenever one attempts to use it with booleans, e.g.,         <code class='verbatim'>np.matrix(&#39;True&#39;)</code>
. Now, this works as expected.</p>


<h1>More ``linalg`` operations now accept empty vectors and matrices</h1>
               <p>All of the following functions in         <code class='verbatim'>np.linalg</code>
 now work when given input arrays with a 0 in the last two dimensions:         <code class='verbatim'>det</code>
,         <code class='verbatim'>slogdet</code>
,         <code class='verbatim'>pinv</code>
,         <code class='verbatim'>eigvals</code>
,         <code class='verbatim'>eigvalsh</code>
,         <code class='verbatim'>eig</code>
,         <code class='verbatim'>eigh</code>
.</p>


<h1>Bundled version of LAPACK is now 3.2.2</h1>
               <p>NumPy comes bundled with a minimal implementation of lapack for systems without a lapack library installed, under the name of         <code class='verbatim'>lapack_lite</code>
. This has been upgraded from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the <code class='not-implemented'>:None:None:`LAPACK changelogs`</code> for details on the all the changes this entails.</p>

               <p>While no new features are exposed through         <code class='verbatim'>numpy</code>
, this fixes some bugs regarding &#34;workspace&#34; sizes, and in some places may use faster algorithms.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`LAPACK changelogs`: http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases&#39;&gt;
           </pre>


<h1>``reduce`` of ``np.hypot.reduce`` and ``np.logical_xor`` allowed in more cases</h1>
               <p>This now works on empty arrays, returning 0, and can reduce over multiple axes. Previously, a         <code class='verbatim'>ValueError</code>
 was thrown in these cases.</p>


<h1>Better ``repr`` of object arrays</h1>
               <p>Object arrays that contain themselves no longer cause a recursion error.</p>

               <p>Object arrays that contain         <code class='verbatim'>list</code>
 objects are now printed in a way that makes clear the difference between a 2d object array, and a 1d object array of lists.</p>


<h1>Changes</h1>

<h1>``argsort`` on masked arrays takes the same default arguments as ``sort``</h1>
               <p>By default,         <code class='verbatim'>argsort</code>
 now places the masked values at the end of the sorted array, in the same way that         <code class='verbatim'>sort</code>
 already did. Additionally, the         <code class='verbatim'>end_with</code>
 argument is added to         <code class='verbatim'>argsort</code>
, for consistency with         <code class='verbatim'>sort</code>
. Note that this argument is not added at the end, so breaks any code that passed         <code class='verbatim'>fill_value</code>
 as a positional argument.</p>


<h1>``average`` now preserves subclasses</h1>
               <p>For ndarray subclasses,         <code class='verbatim'>numpy.average</code>
 will now return an instance of the subclass, matching the behavior of most other NumPy functions such as         <code class='verbatim'>mean</code>
. As a consequence, also calls that returned a scalar may now return a subclass array scalar.</p>


<h1>``array == None`` and ``array != None`` do element-wise comparison</h1>
               <p>Previously these operations returned scalars         <code class='verbatim'>False</code>
 and         <code class='verbatim'>True</code>
 respectively.</p>


<h1>``np.equal, np.not_equal`` for object arrays ignores object identity</h1>
               <p>Previously, these functions always treated identical objects as equal. This had the effect of overriding comparison failures, comparison of objects that did not return booleans, such as np.arrays, and comparison of objects where the results differed from object identity, such as NaNs.</p>


<h1>Boolean indexing changes</h1>
                          <ul>               <li>               <p>Boolean array-likes (such as lists of python bools) are always treated as   boolean indexes.</p>

</li>
               <li>               <p>Boolean scalars (including python         <code class='verbatim'>True</code>
) are legal boolean indexes and   never treated as integers.</p>

</li>
               <li>               <p>Boolean indexes must match the dimension of the axis that they index.</p>

</li>
               <li>               <p>Boolean indexes used on the lhs of an assignment must match the dimensions of   the rhs.</p>

</li>
               <li>               <p>Boolean indexing into scalar arrays return a new 1-d array.  This means that           <code class='verbatim'>array(1)[array(True)]</code>
 gives         <code class='verbatim'>array([1])</code>
 and not the original array.</p>

</li>
            </ul>


<h1>``np.random.multivariate_normal`` behavior with bad covariance matrix</h1>
               <p>It is now possible to adjust the behavior the function will have when dealing with the covariance matrix by using two new keyword arguments:</p>

                          <ul>               <li>               <p>        <code class='verbatim'>tol</code>
 can be used to specify a tolerance to use when checking that   the covariance matrix is positive semidefinite.</p>

</li>
               <li>               <p>        <code class='verbatim'>check_valid</code>
 can be used to configure what the function will do in the   presence of a matrix that is not positive semidefinite. Valid options are           <code class='verbatim'>ignore</code>
,         <code class='verbatim'>warn</code>
 and         <code class='verbatim'>raise</code>
. The default value,         <code class='verbatim'>warn</code>
 keeps the   the behavior used on previous releases.</p>

</li>
            </ul>


<h1>``assert_array_less`` compares ``np.inf`` and ``-np.inf`` now</h1>
               <p>Previously,         <code class='verbatim'>np.testing.assert_array_less</code>
 ignored all infinite values. This is not the expected behavior both according to documentation and intuitively. Now, -inf &lt; x &lt; inf is considered         <code class='verbatim'>True</code>
 for any real number x and all other cases fail.</p>


<h1>``assert_array_`` and masked arrays ``assert_equal`` hide less warnings</h1>
               <p>Some warnings that were previously hidden by the         <code class='verbatim'>assert_array_</code>
 functions are not hidden anymore. In most cases the warnings should be correct and, should they occur, will require changes to the tests using these functions. For the masked array         <code class='verbatim'>assert_equal</code>
 version, warnings may occur when comparing NaT. The function presently does not handle NaT or NaN specifically and it may be best to avoid it at this time should a warning show up due to this change.</p>


<h1>``offset`` attribute value in ``memmap`` objects</h1>
               <p>The         <code class='verbatim'>offset</code>
 attribute in a         <code class='verbatim'>memmap</code>
 object is now set to the offset into the file. This is a behaviour change only for offsets greater than         <code class='verbatim'>mmap.ALLOCATIONGRANULARITY</code>
.</p>


<h1>``np.real`` and ``np.imag`` return scalars for scalar inputs</h1>
               <p>Previously,         <code class='verbatim'>np.real</code>
 and         <code class='verbatim'>np.imag</code>
 used to return array objects when provided a scalar input, which was inconsistent with other functions like         <code class='verbatim'>np.angle</code>
 and         <code class='verbatim'>np.conj</code>
.</p>


<h1>The polynomial convenience classes cannot be passed to ufuncs</h1>
               <p>The ABCPolyBase class, from which the convenience classes are derived, sets         <code class='verbatim'>__array_ufun__ = None</code>
 in order of opt out of ufuncs. If a polynomial convenience class instance is passed as an argument to a ufunc, a         <code class='verbatim'>TypeError</code>
 will now be raised.</p>


<h1>Output arguments to ufuncs can be tuples also for ufunc methods</h1>
               <p>For calls to ufuncs, it was already possible, and recommended, to use an         <code class='verbatim'>out</code>
 argument with a tuple for ufuncs with multiple outputs. This has now been extended to output arguments in the         <code class='verbatim'>reduce</code>
,         <code class='verbatim'>accumulate</code>
, and         <code class='verbatim'>reduceat</code>
 methods. This is mostly for compatibility with         <code class='verbatim'>__array_ufunc</code>
; there are no ufuncs yet that have more than one output.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
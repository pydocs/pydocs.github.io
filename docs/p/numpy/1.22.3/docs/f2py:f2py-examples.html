<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _f2py-examples:&#39;&gt;
           </pre>


<h1>F2PY examples</h1>
               <p>Below are some examples of F2PY usage. This list is not comprehensive, but can be used as a starting point when wrapping your own code.</p>


<h1>F2PY walkthrough: a basic extension module</h1>

<h1>Creating source for a basic extension module</h1>
               <p>Consider the following subroutine, contained in a file named         <code class='verbatim'>add.f</code>
</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/add.f
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py::      </p>

               <pre>python -m numpy.f2py -m add add.f</pre>
               <p>This command will produce an extension module named         <code class='verbatim'>addmodule.c</code>
 in the current directory. This extension module can now be compiled and used from Python just like any other extension module.</p>


<h1>Creating a compiled extension module</h1>
                           <div class='admonition'>
    <div>note</div>
        <p>This usage depends heavily on         <code class='verbatim'>numpy.distutils</code>
, see <code class='not-implemented'>:None:ref:`f2py-bldsys`</code> for more details.</p>

</div>


               <p>You can also get f2py to both compile         <code class='verbatim'>add.f</code>
 along with the produced extension module leaving only a shared-library extension file that can be imported from Python::      </p>

               <pre>python -m numpy.f2py -c -m add add.f</pre>
               <p>This command produces a Python extension module compatible with your platform. This module may then be imported from Python. It will contain a method for each subroutine in         <code class='verbatim'>add</code>
. The docstring of each method contains information about how the module method may be called:</p>

               <pre class='not-implemented'>
.. code-block:: python
    &gt;&gt;&gt; import add
    &gt;&gt;&gt; print(add.zadd.__doc__)
    zadd(a,b,c,n)

    Wrapper for ``zadd``.

    Parameters
    ----------
    a : input rank-1 array(&#39;D&#39;) with bounds (*)
    b : input rank-1 array(&#39;D&#39;) with bounds (*)
    c : input rank-1 array(&#39;D&#39;) with bounds (*)
    n : input int</pre>



<h1>Improving the basic interface</h1>
               <p>The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments are converted to NumPy arrays and the integer argument should be mapped to a         <code class='verbatim'>C</code>
 integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because         <code class='verbatim'>f2py</code>
 knows nothing about the semantics of the arguments (such that         <code class='verbatim'>C</code>
 is an output and         <code class='verbatim'>n</code>
 should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</p>

               <pre class='not-implemented'>
.. code-block:: python
    &gt;&gt;&gt; add.zadd([1, 2, 3], [1, 2], [3, 4], 1000)</pre>


               <p>will cause a program crash on most systems. Under the hood, the lists are being converted to arrays but then the underlying         <code class='verbatim'>add</code>
 function is told to cycle way beyond the borders of the allocated memory.</p>

               <p>In order to improve the interface,         <code class='verbatim'>f2py</code>
 supports directives. This is accomplished by constructing a signature file. It is usually best to start from the interfaces that         <code class='verbatim'>f2py</code>
 produces in that file, which correspond to the default behavior. To get         <code class='verbatim'>f2py</code>
 to generate the interface file use the         <code class='verbatim'>-h</code>
 option::      </p>

               <pre>python -m numpy.f2py -h add.pyf -m add add.f</pre>
               <p>This command creates the         <code class='verbatim'>add.pyf</code>
 file in the current directory. The section of this file corresponding to         <code class='verbatim'>zadd</code>
 is:</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/add.pyf
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>By placing intent directives and checking code, the interface can be cleaned up quite a bit so the Python module method is both easier to use and more robust to malformed inputs.</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/add-edited.pyf
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>The intent directive, intent(out) is used to tell f2py that         <code class='verbatim'>c</code>
 is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable,         <code class='verbatim'>n</code>
, but instead to get it from the size of         <code class='verbatim'>a</code>
. The depend(         <code class='verbatim'>a</code>
 ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&#39;t try to create the variable n until the variable a is created).</p>

               <p>After modifying         <code class='verbatim'>add.pyf</code>
, the new Python module file can be generated by compiling both         <code class='verbatim'>add.f</code>
 and         <code class='verbatim'>add.pyf</code>
      </p>

               <pre>python -m numpy.f2py -c add.pyf add.f</pre>
               <p>The new interface&#39;s docstring is:</p>

               <pre class='not-implemented'>
.. code-block:: python
    &gt;&gt;&gt; import add
    &gt;&gt;&gt; print(add.zadd.__doc__)
    c = zadd(a,b)

    Wrapper for ``zadd``.

    Parameters
    ----------
    a : input rank-1 array(&#39;D&#39;) with bounds (n)
    b : input rank-1 array(&#39;D&#39;) with bounds (n)

    Returns
    -------
    c : rank-1 array(&#39;D&#39;) with bounds (n)</pre>


               <p>Now, the function can be called in a much more robust way:</p>

               <pre class='not-implemented'>
.. code-block:: 
    &gt;&gt;&gt; add.zadd([1, 2, 3], [4, 5, 6])
    array([5.+0.j, 7.+0.j, 9.+0.j])</pre>


               <p>Notice the automatic conversion to the correct format that occurred.</p>


<h1>Inserting directives in Fortran source</h1>
               <p>The robust interface of the previous section can also be generated automatically by placing the variable directives as special comments in the original Fortran code.</p>

                           <div class='admonition'>
    <div>note</div>
        <p>For projects where the Fortran code is being actively developed, this may be preferred.</p>

</div>


               <p>Thus, if the source code is modified to contain:</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/add-improved.f
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>Then, one can compile the extension module using::      </p>

               <pre>python -m numpy.f2py -c -m add add.f</pre>
               <p>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained         <code class='verbatim'>A(N)</code>
 instead of         <code class='verbatim'>A(*)</code>
 and so forth with         <code class='verbatim'>B</code>
 and         <code class='verbatim'>C</code>
, then nearly the same interface can be obtained by placing the         <code class='verbatim'>INTENT(OUT) :: C</code>
 comment line in the source code. The only difference is that         <code class='verbatim'>N</code>
 would be an optional input that would default to the length of         <code class='verbatim'>A</code>
.</p>


<h1>A filtering example</h1>
               <p>This example shows a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example.</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/filter.f
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>This code can be compiled and linked into an extension module named filter using::      </p>

               <pre>python -m numpy.f2py -c -m filter filter.f</pre>
               <p>This will produce an extension module in the current directory with a method named         <code class='verbatim'>dfilter2d</code>
 that returns a filtered version of the input.</p>


<h1>``depends`` keyword example</h1>
               <p>Consider the following code, saved in the file         <code class='verbatim'>myroutine.f90</code>
:</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/myroutine.f90
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>Wrapping this with         <code class='verbatim'>python -m numpy.f2py -c myroutine.f90 -m myroutine</code>
, we can do the following in Python::   </p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import myroutine
&gt;&gt;&gt; x = myroutine.s(2, 3, np.array([5, 6, 7]))
&gt;&gt;&gt; x
array([[5., 0., 0.],
          [0., 0., 0.]])</pre>
               <p>Now, instead of generating the extension module directly, we will create a signature file for this subroutine first. This is a common pattern for multi-step extension module generation. In this case, after running</p>

               <pre class='not-implemented'>
.. code-block:: python
    python -m numpy.f2py myroutine.f90 -h myroutine.pyf</pre>


               <p>the following signature file is generated:</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/myroutine.pyf
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>Now, if we run         <code class='verbatim'>python -m numpy.f2py -c myroutine.pyf myroutine.f90</code>
 we see an error; note that the signature file included a         <code class='verbatim'>depend(m,n)</code>
 statement for         <code class='verbatim'>x</code>
 which is not necessary. Indeed, editing the file above to read</p>

               <pre class='not-implemented'>
.. literalinclude:: ./code/myroutine-edited.pyf
    [&#39;language&#39;, &#39;fortran&#39;]
    </pre>


               <p>and running         <code class='verbatim'>f2py -c myroutine.pyf myroutine.f90</code>
 yields correct results.</p>


<h1>Read more</h1>
                          <ul>               <li>               <p><a link href="https://scipy.github.io/old-wiki/pages/Cookbook/f2py_and_NumPy.html" class='external'>Wrapping C codes using f2py</a></p>

</li>
               <li>               <p><a link href="https://scipy-cookbook.readthedocs.io/items/F2Py.html" class='external'>F2py section on the SciPy Cookbook</a></p>

</li>
               <li>               <p><a link href="http://websrv.cs.umt.edu/isis/index.php/F2py_example" class='external'>F2py example: Interactive System for Ice sheet Simulation</a></p>

</li>
               <li>               <p><a link href="https://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html" class='external'>&#34;Interfacing With Other Languages&#34; section on the SciPy Cookbook.</a></p>

</li>
            </ul>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
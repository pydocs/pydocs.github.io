<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <div class='block_directive'>
    <div class='head'>.. currentmodule:: []
    </div>
    <pre class='not-implemented'><p>numpy </p>
</pre>
</div>


                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _c-code-explanations:&#39;&gt;</pre>

<h1>NumPy C code explanations</h1>
                           <pre>Fanaticism consists of redoubling your efforts when you have forgotten
your aim.
--- *George Santayana*

An authority is a person who can tell you more about something than
you really care to know.
--- *Unknown*
</pre>


               <p>This page attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</p>


<h1>Memory model</h1>
               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>pair : ndarray; memory model </p>
</pre>
</div>


               <p>One fundamental aspect of the         <code class='verbatim'>ndarray</code>
 is that an array is seen as a &#34;chunk&#34; of memory starting at some location. The interpretation of this memory depends on the         <code class='verbatim'>stride</code>
 information. For each dimension in an         <span class="tex2jax_process">$N$</span>
-dimensional array, an integer (        <code class='verbatim'>stride</code>
) dictates how many bytes must be skipped to get to the next element in that dimension. Unless you have a single-segment array, this         <code class='verbatim'>stride</code>
 information must be consulted when traversing through an array. It is not difficult to write code that accepts strides, you just have to use         <code class='verbatim'>char*</code>
 pointers because strides are in units of bytes. Keep in mind also that strides do not have to be unit-multiples of the element size. Also, remember that if the number of dimensions of the array is 0 (sometimes called a         <code class='verbatim'>rank-0</code>
 array), then the         <code class='verbatim'>strides &lt;stride&gt;</code>
 and         <code class='verbatim'>dimensions &lt;dimension&gt;</code>
 variables are         <code class='verbatim'>NULL</code>
.</p>

               <p>Besides the structural information contained in the strides and dimensions members of the         <code class='verbatim'>PyArrayObject</code>
, the flags contain important information about how the data may be accessed. In particular, the         <code class='verbatim'>NPY_ARRAY_ALIGNED</code>
 flag is set when the memory is on a suitable boundary according to the datatype array. Even if you have a         <code class='verbatim'>contiguous</code>
 chunk of memory, you cannot just assume it is safe to dereference a datatype-specific pointer to an element. Only if the         <code class='verbatim'>NPY_ARRAY_ALIGNED</code>
 flag is set, this is a safe operation. On some platforms it will work but on others, like Solaris, it will cause a bus error. The         <code class='verbatim'>NPY_ARRAY_WRITEABLE</code>
 should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the         <code class='verbatim'>NPY_ARRAY_WRITEABLE</code>
 flag is not set will just be rude. Other times it can cause program crashes (<em>e.g.</em> a data-area that is a read-only memory-mapped file).</p>


<h1>Data-type encapsulation</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `arrays.dtypes` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : dtype </p>
</pre>
</div>


               <p>The         <code class='verbatim'>datatype &lt;arrays.dtypes&gt;</code>
 is an important abstraction of the         <code class='verbatim'>ndarray</code>
. Operations will look to the datatype to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the         <code class='verbatim'>f</code>
 member of the         <code class='verbatim'>PyArray_Descr</code>
 structure. In this way, the number of datatypes can be extended simply by providing a         <code class='verbatim'>PyArray_Descr</code>
 structure with suitable function pointers in the         <code class='verbatim'>f</code>
 member. For built-in types, there are some optimizations that bypass this mechanism, but the point of the datatype abstraction is to allow new datatypes to be added.</p>

               <p>One of the built-in datatypes, the         <code class='verbatim'>void</code>
 datatype allows for arbitrary         <code class='verbatim'>structured types &lt;structured data type&gt;</code>
 containing 1 or more fields as elements of the array. A         <code class='verbatim'>field</code>
 is simply another datatype object along with an offset into the current structured type. In order to support arbitrarily nested fields, several recursive implementations of datatype access are implemented for the void type. A common idiom is to cycle through the elements of the dictionary and perform a specific operation based on the datatype object stored at the given offset. These offsets can be arbitrary numbers. Therefore, the possibility of encountering misaligned data must be recognized and taken into account if necessary.</p>


<h1>N-D Iterators</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `arrays.nditer` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : array iterator </p>
</pre>
</div>


               <p>A very common operation in much of NumPy code is the need to iterate over all the elements of a general, strided, N-dimensional array. This operation of a general-purpose N-dimensional loop is abstracted in the notion of an iterator object. To write an N-dimensional loop, you only have to create an iterator object from an ndarray, work with the         <code class='verbatim'>dataptr &lt;PyArrayIterObject.dataptr&gt;</code>
 member of the iterator object structure and call the macro         <code class='verbatim'>PyArray_ITER_NEXT</code>
 on the iterator object to move to the next element. The         <code class='verbatim'>next</code>
 element is always in C-contiguous order. The macro works by first special-casing the C-contiguous, 1-D, and 2-D cases which work very simply.</p>

               <p>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the         <code class='verbatim'>dataptr &lt;PyArrayIterObject.dataptr&gt;</code>
 member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the         <code class='verbatim'>dataptr &lt;PyArrayIterObject.dataptr&gt;</code>
 is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the         <code class='verbatim'>backstrides &lt;PyArrayIterObject.backstrides&gt;</code>
 member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the         <code class='verbatim'>dataptr &lt;PyArrayIterObject.dataptr&gt;</code>
 is adjusted appropriately for arbitrary striding.</p>

               <p>The         <code class='verbatim'>coordinates &lt;PyArrayIterObject.coordinates&gt;</code>
 member of the         <code class='verbatim'>PyArrayIterObject</code>
 structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is bypassed. The         <code class='verbatim'>index &lt;PyArrayIterObject.index&gt;</code>
 member of the         <code class='verbatim'>PyArrayIterObject</code>
 keeps track of the current flat index of the iterator. It is updated by the         <code class='verbatim'>PyArray_ITER_NEXT</code>
 macro.</p>


<h1>Broadcasting</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `basics.broadcasting` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : broadcasting </p>
</pre>
</div>


               <p>In Numeric, the ancestor of NumPy, broadcasting was implemented in several lines of code buried deep in         <code class='verbatim'>ufuncobject.c</code>
. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function         <code class='verbatim'>PyArray_Broadcast</code>
. This function requires a         <code class='verbatim'>PyArrayMultiIterObject</code>
 (or something that is a binary equivalent) to be passed in. The         <code class='verbatim'>PyArrayMultiIterObject</code>
 keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</p>

               <p>The         <code class='verbatim'>PyArray_Broadcast</code>
 function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the         <code class='verbatim'>PyArray_MultiIterNew</code>
 function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the         <code class='verbatim'>shape</code>
 in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&#39;t move as the broadcasting operation operates over the extended dimension.</p>

               <p>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a         <code class='verbatim'>PyArrayIterObject</code>
, the iterators involved in a broadcast result are kept track of in a         <code class='verbatim'>PyArrayMultiIterObject</code>
, and the         <code class='verbatim'>PyArray_Broadcast</code>
 call implements the         <code class='verbatim'>general-broadcasting-rules</code>
.</p>


<h1>Array Scalars</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `arrays.scalars` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : array scalars </p>
</pre>
</div>


               <p>The array scalars offer a hierarchy of Python types that allow a one-to-one correspondence between the datatype stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</p>

               <p>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (        <code class='verbatim'>a[0][&#39;f1&#39;] = value</code>
).</p>


<h1>Indexing</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `basics.indexing`, : ref : `arrays.indexing` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : indexing </p>
</pre>
</div>


               <p>All Python indexing operations         <code class='verbatim'>arr[index]</code>
 are organized by first preparing the index and finding the index type. The supported index types are:</p>

                          <ul>               <li>               <p>integer</p>

</li>
               <li>               <p>        <code class='verbatim'>newaxis</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>python:slice</code>
</p>

</li>
               <li>               <p>        <code class='verbatim'>Ellipsis</code>
</p>

</li>
               <li>               <p>integer arrays/array-likes (advanced)</p>

</li>
               <li>               <p>boolean (single boolean array); if there is more than one boolean array as   the index or the shape does not match exactly, the boolean array will be   converted to an integer array instead.</p>

</li>
               <li>               <p>0-d boolean (and also integer); 0-d boolean arrays are a special   case that has to be handled in the advanced indexing code. They signal   that a 0-d boolean array had to be interpreted as an integer array.</p>

</li>
            </ul>

               <p>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an         <code class='verbatim'>Ellipsis</code>
 is added for incomplete indices for example when a two-dimensional array is indexed with a single integer.</p>

               <p>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an         <code class='verbatim'>Ellipsis</code>
 or         <code class='verbatim'>python:slice</code>
 but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset.  This view can then either be returned or, for assignments, filled using         <code class='verbatim'>PyArray_CopyObject</code>
. Note that         <code class='verbatim'>PyArray_CopyObject</code>
 may also be called on temporary arrays in other branches to support complicated assignments when the array is of object         <code class='verbatim'>dtype</code>
.</p>


<h1>Advanced indexing</h1>
               <p>By far the most complex case is advanced indexing, which may or may not be combined with typical view-based indexing. Here integer indices are interpreted as view-based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</p>

                          <ul>               <li>               <p>There is one indexing array and it, as well as the assignment array, can   be iterated trivially. For example, they may be contiguous. Also, the   indexing array must be of         <code class='verbatim'>intp</code>
 type and the value array in   assignments should be of the correct type. This is purely a fast path.</p>

</li>
               <li>               <p>There are only integer array indices so that no subarray exists.</p>

</li>
               <li>               <p>View-based and advanced indexing is mixed. In this case, the view-based   indexing defines a collection of subarrays that are combined by the   advanced indexing. For example,         <code class='verbatim'>arr[[1, 2, 3], :]</code>
 is created by   vertically stacking the subarrays         <code class='verbatim'>arr[1, :]</code>
,         <code class='verbatim'>arr[2, :]</code>
, and           <code class='verbatim'>arr[3, :]</code>
.</p>

</li>
               <li>               <p>There is a subarray but it has exactly one element. This case can be handled   as if there is no subarray but needs some care during setup.</p>

</li>
            </ul>

               <p>Deciding what case applies, checking broadcasting, and determining the kind of transposition needed are all done in         <code class='verbatim'>PyArray_MapIterNew</code>
. After setting up, there are two cases. If there is no subarray or it only has one element, no subarray iteration is necessary and an iterator is prepared which iterates all indexing arrays <em>as well as</em> the result or value array. If there is a subarray, there are three iterators prepared. One for the indexing arrays, one for the result or value array (minus its subarray), and one for the subarrays of the original and the result/assignment array. The first two iterators give (or allow calculation) of the pointers into the start of the subarray, which then allows restarting the subarray iteration.</p>

               <p>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by         <code class='verbatim'>PyArray_MapIterSwapAxes</code>
 and has to be handled by the caller unless         <code class='verbatim'>PyArray_MapIterNew</code>
 is asked to allocate the result.</p>

               <p>After preparation, getting and setting are relatively straightforward, although the different modes of iteration need to be considered. Unless there is only a single indexing array during item getting, the validity of the indices is checked beforehand. Otherwise, it is handled in the inner loop itself for optimization.</p>

                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _ufuncs-internals:&#39;&gt;</pre>

<h1>Universal functions</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `ufuncs`, : ref : `ufuncs - basics` </p>
</pre>
</div>


               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>single : ufunc </p>
</pre>
</div>


               <p>Universal functions are callable objects that take         <span class="tex2jax_process">$N$</span>
 inputs and produce         <span class="tex2jax_process">$M$</span>
 outputs by wrapping basic 1-D loops that work element-by-element into full easy-to-use functions that seamlessly implement         <code class='verbatim'>broadcasting &lt;basics.broadcasting&gt;</code>
,         <code class='verbatim'>type-checking &lt;ufuncs.casting&gt;</code>
,         <code class='verbatim'>buffered coercion &lt;use-of-internal-buffers&gt;</code>
, and         <code class='verbatim'>output-argument handling &lt;ufuncs-output-type&gt;</code>
. New universal functions are normally created in C, although there is a mechanism for creating ufuncs from Python functions (        <code class='verbatim'>frompyfunc</code>
). The user must supply a 1-D loop that implements the basic function taking the input scalar values and placing the resulting scalars into the appropriate output slots as explained in implementation.</p>


<h1>Setup</h1>
               <p>Every         <code class='verbatim'>ufunc</code>
 calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported         <code class='verbatim'>scalarmath</code>
 module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</p>

               <p>When a         <code class='verbatim'>ufunc</code>
 is called, many things must be done. The information collected from these setup operations is stored in a loop object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with         <code class='verbatim'>PyArray_Broadcast</code>
 so that the broadcasting can be handled in the same way as it is handled in other sections of code.</p>

               <p>The first thing done is to look up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread-specific dictionary takes time which is easily ignored for all but very small arrays.</p>

               <p>After checking, the thread-specific global variables, the inputs are evaluated to determine how the ufunc should proceed and the input and output arrays are constructed if necessary. Any inputs which are not arrays are converted to arrays (using context if necessary). Which of the inputs are scalars (and therefore converted to 0-D arrays) is noted.</p>

               <p>Next, an appropriate 1-D loop is selected from the 1-D loops available to the         <code class='verbatim'>ufunc</code>
 based on the input array types. This 1-D loop is selected by trying to match the signature of the datatypes of the inputs against the available signatures. The signatures corresponding to built-in types are stored in the         <code class='verbatim'>ufunc.types</code>
 member of the ufunc structure. The signatures corresponding to user-defined types are stored in a linked list of function information with the head element stored as a         <code class='verbatim'>CObject</code>
 in the         <code class='verbatim'>userloops</code>
 dictionary keyed by the datatype number (the first user-defined type in the argument list is used as the key). The signatures are searched until a signature is found to which the input arrays can all be cast safely (ignoring any scalar arguments which are not allowed to determine the type of the result). The implication of this search procedure is that &#34;lesser types&#34; should be placed below &#34;larger types&#34; when the signatures are stored. If no 1-D loop is found, then an error is reported. Otherwise, the         <code class='verbatim'>argument_list</code>
 is updated with the stored signature --- in case casting is necessary and to fix the output types assumed by the 1-D loop.</p>

               <p>If the ufunc has 2 inputs and 1 output and the second input is an         <code class='verbatim'>Object</code>
 array then a special-case check is performed so that         <code class='verbatim'>NotImplemented</code>
 is returned if the second input is not an ndarray, has the         <code class='verbatim'>~numpy.class.__array_priority__</code>
 attribute, and has an         <code class='verbatim'>__r{op}__</code>
 special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</p>

               <p>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, misaligned, or out-of-byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</p>

               <p>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&#39;t have the correct type (or is misaligned) and is smaller than the buffer size, then a new output array is constructed with the special         <code class='verbatim'>NPY_ARRAY_WRITEBACKIFCOPY</code>
 flag set. At the end of the function,         <code class='verbatim'>PyArray_ResolveWritebackIfCopy</code>
 is called so that  its contents will be copied back into the output array. Iterators for the output arguments are then processed.</p>

               <p>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for :term`contiguous`, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for misaligned or incorrect data type situations). Depending on which execution method is called for, the loop is then set up and computed.</p>


<h1>Function call</h1>
               <p>This section describes how the basic universal function computation loop is set up and executed for each of the three different kinds of execution. If         <code class='verbatim'>NPY_ALLOW_THREADS</code>
 is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops.  It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</p>


<h1>One loop</h1>
               <p>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byteorder) for both input and output and all arrays have uniform strides (either         <code class='verbatim'>contiguous</code>
, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</p>


<h1>Strided loop</h1>
               <p>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</p>


<h1>Buffered loop</h1>
               <p>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong datatype (including being byteswapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post-processing is performed on the outputs in         <code class='verbatim'>bufsize</code>
 chunks (where         <code class='verbatim'>bufsize</code>
 is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</p>

                          <ul>               <li>               <p>memory allocation of the temporary buffers</p>

</li>
            </ul>

                          <ul>               <li>               <p>deciding whether or not to use buffers on the input and output data   (misaligned and/or wrong datatype)</p>

</li>
            </ul>

                          <ul>               <li>               <p>copying and possibly casting data for any inputs or outputs for which   buffers are necessary.</p>

</li>
            </ul>

                          <ul>               <li>               <p>special-casing         <code class='verbatim'>Object</code>
 arrays so that reference counts are properly   handled when copies and/or casts are necessary.</p>

</li>
            </ul>

                          <ul>               <li>               <p>breaking up the inner 1-D loop into         <code class='verbatim'>bufsize</code>
 chunks (with a possible   remainder).</p>

</li>
            </ul>

               <p>Again, the hardware error flags are checked at the end of each 1-D loop.</p>


<h1>Final output manipulation</h1>
               <p>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the         <code class='verbatim'>~numpy.class.__array_wrap__</code>
 method, then the class with the largest         <code class='verbatim'>~numpy.class.__array_priority__</code>
 attribute determines the type of all the outputs (with the exception of any output arrays passed in). The         <code class='verbatim'>~numpy.class.__array_wrap__</code>
 method of the input array will be called with the ndarray being returned from the ufunc as its input. There are two calling styles of the         <code class='verbatim'>~numpy.class.__array_wrap__</code>
 function supported. The first takes the ndarray as the first argument and a tuple of &#34;context&#34; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a         <code class='verbatim'>TypeError</code>
 occurs, then the function is called with just the ndarray as the first argument.</p>


<h1>Methods</h1>
               <p>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are         <code class='verbatim'>ufunc.reduce</code>
,         <code class='verbatim'>ufunc.accumulate</code>
, and         <code class='verbatim'>ufunc.reduceat</code>
. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered-loop. These are the same basic loop styles as implemented for the general-purpose function call except for the no-element and one-element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</p>


<h1>Setup</h1>
               <p>The setup function for all three methods is         <code class='verbatim'>construct_reduce</code>
. This function creates a reducing loop object and fills it with the parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of         <code class='verbatim'>[otype,
otype, otype]</code>
 where         <code class='verbatim'>otype</code>
 is the requested reduction datatype. The buffer size and error handling are then retrieved from (per-thread) global storage. For small arrays that are misaligned or have incorrect datatype, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not misaligned and has the correct datatype, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed.  The output array is of a different         <code class='verbatim'>shape</code>
 depending on whether the method is         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
,         <code class='verbatim'>accumulate &lt;ufunc.accumulate&gt;</code>
, or         <code class='verbatim'>reduceat &lt;ufunc.reduceat&gt;</code>
. If an output array is already provided, then its shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the         <code class='verbatim'>NPY_ARRAY_WRITEBACKIFCOPY</code>
 flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when         <code class='verbatim'>PyArray_ResolveWritebackIfCopy</code>
 is called at function completion. Finally, iterators are set up to loop over the correct         <code class='verbatim'>axis</code>
 (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</p>


<h1>:meth:`Reduce &lt;ufunc.reduce&gt;`</h1>
               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>triple : ufunc; methods; reduce </p>
</pre>
</div>


               <p>All of the ufunc methods use the same underlying 1-D computational loops with input and output arguments adjusted so that the appropriate reduction takes place. For example, the key to the functioning of         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 is that the 1-D loop is called with the output and the second input pointing to the same position in memory and both having a step-size of 0. The first input is pointing to the input array with a step-size given by the appropriate stride for the selected axis. In this way, the operation performed is</p>

                       <span class="tex2jax_process">$$:nowrap: \begin { align*} o &amp; = &amp; i [ 0] \\ o &amp; = &amp; i [ k]\textrm { &lt; op&gt;}o\quad k=1\ldots N \end { align*} $$</span>

               <p>where         <span class="tex2jax_process">$N+1$</span>
 is the number of elements in the input,         <span class="tex2jax_process">$i$</span>
,         <span class="tex2jax_process">$o$</span>
 is the output, and         <span class="tex2jax_process">$i[k]$</span>
 is the         <span class="tex2jax_process">$k^{\textrm{th}}$</span>
 element of         <span class="tex2jax_process">$i$</span>
 along the selected axis. This basic operation is repeated for arrays with greater than 1 dimension so that the reduction takes place for every 1-D sub-array along the selected axis. An iterator with the selected dimension removed handles this looping.</p>

               <p>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct datatype (including byteorder). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified         <code class='verbatim'>bufsize</code>
.</p>


<h1>:meth:`Accumulate &lt;ufunc.accumulate&gt;`</h1>
               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>triple : ufunc; methods; accumulate </p>
</pre>
</div>


               <p>The         <code class='verbatim'>accumulate &lt;ufunc.accumulate&gt;</code>
 method is very similar to the         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 method in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</p>

                       <span class="tex2jax_process">$$:nowrap: \begin { align*} o [ 0] &amp; = &amp; i [ 0] \\ o [ k] &amp; = &amp; i [ k]\textrm { &lt; op&gt;}o [ k - 1]\quad k=1\ldots N. \end { align*} $$</span>

               <p>The output has the same shape as the input and each 1-D loop operates over         <span class="tex2jax_process">$N$</span>
 elements when the shape in the selected axis is         <span class="tex2jax_process">$N+1$</span>
. Again, buffered loops take care to copy and cast the data before calling the underlying 1-D computational loop.</p>


<h1>:meth:`Reduceat &lt;ufunc.reduceat&gt;`</h1>
               <div class='block_directive'>
    <div class='head'>.. index:: []
    </div>
    <pre class='not-implemented'><p>triple : ufunc; methods; reduceat single : ufunc </p>
</pre>
</div>


               <p>The         <code class='verbatim'>reduceat &lt;ufunc.reduceat&gt;</code>
 function is a generalization of both the         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 and         <code class='verbatim'>accumulate &lt;ufunc.accumulate&gt;</code>
 functions. It implements a         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a         <code class='verbatim'>reduce &lt;ufunc.reduce&gt;</code>
 over the specified indices.</p>

               <p>Misaligned or a loop datatype that does not match the input and/or output datatype is handled using buffered code wherein data is copied to a temporary buffer and cast to the correct datatype if necessary prior to calling the underlying 1-D function. The temporary buffers are created in (element) sizes no bigger than the user settable buffer-size value. Thus, the loop must be flexible enough to call the underlying 1-D computational loop enough times to complete the total calculation in chunks no bigger than the buffer-size.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
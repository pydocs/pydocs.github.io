<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. sectionauthor:: adapted from &#34;Guide to NumPy&#34; by Travis E. Oliphant
    </pre>


               <pre class='not-implemented'>
.. currentmodule:: numpy
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _ufuncs:&#39;&gt;
           </pre>


<h1>Universal functions (:class:`ufunc`)</h1>
               <pre class='not-implemented'>
.. seealso:: :ref:`ufuncs-basics`
    </pre>


               <p>A universal function (or         <code class='verbatim'>ufunc</code>
 for short) is a function that operates on         <code class='verbatim'>ndarrays &lt;numpy.ndarray&gt;</code>
 in an element-by-element fashion, supporting         <code class='verbatim'>array broadcasting &lt;ufuncs.broadcasting&gt;</code>
,         <code class='verbatim'>type
casting &lt;ufuncs.casting&gt;</code>
, and several other standard features. That is, a ufunc is a &#34;        <code class='verbatim'>vectorized &lt;vectorization&gt;</code>
&#34; wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs. For detailed information on universal functions, see         <code class='verbatim'>ufuncs-basics</code>
.</p>


<h1>:class:`ufunc`</h1>
               <pre>.. autosummary:: 
    :toctree:generated/
    numpy.ufunc</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _ufuncs.kwargs:&#39;&gt;
           </pre>


<h1>Optional keyword arguments</h1>
               <p>All ufuncs take optional keyword arguments. Most of these represent advanced usage and will not typically be used.</p>

               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; keyword arguments</pre>


               <pre class='not-implemented'>
.. rubric:: *out*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>The first output can be provided as either a positional or a keyword parameter. Keyword &#39;out&#39; arguments are incompatible with positional ones.</p>

                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>The &#39;out&#39; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</p>

               <p>Passing a single array in the &#39;out&#39; keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</p>

               <p>If &#39;out&#39; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &#39;where&#39; is True. If &#39;where&#39; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</p>

                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Operations where ufunc input and output operands have memory overlap are defined to be the same as for equivalent operations where there is no memory overlap.  Operations affected make temporary copies as needed to eliminate data dependency.  As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result in needless temporary copies.  For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary.  As an example,         <code class='verbatim'>np.add(a, b, out=a)</code>
 will not involve copies.</p>

               <pre class='not-implemented'>
.. rubric:: *where*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Accepts a boolean array which is broadcast together with the operands. Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone. This argument cannot be used for generalized ufuncs as those take non-scalar input.</p>

               <p>Note that if an uninitialized return array is created, values of False will leave those values <strong>uninitialized</strong>.</p>

               <pre class='not-implemented'>
.. rubric:: *axes*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>A list of tuples with indices of axes a generalized ufunc should operate on. For instance, for a signature of         <code class='verbatim'>(i,j),(j,k)-&gt;(i,k)</code>
 appropriate for matrix multiplication, the base elements are two-dimensional matrices and these are taken to be stored in the two last axes of each argument. The corresponding axes keyword would be         <code class='verbatim'>[(-2, -1), (-2, -1), (-2, -1)]</code>
. For simplicity, for generalized ufuncs that operate on 1-dimensional arrays (vectors), a single integer is accepted instead of a single-element tuple, and for generalized ufuncs for which all outputs are scalars, the output tuples can be omitted.</p>

               <pre class='not-implemented'>
.. rubric:: *axis*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>A single axis over which a generalized ufunc should operate. This is a short-cut for ufuncs that operate over a single, shared core dimension, equivalent to passing in         <code class='verbatim'>axes</code>
 with entries of         <code class='verbatim'>(axis,)</code>
 for each single-core-dimension argument and         <code class='verbatim'>()</code>
 for all others.  For instance, for a signature         <code class='verbatim'>(i),(i)-&gt;()</code>
, it is equivalent to passing in         <code class='verbatim'>axes=[(axis,), (axis,), ()]</code>
.</p>

               <pre class='not-implemented'>
.. rubric:: *keepdims*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>If this is set to <code class='not-implemented'>:None:None:`True`</code>, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like         <code class='verbatim'>(i),(i)-&gt;()</code>
 or         <code class='verbatim'>(m,m)-&gt;()</code>
. If used, the location of the dimensions in the output can be controlled with         <code class='verbatim'>axes</code>
 and         <code class='verbatim'>axis</code>
.</p>

               <pre class='not-implemented'>
.. rubric:: *casting*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>May be &#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, or &#39;unsafe&#39;. See         <code class='verbatim'>can_cast</code>
 for explanations of the parameter values.</p>

               <p>Provides a policy for what kind of casting is permitted. For compatibility with previous versions of NumPy, this defaults to &#39;unsafe&#39; for numpy &lt; 1.7. In numpy 1.7 a transition to &#39;same_kind&#39; was begun where ufuncs produce a DeprecationWarning for calls which are allowed under the &#39;unsafe&#39; rules, but not under the &#39;same_kind&#39; rules. From numpy 1.10 and onwards, the default is &#39;same_kind&#39;.</p>

               <pre class='not-implemented'>
.. rubric:: *order*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Specifies the calculation iteration order/memory layout of the output array. Defaults to &#39;K&#39;. &#39;C&#39; means the output should be C-contiguous, &#39;F&#39; means F-contiguous, &#39;A&#39; means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and &#39;K&#39; means to match the element ordering of the inputs as closely as possible.</p>

               <pre class='not-implemented'>
.. rubric:: *dtype*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Overrides the DType of the output arrays the same way as the <em>signature</em>. This should ensure a matching precision of the calculation.  The exact calculation DTypes chosen may depend on the ufunc and the inputs may be cast to this DType to perform the calculation.</p>

               <pre class='not-implemented'>
.. rubric:: *subok*
    </pre>


                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Defaults to true. If set to false, the output will always be a strict array, not a subtype.</p>

               <pre class='not-implemented'>
.. rubric:: *signature*
    </pre>


               <p>Either a Dtype, a tuple of DTypes, or a special signature string indicating the input and output types of a ufunc.</p>

               <p>This argument allows the user to specify exact DTypes to be used for the calculation.  Casting will be used as necessary. The actual DType of the input arrays is not considered unless         <code class='verbatim'>signature</code>
 is         <code class='verbatim'>None</code>
 for that array.</p>

               <p>When all DTypes are fixed, a specific loop is chosen or an error raised if no matching loop exists. If some DTypes are not specified and left         <code class='verbatim'>None</code>
, the behaviour may depend on the ufunc. At this time, a list of available signatures is provided by the <strong>types</strong> attribute of the ufunc.  (This list may be missing DTypes not defined by NumPy.)</p>

               <p>The         <code class='verbatim'>signature</code>
 only specifies the DType class/type.  For example, it can specify that the operation should be         <code class='verbatim'>datetime64</code>
 or         <code class='verbatim'>float64</code>
 operation.  It does not specify the         <code class='verbatim'>datetime64</code>
 time-unit or the         <code class='verbatim'>float64</code>
 byte-order.</p>

               <p>For backwards compatibility this argument can also be provided as <em>sig</em>, although the long form is preferred.  Note that this should not be confused with the generalized ufunc         <code class='verbatim'>signature &lt;details-of-signature&gt;</code>
 that is stored in the <strong>signature</strong> attribute of the of the ufunc object.</p>

               <pre class='not-implemented'>
.. rubric:: *extobj*
    </pre>


               <p>A list of length 3 specifying the ufunc buffer-size, the error mode integer, and the error call-back function. Normally, these values are looked up in a thread-specific dictionary. Passing them here circumvents that look up and uses the low-level specification provided for the error mode. This may be useful, for example, as an optimization for calculations requiring many ufunc calls on small arrays in a loop.</p>


<h1>Attributes</h1>
               <p>There are some informational attributes that universal functions possess. None of the attributes can be set.</p>

               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; attributes</pre>


               <p>============  ================================================================= <strong>__doc__</strong>   A docstring for each ufunc. The first part of the docstring is               dynamically generated from the number of outputs, the name, and               the number of inputs. The second part of the docstring is               provided at creation time and stored with the ufunc.</p>

               <p><strong>__name__</strong>  The name of the ufunc. ============  =================================================================</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ufunc.nin
    ufunc.nout
    ufunc.nargs
    ufunc.ntypes
    ufunc.types
    ufunc.identity
    ufunc.signature</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _ufuncs.methods:&#39;&gt;
           </pre>


<h1>Methods</h1>
               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; methods</pre>


               <pre>.. autosummary:: 
    :toctree:generated/
    ufunc.reduce
    ufunc.accumulate
    ufunc.reduceat
    ufunc.outer
    ufunc.at</pre>
                           <div class='admonition'>
    <div>warning</div>
        <p>A reduce-like operation on an array with a data-type that has a range &#34;too small&#34; to handle the result will silently wrap. One should use <code class='not-implemented'>:None:None:`dtype`</code> to increase the size of the data-type over which reduction takes place.</p>

</div>



<h1>Available ufuncs</h1>
               <p>There are currently more than 60 universal functions defined in         <code class='verbatim'>numpy</code>
 on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (<em>e.g.</em>,         <code class='verbatim'>add(a, b) &lt;add&gt;</code>
 is called internally when         <code class='verbatim'>a + b</code>
 is written and <em>a</em> or <em>b</em> is an         <code class='verbatim'>ndarray</code>
). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</p>

               <p>Recall that each ufunc operates element-by-element. Therefore, each scalar ufunc will be described as if acting on a set of scalar inputs to return a set of scalar outputs.</p>

                           <div class='admonition'>
    <div>note</div>
        <p>The ufunc still returns its output(s) even if you use the optional output argument(s).</p>

</div>



<h1>Math operations</h1>
               <pre>.. autosummary:: 
    add
    subtract
    multiply
    matmul
    divide
    logaddexp
    logaddexp2
    true_divide
    floor_divide
    negative
    positive
    power
    float_power
    remainder
    mod
    fmod
    divmod
    absolute
    fabs
    rint
    sign
    heaviside
    conj
    conjugate
    exp
    exp2
    log
    log2
    log10
    expm1
    log1p
    sqrt
    square
    cbrt
    reciprocal
    gcd
    lcm</pre>
               <pre class='not-implemented'>
.. tip:: 
    The optional output arguments can be used to help you save memory
    for large calculations. If your arrays are large, complicated
    expressions can take longer than absolutely necessary due to the
    creation and (later) destruction of temporary calculation
    spaces. For example, the expression ``G = A * B + C`` is equivalent to
    ``T1 = A * B; G = T1 + C; del T1``. It will be more quickly executed
    as ``G = A * B; add(G, C, G)`` which is the same as
    ``G = A * B; G += C``.</pre>



<h1>Trigonometric functions</h1>
               <p>All trigonometric functions use radians when an angle is called for. The ratio of degrees to radians is         <span class="tex2jax_process">$180^{\circ}/\pi.$</span>
</p>

               <pre>.. autosummary:: 
    sin
    cos
    tan
    arcsin
    arccos
    arctan
    arctan2
    hypot
    sinh
    cosh
    tanh
    arcsinh
    arccosh
    arctanh
    degrees
    radians
    deg2rad
    rad2deg</pre>

<h1>Bit-twiddling functions</h1>
               <p>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</p>

               <pre>.. autosummary:: 
    bitwise_and
    bitwise_or
    bitwise_xor
    invert
    left_shift
    right_shift</pre>

<h1>Comparison functions</h1>
               <pre>.. autosummary:: 
    greater
    greater_equal
    less
    less_equal
    not_equal
    equal</pre>
                           <div class='admonition'>
    <div>warning</div>
        <p>Do not use the Python keywords         <code class='verbatim'>and</code>
 and         <code class='verbatim'>or</code>
 to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp; and \| instead.</p>

</div>


               <pre>.. autosummary:: 
    logical_and
    logical_or
    logical_xor
    logical_not</pre>
                           <div class='admonition'>
    <div>warning</div>
        <p>The bit-wise operators &amp; and \| are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence:         <code class='verbatim'>(a &gt; 2) &amp; (a &lt; 5)</code>
 is the proper syntax because         <code class='verbatim'>a &gt; 2 &amp; a &lt; 5</code>
 will result in an error due to the fact that         <code class='verbatim'>2 &amp; a</code>
 is evaluated first.</p>

</div>


               <pre>.. autosummary:: 
    maximum</pre>
               <pre class='not-implemented'>
.. tip:: 
    The Python function ``max()`` will find the maximum over a one-dimensional
    array, but it will do so using a slower sequence interface. The reduce
    method of the maximum ufunc is much faster. Also, the ``max()`` method
    will not give answers you might expect for arrays with greater than
    one dimension. The reduce method of minimum also allows you to compute
    a total minimum over an array.</pre>


               <pre>.. autosummary:: 
    minimum</pre>
                           <div class='admonition'>
    <div>warning</div>
        <p>the behavior of         <code class='verbatim'>maximum(a, b)</code>
 is different than that of         <code class='verbatim'>max(a, b)</code>
. As a ufunc,         <code class='verbatim'>maximum(a, b)</code>
 performs an element-by-element comparison of <code class='not-implemented'>:None:None:`a`</code> and <code class='not-implemented'>:None:None:`b`</code> and chooses each element of the result according to which element in the two arrays is larger. In contrast,         <code class='verbatim'>max(a, b)</code>
 treats the objects <code class='not-implemented'>:None:None:`a`</code> and <code class='not-implemented'>:None:None:`b`</code> as a whole, looks at the (total) truth value of         <code class='verbatim'>a &gt; b</code>
 and uses it to return either <code class='not-implemented'>:None:None:`a`</code> or <code class='not-implemented'>:None:None:`b`</code> (as a whole). A similar difference exists between         <code class='verbatim'>minimum(a, b)</code>
 and         <code class='verbatim'>min(a, b)</code>
.</p>

</div>


               <pre>.. autosummary:: 
    fmax
    fmin</pre>

<h1>Floating functions</h1>
               <p>Recall that all of these functions work element-by-element over an array, returning an array output. The description details only a single operation.</p>

               <pre>.. autosummary:: 
    isfinite
    isinf
    isnan
    isnat
    fabs
    signbit
    copysign
    nextafter
    spacing
    modf
    ldexp
    frexp
    fmod
    floor
    ceil
    trunc</pre>

<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. currentmodule:: numpy.ma
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _maskedarray.generic:&#39;&gt;
           </pre>

               <pre class='not-implemented'>
.. module:: numpy.ma
    </pre>



<h1>The :mod:`numpy.ma` module</h1>

<h1>Rationale</h1>
               <p>Masked arrays are arrays that may have missing or invalid entries. The         <code class='verbatim'>numpy.ma</code>
 module provides a nearly work-alike replacement for numpy that supports data arrays with masks.</p>


<h1>What is a masked array?</h1>
               <p>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The         <code class='verbatim'>numpy.ma</code>
 module provides a convenient way to address this issue, by introducing masked arrays.</p>

               <p>A masked array is the combination of a standard         <code class='verbatim'>numpy.ndarray</code>
 and a mask. A mask is either         <code class='verbatim'>nomask</code>
, indicating that no value of the associated array is invalid, or an array of booleans that determines for each element of the associated array whether the value is valid or not. When an element of the mask is         <code class='verbatim'>False</code>
, the corresponding element of the associated array is valid and is said to be unmasked. When an element of the mask is         <code class='verbatim'>True</code>
, the corresponding element of the associated array is said to be masked (invalid).</p>

               <p>The package ensures that masked entries are not used in computations.</p>

               <p>As an illustration, let&#39;s consider the following dataset::     </p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = np.array([1, 2, 3, -1, 5])</pre>
               <p>We wish to mark the fourth entry as invalid. The easiest is to create a masked array::     </p>

               <pre>&gt;&gt;&gt; mx = ma.masked_array(x, mask=[0, 0, 0, 1, 0])</pre>
               <p>We can now compute the mean of the dataset, without taking the invalid data into account::     </p>

               <pre>&gt;&gt;&gt; mx.mean()
2.75</pre>

<h1>The :mod:`numpy.ma` module</h1>
               <p>The main feature of the         <code class='verbatim'>numpy.ma</code>
 module is the         <code class='verbatim'>MaskedArray</code>
 class, which is a subclass of         <code class='verbatim'>numpy.ndarray</code>
. The class, its attributes and methods are described in more details in the         <code class='verbatim'>MaskedArray class &lt;maskedarray.baseclass&gt;</code>
 section.</p>

               <p>The         <code class='verbatim'>numpy.ma</code>
 module can be used as an addition to         <code class='verbatim'>numpy</code>
: ::     </p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import numpy.ma as ma</pre>
               <p>To create an array with the second element invalid, we would do::     </p>

               <pre>&gt;&gt;&gt; y = ma.array([1, 2, 3], mask = [0, 1, 0])</pre>
               <p>To create a masked array where all values close to 1.e20 are invalid, we would do::     </p>

               <pre>&gt;&gt;&gt; z = ma.masked_values([1.0, 1.e20, 3.0, 4.0], 1.e20)</pre>
               <p>For a complete discussion of creation methods for masked arrays please see section         <code class='verbatim'>Constructing masked arrays &lt;maskedarray.generic.constructing&gt;</code>
.</p>


<h1>Using numpy.ma</h1>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _maskedarray.generic.constructing:&#39;&gt;
           </pre>


<h1>Constructing masked arrays</h1>
               <p>There are several ways to construct a masked array.</p>

                          <ul>               <li>               <p>A first possibility is to directly invoke the         <code class='verbatim'>MaskedArray</code>
 class.</p>

</li>
            </ul>

                          <ul>               <li>               <p>A second possibility is to use the two masked array constructors,           <code class='verbatim'>array</code>
 and         <code class='verbatim'>masked_array</code>
.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    array
      masked_array</pre>
</li>
            </ul>

                          <ul>               <li>               <p>A third option is to take the view of an existing array. In that case, the   mask of the view is set to         <code class='verbatim'>nomask</code>
 if the array has no named fields,   or an array of boolean with the same structure as the array otherwise.</p>

                           <pre>&gt;&gt;&gt; x = np.array([1, 2, 3])
&gt;&gt;&gt; x.view(ma.MaskedArray)
masked_array(data=[1, 2, 3],
             mask=False,
       fill_value=999999)
&gt;&gt;&gt; x = np.array([(1, 1.), (2, 2.)], dtype=[(&#39;a&#39;,int), (&#39;b&#39;, float)])
&gt;&gt;&gt; x.view(ma.MaskedArray)
masked_array(data=[(1, 1.0), (2, 2.0)],
             mask=[(False, False), (False, False)],
       fill_value=(999999, 1.e+20),
            dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;), (&#39;b&#39;, &#39;&lt;f8&#39;)])
</pre>

</li>
            </ul>

                          <ul>               <li>               <p>Yet another possibility is to use any of the following functions:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    asarray
      asanyarray
      fix_invalid
      masked_equal
      masked_greater
      masked_greater_equal
      masked_inside
      masked_invalid
      masked_less
      masked_less_equal
      masked_not_equal
      masked_object
      masked_outside
      masked_values
      masked_where</pre>
</li>
            </ul>


<h1>Accessing the data</h1>
               <p>The underlying data of a masked array can be accessed in several ways:</p>

                          <ul>               <li>               <p>through the         <code class='verbatim'>~MaskedArray.data</code>
 attribute. The output is a view of the   array as a         <code class='verbatim'>numpy.ndarray</code>
 or one of its subclasses, depending on the   type of the underlying data at the masked array creation.</p>

</li>
            </ul>

                          <ul>               <li>               <p>through the         <code class='verbatim'>~MaskedArray.__array__</code>
 method. The output is then a           <code class='verbatim'>numpy.ndarray</code>
.</p>

</li>
            </ul>

                          <ul>               <li>               <p>by directly taking a view of the masked array as a         <code class='verbatim'>numpy.ndarray</code>
   or one of its subclass (which is actually what using the           <code class='verbatim'>~MaskedArray.data</code>
 attribute does).</p>

</li>
            </ul>

                          <ul>               <li>               <p>by using the         <code class='verbatim'>getdata</code>
 function.</p>

</li>
            </ul>

               <p>None of these methods is completely satisfactory if some entries have been marked as invalid. As a general rule, where a representation of the array is required without any masked entries, it is recommended to fill the array with the         <code class='verbatim'>filled</code>
 method.</p>


<h1>Accessing the mask</h1>
               <p>The mask of a masked array is accessible through its         <code class='verbatim'>~MaskedArray.mask</code>
 attribute. We must keep in mind that a         <code class='verbatim'>True</code>
 entry in the mask indicates an <em>invalid</em> data.</p>

               <p>Another possibility is to use the         <code class='verbatim'>getmask</code>
 and         <code class='verbatim'>getmaskarray</code>
 functions.         <code class='verbatim'>getmask(x)</code>
 outputs the mask of         <code class='verbatim'>x</code>
 if         <code class='verbatim'>x</code>
 is a masked array, and the special value         <code class='verbatim'>nomask</code>
 otherwise.         <code class='verbatim'>getmaskarray(x)</code>
 outputs the mask of         <code class='verbatim'>x</code>
 if         <code class='verbatim'>x</code>
 is a masked array. If         <code class='verbatim'>x</code>
 has no invalid entry or is not a masked array, the function outputs  a boolean array of         <code class='verbatim'>False</code>
 with as many elements as         <code class='verbatim'>x</code>
.</p>


<h1>Accessing only the valid entries</h1>
               <p>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the         <code class='verbatim'>numpy.logical_not</code>
 function or simply with the         <code class='verbatim'>~</code>
 operator::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([[1, 2], [3, 4]], mask=[[0, 1], [1, 0]])
&gt;&gt;&gt; x[~x.mask]
masked_array(data=[1, 4],
             mask=[False, False],
       fill_value=999999)</pre>
               <p>Another way to retrieve the valid data is to use the         <code class='verbatim'>compressed</code>
 method, which returns a one-dimensional         <code class='verbatim'>~numpy.ndarray</code>
 (or one of its subclasses, depending on the value of the         <code class='verbatim'>~MaskedArray.baseclass</code>
 attribute)::     </p>

               <pre>&gt;&gt;&gt; x.compressed()
array([1, 4])</pre>
               <p>Note that the output of         <code class='verbatim'>compressed</code>
 is always 1D.</p>


<h1>Modifying the mask</h1>

<h1>Masking an entry</h1>
               <p>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value         <code class='verbatim'>masked</code>
 to them::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3])
&gt;&gt;&gt; x[0] = ma.masked
&gt;&gt;&gt; x
masked_array(data=[--, 2, 3],
             mask=[ True, False, False],
       fill_value=999999)
&gt;&gt;&gt; y = ma.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; y[(0, 1, 2), (1, 2, 0)] = ma.masked
&gt;&gt;&gt; y
masked_array(
  data=[[1, --, 3],
        [4, 5, --],
        [--, 8, 9]],
  mask=[[False,  True, False],
        [False, False,  True],
        [ True, False, False]],
  fill_value=999999)
&gt;&gt;&gt; z = ma.array([1, 2, 3, 4])
&gt;&gt;&gt; z[:-2] = ma.masked
&gt;&gt;&gt; z
masked_array(data=[--, --, 3, 4],
             mask=[ True,  True, False, False],
       fill_value=999999)</pre>
               <p>A second possibility is to modify the         <code class='verbatim'>~MaskedArray.mask</code>
 directly, but this usage is discouraged.</p>

                           <div class='admonition'>
    <div>note</div>
        <p>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value         <code class='verbatim'>nomask</code>
, that corresponds roughly to the boolean         <code class='verbatim'>False</code>
. Trying to set an element of         <code class='verbatim'>nomask</code>
 will fail with a         <code class='verbatim'>TypeError</code>
 exception, as a boolean does not support item assignment.</p>

</div>


               <p>All the entries of an array can be masked at once by assigning         <code class='verbatim'>True</code>
 to the mask::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 0, 1])
&gt;&gt;&gt; x.mask = True
&gt;&gt;&gt; x
masked_array(data=[--, --, --],
             mask=[ True,  True,  True],
       fill_value=999999,
            dtype=int64)</pre>
               <p>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3])
&gt;&gt;&gt; x.mask = [0, 1, 0]
&gt;&gt;&gt; x
masked_array(data=[1, --, 3],
             mask=[False,  True, False],
       fill_value=999999)</pre>

<h1>Unmasking an entry</h1>
               <p>To unmask one or several specific entries, we can just assign one or several new valid values to them::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 0, 1])
&gt;&gt;&gt; x
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
&gt;&gt;&gt; x[-1] = 5
&gt;&gt;&gt; x
masked_array(data=[1, 2, 5],
             mask=[False, False, False],
       fill_value=999999)</pre>
                           <div class='admonition'>
    <div>note</div>
        <p>Unmasking an entry by direct assignment will silently fail if the masked array has a <em>hard</em> mask, as shown by the         <code class='verbatim'>~MaskedArray.hardmask</code>
 attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the         <code class='verbatim'>soften_mask</code>
 method before the allocation. It can be re-hardened with         <code class='verbatim'>harden_mask</code>
     </p>

        <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 0, 1], hard_mask=True)
&gt;&gt;&gt; x
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
&gt;&gt;&gt; x[-1] = 5
&gt;&gt;&gt; x
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
&gt;&gt;&gt; x.soften_mask()
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
&gt;&gt;&gt; x[-1] = 5
&gt;&gt;&gt; x
masked_array(data=[1, 2, 5],
             mask=[False, False, False],
       fill_value=999999)
&gt;&gt;&gt; x.harden_mask()
masked_array(data=[1, 2, 5],
             mask=[False, False, False],
       fill_value=999999)</pre>
</div>


               <p>To unmask all masked entries of a masked array (provided the mask isn&#39;t a hard mask), the simplest solution is to assign the constant         <code class='verbatim'>nomask</code>
 to the mask::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 0, 1])
&gt;&gt;&gt; x
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
&gt;&gt;&gt; x.mask = ma.nomask
&gt;&gt;&gt; x
masked_array(data=[1, 2, 3],
             mask=[False, False, False],
       fill_value=999999)</pre>

<h1>Indexing and slicing</h1>
               <p>As a         <code class='verbatim'>MaskedArray</code>
 is a subclass of         <code class='verbatim'>numpy.ndarray</code>
, it inherits its mechanisms for indexing and slicing.</p>

               <p>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is         <code class='verbatim'>False</code>
) or the special value         <code class='verbatim'>masked</code>
 (if the corresponding entry of the mask is         <code class='verbatim'>True</code>
)::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 0, 1])
&gt;&gt;&gt; x[0]
1
&gt;&gt;&gt; x[-1]
masked
&gt;&gt;&gt; x[-1] is ma.masked
True</pre>
               <p>If the masked array has named fields, accessing a single entry returns a         <code class='verbatim'>numpy.void</code>
 object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</p>

                           <pre>&gt;&gt;&gt; y = ma.masked_array([(1,2), (3, 4)],
...                mask=[(0, 0), (0, 1)],
...               dtype=[(&#39;a&#39;, int), (&#39;b&#39;, int)])
&gt;&gt;&gt; y[0]
(1, 2)
&gt;&gt;&gt; y[-1]
(3, --)
</pre>

               <p>When accessing a slice, the output is a masked array whose         <code class='verbatim'>~MaskedArray.data</code>
 attribute is a view of the original data, and whose mask is either         <code class='verbatim'>nomask</code>
 (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</p>

                           <pre>&gt;&gt;&gt; x = ma.array([1, 2, 3, 4, 5], mask=[0, 1, 0, 0, 1])
&gt;&gt;&gt; mx = x[:3]
&gt;&gt;&gt; mx
masked_array(data=[1, --, 3],
             mask=[False,  True, False],
       fill_value=999999)
&gt;&gt;&gt; mx[1] = -1
&gt;&gt;&gt; mx
masked_array(data=[1, -1, 3],
             mask=[False, False, False],
       fill_value=999999)
&gt;&gt;&gt; x.mask
array([False, False, False, False,  True])
&gt;&gt;&gt; x.data
array([ 1, -1,  3,  4,  5])
</pre>

               <p>Accessing a field of a masked array with structured datatype returns a         <code class='verbatim'>MaskedArray</code>
.</p>


<h1>Operations on masked arrays</h1>
               <p>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding         <code class='verbatim'>~MaskedArray.data</code>
 entries <em>should</em> be the same before and after the operation.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</p>

</div>


               <p>The         <code class='verbatim'>numpy.ma</code>
 module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as         <code class='verbatim'>~numpy.log</code>
 or         <code class='verbatim'>~numpy.divide</code>
) return the         <code class='verbatim'>masked</code>
 constant whenever the input is masked or falls outside the validity domain::     </p>

               <pre>&gt;&gt;&gt; ma.log([-1, 0, 1, 2])
masked_array(data=[--, --, 0.0, 0.6931471805599453],
             mask=[ True,  True, False, False],
       fill_value=1e+20)</pre>
               <p>Masked arrays also support standard numpy ufuncs. The output is then a masked array. The result of a unary ufunc is masked wherever the input is masked. The result of a binary ufunc is masked wherever any of the input is masked. If the ufunc also returns the optional context output (a 3-element tuple containing the name of the ufunc, its arguments and its domain), the context is processed and entries of the output masked array are masked wherever the corresponding input fall outside the validity domain::     </p>

               <pre>&gt;&gt;&gt; x = ma.array([-1, 1, 0, 2, 3], mask=[0, 0, 0, 0, 1])
&gt;&gt;&gt; np.log(x)
masked_array(data=[--, 0.0, --, 0.6931471805599453, --],
             mask=[ True, False,  True, False,  True],
       fill_value=1e+20)</pre>

<h1>Examples</h1>

<h1>Data with a given value representing missing data</h1>
               <p>Let&#39;s consider a list of elements,         <code class='verbatim'>x</code>
, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average)::     </p>

               <pre>&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = [0.,1.,-9999.,3.,4.]
&gt;&gt;&gt; mx = ma.masked_values (x, -9999.)
&gt;&gt;&gt; print(mx.mean())
2.0
&gt;&gt;&gt; print(mx - mx.mean())
[-2.0 -1.0 -- 1.0 2.0]
&gt;&gt;&gt; print(mx.anom())
[-2.0 -1.0 -- 1.0 2.0]</pre>

<h1>Filling in the missing data</h1>
               <p>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</p>

                           <pre>&gt;&gt;&gt; print(mx.filled(mx.mean()))
[0.  1.  2.  3.  4.]
</pre>


<h1>Numerical operations</h1>
               <p>Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.::     </p>

               <pre>&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = ma.array([1., -1., 3., 4., 5., 6.], mask=[0,0,0,0,1,0])
&gt;&gt;&gt; y = ma.array([1., 2., 0., 4., 5., 6.], mask=[0,0,0,0,0,1])
&gt;&gt;&gt; print(ma.sqrt(x/y))
[1.0 -- -- 1.0 -- --]</pre>
               <p>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</p>


<h1>Ignoring extreme values</h1>
               <p>Let&#39;s consider an array         <code class='verbatim'>d</code>
 of floats between 0 and 1. We wish to compute the average of the values of         <code class='verbatim'>d</code>
 while ignoring any data outside the range         <code class='verbatim'>[0.2, 0.9]</code>
     </p>

               <pre>&gt;&gt;&gt; d = np.linspace(0, 1, 20)
&gt;&gt;&gt; print(d.mean() - ma.masked_outside(d, 0.2, 0.9).mean())
-0.05263157894736836</pre>

<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
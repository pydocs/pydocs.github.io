<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Writing your own ufunc</h1>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:Creating-a-new`:&#39;&gt;
           </pre>


<h1>Creating a new universal function</h1>
               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; adding new</pre>


               <p>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of <code class='not-implemented'>:None:None:`Extending and Embedding the Python Interpreter
&lt;https://docs.python.org/extending/index.html&gt;`</code> and in         <code class='verbatim'>How to extend
NumPy &lt;c-info.how-to-extend&gt;</code>
</p>

               <p>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</p>

                          <ul>               <li>               <p>broadcasting</p>

</li>
               <li>               <p>N-dimensional looping</p>

</li>
               <li>               <p>automatic type-conversions with minimal memory usage</p>

</li>
               <li>               <p>optional output arrays</p>

</li>
            </ul>

               <p>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</p>

               <p>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</p>

               <pre>&gt;&gt;&gt; logit(0)
-inf
&gt;&gt;&gt; logit(1)
inf
&gt;&gt;&gt; logit(2)
nan
&gt;&gt;&gt; logit(-2)
nan</pre>
               <p>This is wonderful because the function writer doesn&#39;t have to manually propagate infs or nans.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:Non-numpy-example`:&#39;&gt;
           </pre>


<h1>Example Non-ufunc extension</h1>
               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; adding new</pre>


               <p>For comparison and general edification of the reader we provide a simple implementation of a C extension of         <code class='verbatim'>logit</code>
 that uses no numpy.</p>

               <p>To do this we need two files. The first is the C file which contains the actual code, and the second is the         <code class='verbatim'>setup.py</code>
 file used to create the module.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    #define PY_SSIZE_T_CLEAN
        #include &lt;Python.h&gt;
        #include &lt;math.h&gt;

        /*
         * spammodule.c
         * This is the C code for a non-numpy Python extension to
         * define the logit function, where logit(p) = log(p/(1-p)).
         * This function will not work on numpy arrays automatically.
         * numpy.vectorize must be called in python to generate
         * a numpy-friendly function.
         *
         * Details explaining the Python-C API can be found under
         * &#39;Extending and Embedding&#39; and &#39;Python/C API&#39; at
         * docs.python.org .
         */


        /* This declares the logit function */
        static PyObject *spam_logit(PyObject *self, PyObject *args);

        /*
         * This tells Python what methods this module has.
         * See the Python-C API for more information.
         */
        static PyMethodDef SpamMethods[] = {
            {&#34;logit&#34;,
                spam_logit,
                METH_VARARGS, &#34;compute logit&#34;},
            {NULL, NULL, 0, NULL}
        };

        /*
         * This actually defines the logit function for
         * input args from Python.
         */

        static PyObject *spam_logit(PyObject *self, PyObject *args)
        {
            double p;

            /* This parses the Python argument into a double */
            if(!PyArg_ParseTuple(args, &#34;d&#34;, &amp;p)) {
                return NULL;
            }

            /* THE ACTUAL LOGIT FUNCTION */
            p = p/(1-p);
            p = log(p);

            /*This builds the answer back into a python object */
            return Py_BuildValue(&#34;d&#34;, p);
        }

        /* This initiates the module using the above definitions. */
        static struct PyModuleDef moduledef = {
            PyModuleDef_HEAD_INIT,
            &#34;spam&#34;,
            NULL,
            -1,
            SpamMethods,
            NULL,
            NULL,
            NULL,
            NULL
        };

        PyMODINIT_FUNC PyInit_spam(void)
        {
            PyObject *m;
            m = PyModule_Create(&amp;moduledef);
            if (!m) {
                return NULL;
            }
            return m;
        }</pre>

</blockquote>

               <p>To use the         <code class='verbatim'>setup.py file</code>
, place         <code class='verbatim'>setup.py</code>
 and         <code class='verbatim'>spammodule.c</code>
 in the same folder. Then         <code class='verbatim'>python setup.py build</code>
 will build the module to import, or         <code class='verbatim'>python setup.py install</code>
 will install the module to your site-packages directory.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    &#39;&#39;&#39;
            setup.py file for spammodule.c

            Calling
            $python setup.py build_ext --inplace
            will build the extension library in the current file.

            Calling
            $python setup.py build
            will build a file that looks like ./build/lib*, where
            lib* is a file that begins with lib. The library will
            be in this file and end with a C library extension,
            such as .so

            Calling
            $python setup.py install
            will install the module in your site-packages file.

            See the distutils section of
            &#39;Extending and Embedding the Python Interpreter&#39;
            at docs.python.org for more information.
        &#39;&#39;&#39;


        from distutils.core import setup, Extension

        module1 = Extension(&#39;spam&#39;, sources=[&#39;spammodule.c&#39;],
                                include_dirs=[&#39;/usr/local/lib&#39;])

        setup(name = &#39;spam&#39;,
                version=&#39;1.0&#39;,
                description=&#39;This is my spam package&#39;,
                ext_modules = [module1])</pre>

</blockquote>

               <p>Once the spam module is imported into python, you can call logit via         <code class='verbatim'>spam.logit</code>
. Note that the function used above cannot be applied as-is to numpy arrays. To do so we must call         <code class='verbatim'>numpy.vectorize</code>
 on it. For example, if a python interpreter is opened in the file containing the spam library or spam has been installed, one can perform the following commands:</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import spam
&gt;&gt;&gt; spam.logit(0)
-inf
&gt;&gt;&gt; spam.logit(1)
inf
&gt;&gt;&gt; spam.logit(0.5)
0.0
&gt;&gt;&gt; x = np.linspace(0,1,10)
&gt;&gt;&gt; spam.logit(x)
TypeError: only length-1 arrays can be converted to Python scalars
&gt;&gt;&gt; f = np.vectorize(spam.logit)
&gt;&gt;&gt; f(x)
array([       -inf, -2.07944154, -1.25276297, -0.69314718, -0.22314355,
    0.22314355,  0.69314718,  1.25276297,  2.07944154,         inf])</pre>
               <p>THE RESULTING LOGIT FUNCTION IS NOT FAST!         <code class='verbatim'>numpy.vectorize</code>
 simply loops over         <code class='verbatim'>spam.logit</code>
. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared         <code class='verbatim'>numpy.vectorize(spam.logit)</code>
 against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:NumPy-one-loop`:&#39;&gt;
           </pre>


<h1>Example NumPy ufunc for one dtype</h1>
               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; adding new</pre>


               <p>For simplicity we give a ufunc for a single dtype, the         <code class='verbatim'>&#39;f8&#39;</code>
         <code class='verbatim'>double</code>
. As in the previous section, we first give the         <code class='verbatim'>.c</code>
 file and then the         <code class='verbatim'>setup.py</code>
 file used to create the module containing the ufunc.</p>

               <p>The place in the code corresponding to the actual computations for the ufunc are marked with         <code class='verbatim'>/\* BEGIN main ufunc computation \*/</code>
 and         <code class='verbatim'>/\* END main ufunc computation \*/</code>
. The code in between those lines is the primary thing that must be changed to create your own ufunc.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    #define PY_SSIZE_T_CLEAN
        #include &lt;Python.h&gt;
        #include &#34;numpy/ndarraytypes.h&#34;
        #include &#34;numpy/ufuncobject.h&#34;
        #include &#34;numpy/npy_3kcompat.h&#34;
        #include &lt;math.h&gt;

        /*
         * single_type_logit.c
         * This is the C code for creating your own
         * NumPy ufunc for a logit function.
         *
         * In this code we only define the ufunc for
         * a single dtype. The computations that must
         * be replaced to create a ufunc for
         * a different function are marked with BEGIN
         * and END.
         *
         * Details explaining the Python-C API can be found under
         * &#39;Extending and Embedding&#39; and &#39;Python/C API&#39; at
         * docs.python.org .
         */

        static PyMethodDef LogitMethods[] = {
            {NULL, NULL, 0, NULL}
        };

        /* The loop definition must precede the PyMODINIT_FUNC. */

        static void double_logit(char **args, const npy_intp *dimensions,
                                 const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in = args[0], *out = args[1];
            npy_intp in_step = steps[0], out_step = steps[1];

            double tmp;

            for (i = 0; i &lt; n; i++) {
                /* BEGIN main ufunc computation */
                tmp = *(double *)in;
                tmp /= 1 - tmp;
                *((double *)out) = log(tmp);
                /* END main ufunc computation */

                in += in_step;
                out += out_step;
            }
        }

        /* This a pointer to the above function */
        PyUFuncGenericFunction funcs[1] = {&amp;double_logit};

        /* These are the input and return dtypes of logit.*/
        static char types[2] = {NPY_DOUBLE, NPY_DOUBLE};

        static struct PyModuleDef moduledef = {
            PyModuleDef_HEAD_INIT,
            &#34;npufunc&#34;,
            NULL,
            -1,
            LogitMethods,
            NULL,
            NULL,
            NULL,
            NULL
        };

        PyMODINIT_FUNC PyInit_npufunc(void)
        {
            PyObject *m, *logit, *d;

            import_array();
            import_umath();

            m = PyModule_Create(&amp;moduledef);
            if (!m) {
                return NULL;
            }

            logit = PyUFunc_FromFuncAndData(funcs, NULL, types, 1, 1, 1,
                                            PyUFunc_None, &#34;logit&#34;,
                                            &#34;logit_docstring&#34;, 0);

            d = PyModule_GetDict(m);

            PyDict_SetItemString(d, &#34;logit&#34;, logit);
            Py_DECREF(logit);

            return m;
        }</pre>

</blockquote>

               <p>This is a         <code class='verbatim'>setup.py file</code>
 for the above code. As before, the module can be build via calling         <code class='verbatim'>python setup.py build</code>
 at the command prompt, or installed to site-packages via         <code class='verbatim'>python setup.py install</code>
. The module can also be placed into a local folder e.g.         <code class='verbatim'>npufunc_directory</code>
 below using         <code class='verbatim'>python setup.py build_ext --inplace</code>
.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    &#39;&#39;&#39;
            setup.py file for single_type_logit.c
            Note that since this is a numpy extension
            we use numpy.distutils instead of
            distutils from the python standard library.

            Calling
            $python setup.py build_ext --inplace
            will build the extension library in the npufunc_directory.

            Calling
            $python setup.py build
            will build a file that looks like ./build/lib*, where
            lib* is a file that begins with lib. The library will
            be in this file and end with a C library extension,
            such as .so

            Calling
            $python setup.py install
            will install the module in your site-packages file.

            See the distutils section of
            &#39;Extending and Embedding the Python Interpreter&#39;
            at docs.python.org  and the documentation
            on numpy.distutils for more information.
        &#39;&#39;&#39;


        def configuration(parent_package=&#39;&#39;, top_path=None):
            from numpy.distutils.misc_util import Configuration

            config = Configuration(&#39;npufunc_directory&#39;,
                                   parent_package,
                                   top_path)
            config.add_extension(&#39;npufunc&#39;, [&#39;single_type_logit.c&#39;])

            return config

        if __name__ == &#34;__main__&#34;:
            from numpy.distutils.core import setup
            setup(configuration=configuration)</pre>

</blockquote>

               <p>After the above has been installed, it can be imported and used as follows.</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import npufunc
&gt;&gt;&gt; npufunc.logit(0.5)
0.0
&gt;&gt;&gt; a = np.linspace(0,1,5)
&gt;&gt;&gt; npufunc.logit(a)
array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:NumPy-many-loop`:&#39;&gt;
           </pre>


<h1>Example NumPy ufunc with multiple dtypes</h1>
               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; adding new</pre>


               <p>We finally give an example of a full ufunc, with inner loops for half-floats, floats, doubles, and long doubles. As in the previous sections we first give the         <code class='verbatim'>.c</code>
 file and then the corresponding         <code class='verbatim'>setup.py</code>
 file.</p>

               <p>The places in the code corresponding to the actual computations for the ufunc are marked with         <code class='verbatim'>/\* BEGIN main ufunc computation \*/</code>
 and         <code class='verbatim'>/\* END main ufunc computation \*/</code>
. The code in between those lines is the primary thing that must be changed to create your own ufunc.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    #define PY_SSIZE_T_CLEAN
        #include &lt;Python.h&gt;
        #include &#34;numpy/ndarraytypes.h&#34;
        #include &#34;numpy/ufuncobject.h&#34;
        #include &#34;numpy/halffloat.h&#34;
        #include &lt;math.h&gt;

        /*
         * multi_type_logit.c
         * This is the C code for creating your own
         * NumPy ufunc for a logit function.
         *
         * Each function of the form type_logit defines the
         * logit function for a different numpy dtype. Each
         * of these functions must be modified when you
         * create your own ufunc. The computations that must
         * be replaced to create a ufunc for
         * a different function are marked with BEGIN
         * and END.
         *
         * Details explaining the Python-C API can be found under
         * &#39;Extending and Embedding&#39; and &#39;Python/C API&#39; at
         * docs.python.org .
         *
         */

        static PyMethodDef LogitMethods[] = {
            {NULL, NULL, 0, NULL}
        };

        /* The loop definitions must precede the PyMODINIT_FUNC. */

        static void long_double_logit(char **args, const npy_intp *dimensions,
                                      const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in = args[0], *out = args[1];
            npy_intp in_step = steps[0], out_step = steps[1];

            long double tmp;

            for (i = 0; i &lt; n; i++) {
                /* BEGIN main ufunc computation */
                tmp = *(long double *)in;
                tmp /= 1 - tmp;
                *((long double *)out) = logl(tmp);
                /* END main ufunc computation */

                in += in_step;
                out += out_step;
            }
        }

        static void double_logit(char **args, const npy_intp *dimensions,
                                 const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in = args[0], *out = args[1];
            npy_intp in_step = steps[0], out_step = steps[1];

            double tmp;

            for (i = 0; i &lt; n; i++) {
                /* BEGIN main ufunc computation */
                tmp = *(double *)in;
                tmp /= 1 - tmp;
                *((double *)out) = log(tmp);
                /* END main ufunc computation */

                in += in_step;
                out += out_step;
            }
        }

        static void float_logit(char **args, const npy_intp *dimensions,
                               const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in = args[0], *out = args[1];
            npy_intp in_step = steps[0], out_step = steps[1];

            float tmp;

            for (i = 0; i &lt; n; i++) {
                /* BEGIN main ufunc computation */
                tmp = *(float *)in;
                tmp /= 1 - tmp;
                *((float *)out) = logf(tmp);
                /* END main ufunc computation */

                in += in_step;
                out += out_step;
            }
        }


        static void half_float_logit(char **args, const npy_intp *dimensions,
                                    const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in = args[0], *out = args[1];
            npy_intp in_step = steps[0], out_step = steps[1];

            float tmp;

            for (i = 0; i &lt; n; i++) {

                /* BEGIN main ufunc computation */
                tmp = npy_half_to_float(*(npy_half *)in);
                tmp /= 1 - tmp;
                tmp = logf(tmp);
                *((npy_half *)out) = npy_float_to_half(tmp);
                /* END main ufunc computation */

                in += in_step;
                out += out_step;
            }
        }


        /*This gives pointers to the above functions*/
        PyUFuncGenericFunction funcs[4] = {&amp;half_float_logit,
                                           &amp;float_logit,
                                           &amp;double_logit,
                                           &amp;long_double_logit};

        static char types[8] = {NPY_HALF, NPY_HALF,
                                NPY_FLOAT, NPY_FLOAT,
                                NPY_DOUBLE, NPY_DOUBLE,
                                NPY_LONGDOUBLE, NPY_LONGDOUBLE};

        static struct PyModuleDef moduledef = {
            PyModuleDef_HEAD_INIT,
            &#34;npufunc&#34;,
            NULL,
            -1,
            LogitMethods,
            NULL,
            NULL,
            NULL,
            NULL
        };

        PyMODINIT_FUNC PyInit_npufunc(void)
        {
            PyObject *m, *logit, *d;

            import_array();
            import_umath();

            m = PyModule_Create(&amp;moduledef);
            if (!m) {
                return NULL;
            }

            logit = PyUFunc_FromFuncAndData(funcs, NULL, types, 4, 1, 1,
                                            PyUFunc_None, &#34;logit&#34;,
                                            &#34;logit_docstring&#34;, 0);

            d = PyModule_GetDict(m);

            PyDict_SetItemString(d, &#34;logit&#34;, logit);
            Py_DECREF(logit);

            return m;
        }</pre>

</blockquote>

               <p>This is a         <code class='verbatim'>setup.py</code>
 file for the above code. As before, the module can be build via calling         <code class='verbatim'>python setup.py build</code>
 at the command prompt, or installed to site-packages via         <code class='verbatim'>python setup.py install</code>
.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    &#39;&#39;&#39;
            setup.py file for multi_type_logit.c
            Note that since this is a numpy extension
            we use numpy.distutils instead of
            distutils from the python standard library.

            Calling
            $python setup.py build_ext --inplace
            will build the extension library in the current file.

            Calling
            $python setup.py build
            will build a file that looks like ./build/lib*, where
            lib* is a file that begins with lib. The library will
            be in this file and end with a C library extension,
            such as .so

            Calling
            $python setup.py install
            will install the module in your site-packages file.

            See the distutils section of
            &#39;Extending and Embedding the Python Interpreter&#39;
            at docs.python.org  and the documentation
            on numpy.distutils for more information.
        &#39;&#39;&#39;


        def configuration(parent_package=&#39;&#39;, top_path=None):
            from numpy.distutils.misc_util import Configuration, get_info

            #Necessary for the half-float d-type.
            info = get_info(&#39;npymath&#39;)

            config = Configuration(&#39;npufunc_directory&#39;,
                                    parent_package,
                                    top_path)
            config.add_extension(&#39;npufunc&#39;,
                                    [&#39;multi_type_logit.c&#39;],
                                    extra_info=info)

            return config

        if __name__ == &#34;__main__&#34;:
            from numpy.distutils.core import setup
            setup(configuration=configuration)</pre>

</blockquote>

               <p>After the above has been installed, it can be imported and used as follows.</p>

               <pre>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import npufunc
&gt;&gt;&gt; npufunc.logit(0.5)
0.0
&gt;&gt;&gt; a = np.linspace(0,1,5)
&gt;&gt;&gt; npufunc.logit(a)
array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:NumPy-many-arg`:&#39;&gt;
           </pre>


<h1>Example NumPy ufunc with multiple arguments/return values</h1>
               <p>Our final example is a ufunc with multiple arguments. It is a modification of the code for a logit ufunc for data with a single dtype. We compute         <code class='verbatim'>(A * B, logit(A * B))</code>
.</p>

               <p>We only give the C code as the setup.py file is exactly the same as the         <code class='verbatim'>setup.py</code>
 file in <code class='not-implemented'>:None:None:`Example NumPy ufunc for one dtype`</code>, except that the line</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    config.add_extension(&#39;npufunc&#39;, [&#39;single_type_logit.c&#39;])</pre>

</blockquote>

               <p>is replaced with</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    config.add_extension(&#39;npufunc&#39;, [&#39;multi_arg_logit.c&#39;])</pre>

</blockquote>

               <p>The C file is given below. The ufunc generated takes two arguments         <code class='verbatim'>A</code>
 and         <code class='verbatim'>B</code>
. It returns a tuple whose first element is         <code class='verbatim'>A * B</code>
 and whose second element is         <code class='verbatim'>logit(A * B)</code>
. Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    #define PY_SSIZE_T_CLEAN
        #include &lt;Python.h&gt;
        #include &#34;numpy/ndarraytypes.h&#34;
        #include &#34;numpy/ufuncobject.h&#34;
        #include &#34;numpy/halffloat.h&#34;
        #include &lt;math.h&gt;

        /*
         * multi_arg_logit.c
         * This is the C code for creating your own
         * NumPy ufunc for a multiple argument, multiple
         * return value ufunc. The places where the
         * ufunc computation is carried out are marked
         * with comments.
         *
         * Details explaining the Python-C API can be found under
         * &#39;Extending and Embedding&#39; and &#39;Python/C API&#39; at
         * docs.python.org.
         */

        static PyMethodDef LogitMethods[] = {
            {NULL, NULL, 0, NULL}
        };

        /* The loop definition must precede the PyMODINIT_FUNC. */

        static void double_logitprod(char **args, const npy_intp *dimensions,
                                     const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp n = dimensions[0];
            char *in1 = args[0], *in2 = args[1];
            char *out1 = args[2], *out2 = args[3];
            npy_intp in1_step = steps[0], in2_step = steps[1];
            npy_intp out1_step = steps[2], out2_step = steps[3];

            double tmp;

            for (i = 0; i &lt; n; i++) {
                /* BEGIN main ufunc computation */
                tmp = *(double *)in1;
                tmp *= *(double *)in2;
                *((double *)out1) = tmp;
                *((double *)out2) = log(tmp / (1 - tmp));
                /* END main ufunc computation */

                in1 += in1_step;
                in2 += in2_step;
                out1 += out1_step;
                out2 += out2_step;
            }
        }

        /*This a pointer to the above function*/
        PyUFuncGenericFunction funcs[1] = {&amp;double_logitprod};

        /* These are the input and return dtypes of logit.*/

        static char types[4] = {NPY_DOUBLE, NPY_DOUBLE,
                                NPY_DOUBLE, NPY_DOUBLE};

        static struct PyModuleDef moduledef = {
            PyModuleDef_HEAD_INIT,
            &#34;npufunc&#34;,
            NULL,
            -1,
            LogitMethods,
            NULL,
            NULL,
            NULL,
            NULL
        };

        PyMODINIT_FUNC PyInit_npufunc(void)
        {
            PyObject *m, *logit, *d;

            import_array();
            import_umath();

            m = PyModule_Create(&amp;moduledef);
            if (!m) {
                return NULL;
            }

            logit = PyUFunc_FromFuncAndData(funcs, NULL, types, 1, 2, 2,
                                            PyUFunc_None, &#34;logit&#34;,
                                            &#34;logit_docstring&#34;, 0);

            d = PyModule_GetDict(m);

            PyDict_SetItemString(d, &#34;logit&#34;, logit);
            Py_DECREF(logit);

            return m;
        }</pre>

</blockquote>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _`sec:NumPy-struct-dtype`:&#39;&gt;
           </pre>


<h1>Example NumPy ufunc with structured array dtype arguments</h1>
               <p>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype         <code class='verbatim'>&#39;u8,u8,u8&#39;</code>
. The process is a bit different from the other examples since a call to         <code class='verbatim'>PyUFunc_FromFuncAndData</code>
 doesn&#39;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call         <code class='verbatim'>PyUFunc_RegisterLoopForDescr</code>
 to finish setting up the ufunc.</p>

               <p>We only give the C code as the         <code class='verbatim'>setup.py</code>
 file is exactly the same as the         <code class='verbatim'>setup.py</code>
 file in <code class='not-implemented'>:None:None:`Example NumPy ufunc for one dtype`</code>, except that the line</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    config.add_extension(&#39;npufunc&#39;, [&#39;single_type_logit.c&#39;])</pre>

</blockquote>

               <p>is replaced with</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: python
    config.add_extension(&#39;npufunc&#39;, [&#39;add_triplet.c&#39;])</pre>

</blockquote>

               <p>The C file is given below.</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    #define PY_SSIZE_T_CLEAN
        #include &lt;Python.h&gt;
        #include &#34;numpy/ndarraytypes.h&#34;
        #include &#34;numpy/ufuncobject.h&#34;
        #include &#34;numpy/npy_3kcompat.h&#34;
        #include &lt;math.h&gt;

        /*
         * add_triplet.c
         * This is the C code for creating your own
         * NumPy ufunc for a structured array dtype.
         *
         * Details explaining the Python-C API can be found under
         * &#39;Extending and Embedding&#39; and &#39;Python/C API&#39; at
         * docs.python.org.
         */

        static PyMethodDef StructUfuncTestMethods[] = {
            {NULL, NULL, 0, NULL}
        };

        /* The loop definition must precede the PyMODINIT_FUNC. */

        static void add_uint64_triplet(char **args, const npy_intp *dimensions,
                                       const npy_intp *steps, void *data)
        {
            npy_intp i;
            npy_intp is1 = steps[0];
            npy_intp is2 = steps[1];
            npy_intp os = steps[2];
            npy_intp n = dimensions[0];
            uint64_t *x, *y, *z;

            char *i1 = args[0];
            char *i2 = args[1];
            char *op = args[2];

            for (i = 0; i &lt; n; i++) {

                x = (uint64_t *)i1;
                y = (uint64_t *)i2;
                z = (uint64_t *)op;

                z[0] = x[0] + y[0];
                z[1] = x[1] + y[1];
                z[2] = x[2] + y[2];

                i1 += is1;
                i2 += is2;
                op += os;
            }
        }

        /* This a pointer to the above function */
        PyUFuncGenericFunction funcs[1] = {&amp;add_uint64_triplet};

        /* These are the input and return dtypes of add_uint64_triplet. */
        static char types[3] = {NPY_UINT64, NPY_UINT64, NPY_UINT64};

        static struct PyModuleDef moduledef = {
            PyModuleDef_HEAD_INIT,
            &#34;struct_ufunc_test&#34;,
            NULL,
            -1,
            StructUfuncTestMethods,
            NULL,
            NULL,
            NULL,
            NULL
        };

        PyMODINIT_FUNC PyInit_struct_ufunc_test(void)
        {
            PyObject *m, *add_triplet, *d;
            PyObject *dtype_dict;
            PyArray_Descr *dtype;
            PyArray_Descr *dtypes[3];

            import_array();
            import_umath();

            m = PyModule_Create(&amp;moduledef);
            if (m == NULL) {
                return NULL;
            }

            /* Create a new ufunc object */
            add_triplet = PyUFunc_FromFuncAndData(NULL, NULL, NULL, 0, 2, 1,
                                                  PyUFunc_None, &#34;add_triplet&#34;,
                                                  &#34;add_triplet_docstring&#34;, 0);

            dtype_dict = Py_BuildValue(&#34;[(s, s), (s, s), (s, s)]&#34;,
                                       &#34;f0&#34;, &#34;u8&#34;, &#34;f1&#34;, &#34;u8&#34;, &#34;f2&#34;, &#34;u8&#34;);
            PyArray_DescrConverter(dtype_dict, &amp;dtype);
            Py_DECREF(dtype_dict);

            dtypes[0] = dtype;
            dtypes[1] = dtype;
            dtypes[2] = dtype;

            /* Register ufunc for structured dtype */
            PyUFunc_RegisterLoopForDescr(add_triplet,
                                         dtype,
                                         &amp;add_uint64_triplet,
                                         dtypes,
                                         NULL);

            d = PyModule_GetDict(m);

            PyDict_SetItemString(d, &#34;add_triplet&#34;, add_triplet);
            Py_DECREF(add_triplet);
            return m;
        }</pre>

</blockquote>

               <pre class='not-implemented'>
.. index:: 
    pair: ufunc; adding new</pre>


               <p>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</p>

                           <blockquote><pre class='not-implemented'>
.. code-block:: c
    static PyUFuncGenericFunction atan2_functions[] = {
                              PyUFunc_ff_f, PyUFunc_dd_d,
                              PyUFunc_gg_g, PyUFunc_OO_O_method};
        static void *atan2_data[] = {
                              (void *)atan2f, (void *)atan2,
                              (void *)atan2l, (void *)&#34;arctan2&#34;};
        static char atan2_signatures[] = {
                      NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
                      NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
                      NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE
                      NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
        ...
        /* in the module initialization code */
        PyObject *f, *dict, *module;
        ...
        dict = PyModule_GetDict(module);
        ...
        f = PyUFunc_FromFuncAndData(atan2_functions,
            atan2_data, atan2_signatures, 4, 2, 1,
            PyUFunc_None, &#34;arctan2&#34;,
            &#34;a safe and correct arctan(x1/x2)&#34;, 0);
        PyDict_SetItemString(dict, &#34;arctan2&#34;, f);
        Py_DECREF(f);
        ...</pre>

</blockquote>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
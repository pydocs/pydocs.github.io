<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. currentmodule:: numpy
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.ndarray:&#39;&gt;
           </pre>


<h1>The N-dimensional array (:class:`ndarray`)</h1>
               <p>An         <code class='verbatim'>ndarray</code>
 is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its         <code class='verbatim'>shape &lt;ndarray.shape&gt;</code>
, which is a         <code class='verbatim'>tuple</code>
 of <em>N</em> non-negative integers that specify the sizes of each dimension. The type of items in the array is specified by a separate         <code class='verbatim'>data-type object (dtype) &lt;arrays.dtypes&gt;</code>
, one of which is associated with each ndarray.</p>

               <p>As with other container objects in Python, the contents of an         <code class='verbatim'>ndarray</code>
 can be accessed and modified by         <code class='verbatim'>indexing or
slicing &lt;arrays.indexing&gt;</code>
 the array (using, for example, <em>N</em> integers), and via the methods and attributes of the         <code class='verbatim'>ndarray</code>
.</p>

               <pre class='not-implemented'>
.. index:: view, base
    </pre>


               <p>Different         <code class='verbatim'>ndarrays &lt;ndarray&gt;</code>
 can share the same data, so that changes made in one         <code class='verbatim'>ndarray</code>
 may be visible in another. That is, an ndarray can be a <em>&#34;view&#34;</em> to another ndarray, and the data it is referring to is taken care of by the <em>&#34;base&#34;</em> ndarray. ndarrays can also be views to memory owned by Python         <code class='verbatim'>strings &lt;str&gt;</code>
 or objects implementing the         <code class='verbatim'>buffer</code>
 or         <code class='verbatim'>array
&lt;arrays.interface&gt;</code>
 interfaces.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    A 2-dimensional array of size 2 x 3, composed of 4-byte integer
    elements:

    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
    &gt;&gt;&gt; type(x)
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; x.shape
    (2, 3)
    &gt;&gt;&gt; x.dtype
    dtype(&#39;int32&#39;)

    The array can be indexed using Python container-like syntax:

    &gt;&gt;&gt; # The element of x in the *second* row, *third* column, namely, 6.
    &gt;&gt;&gt; x[1, 2]
    6

    For example :ref:`slicing &lt;arrays.indexing&gt;` can produce views of
    the array:

    &gt;&gt;&gt; y = x[:,1]
    &gt;&gt;&gt; y
    array([2, 5], dtype=int32)
    &gt;&gt;&gt; y[0] = 9 # this also changes the corresponding element in x
    &gt;&gt;&gt; y
    array([9, 5], dtype=int32)
    &gt;&gt;&gt; x
    array([[1, 9, 3],
           [4, 5, 6]], dtype=int32)</pre>



<h1>Constructing arrays</h1>
               <p>New arrays can be constructed using the routines detailed in         <code class='verbatim'>routines.array-creation</code>
, and also by using the low-level         <code class='verbatim'>ndarray</code>
 constructor:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.ndarray.indexing:&#39;&gt;
           </pre>


<h1>Indexing arrays</h1>
               <p>Arrays can be indexed using an extended Python slicing syntax,         <code class='verbatim'>array[selection]</code>
.  Similar syntax is also used for accessing fields in a         <code class='verbatim'>structured data type</code>
.</p>

               <pre class='not-implemented'>
.. seealso:: :ref:`Array Indexing &lt;arrays.indexing&gt;`.
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _memory-layout:&#39;&gt;
           </pre>


<h1>Internal memory layout of an ndarray</h1>
               <p>An instance of class         <code class='verbatim'>ndarray</code>
 consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps <em>N</em> integers into the location of an item in the block.  The ranges in which the indices can vary is specified by the         <code class='verbatim'>shape
&lt;ndarray.shape&gt;</code>
 of the array. How many bytes each item takes and how the bytes are interpreted is defined by the         <code class='verbatim'>data-type object
&lt;arrays.dtypes&gt;</code>
 associated with the array.</p>

               <pre class='not-implemented'>
.. index:: C-order, Fortran-order, row-major, column-major, stride,
    offset</pre>


               <p>A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an <em>N</em>-dimensional array in a 1-dimensional block. NumPy is flexible, and         <code class='verbatim'>ndarray</code>
 objects can accommodate any <em>strided indexing scheme</em>. In a strided scheme, the N-dimensional index         <span class="tex2jax_process">$(n_0, n_1, ..., n_{N-1})$</span>
 corresponds to the offset (in bytes):</p>

                       <span class="tex2jax_process">$$n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k$$</span>

               <p>from the beginning of the memory block associated with the array. Here,         <span class="tex2jax_process">$s_k$</span>
 are integers which specify the         <code class='verbatim'>strides
&lt;ndarray.strides&gt;</code>
 of the array. The         <code class='verbatim'>column-major</code>
 order (used, for example, in the Fortran language and in <em>Matlab</em>) and         <code class='verbatim'>row-major</code>
 order (used in C) schemes are just specific kinds of strided scheme, and correspond to memory that can be <em>addressed</em> by the strides:</p>

                       <span class="tex2jax_process">$$s_k^{\mathrm{column}} = \mathrm{itemsize} \prod_{j=0}^{k-1} d_j ,
\quad  s_k^{\mathrm{row}} = \mathrm{itemsize} \prod_{j=k+1}^{N-1} d_j .$$</span>

               <pre class='not-implemented'>
.. index:: single-segment, contiguous, non-contiguous
    </pre>


               <p>where         <span class="tex2jax_process">$d_j$</span>
 <code>:None:None:`= self.shape[j]`</code>.</p>

               <p>Both the C and Fortran orders are         <code class='verbatim'>contiguous</code>
, <em>i.e.,</em> single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</p>

                           <div class='admonition'>
    <div>note</div>
        <p><code>:None:None:`Contiguous arrays`</code> and <code>:None:None:`single-segment arrays`</code> are synonymous and are used interchangeably throughout the documentation.</p>

</div>


               <p>While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:</p>

                           <pre>1. If ``self.shape[k] == 1`` then for any legal index ``index[k] == 0``.
   This means that in the formula for the offset :math:`n_k = 0` and thus
   :math:`s_k n_k = 0` and the value of :math:`s_k` `= self.strides[k]` is
   arbitrary.
2. If an array has no elements (``self.size == 0``) there is no legal
   index and the strides are never used. Any array with no elements may be
   considered C-style and Fortran-style contiguous.
</pre>

               <p>Point 1. means that         <code class='verbatim'>self</code>
 and         <code class='verbatim'>self.squeeze()</code>
 always have the same contiguity and         <code class='verbatim'>aligned</code>
 flags value. This also means that even a high dimensional array could be C-style and Fortran-style contiguous at the same time.</p>

               <pre class='not-implemented'>
.. index:: aligned
    </pre>


               <p>An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of <code>:None:None:`self.itemsize`</code>. Understanding <code>:None:None:`memory-alignment`</code> leads to better performance on most hardware.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>It does <em>not</em> generally hold that         <code class='verbatim'>self.strides[-1] == self.itemsize</code>
 for C-style contiguous arrays or         <code class='verbatim'>self.strides[0] == self.itemsize</code>
 for Fortran-style contiguous arrays is true.</p>

        <p>        <code class='verbatim'>NPY_RELAXED_STRIDES_DEBUG=1</code>
 can be used to help find errors when incorrectly relying on the strides in C-extension code (see below warning).</p>

</div>



<h1>Data in new :class:`ndarrays &lt;ndarray&gt;` is in the :term:`row-major`</h1>
                          <ol>               <li>               <p>order, unless otherwise specified, but, for example,  array slicing &lt;arrays.indexing&gt;` often produces         <code class='verbatim'>views &lt;view&gt;</code>
</p>

</li>
            </ol>

               <p>in a different scheme.</p>

                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;.. seealso: :ref:`Indexing &lt;arrays.ndarray.indexing&gt;`_&#39;
   |&gt;
           </pre>

                           <div class='admonition'>
    <div>note</div>
        <p>Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.</p>

</div>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.ndarray.attributes:&#39;&gt;
           </pre>


<h1>Array attributes</h1>
               <p>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</p>


<h1>Memory layout</h1>
               <p>The following attributes contain information about the memory layout of the array:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.flags
    ndarray.shape
    ndarray.strides
    ndarray.ndim
    ndarray.data
    ndarray.size
    ndarray.itemsize
    ndarray.nbytes
    ndarray.base</pre>

<h1>Data type</h1>
               <pre class='not-implemented'>
.. seealso:: :ref:`Data type objects &lt;arrays.dtypes&gt;`
    </pre>


               <p>The data type object associated with the array can be found in the         <code class='verbatim'>dtype &lt;ndarray.dtype&gt;</code>
 attribute:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.dtype</pre>

<h1>Other attributes</h1>
               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.T
    ndarray.real
    ndarray.imag
    ndarray.flat</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.ndarray.array-interface:&#39;&gt;
           </pre>


<h1>Array interface</h1>
               <pre class='not-implemented'>
.. seealso:: :ref:`arrays.interface`.
    </pre>


               <p>==================================  ===================================         <code class='verbatim'>~object.__array_interface__</code>
  Python-side of the array interface         <code class='verbatim'>~object.__array_struct__</code>
     C-side of the array interface ==================================  ===================================</p>


<h1>:mod:`ctypes` foreign function interface</h1>
               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.ctypes</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array.ndarray.methods:&#39;&gt;
           </pre>


<h1>Array methods</h1>
               <p>An         <code class='verbatim'>ndarray</code>
 object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method&#39;s docstring has a more complete description.)</p>

               <p>For the following methods there are also corresponding functions in         <code class='verbatim'>numpy</code>
:         <code class='verbatim'>all</code>
,         <code class='verbatim'>any</code>
,         <code class='verbatim'>argmax</code>
,         <code class='verbatim'>argmin</code>
,         <code class='verbatim'>argpartition</code>
,         <code class='verbatim'>argsort</code>
,         <code class='verbatim'>choose</code>
,         <code class='verbatim'>clip</code>
,         <code class='verbatim'>compress</code>
,         <code class='verbatim'>copy</code>
,         <code class='verbatim'>cumprod</code>
,         <code class='verbatim'>cumsum</code>
,         <code class='verbatim'>diagonal</code>
,         <code class='verbatim'>imag</code>
,         <code class='verbatim'>max &lt;amax&gt;</code>
,         <code class='verbatim'>mean</code>
,         <code class='verbatim'>min &lt;amin&gt;</code>
,         <code class='verbatim'>nonzero</code>
,         <code class='verbatim'>partition</code>
,         <code class='verbatim'>prod</code>
,         <code class='verbatim'>ptp</code>
,         <code class='verbatim'>put</code>
,         <code class='verbatim'>ravel</code>
,         <code class='verbatim'>real</code>
,         <code class='verbatim'>repeat</code>
,         <code class='verbatim'>reshape</code>
,         <code class='verbatim'>round &lt;around&gt;</code>
,         <code class='verbatim'>searchsorted</code>
,         <code class='verbatim'>sort</code>
,         <code class='verbatim'>squeeze</code>
,         <code class='verbatim'>std</code>
,         <code class='verbatim'>sum</code>
,         <code class='verbatim'>swapaxes</code>
,         <code class='verbatim'>take</code>
,         <code class='verbatim'>trace</code>
,         <code class='verbatim'>transpose</code>
,         <code class='verbatim'>var</code>
.</p>


<h1>Array conversion</h1>
               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.item
    ndarray.tolist
    ndarray.itemset
    ndarray.tostring
    ndarray.tobytes
    ndarray.tofile
    ndarray.dump
    ndarray.dumps
    ndarray.astype
    ndarray.byteswap
    ndarray.copy
    ndarray.view
    ndarray.getfield
    ndarray.setflags
    ndarray.fill</pre>

<h1>Shape manipulation</h1>
               <p>For reshape, resize, and transpose, the single tuple argument may be replaced with         <code class='verbatim'>n</code>
 integers which will be interpreted as an n-tuple.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.reshape
    ndarray.resize
    ndarray.transpose
    ndarray.swapaxes
    ndarray.flatten
    ndarray.ravel
    ndarray.squeeze</pre>

<h1>Item selection and manipulation</h1>
               <p>For array methods that take an <em>axis</em> keyword, it defaults to <em>None</em>. If axis is <em>None</em>, then the array is treated as a 1-D array. Any other value for <em>axis</em> represents the dimension along which the operation should proceed.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.take
    ndarray.put
    ndarray.repeat
    ndarray.choose
    ndarray.sort
    ndarray.argsort
    ndarray.partition
    ndarray.argpartition
    ndarray.searchsorted
    ndarray.nonzero
    ndarray.compress
    ndarray.diagonal</pre>

<h1>Calculation</h1>
               <pre class='not-implemented'>
.. index:: axis
    </pre>


               <p>Many of these methods take an argument named <em>axis</em>. In such cases,</p>

                          <ul>               <li>               <p>If <em>axis</em> is <em>None</em> (the default), the array is treated as a 1-D   array and the operation is performed over the entire array. This   behavior is also the default if self is a 0-dimensional array or   array scalar. (An array scalar is an instance of the types/classes   float32, float64, etc., whereas a 0-dimensional array is an ndarray   instance containing precisely one array scalar.)</p>

</li>
            </ul>

                          <ul>               <li>               <p>If <em>axis</em> is an integer, then the operation is done over the given   axis (for each 1-D subarray that can be created along the given axis).</p>

</li>
            </ul>

               <pre class='not-implemented'>
.. admonition:: Example of the *axis* argument
    A 3-dimensional array of size 3 x 3 x 3, summed over each of its
    three axes

    &gt;&gt;&gt; x = np.arange(27).reshape((3,3,3))
    &gt;&gt;&gt; x
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8]],
           [[ 9, 10, 11],
            [12, 13, 14],
            [15, 16, 17]],
           [[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]])
    &gt;&gt;&gt; x.sum(axis=0)
    array([[27, 30, 33],
           [36, 39, 42],
           [45, 48, 51]])
    &gt;&gt;&gt; # for sum, axis is the first keyword, so we may omit it,
    &gt;&gt;&gt; # specifying only its value
    &gt;&gt;&gt; x.sum(0), x.sum(1), x.sum(2)
    (array([[27, 30, 33],
            [36, 39, 42],
            [45, 48, 51]]),
     array([[ 9, 12, 15],
            [36, 39, 42],
            [63, 66, 69]]),
     array([[ 3, 12, 21],
            [30, 39, 48],
            [57, 66, 75]]))</pre>


               <p>The parameter <em>dtype</em> specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of <em>self</em>. To avoid overflow, it can be useful to perform the reduction using a larger data type.</p>

               <p>For several methods, an optional <em>out</em> argument can also be provided and the result will be placed into the output array given. The <em>out</em> argument must be an         <code class='verbatim'>ndarray</code>
 and have the same number of elements. It can have a different data type in which case casting will be performed.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.max
    ndarray.argmax
    ndarray.min
    ndarray.argmin
    ndarray.ptp
    ndarray.clip
    ndarray.conj
    ndarray.round
    ndarray.trace
    ndarray.sum
    ndarray.cumsum
    ndarray.mean
    ndarray.var
    ndarray.std
    ndarray.prod
    ndarray.cumprod
    ndarray.all
    ndarray.any</pre>

<h1>Arithmetic, matrix multiplication, and comparison operations</h1>
               <pre class='not-implemented'>
.. index:: comparison, arithmetic, matrix, operation, operator
    </pre>


               <p>Arithmetic and comparison operations on         <code class='verbatim'>ndarrays &lt;ndarray&gt;</code>
 are defined as element-wise operations, and generally yield         <code class='verbatim'>ndarray</code>
 objects as results.</p>

               <p>Each of the arithmetic operations (        <code class='verbatim'>+</code>
,         <code class='verbatim'>-</code>
,         <code class='verbatim'>*</code>
,         <code class='verbatim'>/</code>
,         <code class='verbatim'>//</code>
,         <code class='verbatim'>%</code>
,         <code class='verbatim'>divmod()</code>
,         <code class='verbatim'>**</code>
 or         <code class='verbatim'>pow()</code>
,         <code class='verbatim'>&lt;&lt;</code>
,         <code class='verbatim'>&gt;&gt;</code>
,         <code class='verbatim'>&amp;</code>
,         <code class='verbatim'>^</code>
,         <code class='verbatim'>|</code>
,         <code class='verbatim'>~</code>
) and the comparisons (        <code class='verbatim'>==</code>
,         <code class='verbatim'>&lt;</code>
,         <code class='verbatim'>&gt;</code>
,         <code class='verbatim'>&lt;=</code>
,         <code class='verbatim'>&gt;=</code>
,         <code class='verbatim'>!=</code>
) is equivalent to the corresponding universal function (or         <code class='verbatim'>ufunc</code>
 for short) in NumPy.  For more information, see the section on         <code class='verbatim'>Universal Functions
&lt;ufuncs&gt;</code>
.</p>

               <p>Comparison operators:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__lt__
    ndarray.__le__
    ndarray.__gt__
    ndarray.__ge__
    ndarray.__eq__
    ndarray.__ne__</pre>
               <p>Truth value of an array (        <code class='verbatim'>bool() &lt;bool&gt;</code>
):</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__bool__</pre>
                           <div class='admonition'>
    <div>note</div>
        <p>Truth-value testing of an array invokes <code>:None:meth:`ndarray.__bool__`</code>, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use <code>:None:meth:`.any() &lt;ndarray.any&gt;`</code> and <code>:None:meth:`.all() &lt;ndarray.all&gt;`</code> instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to         <code class='verbatim'>False</code>
.)</p>

</div>


               <p>Unary operations:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__neg__
    ndarray.__pos__
    ndarray.__abs__
    ndarray.__invert__</pre>
               <p>Arithmetic:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__add__
    ndarray.__sub__
    ndarray.__mul__
    ndarray.__truediv__
    ndarray.__floordiv__
    ndarray.__mod__
    ndarray.__divmod__
    ndarray.__pow__
    ndarray.__lshift__
    ndarray.__rshift__
    ndarray.__and__
    ndarray.__or__
    ndarray.__xor__</pre>
                           <div class='admonition'>
    <div>note</div>
                   <ul>               <li>               <p>Any third argument to <code>:None:func:`pow()`</code> is silently ignored,   as the underlying <code>:None:func:`ufunc &lt;power&gt;`</code> takes only two arguments.</p>

</li>
            </ul>

                   <ul>               <li>               <p>Because <code>:None:class:`ndarray`</code> is a built-in type (written in C), the           <code class='verbatim'>__r{op}__</code>
 special methods are not directly defined.</p>

</li>
            </ul>

                   <ul>               <li>               <p>The functions called to implement many arithmetic special methods   for arrays can be modified using <code>:None:class:`__array_ufunc__ &lt;numpy.class.__array_ufunc__&gt;`</code>.</p>

</li>
            </ul>

</div>


               <p>Arithmetic, in-place:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__iadd__
    ndarray.__isub__
    ndarray.__imul__
    ndarray.__itruediv__
    ndarray.__ifloordiv__
    ndarray.__imod__
    ndarray.__ipow__
    ndarray.__ilshift__
    ndarray.__irshift__
    ndarray.__iand__
    ndarray.__ior__
    ndarray.__ixor__</pre>
                           <div class='admonition'>
    <div>warning</div>
        <p>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array.  Therefore, for mixed precision calculations,         <code class='verbatim'>A {op}=
B</code>
 can be different than         <code class='verbatim'>A = A {op} B</code>
. For example, suppose         <code class='verbatim'>a = ones((3,3))</code>
. Then,         <code class='verbatim'>a += 3j</code>
 is different than         <code class='verbatim'>a = a +
3j</code>
: while they both perform the same computation,         <code class='verbatim'>a += 3</code>
 casts the result to fit back in         <code class='verbatim'>a</code>
, whereas         <code class='verbatim'>a = a + 3j</code>
 re-binds the name         <code class='verbatim'>a</code>
 to the result.</p>

</div>


               <p>Matrix Multiplication:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__matmul__</pre>
                           <div class='admonition'>
    <div>note</div>
        <p>Matrix operators         <code class='verbatim'>@</code>
 and         <code class='verbatim'>@=</code>
 were introduced in Python 3.5 following <code>:None:pep:`465`</code>, and the         <code class='verbatim'>@</code>
 operator has been introduced in NumPy 1.10.0. Further information can be found in the <code>:None:func:`matmul`</code> documentation.</p>

</div>



<h1>Special methods</h1>
               <p>For standard library functions:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__copy__
    ndarray.__deepcopy__
    ndarray.__reduce__
    ndarray.__setstate__</pre>
               <p>Basic customization:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__new__
    ndarray.__array__
    ndarray.__array_wrap__</pre>
               <p>Container customization: (see         <code class='verbatim'>Indexing &lt;arrays.indexing&gt;</code>
)</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__len__
    ndarray.__getitem__
    ndarray.__setitem__
    ndarray.__contains__</pre>
               <p>Conversion; the operations         <code class='verbatim'>int() &lt;int&gt;</code>
,         <code class='verbatim'>float() &lt;float&gt;</code>
 and         <code class='verbatim'>complex() &lt;complex&gt;</code>
. They work only on arrays that have one element in them and return the appropriate scalar.</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__int__
    ndarray.__float__
    ndarray.__complex__</pre>
               <p>String representations:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__str__
    ndarray.__repr__</pre>
               <p>Utility method for typing:</p>

               <pre>.. autosummary:: 
    :toctree:generated/
    ndarray.__class_getitem__</pre>

<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Glossary</h1>
               <pre class='not-implemented'>
.. glossary:: 
    (`n`,)
        A parenthesized number followed by a comma denotes a tuple with one
        element. The trailing comma distinguishes a one-element tuple from a
        parenthesized ``n``.


    -1
        - **In a dimension entry**, instructs NumPy to choose the length
          that will keep the total number of array elements the same.

            &gt;&gt;&gt; np.arange(12).reshape(4, -1).shape
            (4, 3)

        - **In an index**, any negative value
          `denotes &lt;https://docs.python.org/dev/faq/programming.html#what-s-a-negative-index&gt;`_
          indexing from the right.

    . . .
        An :py:data:`Ellipsis`.

        - **When indexing an array**, shorthand that the missing axes, if they
          exist, are full slices.

            &gt;&gt;&gt; a = np.arange(24).reshape(2,3,4)

            &gt;&gt;&gt; a[...].shape
            (2, 3, 4)

            &gt;&gt;&gt; a[...,0].shape
            (2, 3)

            &gt;&gt;&gt; a[0,...].shape
            (3, 4)

            &gt;&gt;&gt; a[0,...,0].shape
            (3,)

          It can be used at most once; ``a[...,0,...]`` raises an :exc:`IndexError`.

        - **In printouts**, NumPy substitutes ``...`` for the middle elements of
          large arrays. To see the entire array, use `numpy.printoptions`


    :
        The Python :term:`python:slice`
        operator. In ndarrays, slicing can be applied to every
        axis:

            &gt;&gt;&gt; a = np.arange(24).reshape(2,3,4)
            &gt;&gt;&gt; a
            array([[[ 0,  1,  2,  3],
                    [ 4,  5,  6,  7],
                    [ 8,  9, 10, 11]],
            &lt;BLANKLINE&gt;
                   [[12, 13, 14, 15],
                    [16, 17, 18, 19],
                    [20, 21, 22, 23]]])
            &lt;BLANKLINE&gt;
            &gt;&gt;&gt; a[1:,-2:,:-1]
            array([[[16, 17, 18],
                    [20, 21, 22]]])

        Trailing slices can be omitted: ::

            &gt;&gt;&gt; a[1] == a[1,:,:]
            array([[ True,  True,  True,  True],
                   [ True,  True,  True,  True],
                   [ True,  True,  True,  True]])

        In contrast to Python, where slicing creates a copy, in NumPy slicing
        creates a :term:`view`.

        For details, see :ref:`combining-advanced-and-basic-indexing`.


    &lt;
        In a dtype declaration, indicates that the data is
        :term:`little-endian` (the bracket is big on the right). ::

            &gt;&gt;&gt; dt = np.dtype(&#39;&lt;f&#39;)  # little-endian single-precision float


    &gt;
        In a dtype declaration, indicates that the data is
        :term:`big-endian` (the bracket is big on the left). ::

            &gt;&gt;&gt; dt = np.dtype(&#39;&gt;H&#39;)  # big-endian unsigned short


    advanced indexing
        Rather than using a :doc:`scalar &lt;reference/arrays.scalars&gt;` or slice as
        an index, an axis can be indexed with an array, providing fine-grained
        selection. This is known as :ref:`advanced indexing&lt;advanced-indexing&gt;`
        or &#34;fancy indexing&#34;.


    along an axis
        An operation `along axis n` of array ``a`` behaves as if its argument
        were an array of slices of ``a`` where each slice has a successive
        index of axis `n`.

        For example, if ``a`` is a 3 x `N` array, an operation along axis 0
        behaves as if its argument were an array containing slices of each row:

            &gt;&gt;&gt; np.array((a[0,:], a[1,:], a[2,:])) #doctest: +SKIP

        To make it concrete, we can pick the operation to be the array-reversal
        function :func:`numpy.flip`, which accepts an ``axis`` argument. We
        construct a 3 x 4 array ``a``:

            &gt;&gt;&gt; a = np.arange(12).reshape(3,4)
            &gt;&gt;&gt; a
            array([[ 0,  1,  2,  3],
                   [ 4,  5,  6,  7],
                   [ 8,  9, 10, 11]])

        Reversing along axis 0 (the row axis) yields

            &gt;&gt;&gt; np.flip(a,axis=0)
            array([[ 8,  9, 10, 11],
                   [ 4,  5,  6,  7],
                   [ 0,  1,  2,  3]])

        Recalling the definition of `along an axis`,  ``flip`` along axis 0 is
        treating its argument as if it were

            &gt;&gt;&gt; np.array((a[0,:], a[1,:], a[2,:]))
            array([[ 0,  1,  2,  3],
                   [ 4,  5,  6,  7],
                   [ 8,  9, 10, 11]])

        and the result of ``np.flip(a,axis=0)`` is to reverse the slices:

            &gt;&gt;&gt; np.array((a[2,:],a[1,:],a[0,:]))
            array([[ 8,  9, 10, 11],
                   [ 4,  5,  6,  7],
                   [ 0,  1,  2,  3]])


    array
        Used synonymously in the NumPy docs with :term:`ndarray`.


    array_like
        Any :doc:`scalar &lt;reference/arrays.scalars&gt;` or
        :term:`python:sequence`
        that can be interpreted as an ndarray.  In addition to ndarrays
        and scalars this category includes lists (possibly nested and with
        different element types) and tuples. Any argument accepted by
        :doc:`numpy.array &lt;reference/generated/numpy.array&gt;`
        is array_like. ::

            &gt;&gt;&gt; a = np.array([[1, 2.0], [0, 0], (1+1j, 3.)])

            &gt;&gt;&gt; a
            array([[1.+0.j, 2.+0.j],
                   [0.+0.j, 0.+0.j],
                   [1.+1.j, 3.+0.j]])


    array scalar
        An :doc:`array scalar &lt;reference/arrays.scalars&gt;` is an instance of the types/classes float32, float64,
        etc.. For uniformity in handling operands, NumPy treats a scalar as
        an array of zero dimension. In contrast, a 0-dimensional array is an :doc:`ndarray &lt;reference/arrays.ndarray&gt;` instance
        containing precisely one value.


    axis
        Another term for an array dimension. Axes are numbered left to right;
        axis 0 is the first element in the shape tuple.

        In a two-dimensional vector, the elements of axis 0 are rows and the
        elements of axis 1 are columns.

        In higher dimensions, the picture changes. NumPy prints
        higher-dimensional vectors as replications of row-by-column building
        blocks, as in this three-dimensional vector:

            &gt;&gt;&gt; a = np.arange(12).reshape(2,2,3)
            &gt;&gt;&gt; a
            array([[[ 0,  1,  2],
                    [ 3,  4,  5]],
                   [[ 6,  7,  8],
                    [ 9, 10, 11]]])

        ``a`` is depicted as a two-element array whose elements are 2x3 vectors.
        From this point of view, rows and columns are the final two axes,
        respectively, in any shape.

        This rule helps you anticipate how a vector will be printed, and
        conversely how to find the index of any of the printed elements. For
        instance, in the example, the last two values of 8&#39;s index must be 0 and
        2. Since 8 appears in the second of the two 2x3&#39;s, the first index must
        be 1:

            &gt;&gt;&gt; a[1,0,2]
            8

        A convenient way to count dimensions in a printed vector is to
        count ``[`` symbols after the open-parenthesis. This is
        useful in distinguishing, say, a (1,2,3) shape from a (2,3) shape:

            &gt;&gt;&gt; a = np.arange(6).reshape(2,3)
            &gt;&gt;&gt; a.ndim
            2
            &gt;&gt;&gt; a
            array([[0, 1, 2],
                   [3, 4, 5]])

            &gt;&gt;&gt; a = np.arange(6).reshape(1,2,3)
            &gt;&gt;&gt; a.ndim
            3
            &gt;&gt;&gt; a
            array([[[0, 1, 2],
                    [3, 4, 5]]])


    .base

        If an array does not own its memory, then its
        :doc:`base &lt;reference/generated/numpy.ndarray.base&gt;` attribute returns
        the object whose memory the array is referencing. That object may be
        referencing the memory from still another object, so the owning object
        may be ``a.base.base.base...``. Some writers erroneously claim that
        testing ``base`` determines if arrays are :term:`view`\ s. For the
        correct way, see :func:`numpy.shares_memory`.


    big-endian
        See `Endianness &lt;https://en.wikipedia.org/wiki/Endianness&gt;`_.


    BLAS
        `Basic Linear Algebra Subprograms &lt;https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms&gt;`_


    broadcast
        *broadcasting* is NumPy&#39;s ability to process ndarrays of
        different sizes as if all were the same size.

        It permits an elegant do-what-I-mean behavior where, for instance,
        adding a scalar to a vector adds the scalar value to every element.

            &gt;&gt;&gt; a = np.arange(3)
            &gt;&gt;&gt; a
            array([0, 1, 2])

            &gt;&gt;&gt; a + [3, 3, 3]
            array([3, 4, 5])

            &gt;&gt;&gt; a + 3
            array([3, 4, 5])

        Ordinarly, vector operands must all be the same size, because NumPy
        works element by element -- for instance, ``c = a * b`` is ::

            c[0,0,0] = a[0,0,0] * b[0,0,0]
            c[0,0,1] = a[0,0,1] * b[0,0,1]
           ...

        But in certain useful cases, NumPy can duplicate data along &#34;missing&#34;
        axes or &#34;too-short&#34; dimensions so shapes will match. The duplication
        costs no memory or time. For details, see
        :doc:`Broadcasting. &lt;user/basics.broadcasting&gt;`


    C order
        Same as :term:`row-major`.


    column-major
        See `Row- and column-major order &lt;https://en.wikipedia.org/wiki/Row-_and_column-major_order&gt;`_.


    contiguous

        An array is contiguous if:

        - it occupies an unbroken block of memory, and
        - array elements with higher indexes occupy higher addresses (that
          is, no :term:`stride` is negative).

        There are two types of proper-contiguous NumPy arrays:

        - Fortran-contiguous arrays refer to data that is stored column-wise,
          i.e. the indexing of data as stored in memory starts from the
          lowest dimension;
        - C-contiguous, or simply contiguous arrays, refer to data that is
          stored row-wise, i.e. the indexing of data as stored in memory
          starts from the highest dimension.

        For one-dimensional arrays these notions coincide.

        For example, a 2x2 array ``A`` is Fortran-contiguous if its elements are
        stored in memory in the following order::

            A[0,0] A[1,0] A[0,1] A[1,1]

        and C-contiguous if the order is as follows::

            A[0,0] A[0,1] A[1,0] A[1,1]

        To test whether an array is C-contiguous, use the ``.flags.c_contiguous``
        attribute of NumPy arrays.  To test for Fortran contiguity, use the
        ``.flags.f_contiguous`` attribute.


    copy
        See :term:`view`.


    dimension
        See :term:`axis`.


    dtype
        The datatype describing the (identically typed) elements in an ndarray.
        It can be changed to reinterpret the array contents. For details, see
        :doc:`Data type objects (dtype). &lt;reference/arrays.dtypes&gt;`


    fancy indexing
        Another term for :term:`advanced indexing`.


    field
        In a :term:`structured data type`, each subtype is called a `field`.
        The `field` has a name (a string), a type (any valid dtype), and
        an optional `title`. See :ref:`arrays.dtypes`.


    Fortran order
        Same as :term:`column-major`.


    flattened
        See :term:`ravel`.


    homogeneous
        All elements of a homogeneous array have the same type. ndarrays, in
        contrast to Python lists, are homogeneous. The type can be complicated,
        as in a :term:`structured array`, but all elements have that type.

        NumPy `object arrays &lt;#term-object-array&gt;`_, which contain references to
        Python objects, fill the role of heterogeneous arrays.


    itemsize
        The size of the dtype element in bytes.


    little-endian
        See `Endianness &lt;https://en.wikipedia.org/wiki/Endianness&gt;`_.


    mask
        A boolean array used to select only certain elements for an operation:

            &gt;&gt;&gt; x = np.arange(5)
            &gt;&gt;&gt; x
            array([0, 1, 2, 3, 4])

            &gt;&gt;&gt; mask = (x &gt; 2)
            &gt;&gt;&gt; mask
            array([False, False, False, True,  True])

            &gt;&gt;&gt; x[mask] = -1
            &gt;&gt;&gt; x
            array([ 0,  1,  2,  -1, -1])


    masked array
        Bad or missing data can be cleanly ignored by putting it in a masked
        array, which has an internal boolean array indicating invalid
        entries. Operations with masked arrays ignore these entries. ::

          &gt;&gt;&gt; a = np.ma.masked_array([np.nan, 2, np.nan], [True, False, True])
          &gt;&gt;&gt; a
          masked_array(data=[--, 2.0, --],
                       mask=[ True, False,  True],
                 fill_value=1e+20)

          &gt;&gt;&gt; a + [1, 2, 3]
          masked_array(data=[--, 4.0, --],
                       mask=[ True, False,  True],
                 fill_value=1e+20)

        For details, see :doc:`Masked arrays. &lt;reference/maskedarray&gt;`


    matrix
        NumPy&#39;s two-dimensional
        :doc:`matrix class &lt;reference/generated/numpy.matrix&gt;`
        should no longer be used; use regular ndarrays.


    ndarray
       :doc:`NumPy&#39;s basic structure &lt;reference/arrays&gt;`.


    object array
        An array whose dtype is ``object``; that is, it contains references to
        Python objects. Indexing the array dereferences the Python objects, so
        unlike other ndarrays, an object array has the ability to hold
        heterogeneous objects.


    ravel
        :doc:`numpy.ravel \
        &lt;reference/generated/numpy.ravel&gt;`
        and :doc:`numpy.flatten \
        &lt;reference/generated/numpy.ndarray.flatten&gt;`
        both flatten an ndarray. ``ravel`` will return a view if possible;
        ``flatten`` always returns a copy.

        Flattening collapses a multidimensional array to a single dimension;
        details of how this is done (for instance, whether ``a[n+1]`` should be
        the next row or next column) are parameters.


    record array
        A :term:`structured array` with allowing access in an attribute style
        (``a.field``) in addition to ``a[&#39;field&#39;]``. For details, see
        :doc:`numpy.recarray. &lt;reference/generated/numpy.recarray&gt;`


    row-major
        See `Row- and column-major order &lt;https://en.wikipedia.org/wiki/Row-_and_column-major_order&gt;`_.
        NumPy creates arrays in row-major order by default.


    scalar
        In NumPy, usually a synonym for :term:`array scalar`.


    shape
        A tuple showing the length of each dimension of an ndarray. The
        length of the tuple itself is the number of dimensions
        (:doc:`numpy.ndim &lt;reference/generated/numpy.ndarray.ndim&gt;`).
        The product of the tuple elements is the number of elements in the
        array. For details, see
        :doc:`numpy.ndarray.shape &lt;reference/generated/numpy.ndarray.shape&gt;`.


    stride
        Physical memory is one-dimensional;  strides provide a mechanism to map
        a given index to an address in memory. For an N-dimensional array, its
        ``strides`` attribute is an N-element tuple; advancing from index
        ``i`` to index ``i+1`` on axis ``n`` means adding ``a.strides[n]`` bytes
        to the address.

        Strides are computed automatically from an array&#39;s dtype and
        shape, but can be directly specified using
        :doc:`as_strided. &lt;reference/generated/numpy.lib.stride_tricks.as_strided&gt;`

        For details, see
        :doc:`numpy.ndarray.strides &lt;reference/generated/numpy.ndarray.strides&gt;`.

        To see how striding underlies the power of NumPy views, see
        `The NumPy array: a structure for efficient numerical computation. \
        &lt;https://arxiv.org/pdf/1102.1523.pdf&gt;`_


    structured array
        Array whose :term:`dtype` is a :term:`structured data type`.


    structured data type
        Users can create arbitrarily complex :term:`dtypes &lt;dtype&gt;`
        that can include other arrays and dtypes. These composite dtypes are called
        :doc:`structured data types. &lt;user/basics.rec&gt;`


    subarray
       An array nested in a :term:`structured data type`, as ``b`` is here:

         &gt;&gt;&gt; dt = np.dtype([(&#39;a&#39;, np.int32), (&#39;b&#39;, np.float32, (3,))])
         &gt;&gt;&gt; np.zeros(3, dtype=dt)
         array([(0, [0., 0., 0.]), (0, [0., 0., 0.]), (0, [0., 0., 0.])],
               dtype=[(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, &#39;&lt;f4&#39;, (3,))])


    subarray data type
        An element of a structured datatype that behaves like an ndarray.


    title
        An alias for a field name in a structured datatype.


    type
        In NumPy, usually a synonym for :term:`dtype`. For the more general
        Python meaning, :term:`see here. &lt;python:type&gt;`


    ufunc
        NumPy&#39;s fast element-by-element computation (:term:`vectorization`)
        gives a choice which function gets applied. The general term for the
        function is ``ufunc``, short for ``universal function``. NumPy routines
        have built-in ufuncs, but users can also
        :doc:`write their own. &lt;reference/ufuncs&gt;`


    vectorization
        NumPy hands off array processing to C, where looping and computation are
        much faster than in Python. To exploit this, programmers using NumPy
        eliminate Python loops in favor of array-to-array operations.
        :term:`vectorization` can refer both to the C offloading and to
        structuring NumPy code to leverage it.

    view
        Without touching underlying data, NumPy can make one array appear
        to change its datatype and shape.

        An array created this way is a `view`, and NumPy often exploits the
        performance gain of using a view versus making a new array.

        A potential drawback is that writing to a view can alter the original
        as well. If this is a problem, NumPy instead needs to create a
        physically distinct array -- a `copy`.

        Some NumPy routines always return views, some always return copies, some
        may return one or the other, and for some the choice can be specified.
        Responsibility for managing views and copies falls to the programmer.
        :func:`numpy.shares_memory` will check whether ``b`` is a view of
        ``a``, but an exact answer isn&#39;t always feasible, as the documentation
        page explains.

          &gt;&gt;&gt; x = np.arange(5)
          &gt;&gt;&gt; x
          array([0, 1, 2, 3, 4])

          &gt;&gt;&gt; y = x[::2]
          &gt;&gt;&gt; y
          array([0, 2, 4])

          &gt;&gt;&gt; x[0] = 3 # changing x changes y as well, since y is a view on x
          &gt;&gt;&gt; y
          array([3, 2, 4])</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
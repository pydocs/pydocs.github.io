<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Data Type API</h1>
               <pre class='not-implemented'>
.. sectionauthor:: Travis E. Oliphant
    </pre>


               <p>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions.  Thus,         <code class='verbatim'>NPY_FLOAT</code>
 picks up a 32-bit float in C, but         <code class='verbatim'>numpy.float_</code>
 in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</p>

</div>



<h1>Enumerated Types</h1>
               <pre class='not-implemented'>
.. c:enumerator:: NPY_TYPES
    </pre>


               <p>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called         <code class='verbatim'>NPY_{NAME}</code>
:</p>

               <pre class='not-implemented'>
.. c:enumerator:: NPY_BOOL
    The enumeration value for the boolean type, stored as one byte.
    It may only be set to the values 0 and 1.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_BYTE
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_INT8
    The enumeration value for an 8-bit/1-byte signed integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_SHORT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_INT16
    The enumeration value for a 16-bit/2-byte signed integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_INT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_INT32
    The enumeration value for a 32-bit/4-byte signed integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_LONG
    Equivalent to either NPY_INT or NPY_LONGLONG, depending on the
    platform.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_LONGLONG
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_INT64
    The enumeration value for a 64-bit/8-byte signed integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UBYTE
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINT8
    The enumeration value for an 8-bit/1-byte unsigned integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_USHORT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINT16
    The enumeration value for a 16-bit/2-byte unsigned integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINT32
    The enumeration value for a 32-bit/4-byte unsigned integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_ULONG
    Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the
    platform.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_ULONGLONG
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINT64
    The enumeration value for a 64-bit/8-byte unsigned integer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_HALF
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_FLOAT16
    The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating
    point type.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_FLOAT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_FLOAT32
    The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating
    point type.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_DOUBLE
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_FLOAT64
    The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating
    point type.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_LONGDOUBLE
    The enumeration value for a platform-specific floating point type which is
    at least as large as NPY_DOUBLE, but larger on many platforms.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_CFLOAT
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_COMPLEX64
    The enumeration value for a 64-bit/8-byte complex type made up of
    two NPY_FLOAT values.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_CDOUBLE
    </pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_COMPLEX128
    The enumeration value for a 128-bit/16-byte complex type made up of
    two NPY_DOUBLE values.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_CLONGDOUBLE
    The enumeration value for a platform-specific complex floating point
    type which is made up of two NPY_LONGDOUBLE values.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_DATETIME
    The enumeration value for a data type which holds dates or datetimes with
    a precision based on selectable date or time units.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_TIMEDELTA
    The enumeration value for a data type which holds lengths of times in
    integers of selectable date or time units.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_STRING
    The enumeration value for ASCII strings of a selectable size. The
    strings have a fixed maximum size within a given array.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UNICODE
    The enumeration value for UCS4 strings of a selectable size. The
    strings have a fixed maximum size within a given array.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_OBJECT
    The enumeration value for references to arbitrary Python objects.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_VOID
    Primarily used to hold struct dtypes, but can contain arbitrary
    binary data.</pre>


               <p>Some useful aliases of the above types are</p>

               <pre class='not-implemented'>
.. c:enumerator:: NPY_INTP
    The enumeration value for a signed integer type which is the same
    size as a (void \*) pointer. This is the type used by all
    arrays of indices.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_UINTP
    The enumeration value for an unsigned integer type which is the
    same size as a (void \*) pointer.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_MASK
    The enumeration value of the type used for masks, such as with
    the :c:data:`NPY_ITER_ARRAYMASK` iterator flag. This is equivalent
    to :c:data:`NPY_UINT8`.</pre>


               <pre class='not-implemented'>
.. c:enumerator:: NPY_DEFAULT_TYPE
    The default type to use when no dtype is explicitly specified, for
    example when calling np.zero(shape). This is equivalent to
    :c:data:`NPY_DOUBLE`.</pre>


               <p>Other useful related constants are</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_NTYPES
    The total number of built-in NumPy types. The enumeration covers
    the range from 0 to NPY_NTYPES-1.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_NOTYPE
    A signal value guaranteed not to be a valid type enumeration number.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_USERDEF
    The start of type numbers used for Custom Data types.</pre>


               <p>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is         <code class='verbatim'>NPY_{NAME}LTR</code>
 where         <code class='verbatim'>{NAME}</code>
 can be</p>

                           <pre>**BOOL**, **BYTE**, **UBYTE**, **SHORT**, **USHORT**, **INT**,
**UINT**, **LONG**, **ULONG**, **LONGLONG**, **ULONGLONG**,
**HALF**, **FLOAT**, **DOUBLE**, **LONGDOUBLE**, **CFLOAT**,
**CDOUBLE**, **CLONGDOUBLE**, **DATETIME**, **TIMEDELTA**,
**OBJECT**, **STRING**, **VOID**

**INTP**, **UINTP**

**GENBOOL**, **SIGNED**, **UNSIGNED**, **FLOATING**, **COMPLEX**
</pre>

               <p>The latter group of         <code class='verbatim'>{NAME}s</code>
 corresponds to letters used in the array interface typestring specification.</p>


<h1>Defines</h1>

<h1>Max and min values for integers</h1>
               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>NPY_MAX_INT{bits}</code>
,         <code class='verbatim'>NPY_MAX_UINT{bits}</code>
,         <code class='verbatim'>NPY_MIN_INT{bits}</code>
</p>
</dt>
               <dd><p>These are defined for         <code class='verbatim'>{bits}</code>
 = 8, 16, 32, 64, 128, and 256 and provide     the maximum (minimum) value of the corresponding (unsigned) integer     type. Note: the actual integer type may not be available on all     platforms (i.e. 128-bit and 256-bit integers are rare).</p>
</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>NPY_MIN_{type}</code>
</p>
</dt>
               <dd><p>This is defined for         <code class='verbatim'>{type}</code>
 = <strong>BYTE</strong>, <strong>SHORT</strong>, <strong>INT</strong>,     <strong>LONG</strong>, <strong>LONGLONG</strong>, <strong>INTP</strong></p>
</dd>
           </dl>

               <!-- deflist -->
           <dl>
               <dt><p>        <code class='verbatim'>NPY_MAX_{type}</code>
</p>
</dt>
               <dd><p>This is defined for all defined for         <code class='verbatim'>{type}</code>
 = <strong>BYTE</strong>, <strong>UBYTE</strong>,     <strong>SHORT</strong>, <strong>USHORT</strong>, <strong>INT</strong>, <strong>UINT</strong>, <strong>LONG</strong>, <strong>ULONG</strong>,     <strong>LONGLONG</strong>, <strong>ULONGLONG</strong>, <strong>INTP</strong>, <strong>UINTP</strong></p>
</dd>
           </dl>


<h1>Number of bits in data types</h1>
               <p>All         <code class='verbatim'>NPY_SIZEOF_{CTYPE}</code>
 constants have corresponding         <code class='verbatim'>NPY_BITSOF_{CTYPE}</code>
 constants defined. The         <code class='verbatim'>NPY_BITSOF_{CTYPE}</code>
 constants provide the number of bits in the data type.  Specifically, the available         <code class='verbatim'>{CTYPE}s</code>
 are</p>

                           <pre>**BOOL**, **CHAR**, **SHORT**, **INT**, **LONG**,
**LONGLONG**, **FLOAT**, **DOUBLE**, **LONGDOUBLE**
</pre>


<h1>Bit-width references to enumerated typenums</h1>
               <p>All of the numeric data types (integer, floating point, and complex) have constants that are defined to be a specific enumerated type number. Exactly which enumerated type a bit-width type refers to is platform dependent. In particular, the constants available are         <code class='verbatim'>PyArray_{NAME}{BITS}</code>
 where         <code class='verbatim'>{NAME}</code>
 is <strong>INT</strong>, <strong>UINT</strong>, <strong>FLOAT</strong>, <strong>COMPLEX</strong> and         <code class='verbatim'>{BITS}</code>
 can be 8, 16, 32, 64, 80, 96, 128, 160, 192, 256, and 512.  Obviously not all bit-widths are available on all platforms for all the kinds of numeric types. Commonly 8-, 16-, 32-, 64-bit integers; 32-, 64-bit floats; and 64-, 128-bit complex types are available.</p>


<h1>Integer that can hold a pointer</h1>
               <p>The constants <strong>NPY_INTP</strong> and <strong>NPY_UINTP</strong> refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to <strong>NPY_INTP</strong> , because the dimension of the array is of type npy_intp.</p>


<h1>C-type names</h1>
               <p>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</p>


<h1>Boolean</h1>
               <pre class='not-implemented'>
.. c:type:: npy_bool
    unsigned char; The constants :c:data:`NPY_FALSE` and
    :c:data:`NPY_TRUE` are also defined.</pre>



<h1>(Un)Signed Integer</h1>
               <p>Unsigned versions of the integers can be defined by pre-pending a &#39;u&#39; to the front of the integer name.</p>

               <pre class='not-implemented'>
.. c:type:: npy_byte
    char</pre>


               <pre class='not-implemented'>
.. c:type:: npy_ubyte
    unsigned char</pre>


               <pre class='not-implemented'>
.. c:type:: npy_short
    short</pre>


               <pre class='not-implemented'>
.. c:type:: npy_ushort
    unsigned short</pre>


               <pre class='not-implemented'>
.. c:type:: npy_int
    int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_uint
    unsigned int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_int16
    16-bit integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_uint16
    16-bit unsigned integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_int32
    32-bit integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_uint32
    32-bit unsigned integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_int64
    64-bit integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_uint64
    64-bit unsigned integer</pre>


               <pre class='not-implemented'>
.. c:type:: npy_long
    long int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_ulong
    unsigned long int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_longlong
    long long int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_ulonglong
    unsigned long long int</pre>


               <pre class='not-implemented'>
.. c:type:: npy_intp
    Py_intptr_t (an integer that is the size of a pointer on
    the platform).</pre>


               <pre class='not-implemented'>
.. c:type:: npy_uintp
    unsigned Py_intptr_t (an integer that is the size of a pointer on
    the platform).</pre>



<h1>(Complex) Floating point</h1>
               <pre class='not-implemented'>
.. c:type:: npy_half
    16-bit float</pre>


               <pre class='not-implemented'>
.. c:type:: npy_float
    32-bit float</pre>


               <pre class='not-implemented'>
.. c:type:: npy_cfloat
    32-bit complex float</pre>


               <pre class='not-implemented'>
.. c:type:: npy_double
    64-bit double</pre>


               <pre class='not-implemented'>
.. c:type:: npy_cdouble
    64-bit complex double</pre>


               <pre class='not-implemented'>
.. c:type:: npy_longdouble
    long double</pre>


               <pre class='not-implemented'>
.. c:type:: npy_clongdouble
    long complex double</pre>


               <p>complex types are structures with <strong>.real</strong> and <strong>.imag</strong> members (in that order).</p>


<h1>Bit-width names</h1>
               <p>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</p>

                           <pre>``npy_int{bits}``, ``npy_uint{bits}``, ``npy_float{bits}``,
and ``npy_complex{bits}``
</pre>

               <p>where         <code class='verbatim'>{bits}</code>
 is the number of bits in the type and can be <strong>8</strong>, <strong>16</strong>, <strong>32</strong>, <strong>64</strong>, 128, and 256 for integer types; 16, <strong>32</strong> , <strong>64</strong>, 80, 96, 128, and 256 for floating-point types; and 32, <strong>64</strong>, <strong>128</strong>, 160, 192, and 512 for complex-valued types. Which bit-widths are available is platform dependent. The bolded bit-widths are usually available on all platforms.</p>


<h1>Printf Formatting</h1>
               <p>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_LONGLONG_FMT
    </pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ULONGLONG_FMT
    </pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_INTP_FMT
    </pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_UINTP_FMT
    </pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_LONGDOUBLE_FMT
    </pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
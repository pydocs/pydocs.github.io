<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Using Python as glue</h1>
               <p>Many people like to say that Python is a fantastic glue language. Hopefully, this Chapter will convince you that this is true. The first adopters of Python for science were typically people who used it to glue together large application codes running on super-computers. Not only was it much nicer to code in Python than in a shell script or Perl, in addition, the ability to easily extend Python made it relatively easy to create new classes and types specifically adapted to the problems being solved. From the interactions of these early contributors, Numeric emerged as an array-like object that could be used to pass data between these applications.</p>

               <p>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</p>

               <p>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &#34;Google&#34; in order to learn more.</p>


<h1>Calling other compiled libraries from Python</h1>
               <p>While Python is a great language and a pleasure to code in, its dynamic nature results in overhead that can cause some code ( <em>i.e.</em> raw computations inside of for loops) to be up 10-100 times slower than equivalent code written in a static compiled language. In addition, it can cause memory usage to be larger than necessary as temporary arrays are created and destroyed during computation. For many types of computing needs, the extra slow-down and memory consumption can often not be spared (at least for time- or memory- critical portions of your code). Therefore one of the most common needs is to call out from Python code to a fast, machine-code routine (e.g. compiled using C/C++ or Fortran). The fact that this is relatively easy to do is a big reason why Python is such an excellent high-level language for scientific and engineering programming.</p>

               <p>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the <a link href="https://docs.python.org/3/library/ctypes.html" class='external'>ctypes</a> module.  Writing an extension module is the most common method.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>Calling C-code from Python can result in Python crashes if you are not careful. None of the approaches in this chapter are immune. You have to know something about the way data is handled by both NumPy and by the third-party library being used.</p>

</div>



<h1>Hand-generated wrappers</h1>
               <p>Extension modules were discussed in         <code class='verbatim'>writing-an-extension</code>
. The most basic way to interface with compiled code is to write an extension module and construct a module method that calls the compiled code. For improved readability, your method should take advantage of the         <code class='verbatim'>PyArg_ParseTuple</code>
 call to convert between Python objects and C data-types. For standard C data-types there is probably already a built-in converter. For others you may need  to write your own converter and use the         <code class='verbatim'>&#34;O&amp;&#34;</code>
 format string which allows you to specify a function that will be used to perform the conversion from the Python object to whatever C-structures are needed.</p>

               <p>Once the conversions to the appropriate C-structures and C data-types have been performed, the next step in the wrapper is to call the underlying function. This is straightforward if the underlying function is in C or C++. However, in order to call Fortran code you must be familiar with how Fortran subroutines are called from C/C++ using your compiler and platform. This can vary somewhat platforms and compilers (which is another reason f2py makes life much simpler for interfacing Fortran code) but generally involves underscore mangling of the name and the fact that all variables are passed by reference (i.e. all arguments are pointers).</p>

               <p>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &#34;cutting-pasting-and-modifying&#34; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</p>


<h1>f2py</h1>
               <p>F2py allows you to automatically construct an extension module that interfaces to routines in Fortran 77/90/95 code. It has the ability to parse Fortran 77/90/95 code and automatically generate Python signatures for the subroutines it encounters, or you can guide how the subroutine interfaces with Python by constructing an interface-definition-file (or modifying the f2py-produced one).</p>

               <p>See the         <code class='verbatim'>F2PY documentation &lt;f2py&gt;</code>
 for more information and examples.</p>

               <p>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In our opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</p>

               <pre class='not-implemented'>
.. index:: 
    single: f2py</pre>



<h1>Cython</h1>
               <p><a link href="http://cython.org" class='external'>Cython</a> is a compiler for a Python dialect that adds (optional) static typing for speed, and allows mixing C or C++ code into your modules. It produces C or C++ extensions that can be compiled and imported in Python code.</p>

               <p>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</p>

               <pre class='not-implemented'>
.. index:: 
    single: cython</pre>


               <p>Notice that Cython is an extension-module generator only. Unlike f2py, it includes no automatic facility for compiling and linking the extension module (which must be done in the usual fashion). It does provide a modified distutils class called         <code class='verbatim'>build_ext</code>
 which lets you build an extension module from a         <code class='verbatim'>.pyx</code>
 source. Thus, you could write in a         <code class='verbatim'>setup.py</code>
 file:</p>

               <pre class='not-implemented'>
.. code-block:: python
    from Cython.Distutils import build_ext
    from distutils.extension import Extension
    from distutils.core import setup
    import numpy

    setup(name=&#39;mine&#39;, description=&#39;Nothing&#39;,
          ext_modules=[Extension(&#39;filter&#39;, [&#39;filter.pyx&#39;],
                                 include_dirs=[numpy.get_include()])],
          cmdclass = {&#39;build_ext&#39;:build_ext})</pre>


               <p>Adding the NumPy include directory is, of course, only necessary if you are using NumPy arrays in the extension module (which is what we assume you are using Cython for). The distutils extensions in NumPy also include support for automatically producing the extension-module and linking it from a         <code class='verbatim'>.pyx</code>
 file. It works so that if the user does not have Cython installed, then it looks for a file with the same file-name but a         <code class='verbatim'>.c</code>
 extension which it then uses instead of trying to produce the         <code class='verbatim'>.c</code>
 file again.</p>

               <p>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the         <code class='verbatim'>cdef</code>
 keyword to statically define C variables.</p>

               <p>Let&#39;s look at two examples we&#39;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</p>


<h1>Complex addition in Cython</h1>
               <p>Here is part of a Cython module named         <code class='verbatim'>add.pyx</code>
 which implements the complex addition functions we previously implemented using f2py:</p>

               <pre class='not-implemented'>
.. code-block:: cython
    cimport cython
    cimport numpy as np
    import numpy as np

    # We need to initialize NumPy.
    np.import_array()

    #@cython.boundscheck(False)
    def zadd(in1, in2):
        cdef double complex[:] a = in1.ravel()
        cdef double complex[:] b = in2.ravel()

        out = np.empty(a.shape[0], np.complex64)
        cdef double complex[:] c = out.ravel()

        for i in range(c.shape[0]):
            c[i].real = a[i].real + b[i].real
            c[i].imag = a[i].imag + b[i].imag

        return out</pre>


               <p>This module shows use of the         <code class='verbatim'>cimport</code>
 statement to load the definitions from the         <code class='verbatim'>numpy.pxd</code>
 header that ships with Cython. It looks like NumPy is imported twice;         <code class='verbatim'>cimport</code>
 only makes the NumPy C-API available, while the regular         <code class='verbatim'>import</code>
 causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</p>

               <p>The example also demonstrates Cython&#39;s &#34;typed memoryviews&#34;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax         <code class='verbatim'>double complex[:]</code>
 denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be         <code class='verbatim'>int[::1]</code>
, while a matrix of floats would be         <code class='verbatim'>float[:, :]</code>
.</p>

               <p>Shown commented is the         <code class='verbatim'>cython.boundscheck</code>
 decorator, which turns bounds-checking for memory view accesses on or off on a per-function basis. We can use this to further speed up our code, at the expense of safety (or a manual check prior to entering the loop).</p>

               <p>Other than the view syntax, the function is immediately readable to a Python programmer. Static typing of the variable         <code class='verbatim'>i</code>
 is implicit. Instead of the view syntax, we could also have used Cython&#39;s special NumPy array syntax, but the view syntax is preferred.</p>


<h1>Image filter in Cython</h1>
               <p>The two-dimensional example we created using Fortran is just as easy to write in Cython:</p>

               <pre class='not-implemented'>
.. code-block:: cython
    cimport numpy as np
    import numpy as np

    np.import_array()

    def filter(img):
        cdef double[:, :] a = np.asarray(img, dtype=np.double)
        out = np.zeros(img.shape, dtype=np.double)
        cdef double[:, ::1] b = out

        cdef np.npy_intp i, j

        for i in range(1, a.shape[0] - 1):
            for j in range(1, a.shape[1] - 1):
                b[i, j] = (a[i, j]
                           + .5 * (  a[i-1, j] + a[i+1, j]
                                   + a[i, j-1] + a[i, j+1])
                           + .25 * (  a[i-1, j-1] + a[i-1, j+1]
                                    + a[i+1, j-1] + a[i+1, j+1]))

        return out</pre>


               <p>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module         <code class='verbatim'>image</code>
, then a 2-d image,         <code class='verbatim'>img</code>
, can be filtered using this code very quickly using:</p>

               <pre class='not-implemented'>
.. code-block:: python
    import image
    out = image.filter(img)</pre>


               <p>Regarding the code, two things are of note: firstly, it is impossible to return a memory view to Python. Instead, a NumPy array         <code class='verbatim'>out</code>
 is first created, and then a view         <code class='verbatim'>b</code>
 onto this array is used for the computation. Secondly, the view         <code class='verbatim'>b</code>
 is typed         <code class='verbatim'>double[:, ::1]</code>
. This means 2-d array with contiguous rows, i.e., C matrix order. Specifying the order explicitly can speed up some algorithms since they can skip stride computations.</p>


<h1>Conclusion</h1>
               <p>Cython is the extension mechanism of choice for several scientific Python libraries, including Scipy, Pandas, SAGE, scikit-image and scikit-learn, as well as the XML processing library LXML. The language and compiler are well-maintained.</p>

               <p>There are several disadvantages of using Cython:</p>

                          <ol>               <li>               <p>When coding custom algorithms, and sometimes when wrapping existing C    libraries, some familiarity with C is required. In particular, when using    C memory management (        <code class='verbatim'>malloc</code>
 and friends), it&#39;s easy to introduce    memory leaks. However, just compiling a Python module renamed to         <code class='verbatim'>.pyx</code>
    can already speed it up, and adding a few type declarations can give    dramatic speedups in some code.</p>

</li>
               <li>               <p>It is easy to lose a clean separation between Python and C which makes    re-using your C-code for other non-Python-related projects more    difficult.</p>

</li>
               <li>               <p>The C-code generated by Cython is hard to read and modify (and typically    compiles with annoying but harmless warnings).</p>

</li>
            </ol>

               <p>One big advantage of Cython-generated extension modules is that they are easy to distribute. In summary, Cython is a very capable tool for either gluing C code or generating an extension module quickly and should not be over-looked. It is especially useful for people that can&#39;t or won&#39;t write C or Fortran code.</p>

               <pre class='not-implemented'>
.. index:: 
    single: cython</pre>



<h1>ctypes</h1>
               <p><a link href="https://docs.python.org/3/library/ctypes.html" class='external'>Ctypes</a> is a Python extension module, included in the stdlib, that allows you to call an arbitrary function in a shared library directly from Python. This approach allows you to interface with C-code directly from Python. This opens up an enormous number of libraries for use from Python. The drawback, however, is that coding mistakes can lead to ugly program crashes very easily (just as can happen in C) because there is little type or bounds checking done on the parameters. This is especially true when array data is passed in as a pointer to a raw memory location. The responsibility is then on you that the subroutine will not access memory outside the actual array area. But, if you don&#39;t mind living a little dangerously ctypes can be an effective tool for quickly taking advantage of a large shared library (or writing extended functionality in your own shared library).</p>

               <pre class='not-implemented'>
.. index:: 
    single: ctypes</pre>


               <p>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</p>

               <p>To use ctypes you must</p>

                          <ol>               <li>               <p>Have a shared library.</p>

</li>
               <li>               <p>Load the shared library.</p>

</li>
               <li>               <p>Convert the Python objects to ctypes-understood arguments.</p>

</li>
               <li>               <p>Call the function from the library with the ctypes arguments.</p>

</li>
            </ol>


<h1>Having a shared library</h1>
               <p>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</p>

                          <ul>               <li>               <p>A shared library must be compiled in a special way ( <em>e.g.</em> using   the         <code class='verbatim'>-shared</code>
 flag with gcc).</p>

</li>
               <li>               <p>On some platforms (<em>e.g.</em> Windows), a shared library requires a   .def file that specifies the functions to be exported. For example a   mylib.def file might contain::        </p>

               <pre>LIBRARY mylib.dll
EXPORTS
cool_function1
cool_function2</pre>
               <p>Alternatively, you may be able to use the storage-class specifier           <code class='verbatim'>__declspec(dllexport)</code>
 in the C-definition of the function to avoid   the need for this         <code class='verbatim'>.def</code>
 file.</p>

</li>
            </ul>

               <p>There is no standard way in Python distutils to create a standard shared library (an extension module is a &#34;special&#34; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</p>


<h1>Loading the shared library</h1>
               <p>A simple, but robust way to load the shared library is to get the absolute path name and load it using the cdll object of ctypes:</p>

               <pre class='not-implemented'>
.. code-block:: python
    lib = ctypes.cdll[&lt;full_path_name&gt;]</pre>


               <p>However, on Windows accessing an attribute of the         <code class='verbatim'>cdll</code>
 method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a         <code class='verbatim'>ctypes.util.find_library</code>
 utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll -- Windows, .so -- Linux, .dylib -- Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</p>

               <p>NumPy provides a convenience function called         <code class='verbatim'>ctypeslib.load_library</code>
 (name, path). This function takes the name of the shared library (including any prefix like &#39;lib&#39; but excluding the extension) and a path where the shared library can be located. It returns a ctypes library object or raises an         <code class='verbatim'>OSError</code>
 if the library cannot be found or raises an         <code class='verbatim'>ImportError</code>
 if the ctypes module is not available. (Windows users: the ctypes library object loaded using         <code class='verbatim'>load_library</code>
 is always loaded assuming cdecl calling convention. See the ctypes documentation under         <code class='verbatim'>ctypes.windll</code>
 and/or         <code class='verbatim'>ctypes.oledll</code>
 for ways to load libraries under other calling conventions).</p>

               <p>The functions in the shared library are available as attributes of the ctypes library object (returned from         <code class='verbatim'>ctypeslib.load_library</code>
) or as items using         <code class='verbatim'>lib[&#39;func_name&#39;]</code>
 syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</p>


<h1>Converting arguments</h1>
               <p>Python ints/longs, strings, and unicode objects are automatically converted as needed to equivalent ctypes arguments The None object is also converted automatically to a NULL pointer. All other Python objects must be converted to ctypes-specific types. There are two ways around this restriction that allow ctypes to integrate with other objects.</p>

                          <ol>               <li>               <p>Don&#39;t set the argtypes attribute of the function object and define an            <code class='verbatim'>_as_parameter_</code>
 method for the object you want to pass in. The            <code class='verbatim'>_as_parameter_</code>
 method must return a Python int which will be passed    directly to the function.</p>

</li>
               <li>               <p>Set the argtypes attribute to a list whose entries contain objects    with a classmethod named from_param that knows how to convert your    object to an object that ctypes can understand (an int/long, string,    unicode, or object with the         <code class='verbatim'>_as_parameter_</code>
 attribute).</p>

</li>
            </ol>

               <p>NumPy uses both methods with a preference for the second method because it can be safer. The ctypes attribute of the ndarray returns an object that has an         <code class='verbatim'>_as_parameter_</code>
 attribute which returns an integer representing the address of the ndarray to which it is associated. As a result, one can pass this ctypes attribute object directly to a function expecting a pointer to the data in your ndarray. The caller must be sure that the ndarray object is of the correct type, shape, and has the correct flags set or risk nasty crashes if the data-pointer to inappropriate arrays are passed in.</p>

               <p>To implement the second method, NumPy provides the class-factory function         <code class='verbatim'>ndpointer</code>
 in the         <code class='verbatim'>numpy.ctypeslib</code>
 module. This class-factory function produces an appropriate class that can be placed in an argtypes attribute entry of a ctypes function. The class will contain a from_param method which ctypes will use to convert any ndarray passed in to the function to a ctypes-recognized object. In the process, the conversion will perform checking on any properties of the ndarray that were specified by the user in the call to         <code class='verbatim'>ndpointer</code>
. Aspects of the ndarray that can be checked include the data-type, the number-of-dimensions, the shape, and/or the state of the flags on any array passed. The return value of the from_param method is the ctypes attribute of the array which (because it contains the         <code class='verbatim'>_as_parameter_</code>
 attribute pointing to the array data area) can be used by ctypes directly.</p>

               <p>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes <strong>data</strong>, <strong>shape</strong>, and <strong>strides</strong> can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a         <code class='verbatim'>c_void_p</code>
 representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods         <code class='verbatim'>data_as({ctype})</code>
,         <code class='verbatim'>shape_as(&lt;base ctype&gt;)</code>
, and         <code class='verbatim'>strides_as(&lt;base
ctype&gt;)</code>
. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the         <code class='verbatim'>ctypeslib</code>
 module also contains         <code class='verbatim'>c_intp</code>
 as a ctypes integer data-type whose size is the same as the size of         <code class='verbatim'>c_void_p</code>
 on the platform (its value is None if ctypes is not installed).</p>


<h1>Calling the function</h1>
               <p>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if         <code class='verbatim'>./mylib.so</code>
 has a function named         <code class='verbatim'>cool_function1</code>
, it may be accessed either as:</p>

               <pre class='not-implemented'>
.. code-block:: python
    lib = numpy.ctypeslib.load_library(&#39;mylib&#39;,&#39;.&#39;)
    func1 = lib.cool_function1  # or equivalently
    func1 = lib[&#39;cool_function1&#39;]</pre>


               <p>In ctypes, the return-value of a function is set to be &#39;int&#39; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&#39;void&#39;):</p>

               <pre class='not-implemented'>
.. code-block:: python
    func1.restype = None</pre>


               <p>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the         <code class='verbatim'>ndpointer</code>
 factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The         <code class='verbatim'>ndpointer</code>
 function has the signature</p>

               <pre class='not-implemented'>
.. function:: ndpointer(dtype=None, ndim=None, shape=None, flags=None)
    Keyword arguments with the value ``None`` are not checked.
    Specifying a keyword enforces checking of that aspect of the
    ndarray on conversion to a ctypes-compatible object. The dtype
    keyword can be any object understood as a data-type object. The
    ndim keyword should be an integer, and the shape keyword should be
    an integer or a sequence of integers. The flags keyword specifies
    the minimal flags that are required on any array passed in. This
    can be specified as a string of comma separated requirements, an
    integer indicating the requirement bits OR&#39;d together, or a flags
    object returned from the flags attribute of an array with the
    necessary requirements.</pre>


               <p>Using an ndpointer class in the argtypes method can make it significantly safer to call a C function using ctypes and the data- area of an ndarray. You may still want to wrap the function in an additional Python wrapper to make it user-friendly (hiding some obvious arguments and making some arguments output arguments). In this process, the         <code class='verbatim'>requires</code>
 function in NumPy may be useful to return the right kind of array from a given input.</p>


<h1>Complete example</h1>
               <p>In this example, we will demonstrate how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions         <code class='verbatim'>zadd</code>
,         <code class='verbatim'>dadd</code>
,         <code class='verbatim'>sadd</code>
,         <code class='verbatim'>cadd</code>
, and         <code class='verbatim'>dfilter2d</code>
. The         <code class='verbatim'>zadd</code>
 function is:</p>

               <pre class='not-implemented'>
.. code-block:: c
    /* Add arrays of contiguous data */
    typedef struct {double real; double imag;} cdouble;
    typedef struct {float real; float imag;} cfloat;
    void zadd(cdouble *a, cdouble *b, cdouble *c, long n)
    {
        while (n--) {
            c-&gt;real = a-&gt;real + b-&gt;real;
            c-&gt;imag = a-&gt;imag + b-&gt;imag;
            a++; b++; c++;
        }
    }</pre>


               <p>with similar code for         <code class='verbatim'>cadd</code>
,         <code class='verbatim'>dadd</code>
, and         <code class='verbatim'>sadd</code>
 that handles complex float, double, and float data-types, respectively:</p>

               <pre class='not-implemented'>
.. code-block:: c
    void cadd(cfloat *a, cfloat *b, cfloat *c, long n)
    {
            while (n--) {
                    c-&gt;real = a-&gt;real + b-&gt;real;
                    c-&gt;imag = a-&gt;imag + b-&gt;imag;
                    a++; b++; c++;
            }
    }
    void dadd(double *a, double *b, double *c, long n)
    {
            while (n--) {
                    *c++ = *a++ + *b++;
            }
    }
    void sadd(float *a, float *b, float *c, long n)
    {
            while (n--) {
                    *c++ = *a++ + *b++;
            }
    }</pre>


               <p>The         <code class='verbatim'>code.c</code>
 file also contains the function         <code class='verbatim'>dfilter2d</code>
:</p>

               <pre class='not-implemented'>
.. code-block:: c
    /*
     * Assumes b is contiguous and has strides that are multiples of
     * sizeof(double)
     */
    void
    dfilter2d(double *a, double *b, ssize_t *astrides, ssize_t *dims)
    {
        ssize_t i, j, M, N, S0, S1;
        ssize_t r, c, rm1, rp1, cp1, cm1;

        M = dims[0]; N = dims[1];
        S0 = astrides[0]/sizeof(double);
        S1 = astrides[1]/sizeof(double);
        for (i = 1; i &lt; M - 1; i++) {
            r = i*S0;
            rp1 = r + S0;
            rm1 = r - S0;
            for (j = 1; j &lt; N - 1; j++) {
                c = j*S1;
                cp1 = j + S1;
                cm1 = j - S1;
                b[i*N + j] = a[r + c] +
                    (a[rp1 + c] + a[rm1 + c] +
                     a[r + cp1] + a[r + cm1])*0.5 +
                    (a[rp1 + cp1] + a[rp1 + cm1] +
                     a[rm1 + cp1] + a[rm1 + cp1])*0.25;
            }
        }
    }</pre>


               <p>A possible advantage this code has over the Fortran-equivalent code is that it takes arbitrarily strided (i.e. non-contiguous arrays) and may also run faster depending on the optimization capability of your compiler. But, it is an obviously more complicated than the simple code in         <code class='verbatim'>filter.f</code>
. This code must be compiled into a shared library. On my Linux system this is accomplished using::      </p>

               <pre>gcc -o code.so -shared code.c</pre>
               <p>Which creates a shared_library named code.so in the current directory. On Windows don&#39;t forget to either add         <code class='verbatim'>__declspec(dllexport)</code>
 in front of void on the line preceding each function definition, or write a         <code class='verbatim'>code.def</code>
 file that lists the names of the functions to be exported.</p>

               <p>A suitable Python interface to this shared library should be constructed. To do this create a file named interface.py with the following lines at the top:</p>

               <pre class='not-implemented'>
.. code-block:: python
    __all__ = [&#39;add&#39;, &#39;filter2d&#39;]

    import numpy as np
    import os

    _path = os.path.dirname(&#39;__file__&#39;)
    lib = np.ctypeslib.load_library(&#39;code&#39;, _path)
    _typedict = {&#39;zadd&#39; : complex, &#39;sadd&#39; : np.single,
                 &#39;cadd&#39; : np.csingle, &#39;dadd&#39; : float}
    for name in _typedict.keys():
        val = getattr(lib, name)
        val.restype = None
        _type = _typedict[name]
        val.argtypes = [np.ctypeslib.ndpointer(_type,
                          flags=&#39;aligned, contiguous&#39;),
                        np.ctypeslib.ndpointer(_type,
                          flags=&#39;aligned, contiguous&#39;),
                        np.ctypeslib.ndpointer(_type,
                          flags=&#39;aligned, contiguous,&#39;\
                                &#39;writeable&#39;),
                        np.ctypeslib.c_intp]</pre>


               <p>This code loads the shared library named         <code class='verbatim'>code.{ext}</code>
 located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</p>

               <p>Setting up the filtering function is similar and allows the filtering function to be called with ndarray arguments as the first two arguments and with pointers to integers (large enough to handle the strides and shape of an ndarray) as the last two arguments.:</p>

               <pre class='not-implemented'>
.. code-block:: python
    lib.dfilter2d.restype=None
    lib.dfilter2d.argtypes = [np.ctypeslib.ndpointer(float, ndim=2,
                                           flags=&#39;aligned&#39;),
                              np.ctypeslib.ndpointer(float, ndim=2,
                                     flags=&#39;aligned, contiguous,&#39;\
                                           &#39;writeable&#39;),
                              ctypes.POINTER(np.ctypeslib.c_intp),
                              ctypes.POINTER(np.ctypeslib.c_intp)]</pre>


               <p>Next, define a simple selection function that chooses which addition function to call in the shared library based on the data-type:</p>

               <pre class='not-implemented'>
.. code-block:: python
    def select(dtype):
        if dtype.char in [&#39;?bBhHf&#39;]:
            return lib.sadd, single
        elif dtype.char in [&#39;F&#39;]:
            return lib.cadd, csingle
        elif dtype.char in [&#39;DG&#39;]:
            return lib.zadd, complex
        else:
            return lib.dadd, float
        return func, ntype</pre>


               <p>Finally, the two functions to be exported by the interface can be written simply as:</p>

               <pre class='not-implemented'>
.. code-block:: python
    def add(a, b):
        requires = [&#39;CONTIGUOUS&#39;, &#39;ALIGNED&#39;]
        a = np.asanyarray(a)
        func, dtype = select(a.dtype)
        a = np.require(a, dtype, requires)
        b = np.require(b, dtype, requires)
        c = np.empty_like(a)
        func(a,b,c,a.size)
        return c</pre>


               <p>and:</p>

               <pre class='not-implemented'>
.. code-block:: python
    def filter2d(a):
        a = np.require(a, float, [&#39;ALIGNED&#39;])
        b = np.zeros_like(a)
        lib.dfilter2d(a, b, a.ctypes.strides, a.ctypes.shape)
        return b</pre>



<h1>Conclusion</h1>
               <pre class='not-implemented'>
.. index:: 
    single: ctypes</pre>


               <p>Using ctypes is a powerful way to connect Python with arbitrary C-code. Its advantages for extending Python include</p>

                          <ul>               <li>               <p>clean separation of C code from Python code</p>

                           <blockquote>           <ul>               <li>               <p>no need to learn a new syntax except Python and C</p>

</li>
               <li>               <p>allows re-use of C code</p>

</li>
               <li>               <p>functionality in shared libraries written for other purposes can be       obtained with a simple Python wrapper and search for the library.</p>

</li>
            </ul>
</blockquote>

</li>
               <li>               <p>easy integration with NumPy through the ctypes attribute</p>

</li>
               <li>               <p>full argument checking with the ndpointer class factory</p>

</li>
            </ul>

               <p>Its disadvantages include</p>

                          <ul>               <li>               <p>It is difficult to distribute an extension module made using ctypes   because of a lack of support for building shared libraries in   distutils.</p>

</li>
               <li>               <p>You must have shared-libraries of your code (no static libraries).</p>

</li>
               <li>               <p>Very little support for C++ code and its different library-calling   conventions. You will probably need a C wrapper around C++ code to use   with ctypes (or just use Boost.Python instead).</p>

</li>
            </ul>

               <p>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</p>


<h1>Additional tools you may find useful</h1>
               <p>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because of a lack of reasonable documentation (SIP, Boost). Links to these methods are not included since the most relevant can be found using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that inclusion in this list means that the package deserves attention. Information about these packages are collected here because many people have found them useful and we&#39;d like to give you as many options as possible for tackling the problem of easily integrating your code.</p>


<h1>SWIG</h1>
               <pre class='not-implemented'>
.. index:: 
    single: swig</pre>


               <p>Simplified Wrapper and Interface Generator (SWIG) is an old and fairly stable method for wrapping C/C++-libraries to a large variety of other languages. It does not specifically understand NumPy arrays but can be made usable with NumPy through the use of typemaps. There are some sample typemaps in the numpy/tools/swig directory under numpy.i together with an example module that makes use of them. SWIG excels at wrapping large C/C++ libraries because it can (almost) parse their headers and auto-produce an interface. Technically, you need to generate a         <code class='verbatim'>.i</code>
 file that defines the interface. Often, however, this         <code class='verbatim'>.i</code>
 file can be parts of the header itself. The interface usually needs a bit of tweaking to be very useful. This ability to parse C/C++ headers and auto-generate the interface still makes SWIG a useful approach to adding functionalilty from C/C++ into Python, despite the other methods that have emerged that are more targeted to Python. SWIG can actually target extensions for several languages, but the typemaps usually have to be language-specific. Nonetheless, with modifications to the Python-specific typemaps, SWIG can be used to interface a library with other languages such as Perl, Tcl, and Ruby.</p>

               <p>My experience with SWIG has been generally positive in that it is relatively easy to use and quite powerful. It has been used often before becoming more proficient at writing C-extensions. However, writing custom interfaces with SWIG is often troublesome because it must be done using the concept of typemaps which are not Python specific and are written in a C-like syntax. Therefore, other gluing strategies are preferred and SWIG would be probably considered only to wrap a very-large C/C++ library. Nonetheless, there are others who use SWIG quite happily.</p>


<h1>SIP</h1>
               <pre class='not-implemented'>
.. index:: 
    single: SIP</pre>


               <p>SIP is another tool for wrapping C/C++ libraries that is Python specific and appears to have very good support for C++. Riverbank Computing developed SIP in order to create Python bindings to the QT library. An interface file must be written to generate the binding, but the interface file looks a lot like a C/C++ header file. While SIP is not a full C++ parser, it understands quite a bit of C++ syntax as well as its own special directives that allow modification of how the Python binding is accomplished. It also allows the user to define mappings between Python types and C/C++ structures and classes.</p>


<h1>Boost Python</h1>
               <pre class='not-implemented'>
.. index:: 
    single: Boost.Python</pre>


               <p>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. Using Boost to wrap simple C-subroutines is usually over-kill. Its primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</p>


<h1>PyFort</h1>
               <p>PyFort is a nice tool for wrapping Fortran and Fortran-like C-code into Python with support for Numeric arrays. It was written by Paul Dubois, a distinguished computer scientist and the very first maintainer of Numeric (now retired). It is worth mentioning in the hopes that somebody will update PyFort to work with NumPy arrays as well which now support either Fortran or C-style contiguous arrays.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _basics.copies-and-views:&#39;&gt;</pre>

<h1>Copies and views</h1>
               <p>When operating on NumPy arrays, it is possible to access the internal data buffer directly using a         <code class='verbatim'>view &lt;view&gt;</code>
 without copying data around. This ensures good performance but can also cause unwanted problems if the user is not aware of how this works. Hence, it is important to know the difference between these two terms and to know which operations return copies and which return views.</p>

               <p>The NumPy array is a data structure consisting of two parts: the         <code class='verbatim'>contiguous</code>
 data buffer with the actual data elements and the metadata that contains information about the data buffer. The metadata includes data type, strides, and other important information that helps manipulate the         <code class='verbatim'>.ndarray</code>
 easily. See the         <code class='verbatim'>numpy-internals</code>
 section for a detailed look.</p>

                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _view:&#39;&gt;</pre>

<h1>View</h1>
               <p>It is possible to access the array differently by just changing certain metadata like         <code class='verbatim'>stride</code>
 and         <code class='verbatim'>dtype</code>
 without changing the data buffer. This creates a new way of looking at the data and these new arrays are called views. The data buffer remains the same, so any changes made to a view reflects in the original copy. A view can be forced through the         <code class='verbatim'>.ndarray.view</code>
 method.</p>


<h1>Copy</h1>
               <p>When a new array is created by duplicating the data buffer as well as the metadata, it is called a copy. Changes made to the copy do not reflect on the original array. Making a copy is slower and memory-consuming but sometimes necessary. A copy can be forced by using         <code class='verbatim'>.ndarray.copy</code>
.</p>

                          <code class='not-implemented'>Type Unimplemented (A) Not implemented yet</code>
           <pre class='not-implemented'>&lt;Unimplemented &#39;target&#39; &#39;.. _indexing-operations:&#39;&gt;</pre>

<h1>Indexing operations</h1>
               <div class='block_directive'>
    <div class='head'>.. seealso:: []
    </div>
    <pre class='not-implemented'><p>: ref : `basics.indexing` </p>
</pre>
</div>


               <p>Views are created when elements can be addressed with offsets and strides in the original array. Hence, basic indexing always creates views. For example::      </p>

               <pre>&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; y = x[1:3]  # creates a view
&gt;&gt;&gt; y
array([1, 2])
&gt;&gt;&gt; x[1:3] = [10, 11]
&gt;&gt;&gt; x
array([ 0, 10, 11,  3,  4,  5,  6,  7,  8,  9])
&gt;&gt;&gt; y
array([10, 11])</pre>
               <p>Here,         <code class='verbatim'>y</code>
 gets changed when         <code class='verbatim'>x</code>
 is changed because it is a view.</p>

               <p>        <code class='verbatim'>advanced-indexing</code>
, on the other hand, always creates copies. For example::      </p>

               <pre>&gt;&gt;&gt; x = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; y = x[[1, 2]]
&gt;&gt;&gt; y
array([[3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; y.base is None
True</pre>
               <p>Here,         <code class='verbatim'>y</code>
 is a copy, as signified by the         <code class='verbatim'>base &lt;.ndarray.base&gt;</code>
 attribute. We can also confirm this by assigning new values to         <code class='verbatim'>x[[1, 2]]</code>
 which in turn will not affect         <code class='verbatim'>y</code>
 at all::      </p>

               <pre>&gt;&gt;&gt; x[[1, 2]] = [[10, 11, 12], [13, 14, 15]]
&gt;&gt;&gt; x
array([[ 0,  1,  2],
       [10, 11, 12],
       [13, 14, 15]])
&gt;&gt;&gt; y
array([[3, 4, 5],
       [6, 7, 8]])</pre>
               <p>It must be noted here that during the assignment of         <code class='verbatim'>x[[1, 2]]</code>
 no view or copy is created as the assignment happens in-place.</p>


<h1>Other operations</h1>
               <p>The         <code class='verbatim'>numpy.reshape</code>
 function creates a view where possible or a copy otherwise. In most cases, the strides can be modified to reshape the array with a view. However, in some cases where the array becomes non-contiguous (perhaps after a         <code class='verbatim'>.ndarray.transpose</code>
 operation), the reshaping cannot be done by modifying strides and requires a copy. In these cases, we can raise an error by assigning the new shape to the shape attribute of the array. For example::      </p>

               <pre>&gt;&gt;&gt; x = np.ones((2, 3))
&gt;&gt;&gt; y = x.T  # makes the array non-contiguous
&gt;&gt;&gt; y
array([[1., 1.],
       [1., 1.],
       [1., 1.]])
&gt;&gt;&gt; z = y.view()
&gt;&gt;&gt; z.shape = 6
Traceback (most recent call last):
   ...
AttributeError: Incompatible shape for in-place modification. Use
`.reshape()` to make a copy with the desired shape.</pre>
               <p>Taking the example of another operation,         <code class='verbatim'>.ravel</code>
 returns a contiguous flattened view of the array wherever possible. On the other hand,         <code class='verbatim'>.ndarray.flatten</code>
 always returns a flattened copy of the array. However, to guarantee a view in most cases,         <code class='verbatim'>x.reshape(-1)</code>
 may be preferable.</p>


<h1>How to tell if the array is a view or a copy</h1>
               <p>The         <code class='verbatim'>base &lt;.ndarray.base&gt;</code>
 attribute of the ndarray makes it easy to tell if an array is a view or a copy. The base attribute of a view returns the original array while it returns         <code class='verbatim'>None</code>
 for a copy.</p>

                           <pre>&gt;&gt;&gt; x = np.arange(9)
&gt;&gt;&gt; x
array([0, 1, 2, 3, 4, 5, 6, 7, 8])
&gt;&gt;&gt; y = x.reshape(3, 3)
&gt;&gt;&gt; y
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; y.base  # .reshape() creates a view
array([0, 1, 2, 3, 4, 5, 6, 7, 8])
&gt;&gt;&gt; z = y[[2, 1]]
&gt;&gt;&gt; z
array([[6, 7, 8],
       [3, 4, 5]])
&gt;&gt;&gt; z.base is None  # advanced indexing creates a copy
True
</pre>


               <p>Note that the         <code class='verbatim'>base</code>
 attribute should not be used to determine if an ndarray object is <em>new</em>; only if it is a view or a copy of another ndarray.</p>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
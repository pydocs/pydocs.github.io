<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.3/api/numpy'>1.22.3</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.3/api/numpy">1.22.3</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.3/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.3/api/numpy">API</a>
                        <a href="/p/numpy/1.22.3/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.3/examples">Examples</a>
                        <a href="/p/numpy/1.22.3/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
<div class='container'>
    <div class="sidenav">
        <img src="/p/numpy/1.22.3/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.3</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







               <pre class='not-implemented'>
.. currentmodule:: numpy
    </pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.datetime:&#39;&gt;
           </pre>


<h1>Datetimes and Timedeltas</h1>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called         <code class='verbatim'>datetime64</code>
, so named because         <code class='verbatim'>~datetime.datetime</code>
 is already taken by the Python standard library.</p>


<h1>Datetime64 Conventions and Assumptions</h1>
               <p>Similar to the Python <code><a href="/p/datetime/*/api/datetime.date.html" class='exists'>date</a></code>
 class, dates are expressed in the current Gregorian Calendar, indefinitely extended both in the future and in the past.  Contrary to Python <code><a href="/p/datetime/*/api/datetime.date.html" class='exists'>date</a></code>
, which supports only years in the 1 AD — 9999 AD range, <code>:None:None:`datetime64`</code> allows also for dates BC; years BC follow the <a link href="https://en.wikipedia.org/wiki/Astronomical_year_numbering" class='external'>Astronomical
year numbering</a> convention, i.e. year 2 BC is numbered −1, year 1 BC is numbered 0, year 1 AD is numbered 1.</p>

               <p>Time instants, say 16:23:32.234, are represented counting hours, minutes, seconds and fractions from midnight: i.e. 00:00:00.000 is midnight, 12:00:00.000 is noon, etc. Each calendar day has exactly 86400 seconds. This is a &#34;naive&#34; time, with no explicit notion of timezones or specific time scales (UT1, UTC, TAI, etc.).</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;footnote&#39; &#39;.. [#] The calendar obtained by extending the Gregorian calendar before its\n       official adoption on Oct. 15, 1582 is called `Proleptic Gregorian Calendar\n       &lt;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&gt;`_&#39;&gt;
           </pre>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;footnote&#39; &#39;.. [#] The assumption of 86400 seconds per calendar day is not valid for UTC,\n       the present day civil time scale. In fact due to the presence of\n       `leap seconds &lt;https://en.wikipedia.org/wiki/Leap_second&gt;`_ on rare occasions\n       a day may be 86401 or 86399 seconds long. On the contrary the 86400s day\n       assumption holds for the TAI timescale. An explicit support for TAI and\n       TAI to UTC conversion, accounting for leap seconds, is proposed but not\n       yet implemented. See also the `shortcomings`_ section below.&#39;&gt;
           </pre>


<h1>Basic Datetimes</h1>
               <p>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. It is also possible to create datetimes from an integer by offset relative to the Unix epoch (00:00:00 UTC on 1 January 1970). The unit for internal storage is automatically selected from the form of the string, and can be either a         <code class='verbatim'>date unit &lt;arrays.dtypes.dateunits&gt;</code>
 or a         <code class='verbatim'>time unit &lt;arrays.dtypes.timeunits&gt;</code>
. The date units are years (&#39;Y&#39;), months (&#39;M&#39;), weeks (&#39;W&#39;), and days (&#39;D&#39;), while the time units are hours (&#39;h&#39;), minutes (&#39;m&#39;), seconds (&#39;s&#39;), milliseconds (&#39;ms&#39;), and some additional SI-prefix seconds-based units. The <code>:None:None:`datetime64`</code> data type also accepts the string &#34;NAT&#34;, in any combination of lowercase/uppercase letters, for a &#34;Not A Time&#34; value.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    A simple ISO date:

    &gt;&gt;&gt; np.datetime64(&#39;2005-02-25&#39;)
    numpy.datetime64(&#39;2005-02-25&#39;)

    From an integer and a date unit, 1 year since the UNIX epoch:

    &gt;&gt;&gt; np.datetime64(1, &#39;Y&#39;)
    numpy.datetime64(&#39;1971&#39;)

    Using months for the unit:

    &gt;&gt;&gt; np.datetime64(&#39;2005-02&#39;)
    numpy.datetime64(&#39;2005-02&#39;)

    Specifying just the month, but forcing a &#39;days&#39; unit:

    &gt;&gt;&gt; np.datetime64(&#39;2005-02&#39;, &#39;D&#39;)
    numpy.datetime64(&#39;2005-02-01&#39;)

    From a date and time:

    &gt;&gt;&gt; np.datetime64(&#39;2005-02-25T03:30&#39;)
    numpy.datetime64(&#39;2005-02-25T03:30&#39;)

    NAT (not a time):

    &gt;&gt;&gt; np.datetime64(&#39;nat&#39;)
    numpy.datetime64(&#39;NaT&#39;)</pre>


               <p>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.array([&#39;2007-07-13&#39;, &#39;2006-01-13&#39;, &#39;2010-08-13&#39;], dtype=&#39;datetime64&#39;)
    array([&#39;2007-07-13&#39;, &#39;2006-01-13&#39;, &#39;2010-08-13&#39;], dtype=&#39;datetime64[D]&#39;)

    &gt;&gt;&gt; np.array([&#39;2001-01-01T12:00&#39;, &#39;2002-02-03T13:56:03.172&#39;], dtype=&#39;datetime64&#39;)
    array([&#39;2001-01-01T12:00:00.000&#39;, &#39;2002-02-03T13:56:03.172&#39;],
          dtype=&#39;datetime64[ms]&#39;)</pre>


               <p>An array of datetimes can be constructed from integers representing POSIX timestamps with the given unit.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.array([0, 1577836800], dtype=&#39;datetime64[s]&#39;)
    array([&#39;1970-01-01T00:00:00&#39;, &#39;2020-01-01T00:00:00&#39;],
          dtype=&#39;datetime64[s]&#39;)

    &gt;&gt;&gt; np.array([0, 1577836800000]).astype(&#39;datetime64[ms]&#39;)
    array([&#39;1970-01-01T00:00:00.000&#39;, &#39;2020-01-01T00:00:00.000&#39;],
          dtype=&#39;datetime64[ms]&#39;)</pre>


               <p>The datetime type works with many common NumPy functions, for example         <code class='verbatim'>arange</code>
 can be used to generate ranges of dates.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    All the dates for one month:

    &gt;&gt;&gt; np.arange(&#39;2005-02&#39;, &#39;2005-03&#39;, dtype=&#39;datetime64[D]&#39;)
    array([&#39;2005-02-01&#39;, &#39;2005-02-02&#39;, &#39;2005-02-03&#39;, &#39;2005-02-04&#39;,
           &#39;2005-02-05&#39;, &#39;2005-02-06&#39;, &#39;2005-02-07&#39;, &#39;2005-02-08&#39;,
           &#39;2005-02-09&#39;, &#39;2005-02-10&#39;, &#39;2005-02-11&#39;, &#39;2005-02-12&#39;,
           &#39;2005-02-13&#39;, &#39;2005-02-14&#39;, &#39;2005-02-15&#39;, &#39;2005-02-16&#39;,
           &#39;2005-02-17&#39;, &#39;2005-02-18&#39;, &#39;2005-02-19&#39;, &#39;2005-02-20&#39;,
           &#39;2005-02-21&#39;, &#39;2005-02-22&#39;, &#39;2005-02-23&#39;, &#39;2005-02-24&#39;,
           &#39;2005-02-25&#39;, &#39;2005-02-26&#39;, &#39;2005-02-27&#39;, &#39;2005-02-28&#39;],
          dtype=&#39;datetime64[D]&#39;)</pre>


               <p>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &#39;safe&#39; cast because the moment of time is still being represented exactly.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.datetime64(&#39;2005&#39;) == np.datetime64(&#39;2005-01-01&#39;)
    True

    &gt;&gt;&gt; np.datetime64(&#39;2010-03-14T15&#39;) == np.datetime64(&#39;2010-03-14T15:00:00.00&#39;)
    True</pre>


                           <div class='admonition'>
    <div>deprecated</div>
        <p>NumPy does not store timezone information. For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC±00:00 (Zulu time). This behaviour is deprecated and will raise an error in the future.</p>

</div>



<h1>Datetime and Timedelta Arithmetic</h1>
               <p>NumPy allows the subtraction of two datetime values, an operation which produces a number with a time unit. Because NumPy doesn&#39;t have a physical quantities system in its core, the <code>:None:None:`timedelta64`</code> data type was created to complement <code>:None:None:`datetime64`</code>. The arguments for <code>:None:None:`timedelta64`</code> are a number, to represent the number of units, and a date/time unit, such as (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds. The <code>:None:None:`timedelta64`</code> data type also accepts the string &#34;NAT&#34; in place of the number for a &#34;Not A Time&#34; value.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.timedelta64(1, &#39;D&#39;)
    numpy.timedelta64(1,&#39;D&#39;)

    &gt;&gt;&gt; np.timedelta64(4, &#39;h&#39;)
    numpy.timedelta64(4,&#39;h&#39;)

    &gt;&gt;&gt; np.timedelta64(&#39;nAt&#39;)
    numpy.timedelta64(&#39;NaT&#39;)</pre>


               <p>Datetimes and Timedeltas work together to provide ways for simple datetime calculations.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.datetime64(&#39;2009-01-01&#39;) - np.datetime64(&#39;2008-01-01&#39;)
    numpy.timedelta64(366,&#39;D&#39;)

    &gt;&gt;&gt; np.datetime64(&#39;2009&#39;) + np.timedelta64(20, &#39;D&#39;)
    numpy.datetime64(&#39;2009-01-21&#39;)

    &gt;&gt;&gt; np.datetime64(&#39;2011-06-15T00:00&#39;) + np.timedelta64(12, &#39;h&#39;)
    numpy.datetime64(&#39;2011-06-15T12:00&#39;)

    &gt;&gt;&gt; np.timedelta64(1,&#39;W&#39;) / np.timedelta64(1,&#39;D&#39;)
    7.0

    &gt;&gt;&gt; np.timedelta64(1,&#39;W&#39;) % np.timedelta64(10,&#39;D&#39;)
    numpy.timedelta64(7,&#39;D&#39;)

    &gt;&gt;&gt; np.datetime64(&#39;nat&#39;) - np.datetime64(&#39;2009-01-01&#39;)
    numpy.timedelta64(&#39;NaT&#39;,&#39;D&#39;)

    &gt;&gt;&gt; np.datetime64(&#39;2009-01-01&#39;) + np.timedelta64(&#39;nat&#39;)
    numpy.datetime64(&#39;NaT&#39;)</pre>


               <p>There are two Timedelta units (&#39;Y&#39;, years and &#39;M&#39;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; a = np.timedelta64(1, &#39;Y&#39;)

    &gt;&gt;&gt; np.timedelta64(a, &#39;M&#39;)
    numpy.timedelta64(12,&#39;M&#39;)

    &gt;&gt;&gt; np.timedelta64(a, &#39;D&#39;)
    Traceback (most recent call last):
      File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
    TypeError: Cannot cast NumPy timedelta64 scalar from metadata [Y] to [D] according to the rule &#39;same_kind&#39;</pre>



<h1>Datetime Units</h1>
               <p>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</p>

               <p>Datetimes are always stored with an epoch of 1970-01-01T00:00. This means the supported dates are always a symmetric interval around the epoch, called &#34;time span&#34; in the table below.</p>

               <p>The length of the span is the range of a 64-bit integer times the length of the date or unit.  For example, the time span for &#39;W&#39; (week) is exactly 7 times longer than the time span for &#39;D&#39; (day), and the time span for &#39;D&#39; (day) is exactly 24 times longer than the time span for &#39;h&#39; (hour).</p>

               <p>Here are the date units:</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _arrays.dtypes.dateunits:&#39;&gt;
           </pre>

               <!-- deflist -->
           <dl>
               <dt><p>======== ================ ======================= ==========================</p>
</dt>
               <dd><p>Code       Meaning       Time span (relative)    Time span (absolute)</p>
</dd>
               <dt><p>======== ================ ======================= ==========================</p>
</dt>
               <dd><p>Y       year             +/- 9.2e18 years        [9.2e18 BC, 9.2e18 AD]    M       month            +/- 7.6e17 years        [7.6e17 BC, 7.6e17 AD]    W       week             +/- 1.7e17 years        [1.7e17 BC, 1.7e17 AD]    D       day              +/- 2.5e16 years        [2.5e16 BC, 2.5e16 AD]</p>
</dd>
               <dt><p>======== ================ ======================= ==========================  And here are the time units:  .. _arrays.dtypes.timeunits:  ======== ================ ======================= ==========================</p>
</dt>
               <dd><p>Code       Meaning       Time span (relative)    Time span (absolute)</p>
</dd>
               <dt><p>======== ================ ======================= ==========================</p>
</dt>
               <dd><p>h       hour             +/- 1.0e15 years        [1.0e15 BC, 1.0e15 AD]    m       minute           +/- 1.7e13 years        [1.7e13 BC, 1.7e13 AD]    s       second           +/- 2.9e11 years        [2.9e11 BC, 2.9e11 AD]    ms      millisecond      +/- 2.9e8 years         [ 2.9e8 BC,  2.9e8 AD]</p>
</dd>
               <dt><p>us / μs    microsecond      +/- 2.9e5 years         [290301 BC, 294241 AD]</p>
</dt>
               <dd><p>ns      nanosecond       +/- 292 years           [  1678 AD,   2262 AD]    ps      picosecond       +/- 106 days            [  1969 AD,   1970 AD]    fs      femtosecond      +/- 2.6 hours           [  1969 AD,   1970 AD]    as      attosecond       +/- 9.2 seconds         [  1969 AD,   1970 AD]</p>
</dd>
               <dt><p>======== ================ ======================= ==========================  Business Day Functionality ==========================  To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &#34;busday&#34; (business day) functions.  The default for busday functions is that the only valid days are Monday through Friday (the usual business days).  The implementation is based on a &#34;weekmask&#34; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.  The &#34;busday&#34; functions can additionally check a list of &#34;holiday&#34; dates, specific dates that are not valid days.  The function         <code class='verbatim'>busday_offset</code>
 allows you to apply offsets specified in business days to datetimes with a unit of &#39;D&#39; (day).  .. admonition:: Example</p>
</dt>
               <dd><pre>&gt;&gt;&gt; np.busday_offset(&#39;2011-06-23&#39;, 1)
numpy.datetime64(&#39;2011-06-24&#39;)</pre><pre>&gt;&gt;&gt; np.busday_offset(&#39;2011-06-23&#39;, 2)
numpy.datetime64(&#39;2011-06-27&#39;)</pre></dd>
           </dl>

               <p>When an input date falls on the weekend or a holiday,         <code class='verbatim'>busday_offset</code>
 first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &#39;raise&#39;, which simply raises an exception. The rules most typically used are &#39;forward&#39; and &#39;backward&#39;.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.busday_offset(&#39;2011-06-25&#39;, 2)
    Traceback (most recent call last):
      File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
    ValueError: Non-business day date in busday_offset

    &gt;&gt;&gt; np.busday_offset(&#39;2011-06-25&#39;, 0, roll=&#39;forward&#39;)
    numpy.datetime64(&#39;2011-06-27&#39;)

    &gt;&gt;&gt; np.busday_offset(&#39;2011-06-25&#39;, 2, roll=&#39;forward&#39;)
    numpy.datetime64(&#39;2011-06-29&#39;)

    &gt;&gt;&gt; np.busday_offset(&#39;2011-06-25&#39;, 0, roll=&#39;backward&#39;)
    numpy.datetime64(&#39;2011-06-24&#39;)

    &gt;&gt;&gt; np.busday_offset(&#39;2011-06-25&#39;, 2, roll=&#39;backward&#39;)
    numpy.datetime64(&#39;2011-06-28&#39;)</pre>


               <p>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    The first business day on or after a date:

    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-20&#39;, 0, roll=&#39;forward&#39;)
    numpy.datetime64(&#39;2011-03-21&#39;)
    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-22&#39;, 0, roll=&#39;forward&#39;)
    numpy.datetime64(&#39;2011-03-22&#39;)

    The first business day strictly after a date:

    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-20&#39;, 1, roll=&#39;backward&#39;)
    numpy.datetime64(&#39;2011-03-21&#39;)
    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-22&#39;, 1, roll=&#39;backward&#39;)
    numpy.datetime64(&#39;2011-03-23&#39;)</pre>


               <p>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&#39;s day is on the second Sunday in May, which can be computed with a custom weekmask.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.busday_offset(&#39;2012-05&#39;, 1, roll=&#39;forward&#39;, weekmask=&#39;Sun&#39;)
    numpy.datetime64(&#39;2012-05-13&#39;)</pre>


               <p>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object         <code class='verbatim'>busdaycalendar</code>
 which stores the data necessary in an optimized form.</p>


<h1>np.is_busday():</h1>
               <p>To test a <code>:None:None:`datetime64`</code> value to see if it is a valid day, use         <code class='verbatim'>is_busday</code>
.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.is_busday(np.datetime64(&#39;2011-07-15&#39;))  # a Friday
    True
    &gt;&gt;&gt; np.is_busday(np.datetime64(&#39;2011-07-16&#39;)) # a Saturday
    False
    &gt;&gt;&gt; np.is_busday(np.datetime64(&#39;2011-07-16&#39;), weekmask=&#34;Sat Sun&#34;)
    True
    &gt;&gt;&gt; a = np.arange(np.datetime64(&#39;2011-07-11&#39;), np.datetime64(&#39;2011-07-18&#39;))
    &gt;&gt;&gt; np.is_busday(a)
    array([ True,  True,  True,  True,  True, False, False])</pre>



<h1>np.busday_count():</h1>
               <p>To find how many valid days there are in a specified range of datetime64 dates, use         <code class='verbatim'>busday_count</code>
:</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; np.busday_count(np.datetime64(&#39;2011-07-11&#39;), np.datetime64(&#39;2011-07-18&#39;))
    5
    &gt;&gt;&gt; np.busday_count(np.datetime64(&#39;2011-07-18&#39;), np.datetime64(&#39;2011-07-11&#39;))
    -5</pre>


               <p>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &gt;&gt;&gt; a = np.arange(np.datetime64(&#39;2011-07-11&#39;), np.datetime64(&#39;2011-07-18&#39;))
    &gt;&gt;&gt; np.count_nonzero(np.is_busday(a))
    5</pre>



<h1>Custom Weekmasks</h1>
               <p>Here are several examples of custom weekmask values.  These examples specify the &#34;busday&#34; default of Monday through Friday being valid days.</p>

               <p>Some examples::      </p>

               <pre># Positional sequences; positions are Monday through Sunday.
# Length of the sequence must be exactly 7.
weekmask = [1, 1, 1, 1, 1, 0, 0]
# list or other sequence; 0 == invalid day, 1 == valid day
weekmask = &#34;1111100&#34;
# string &#39;0&#39; == invalid day, &#39;1&#39; == valid day

# string abbreviations from this list: Mon Tue Wed Thu Fri Sat Sun
weekmask = &#34;Mon Tue Wed Thu Fri&#34;
# any amount of whitespace is allowed; abbreviations are case-sensitive.
weekmask = &#34;MonTue Wed  Thu\tFri&#34;</pre>
                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _shortcomings:&#39;&gt;
           </pre>


<h1>Datetime64 shortcomings</h1>
               <p>The assumption that all days are exactly 86400 seconds long makes <code>:None:None:`datetime64`</code> largely compatible with Python <code><a href="/p/datetime/*/api/datetime.html" class='exists'>datetime</a></code>
 and &#34;POSIX time&#34; semantics; therefore they all share the same well known shortcomings with respect to the UTC timescale and historical time determination. A brief non exhaustive summary is given below.</p>

                          <ul>               <li>               <p>It is impossible to parse valid UTC timestamps occurring during a positive   leap second.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    &#34;2016-12-31 23:59:60 UTC&#34; was a leap second, therefore &#34;2016-12-31
      23:59:60.450 UTC&#34; is a valid timestamp which is not parseable by
      `datetime64`:

        &gt;&gt;&gt; np.datetime64(&#34;2016-12-31 23:59:60.450&#34;)
        Traceback (most recent call last):
          File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
        ValueError: Seconds out of range in datetime string &#34;2016-12-31 23:59:60.450&#34;</pre>


</li>
            </ul>

                          <ul>               <li>               <p>Timedelta64 computations between two UTC dates can be wrong by an integer   number of SI seconds.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    Compute the number of SI seconds between &#34;2021-01-01 12:56:23.423 UTC&#34; and
      &#34;2001-01-01 00:00:00.000 UTC&#34;:

        &gt;&gt;&gt; (
        ...   np.datetime64(&#34;2021-01-01 12:56:23.423&#34;)
        ...   - np.datetime64(&#34;2001-01-01&#34;)
        ... ) / np.timedelta64(1, &#34;s&#34;)
        631198583.423

      however correct answer is `631198588.423` SI seconds because there were 5
      leap seconds between 2001 and 2021.</pre>


</li>
            </ul>

                          <ul>               <li>               <p>Timedelta64 computations for dates in the past do not return SI seconds, as   one would expect.</p>

               <pre class='not-implemented'>
.. admonition:: Example
    Compute the number of seconds between &#34;000-01-01 UT&#34; and &#34;1600-01-01 UT&#34;,
      where UT is `universal time
      &lt;https://en.wikipedia.org/wiki/Universal_Time&gt;`_:

       &gt;&gt;&gt; a = np.datetime64(&#34;0000-01-01&#34;, &#34;us&#34;)
       &gt;&gt;&gt; b = np.datetime64(&#34;1600-01-01&#34;, &#34;us&#34;)
       &gt;&gt;&gt; b - a
       numpy.timedelta64(50491123200000000,&#39;us&#39;)

      The computed results, `50491123200` seconds, is obtained as the elapsed
      number of days (`584388`) times `86400` seconds; this is the number of
      seconds of a clock in sync with earth rotation. The exact value in SI
      seconds can only be estimated, e.g using data published in `Measurement of
      the Earth&#39;s rotation: 720 BC to AD 2015, 2016, Royal Society&#39;s Proceedings
      A 472, by Stephenson et.al. &lt;https://doi.org/10.1098/rspa.2016.0404&gt;`_. A
      sensible estimate is `50491112870 ± 90` seconds, with a difference of 10330
      seconds.</pre>


</li>
            </ul>


<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
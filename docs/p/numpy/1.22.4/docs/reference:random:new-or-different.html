<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.4/api/numpy'>1.22.4</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.4/api/numpy">1.22.4</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.4/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.4/api/numpy">API</a>
                        <a href="/p/numpy/1.22.4/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.4/examples">Examples</a>
                        <a href="/p/numpy/1.22.4/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.4/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.4</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _new-or-different:&#39;&gt;
           </pre>

               <pre class='not-implemented'>
.. currentmodule:: numpy.random
    </pre>



<h1>What&#39;s New or Different</h1>
                           <div class='admonition'>
    <div>warning</div>
        <p>The Box-Muller method used to produce NumPy&#39;s normals is no longer available in <code class='not-implemented'>:None:None:`Generator`</code>.  It is not possible to reproduce the exact random values using         <code class='verbatim'>Generator</code>
 for the normal distribution or any other distribution that relies on the normal such as the <code class='not-implemented'>:None:None:`Generator.gamma`</code> or <code class='not-implemented'>:None:None:`Generator.standard_t`</code>. If you require bitwise backward compatible streams, use <code class='not-implemented'>:None:None:`RandomState`</code>, i.e., <code class='not-implemented'>:None:None:`RandomState.gamma`</code> or <code class='not-implemented'>:None:None:`RandomState.standard_t`</code>.</p>

</div>


               <p>Quick comparison of legacy         <code class='verbatim'>mtrand &lt;legacy&gt;</code>
 to the new <code class='not-implemented'>:None:None:`Generator`</code></p>

               <p>================== ==================== ============= Feature            Older Equivalent     Notes ------------------ -------------------- ------------- <code class='not-implemented'>:None:None:`~.Generator`</code>      <code class='not-implemented'>:None:None:`~.RandomState`</code>              <code class='verbatim'>Generator</code>
 requires a stream                                         source, called a <code class='not-implemented'>:None:None:`BitGenerator`</code>                                         A number of these are provided.                                                 <code class='verbatim'>RandomState</code>
 uses                                         the Mersenne Twister <code class='not-implemented'>:None:None:`~.MT19937`</code> by                                         default, but can also be instantiated                                         with any BitGenerator. ------------------ -------------------- -------------         <code class='verbatim'>random</code>
                 <code class='verbatim'>random_sample</code>
,   Access the values in a BitGenerator,                            <code class='verbatim'>rand</code>
             convert them to         <code class='verbatim'>float64</code>
 in the                                         interval         <code class='verbatim'>[0.0.,</code>
 `` 1.0)``.                                         In addition to the         <code class='verbatim'>size</code>
 kwarg, now                                         supports         <code class='verbatim'>dtype=&#39;d&#39;</code>
 or         <code class='verbatim'>dtype=&#39;f&#39;</code>
,                                         and an         <code class='verbatim'>out</code>
 kwarg to fill a user-                                         supplied array.</p>

                           <blockquote><p>Many other distributions are also                                         supported.</p>
</blockquote>

               <p>------------------ -------------------- -------------         <code class='verbatim'>integers</code>
               <code class='verbatim'>randint</code>
,         Use the         <code class='verbatim'>endpoint</code>
 kwarg to adjust                            <code class='verbatim'>random_integers</code>
  the inclusion or exclusion of the                                                 <code class='verbatim'>high</code>
 interval endpoint ================== ==================== =============</p>

               <p>And in more detail:</p>

                          <ul>               <li>               <p>Simulate from the complex normal distribution   (<code class='not-implemented'>:None:None:`~.Generator.complex_normal`</code>)</p>

</li>
               <li>               <p>The normal, exponential and gamma generators use 256-step Ziggurat   methods which are 2-10 times faster than NumPy&#39;s default implementation in   <code class='not-implemented'>:None:None:`~.Generator.standard_normal`</code>, <code class='not-implemented'>:None:None:`~.Generator.standard_exponential`</code> or   <code class='not-implemented'>:None:None:`~.Generator.standard_gamma`</code>.</p>

</li>
            </ul>

               <pre class='not-implemented'>
.. ipython:: python
    from  numpy.random import Generator, PCG64
    import numpy.random
    rng = Generator(PCG64())
    %timeit -n 1 rng.standard_normal(100000)
    %timeit -n 1 numpy.random.standard_normal(100000)</pre>


               <pre class='not-implemented'>
.. ipython:: python
    %timeit -n 1 rng.standard_exponential(100000)
    %timeit -n 1 numpy.random.standard_exponential(100000)</pre>


               <pre class='not-implemented'>
.. ipython:: python
    %timeit -n 1 rng.standard_gamma(3.0, 100000)
    %timeit -n 1 numpy.random.standard_gamma(3.0, 100000)</pre>


                          <ul>               <li>               <p><code class='not-implemented'>:None:None:`~.Generator.integers`</code> is now the canonical way to generate integer   random numbers from a discrete uniform distribution. The         <code class='verbatim'>rand</code>
 and           <code class='verbatim'>randn</code>
 methods are only available through the legacy <code class='not-implemented'>:None:None:`~.RandomState`</code>.   This replaces both         <code class='verbatim'>randint</code>
 and the deprecated         <code class='verbatim'>random_integers</code>
.</p>

</li>
               <li>               <p>The Box-Muller method used to produce NumPy&#39;s normals is no longer available.</p>

</li>
               <li>               <p>All bit generators can produce doubles, uint64s and   uint32s via CTypes (<code class='not-implemented'>:None:None:`~PCG64.ctypes`</code>) and CFFI (<code class='not-implemented'>:None:None:`~PCG64.cffi`</code>).   This allows these bit generators to be used in numba.</p>

</li>
               <li>               <p>The bit generators can be used in downstream projects via   Cython.</p>

</li>
               <li>               <p>Optional         <code class='verbatim'>dtype</code>
 argument that accepts         <code class='verbatim'>np.float32</code>
 or         <code class='verbatim'>np.float64</code>
   to produce either single or double precision uniform random variables for   select distributions</p>

                          <ul>               <li>               <p>Uniforms (<code class='not-implemented'>:None:None:`~.Generator.random`</code> and <code class='not-implemented'>:None:None:`~.Generator.integers`</code>)</p>

</li>
               <li>               <p>Normals (<code class='not-implemented'>:None:None:`~.Generator.standard_normal`</code>)</p>

</li>
               <li>               <p>Standard Gammas (<code class='not-implemented'>:None:None:`~.Generator.standard_gamma`</code>)</p>

</li>
               <li>               <p>Standard Exponentials (<code class='not-implemented'>:None:None:`~.Generator.standard_exponential`</code>)</p>

</li>
            </ul>

</li>
            </ul>

               <pre class='not-implemented'>
.. ipython:: python
    rng = Generator(PCG64(0))
    rng.random(3, dtype=&#39;d&#39;)
    rng.random(3, dtype=&#39;f&#39;)</pre>


                          <ul>               <li>               <p>Optional         <code class='verbatim'>out</code>
 argument that allows existing arrays to be filled for   select distributions</p>

                          <ul>               <li>               <p>Uniforms (<code class='not-implemented'>:None:None:`~.Generator.random`</code>)</p>

</li>
               <li>               <p>Normals (<code class='not-implemented'>:None:None:`~.Generator.standard_normal`</code>)</p>

</li>
               <li>               <p>Standard Gammas (<code class='not-implemented'>:None:None:`~.Generator.standard_gamma`</code>)</p>

</li>
               <li>               <p>Standard Exponentials (<code class='not-implemented'>:None:None:`~.Generator.standard_exponential`</code>)</p>

</li>
            </ul>

               <p>This allows multithreading to fill large arrays in chunks using suitable   BitGenerators in parallel.</p>

</li>
            </ul>

               <pre class='not-implemented'>
.. ipython:: python
    existing = np.zeros(4)
    rng.random(out=existing[:2])
    print(existing)</pre>


                          <ul>               <li>               <p>Optional         <code class='verbatim'>axis</code>
 argument for methods like <code class='not-implemented'>:None:None:`~.Generator.choice`</code>,   <code class='not-implemented'>:None:None:`~.Generator.permutation`</code> and <code class='not-implemented'>:None:None:`~.Generator.shuffle`</code> that controls which   axis an operation is performed over for multi-dimensional arrays.</p>

</li>
            </ul>

               <pre class='not-implemented'>
.. ipython:: python
    rng = Generator(PCG64(123456789))
    a = np.arange(12).reshape((3, 4))
    a
    rng.choice(a, axis=1, size=5)
    rng.shuffle(a, axis=1)        # Shuffle in-place
    a</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
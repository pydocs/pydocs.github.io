<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.4/api/numpy'>1.22.4</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.4/api/numpy">1.22.4</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.4/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.4/api/numpy">API</a>
                        <a href="/p/numpy/1.22.4/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.4/examples">Examples</a>
                        <a href="/p/numpy/1.22.4/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.4/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.4</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







<h1>Array API</h1>
               <pre class='not-implemented'>
.. sectionauthor:: Travis E. Oliphant
    </pre>


               <pre class='not-implemented'>
.. index:: 
    pair: ndarray; C-API
    pair: C-API; array</pre>



<h2>Array structure and data access</h2>
               <p>These macros access the         <code class='verbatim'>PyArrayObject</code>
 structure members and are defined in         <code class='verbatim'>ndarraytypes.h</code>
. The input argument, <em>arr</em>, can be any         <code class='verbatim'>PyObject *</code>
 that is directly interpretable as a         <code class='verbatim'>PyArrayObject *</code>
 (any instance of the         <code class='verbatim'>PyArray_Type</code>
 and its sub-types).</p>

               <pre class='not-implemented'>
.. c:function:: int PyArray_NDIM(PyArrayObject *arr)
    The number of dimensions in the array.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_FLAGS(PyArrayObject* arr)
    Returns an integer representing the :ref:`array-flags&lt;array-flags&gt;`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_TYPE(PyArrayObject* arr)
    Return the (builtin) typenumber for the elements of this array.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_SETITEM( \
    PyArrayObject* arr, void* itemptr, PyObject* obj)</pre>


                           <blockquote><p>Convert obj and place it in the ndarray, <em>arr</em>, at the place     pointed to by itemptr. Return -1 if an error occurs or 0 on     success.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_ENABLEFLAGS(PyArrayObject* arr, int flags)
    .. versionadded:: 1.7

    Enables the specified array flags. This function does no validation,
    and assumes that you know what you&#39;re doing.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_CLEARFLAGS(PyArrayObject* arr, int flags)
    .. versionadded:: 1.7

    Clears the specified array flags. This function does no validation,
    and assumes that you know what you&#39;re doing.</pre>


               <pre class='not-implemented'>
.. c:function:: void *PyArray_DATA(PyArrayObject *arr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: char *PyArray_BYTES(PyArrayObject *arr)
    These two macros are similar and obtain the pointer to the
    data-buffer for the array. The first macro can (and should be)
    assigned to a particular pointer where the second is for generic
    processing. If you have not guaranteed a contiguous and/or aligned
    array then be sure you understand how to access the data in the
    array to avoid memory and/or alignment problems.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp *PyArray_DIMS(PyArrayObject *arr)
    Returns a pointer to the dimensions/shape of the array. The
    number of elements matches the number of dimensions
    of the array. Can return ``NULL`` for 0-dimensional arrays.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp *PyArray_SHAPE(PyArrayObject *arr)
    .. versionadded:: 1.7

    A synonym for :c:func:`PyArray_DIMS`, named to be consistent with the
    `shape &lt;numpy.ndarray.shape&gt;` usage within Python.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp *PyArray_STRIDES(PyArrayObject* arr)
    Returns a pointer to the strides of the array. The
    number of elements matches the number of dimensions
    of the array.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_DIM(PyArrayObject* arr, int n)
    Return the shape in the *n* :math:`^{\textrm{th}}` dimension.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_STRIDE(PyArrayObject* arr, int n)
    Return the stride in the *n* :math:`^{\textrm{th}}` dimension.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_ITEMSIZE(PyArrayObject* arr)
    Return the itemsize for the elements of this array.

    Note that, in the old API that was deprecated in version 1.7, this function
    had the return type ``int``.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_SIZE(PyArrayObject* arr)
    Returns the total size (in number of elements) of the array.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_Size(PyArrayObject* obj)
    Returns 0 if *obj* is not a sub-class of ndarray. Otherwise,
    returns the total number of elements in the array. Safer version
    of :c:func:`PyArray_SIZE` (*obj*).</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_NBYTES(PyArrayObject* arr)
    Returns the total number of bytes consumed by the array.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject *PyArray_BASE(PyArrayObject* arr)
    This returns the base object of the array. In most cases, this
    means the object which owns the memory the array is pointing at.

    If you are constructing an array using the C API, and specifying
    your own memory, you should use the function :c:func:`PyArray_SetBaseObject`
    to set the base to an object which owns the memory.

    If the :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag is set, it has a different
    meaning, namely base is the array into which the current array will
    be copied upon copy resolution. This overloading of the base property
    for two functions is likely to change in a future version of NumPy.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr *PyArray_DESCR(PyArrayObject* arr)
    Returns a borrowed reference to the dtype property of the array.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr *PyArray_DTYPE(PyArrayObject* arr)
    .. versionadded:: 1.7

    A synonym for PyArray_DESCR, named to be consistent with the
    &#39;dtype&#39; usage within Python.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject *PyArray_GETITEM(PyArrayObject* arr, void* itemptr)
    Get a Python object of a builtin type from the ndarray, *arr*,
    at the location pointed to by itemptr. Return ``NULL`` on failure.

    `numpy.ndarray.item` is identical to PyArray_GETITEM.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_FinalizeFunc(PyArrayObject* arr, PyObject* obj)
    The function pointed to by the CObject
    :obj:`~numpy.class.__array_finalize__`.
    The first argument is the newly created sub-type. The second argument
    (if not NULL) is the &#34;parent&#34; array (if the array was created using
    slicing or some other operation where a clearly-distinguishable parent
    is present). This routine can do anything it wants to. It should
    return a -1 on error and 0 otherwise.</pre>



<h3>Data access</h3>
               <p>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using         <code class='verbatim'>PyArray_FromAny</code>
. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</p>

               <pre class='not-implemented'>
.. c:function:: void* PyArray_GetPtr(PyArrayObject* aobj, npy_intp* ind)
    Return a pointer to the data of the ndarray, *aobj*, at the
    N-dimensional index given by the c-array, *ind*, (which must be
    at least *aobj* -&gt;nd in size). You may want to typecast the
    returned pointer to the data type of the ndarray.</pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_GETPTR1(PyArrayObject* obj, npy_intp i)
    </pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_GETPTR2( \
    PyArrayObject* obj, npy_intp i, npy_intp j)</pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_GETPTR3( \
    PyArrayObject* obj, npy_intp i, npy_intp j, npy_intp k)</pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_GETPTR4( \
    PyArrayObject* obj, npy_intp i, npy_intp j, npy_intp k, npy_intp l)</pre>


                           <blockquote><p>Quick, inline access to the element at the given coordinates in     the ndarray, <em>obj</em>, which must have respectively 1, 2, 3, or 4     dimensions (this is not checked). The corresponding <em>i</em>, <em>j</em>,     <em>k</em>, and <em>l</em> coordinates can be any integer but will be     interpreted as         <code class='verbatim'>npy_intp</code>
. You may want to typecast the     returned pointer to the data type of the ndarray.</p>
</blockquote>


<h2>Creating arrays</h2>

<h3>From scratch</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_NewFromDescr( \
    PyTypeObject* subtype, PyArray_Descr* descr, int nd, npy_intp const* dims, \
    npy_intp const* strides, void* data, int flags, PyObject* obj)</pre>


                           <blockquote><p>This function steals a reference to <em>descr</em>. The easiest way to get one     is using         <code class='verbatim'>PyArray_DescrFromType</code>
.</p>
<p>This is the main array creation function. Most new arrays are     created with this flexible function.</p>
<p>The returned object is an object of Python-type <em>subtype</em>, which     must be a subtype of         <code class='verbatim'>PyArray_Type</code>
.  The array has <em>nd</em>     dimensions, described by <em>dims</em>. The data-type descriptor of the     new array is <em>descr</em>.</p>
<p>If <em>subtype</em> is of an array subclass instead of the base             <code class='verbatim'>&amp;PyArray_Type&lt;PyArray_Type&gt;</code>
, then <em>obj</em> is the object to pass to     the         <code class='verbatim'>~numpy.class.__array_finalize__</code>
 method of the subclass.</p>
<p>If <em>data</em> is         <code class='verbatim'>NULL</code>
, then new unitinialized memory will be allocated and     <em>flags</em> can be non-zero to indicate a Fortran-style contiguous array. Use             <code class='verbatim'>PyArray_FILLWBYTE</code>
 to initialize the memory.</p>
<p>If <em>data</em> is not         <code class='verbatim'>NULL</code>
, then it is assumed to point to the memory     to be used for the array and the <em>flags</em> argument is used as the     new flags for the array (except the state of         <code class='verbatim'>NPY_ARRAY_OWNDATA</code>
,             <code class='verbatim'>NPY_ARRAY_WRITEBACKIFCOPY</code>
 flag of the new array will be reset).</p>
<p>In addition, if <em>data</em> is non-NULL, then <em>strides</em> can     also be provided. If <em>strides</em> is         <code class='verbatim'>NULL</code>
, then the array strides     are computed as C-style contiguous (default) or Fortran-style     contiguous (<em>flags</em> is nonzero for <em>data</em> =         <code class='verbatim'>NULL</code>
 or <em>flags</em> &amp;             <code class='verbatim'>NPY_ARRAY_F_CONTIGUOUS</code>
 is nonzero non-NULL <em>data</em>). Any     provided <em>dims</em> and <em>strides</em> are copied into newly allocated     dimension and strides arrays for the new array object.</p>
<p>        <code class='verbatim'>PyArray_CheckStrides</code>
 can help verify non-         <code class='verbatim'>NULL</code>
 stride     information.</p>
<p>If         <code class='verbatim'>data</code>
 is provided, it must stay alive for the life of the array. One     way to manage this is through         <code class='verbatim'>PyArray_SetBaseObject</code>
</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_NewLikeArray( \
    PyArrayObject* prototype, NPY_ORDER order, PyArray_Descr* descr, \
    int subok)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>This function steals a reference to <em>descr</em> if it is not NULL.     This array creation routine allows for the convenient creation of     a new array matching an existing array&#39;s shapes and memory layout,     possibly changing the layout and/or data type.</p>
<p>When <em>order</em> is         <code class='verbatim'>NPY_ANYORDER</code>
, the result order is             <code class='verbatim'>NPY_FORTRANORDER</code>
 if <em>prototype</em> is a fortran array,             <code class='verbatim'>NPY_CORDER</code>
 otherwise.  When <em>order</em> is             <code class='verbatim'>NPY_KEEPORDER</code>
, the result order matches that of <em>prototype</em>, even     when the axes of <em>prototype</em> aren&#39;t in C or Fortran order.</p>
<p>If <em>descr</em> is NULL, the data type of <em>prototype</em> is used.</p>
<p>If <em>subok</em> is 1, the newly created array will use the sub-type of     <em>prototype</em> to create the new array, otherwise it will create a     base-class array.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_New( \
    PyTypeObject* subtype, int nd, npy_intp const* dims, int type_num, \
    npy_intp const* strides, void* data, int itemsize, int flags, \
    PyObject* obj)</pre>


                           <blockquote><p>This is similar to         <code class='verbatim'>PyArray_NewFromDescr</code>
 (...) except you     specify the data-type descriptor with <em>type_num</em> and <em>itemsize</em>,     where <em>type_num</em> corresponds to a builtin (or user-defined)     type. If the type always has the same number of bytes, then     itemsize is ignored. Otherwise, itemsize specifies the particular     size of this array.</p>
</blockquote>

                           <div class='admonition'>
    <div>warning</div>
        <p>If data is passed to <code class='not-implemented'>:c:func:`PyArray_NewFromDescr`</code> or <code class='not-implemented'>:c:func:`PyArray_New`</code>, this memory must not be deallocated until the new array is deleted.  If this data came from another Python object, this can be accomplished using <code class='not-implemented'>:c:func:`Py_INCREF`</code> on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_SimpleNew(int nd, npy_intp const* dims, int typenum)
    Create a new uninitialized array of type, *typenum*, whose size in
    each of *nd* dimensions is given by the integer array, *dims*.The memory
    for the array is uninitialized (unless typenum is :c:data:`NPY_OBJECT`
    in which case each element in the array is set to NULL). The
    *typenum* argument allows specification of any of the builtin
    data-types such as :c:data:`NPY_FLOAT` or :c:data:`NPY_LONG`. The
    memory for the array can be set to zero if desired using
    :c:func:`PyArray_FILLWBYTE` (return_object, 0).This function cannot be
    used to create a flexible-type array (no itemsize given).</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_SimpleNewFromData( \
    int nd, npy_intp const* dims, int typenum, void* data)</pre>


                           <blockquote><p>Create an array wrapper around <em>data</em> pointed to by the given     pointer. The array flags will have a default that the data area is     well-behaved and C-style contiguous. The shape of the array is     given by the <em>dims</em> c-array of length <em>nd</em>. The data-type of the     array is indicated by <em>typenum</em>. If data comes from another     reference-counted Python object, the reference count on this object     should be increased after the pointer is passed in, and the base member     of the returned ndarray should point to the Python object that owns     the data. This will ensure that the provided memory is not     freed while the returned array is in existence.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_SimpleNewFromDescr( \
    int nd, npy_int const* dims, PyArray_Descr* descr)</pre>


                           <blockquote><p>This function steals a reference to <em>descr</em>.</p>
<p>Create a new array with the provided data-type descriptor, <em>descr</em>,     of the shape determined by <em>nd</em> and <em>dims</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_FILLWBYTE(PyObject* obj, int val)
    Fill the array pointed to by *obj* ---which must be a (subclass
    of) ndarray---with the contents of *val* (evaluated as a byte).
    This macro calls memset, so obj must be contiguous.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Zeros( \
    int nd, npy_intp const* dims, PyArray_Descr* dtype, int fortran)</pre>


                           <blockquote><p>Construct a new <em>nd</em> -dimensional array with shape given by <em>dims</em>     and data type given by <em>dtype</em>. If <em>fortran</em> is non-zero, then a     Fortran-order array is created, otherwise a C-order array is     created. Fill the memory with zeros (or the 0 object if <em>dtype</em>     corresponds to         <code class='verbatim'>NPY_OBJECT</code>
 ).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ZEROS( \
    int nd, npy_intp const* dims, int type_num, int fortran)</pre>


                           <blockquote><p>Macro form of         <code class='verbatim'>PyArray_Zeros</code>
 which takes a type-number instead     of a data-type object.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Empty( \
    int nd, npy_intp const* dims, PyArray_Descr* dtype, int fortran)</pre>


                           <blockquote><p>Construct a new <em>nd</em> -dimensional array with shape given by <em>dims</em>     and data type given by <em>dtype</em>. If <em>fortran</em> is non-zero, then a     Fortran-order array is created, otherwise a C-order array is     created. The array is uninitialized unless the data type     corresponds to         <code class='verbatim'>NPY_OBJECT</code>
 in which case the array is     filled with         <code class='verbatim'>Py_None</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_EMPTY( \
    int nd, npy_intp const* dims, int typenum, int fortran)</pre>


                           <blockquote><p>Macro form of         <code class='verbatim'>PyArray_Empty</code>
 which takes a type-number,     <em>typenum</em>, instead of a data-type object.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Arange( \
    double start, double stop, double step, int typenum)</pre>


                           <blockquote><p>Construct a new 1-dimensional array of data-type, <em>typenum</em>, that     ranges from <em>start</em> to <em>stop</em> (exclusive) in increments of <em>step</em>     . Equivalent to <strong>arange</strong> (<em>start</em>, <em>stop</em>, <em>step</em>, dtype).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ArangeObj( \
    PyObject* start, PyObject* stop, PyObject* step, PyArray_Descr* descr)</pre>


                           <blockquote><p>Construct a new 1-dimensional array of data-type determined by             <code class='verbatim'>descr</code>
, that ranges from         <code class='verbatim'>start</code>
 to         <code class='verbatim'>stop</code>
 (exclusive) in     increments of         <code class='verbatim'>step</code>
. Equivalent to arange(         <code class='verbatim'>start</code>
,             <code class='verbatim'>stop</code>
,         <code class='verbatim'>step</code>
,         <code class='verbatim'>typenum</code>
 ).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_SetBaseObject(PyArrayObject* arr, PyObject* obj)
    .. versionadded:: 1.7

    This function **steals a reference** to ``obj`` and sets it as the
    base property of ``arr``.

    If you construct an array by passing in your own memory buffer as
    a parameter, you need to set the array&#39;s `base` property to ensure
    the lifetime of the memory buffer is appropriate.

    The return value is 0 on success, -1 on failure.

    If the object provided is an array, this function traverses the
    chain of `base` pointers so that each array points to the owner
    of the memory directly. Once the base is set, it may not be changed
    to another value.</pre>



<h3>From other objects</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromAny( \
    PyObject* op, PyArray_Descr* dtype, int min_depth, int max_depth, \
    int requirements, PyObject* context)</pre>


                           <blockquote><p>This is the main function used to obtain an array from any nested     sequence, or object that exposes the array interface, <em>op</em>. The     parameters allow specification of the required <em>dtype</em>, the     minimum (<em>min_depth</em>) and maximum (<em>max_depth</em>) number of     dimensions acceptable, and other <em>requirements</em> for the array. This     function <strong>steals a reference</strong> to the dtype argument, which needs     to be a         <code class='verbatim'>PyArray_Descr</code>
 structure     indicating the desired data-type (including required     byteorder). The <em>dtype</em> argument may be         <code class='verbatim'>NULL</code>
, indicating that any     data-type (and byteorder) is acceptable. Unless             <code class='verbatim'>NPY_ARRAY_FORCECAST</code>
 is present in         <code class='verbatim'>flags</code>
,     this call will generate an error if the data     type cannot be safely obtained from the object. If you want to use             <code class='verbatim'>NULL</code>
 for the <em>dtype</em> and ensure the array is notswapped then     use         <code class='verbatim'>PyArray_CheckFromAny</code>
. A value of 0 for either of the     depth parameters causes the parameter to be ignored. Any of the     following array flags can be added (<em>e.g.</em> using \|) to get the     <em>requirements</em> argument. If your code can handle general (<em>e.g.</em>     strided, byte-swapped, or unaligned arrays) then <em>requirements</em>     may be 0. Also, if <em>op</em> is not already an array (or does not     expose the array interface), then a new array will be created (and     filled from <em>op</em> using the sequence protocol). The new array will     have         <code class='verbatim'>NPY_ARRAY_DEFAULT</code>
 as its flags member. The <em>context</em>     argument is unused.</p>
<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_C_CONTIGUOUS
    Make sure the returned array is C-style contiguous</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_F_CONTIGUOUS
    Make sure the returned array is Fortran-style contiguous.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ALIGNED
    Make sure the returned array is aligned on proper boundaries for its
        data type. An aligned array has the data pointer and every strides
        factor as a multiple of the alignment factor for the data-type-
        descriptor.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_WRITEABLE
    Make sure the returned array can be written to.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ENSURECOPY
    Make sure a copy is made of *op*. If this flag is not
        present, data is not copied if it can be avoided.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ENSUREARRAY
    Make sure the result is a base-class ndarray. By
        default, if *op* is an instance of a subclass of
        ndarray, an instance of that same subclass is returned. If
        this flag is set, an ndarray object will be returned instead.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FORCECAST
    Force a cast to the output type even if it cannot be done
        safely.  Without this flag, a data cast will occur only if it
        can be done safely, otherwise an error is raised.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_WRITEBACKIFCOPY
    If *op* is already an array, but does not satisfy the
        requirements, then a copy is made (which will satisfy the
        requirements). If this flag is present and a copy (of an object
        that is already an array) must be made, then the corresponding
        :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag is set in the returned
        copy and *op* is made to be read-only. You must be sure to call
        :c:func:`PyArray_ResolveWritebackIfCopy` to copy the contents
        back into *op* and the *op* array
        will be made writeable again. If *op* is not writeable to begin
        with, or if it is not already an array, then an error is raised.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_BEHAVED
    :c:data:`NPY_ARRAY_ALIGNED` \| :c:data:`NPY_ARRAY_WRITEABLE`</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_CARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_BEHAVED`</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_CARRAY_RO
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FARRAY
    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_BEHAVED`</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FARRAY_RO
    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_DEFAULT
    :c:data:`NPY_ARRAY_CARRAY`</pre>

</blockquote>

                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;..\n  dedented to allow internal linking, pending a refactoring&#39;
   |&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_IN_ARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`

    .. c:macro:: NPY_ARRAY_IN_FARRAY

        :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_OUT_ARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_WRITEABLE` \|
    :c:data:`NPY_ARRAY_ALIGNED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_OUT_ARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED` \|
    :c:data:`NPY_ARRAY_WRITEABLE`

    .. c:macro:: NPY_ARRAY_OUT_FARRAY

        :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_WRITEABLE` \|
        :c:data:`NPY_ARRAY_ALIGNED`</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;..\n  dedented to allow internal linking, pending a refactoring&#39;
   |&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_INOUT_ARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_WRITEABLE` \|
    :c:data:`NPY_ARRAY_ALIGNED` \| :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`

    .. c:macro:: NPY_ARRAY_INOUT_FARRAY

        :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_WRITEABLE` \|
        :c:data:`NPY_ARRAY_ALIGNED` \| :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_GetArrayParamsFromObject( \
    PyObject* op, PyArray_Descr* requested_dtype, npy_bool writeable, \
    PyArray_Descr** out_dtype, int* out_ndim, npy_intp* out_dims, \
    PyArrayObject** out_arr, PyObject* context)</pre>


                           <blockquote>            <div class='admonition'>
    <div>deprecated</div>
        <!-- deflist -->
           <dl>
               <dt><p>Unless NumPy is made aware of an issue with this, this function</p>
</dt>
               <dd><p>is scheduled for rapid removal without replacement.</p>
</dd>
           </dl>

</div>

            <div class='admonition'>
    <div>versionchanged</div>
        <p><code class='not-implemented'>:None:None:`context`</code> is never used. Its use results in an error.</p>

</div>

            <div class='admonition'>
    <div>versionadded</div>
</div>

</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_CheckFromAny( \
    PyObject* op, PyArray_Descr* dtype, int min_depth, int max_depth, \
    int requirements, PyObject* context)</pre>


                           <blockquote><p>Nearly identical to         <code class='verbatim'>PyArray_FromAny</code>
 (...) except     <em>requirements</em> can contain         <code class='verbatim'>NPY_ARRAY_NOTSWAPPED</code>
 (over-riding the     specification in <em>dtype</em>) and         <code class='verbatim'>NPY_ARRAY_ELEMENTSTRIDES</code>
 which     indicates that the array should be aligned in the sense that the     strides are multiples of the element size.</p>
<p>In versions 1.6 and earlier of NumPy, the following flags     did not have the _ARRAY_ macro namespace in them. That form     of the constant names is deprecated in 1.7.</p>
</blockquote>

                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;..\n  dedented to allow internal linking, pending a refactoring&#39;
   |&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_NOTSWAPPED
    Make sure the returned array has a data-type descriptor that is in
    machine byte-order, over-riding any specification in the *dtype*
    argument. Normally, the byte-order requirement is determined by
    the *dtype* argument. If this flag is set and the dtype argument
    does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is
    not in machine byte- order), then a new data-type descriptor is
    created and used with its byte-order field set to native.

    .. c:macro:: NPY_ARRAY_BEHAVED_NS

        :c:data:`NPY_ARRAY_ALIGNED` \| :c:data:`NPY_ARRAY_WRITEABLE` \|
        :c:data:`NPY_ARRAY_NOTSWAPPED`</pre>


                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;..\n  dedented to allow internal linking, pending a refactoring&#39;
   |&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ELEMENTSTRIDES
    Make sure the returned array has strides that are multiples of the
    element size.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromArray( \
    PyArrayObject* op, PyArray_Descr* newtype, int requirements)</pre>


                           <blockquote><p>Special case of         <code class='verbatim'>PyArray_FromAny</code>
 for when <em>op</em> is already an     array but it needs to be of a specific <em>newtype</em> (including     byte-order) or has certain <em>requirements</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromStructInterface(PyObject* op)
    Returns an ndarray object from a Python object that exposes the
    :obj:`~object.__array_struct__` attribute and follows the array interface
    protocol. If the object does not contain this attribute then a
    borrowed reference to :c:data:`Py_NotImplemented` is returned.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromInterface(PyObject* op)
    Returns an ndarray object from a Python object that exposes the
    :obj:`~object.__array_interface__` attribute following the array interface
    protocol. If the object does not contain this attribute then a
    borrowed reference to :c:data:`Py_NotImplemented` is returned.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromArrayAttr( \
    PyObject* op, PyArray_Descr* dtype, PyObject* context)</pre>


                           <blockquote><p>Return an ndarray object from a Python object that exposes the             <code class='verbatim'>~numpy.class.__array__</code>
 method. The         <code class='verbatim'>~numpy.class.__array__</code>
     method can take 0, or 1 argument         <code class='verbatim'>([dtype])</code>
.         <code class='verbatim'>context</code>
 is unused.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ContiguousFromAny( \
    PyObject* op, int typenum, int min_depth, int max_depth)</pre>


                           <blockquote><p>This function returns a (C-style) contiguous and behaved function     array from any nested sequence or array interface exporting     object, <em>op</em>, of (non-flexible) type given by the enumerated     <em>typenum</em>, of minimum depth <em>min_depth</em>, and of maximum depth     <em>max_depth</em>. Equivalent to a call to         <code class='verbatim'>PyArray_FromAny</code>
 with     requirements set to         <code class='verbatim'>NPY_ARRAY_DEFAULT</code>
 and the type_num member of the     type argument set to <em>typenum</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ContiguousFromObject( \
    PyObject* op, int typenum, int min_depth, int max_depth)</pre>


                           <blockquote><p>This function returns a well-behaved C-style contiguous array from any nested     sequence or array-interface exporting object. The minimum number of dimensions     the array can have is given by <code class='not-implemented'>:None:None:`min_depth`</code> while the maximum is <code class='not-implemented'>:None:None:`max_depth`</code>.     This is equivalent to call         <code class='verbatim'>PyArray_FromAny</code>
 with requirements             <code class='verbatim'>NPY_ARRAY_DEFAULT</code>
 and         <code class='verbatim'>NPY_ARRAY_ENSUREARRAY</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromObject( \
    PyObject* op, int typenum, int min_depth, int max_depth)</pre>


                           <blockquote><p>Return an aligned and in native-byteorder array from any nested     sequence or array-interface exporting object, op, of a type given by     the enumerated typenum. The minimum number of dimensions the array can     have is given by min_depth while the maximum is max_depth. This is     equivalent to a call to         <code class='verbatim'>PyArray_FromAny</code>
 with requirements set to     BEHAVED.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_EnsureArray(PyObject* op)
    This function **steals a reference** to ``op`` and makes sure that
    ``op`` is a base-class ndarray. It special cases array scalars,
    but otherwise calls :c:func:`PyArray_FromAny` ( ``op``, NULL, 0, 0,
    :c:data:`NPY_ARRAY_ENSUREARRAY`, NULL).</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromString( \
    char* string, npy_intp slen, PyArray_Descr* dtype, npy_intp num, \
    char* sep)</pre>


                           <blockquote><p>Construct a one-dimensional ndarray of a single type from a binary     or (ASCII) text         <code class='verbatim'>string</code>
 of length         <code class='verbatim'>slen</code>
. The data-type of     the array to-be-created is given by         <code class='verbatim'>dtype</code>
. If num is -1, then     <strong>copy</strong> the entire string and return an appropriately sized     array, otherwise,         <code class='verbatim'>num</code>
 is the number of items to <strong>copy</strong> from     the string. If         <code class='verbatim'>sep</code>
 is NULL (or &#34;&#34;), then interpret the string     as bytes of binary data, otherwise convert the sub-strings     separated by         <code class='verbatim'>sep</code>
 to items of data-type         <code class='verbatim'>dtype</code>
. Some     data-types may not be readable in text mode and an error will be     raised if that occurs. All errors return NULL.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromFile( \
    FILE* fp, PyArray_Descr* dtype, npy_intp num, char* sep)</pre>


                           <blockquote><p>Construct a one-dimensional ndarray of a single type from a binary     or text file. The open file pointer is         <code class='verbatim'>fp</code>
, the data-type of     the array to be created is given by         <code class='verbatim'>dtype</code>
. This must match     the data in the file. If         <code class='verbatim'>num</code>
 is -1, then read until the end of     the file and return an appropriately sized array, otherwise,             <code class='verbatim'>num</code>
 is the number of items to read. If         <code class='verbatim'>sep</code>
 is NULL (or     &#34;&#34;), then read from the file in binary mode, otherwise read from     the file in text mode with         <code class='verbatim'>sep</code>
 providing the item     separator. Some array types cannot be read in text mode in which     case an error is raised.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromBuffer( \
    PyObject* buf, PyArray_Descr* dtype, npy_intp count, npy_intp offset)</pre>


                           <blockquote><p>Construct a one-dimensional ndarray of a single type from an     object,         <code class='verbatim'>buf</code>
, that exports the (single-segment) buffer protocol     (or has an attribute __buffer\__ that returns an object that     exports the buffer protocol). A writeable buffer will be tried     first followed by a read- only buffer. The         <code class='verbatim'>NPY_ARRAY_WRITEABLE</code>
     flag of the returned array will reflect which one was     successful. The data is assumed to start at         <code class='verbatim'>offset</code>
 bytes from     the start of the memory location for the object. The type of the     data in the buffer will be interpreted depending on the data- type     descriptor,         <code class='verbatim'>dtype.</code>
 If         <code class='verbatim'>count</code>
 is negative then it will be     determined from the size of the buffer and the requested itemsize,     otherwise,         <code class='verbatim'>count</code>
 represents how many elements should be     converted from the buffer.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CopyInto(PyArrayObject* dest, PyArrayObject* src)
    Copy from the source array, ``src``, into the destination array,
    ``dest``, performing a data-type conversion if necessary. If an
    error occurs return -1 (otherwise 0). The shape of ``src`` must be
    broadcastable to the shape of ``dest``. The data areas of dest
    and src must not overlap.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CopyObject(PyArrayObject* dest, PyObject* src)
    Assign an object ``src`` to a NumPy array ``dest`` according to
    array-coercion rules. This is basically identical to
    :c:func:`PyArray_FromAny`, but assigns directly to the output array.
    Returns 0 on success and -1 on failures.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_MoveInto(PyArrayObject* dest, PyArrayObject* src)
    Move data from the source array, ``src``, into the destination
    array, ``dest``, performing a data-type conversion if
    necessary. If an error occurs return -1 (otherwise 0). The shape
    of ``src`` must be broadcastable to the shape of ``dest``. The
    data areas of dest and src may overlap.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArrayObject* PyArray_GETCONTIGUOUS(PyObject* op)
    If ``op`` is already (C-style) contiguous and well-behaved then
    just return a reference, otherwise return a (contiguous and
    well-behaved) copy of the array. The parameter op must be a
    (sub-class of an) ndarray and no checking for that is done.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FROM_O(PyObject* obj)
    Convert ``obj`` to an ndarray. The argument can be any nested
    sequence or object that exports the array interface. This is a
    macro form of :c:func:`PyArray_FromAny` using ``NULL``, 0, 0, 0 for the
    other arguments. Your code must be able to handle any data-type
    descriptor and any combination of data-flags to use this macro.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FROM_OF(PyObject* obj, int requirements)
    Similar to :c:func:`PyArray_FROM_O` except it can take an argument
    of *requirements* indicating properties the resulting array must
    have. Available requirements that can be enforced are
    :c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_F_CONTIGUOUS`,
    :c:data:`NPY_ARRAY_ALIGNED`, :c:data:`NPY_ARRAY_WRITEABLE`,
    :c:data:`NPY_ARRAY_NOTSWAPPED`, :c:data:`NPY_ARRAY_ENSURECOPY`,
    :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, :c:data:`NPY_ARRAY_FORCECAST`, and
    :c:data:`NPY_ARRAY_ENSUREARRAY`. Standard combinations of flags can also
    be used:</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FROM_OT(PyObject* obj, int typenum)
    Similar to :c:func:`PyArray_FROM_O` except it can take an argument of
    *typenum* specifying the type-number the returned array.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FROM_OTF( \
    PyObject* obj, int typenum, int requirements)</pre>


                           <blockquote><p>Combination of         <code class='verbatim'>PyArray_FROM_OF</code>
 and         <code class='verbatim'>PyArray_FROM_OT</code>
     allowing both a <em>typenum</em> and a <em>flags</em> argument to be provided.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FROMANY( \
    PyObject* obj, int typenum, int min, int max, int requirements)</pre>


                           <blockquote><p>Similar to         <code class='verbatim'>PyArray_FromAny</code>
 except the data-type is     specified using a typenumber.         <code class='verbatim'>PyArray_DescrFromType</code>
     (<em>typenum</em>) is passed directly to         <code class='verbatim'>PyArray_FromAny</code>
. This     macro also adds         <code class='verbatim'>NPY_ARRAY_DEFAULT</code>
 to requirements if             <code class='verbatim'>NPY_ARRAY_ENSURECOPY</code>
 is passed in as requirements.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject *PyArray_CheckAxis( \
    PyObject* obj, int* axis, int requirements)</pre>


                           <blockquote><p>Encapsulate the functionality of functions and methods that take     the axis= keyword and work properly with None as the axis     argument. The input array is         <code class='verbatim'>obj</code>
, while         <code class='verbatim'>*axis</code>
 is a     converted integer (so that &gt;=MAXDIMS is the None value), and             <code class='verbatim'>requirements</code>
 gives the needed properties of         <code class='verbatim'>obj</code>
. The     output is a converted version of the input so that requirements     are met and if needed a flattening has occurred. On output     negative values of         <code class='verbatim'>*axis</code>
 are converted and the new value is     checked to ensure consistency with the shape of         <code class='verbatim'>obj</code>
.</p>
</blockquote>


<h2>Dealing with types</h2>

<h3>General check of Python Type</h3>
               <pre class='not-implemented'>
.. c:function:: int PyArray_Check(PyObject *op)
    Evaluates true if *op* is a Python object whose type is a sub-type
    of :c:data:`PyArray_Type`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CheckExact(PyObject *op)
    Evaluates true if *op* is a Python object with type
    :c:data:`PyArray_Type`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_HasArrayInterface(PyObject *op, PyObject *out)
    If ``op`` implements any part of the array interface, then ``out``
    will contain a new reference to the newly created ndarray using
    the interface or ``out`` will contain ``NULL`` if an error during
    conversion occurs. Otherwise, out will contain a borrowed
    reference to :c:data:`Py_NotImplemented` and no error condition is set.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_HasArrayInterfaceType(\
    PyObject *op, PyArray_Descr *dtype, PyObject *context, PyObject *out)</pre>


                           <blockquote><p>If         <code class='verbatim'>op</code>
 implements any part of the array interface, then         <code class='verbatim'>out</code>
     will contain a new reference to the newly created ndarray using     the interface or         <code class='verbatim'>out</code>
 will contain         <code class='verbatim'>NULL</code>
 if an error during     conversion occurs. Otherwise, out will contain a borrowed     reference to Py_NotImplemented and no error condition is set.     This version allows setting of the dtype in the part of the array interface     that looks for the         <code class='verbatim'>~numpy.class.__array__</code>
 attribute. <code class='not-implemented'>:None:None:`context`</code> is     unused.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_IsZeroDim(PyObject *op)
    Evaluates true if *op* is an instance of (a subclass of)
    :c:data:`PyArray_Type` and has 0 dimensions.</pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_IsScalar(op, cls)
    Evaluates true if *op* is an instance of ``Py{cls}ArrType_Type``.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CheckScalar(PyObject *op)
    Evaluates true if *op* is either an array scalar (an instance of a
    sub-type of :c:data:`PyGenericArr_Type` ), or an instance of (a
    sub-class of) :c:data:`PyArray_Type` whose dimensionality is 0.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IsPythonNumber(PyObject *op)
    Evaluates true if *op* is an instance of a builtin numeric type (int,
    float, complex, long, bool)</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IsPythonScalar(PyObject *op)
    Evaluates true if *op* is a builtin Python scalar object (int,
    float, complex, bytes, str, long, bool).</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IsAnyScalar(PyObject *op)
    Evaluates true if *op* is either a Python scalar object (see
    :c:func:`PyArray_IsPythonScalar`) or an array scalar (an instance of a sub-
    type of :c:data:`PyGenericArr_Type` ).</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CheckAnyScalar(PyObject *op)
    Evaluates true if *op* is a Python scalar object (see
    :c:func:`PyArray_IsPythonScalar`), an array scalar (an instance of a
    sub-type of :c:data:`PyGenericArr_Type`) or an instance of a sub-type of
    :c:data:`PyArray_Type` whose dimensionality is 0.</pre>



<h3>Data-type checking</h3>
               <p>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a         <code class='verbatim'>PyObject *</code>
 that can be directly interpreted as a         <code class='verbatim'>PyArrayObject *</code>
.</p>

               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISUNSIGNED(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISUNSIGNED(PyArray_Descr *descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISUNSIGNED(PyArrayObject *obj)
    Type represents an unsigned integer.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISSIGNED(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISSIGNED(PyArray_Descr *descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISSIGNED(PyArrayObject *obj)
    Type represents a signed integer.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISINTEGER(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISINTEGER(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISINTEGER(PyArrayObject *obj)
    Type represents any integer.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISFLOAT(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISFLOAT(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISFLOAT(PyArrayObject *obj)
    Type represents any floating point number.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISCOMPLEX(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISCOMPLEX(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISCOMPLEX(PyArrayObject *obj)
    Type represents any complex floating point number.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISNUMBER(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISNUMBER(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISNUMBER(PyArrayObject *obj)
    Type represents any integer, floating point, or complex floating point
    number.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISSTRING(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISSTRING(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISSTRING(PyArrayObject *obj)
    Type represents a string data type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISPYTHON(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISPYTHON(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISPYTHON(PyArrayObject *obj)
    Type represents an enumerated type corresponding to one of the
    standard Python scalar (bool, int, float, or complex).</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISFLEXIBLE(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISFLEXIBLE(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISFLEXIBLE(PyArrayObject *obj)
    Type represents one of the flexible array types ( :c:data:`NPY_STRING`,
    :c:data:`NPY_UNICODE`, or :c:data:`NPY_VOID` ).</pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISUNSIZED(PyArray_Descr* descr)
    Type has no size information attached, and can be resized. Should only be
    called on flexible dtypes. Types that are attached to an array will always
    be sized, hence the array form of this macro not existing.

    .. versionchanged:: 1.18

    For structured datatypes with no fields this function now returns False.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISUSERDEF(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISUSERDEF(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISUSERDEF(PyArrayObject *obj)
    Type represents a user-defined type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISEXTENDED(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISEXTENDED(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISEXTENDED(PyArrayObject *obj)
    Type is either flexible or user-defined.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISOBJECT(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISOBJECT(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISOBJECT(PyArrayObject *obj)
    Type represents object data type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyTypeNum_ISBOOL(int num)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_ISBOOL(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISBOOL(PyArrayObject *obj)
    Type represents Boolean data type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyDataType_HASFIELDS(PyArray_Descr* descr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_HASFIELDS(PyArrayObject *obj)
    Type has fields associated with it.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISNOTSWAPPED(PyArrayObject *m)
    Evaluates true if the data area of the ndarray *m* is in machine
    byte-order according to the array&#39;s data-type descriptor.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISBYTESWAPPED(PyArrayObject *m)
    Evaluates true if the data area of the ndarray *m* is **not** in
    machine byte-order according to the array&#39;s data-type descriptor.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_bool PyArray_EquivTypes( \
    PyArray_Descr* type1, PyArray_Descr* type2)</pre>


                           <blockquote><p>Return         <code class='verbatim'>NPY_TRUE</code>
 if <em>type1</em> and <em>type2</em> actually represent     equivalent types for this platform (the fortran member of each     type is ignored). For example, on 32-bit platforms,             <code class='verbatim'>NPY_LONG</code>
 and         <code class='verbatim'>NPY_INT</code>
 are equivalent. Otherwise     return         <code class='verbatim'>NPY_FALSE</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: npy_bool PyArray_EquivArrTypes( \
    PyArrayObject* a1, PyArrayObject * a2)</pre>


                           <blockquote><p>Return         <code class='verbatim'>NPY_TRUE</code>
 if <em>a1</em> and <em>a2</em> are arrays with equivalent     types for this platform.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: npy_bool PyArray_EquivTypenums(int typenum1, int typenum2)
    Special case of :c:func:`PyArray_EquivTypes` (...) that does not accept
    flexible data types but may be easier to call.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_EquivByteorders(int b1, int b2)
    True if byteorder characters *b1* and *b2* ( :c:data:`NPY_LITTLE`,
    :c:data:`NPY_BIG`, :c:data:`NPY_NATIVE`, :c:data:`NPY_IGNORE` ) are
    either equal or equivalent as to their specification of a native
    byte order. Thus, on a little-endian machine :c:data:`NPY_LITTLE`
    and :c:data:`NPY_NATIVE` are equivalent where they are not
    equivalent on a big-endian machine.</pre>



<h3>Converting data types</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Cast(PyArrayObject* arr, int typenum)
    Mainly for backwards compatibility to the Numeric C-API and for
    simple casts to non-flexible types. Return a new array object with
    the elements of *arr* cast to the data-type *typenum* which must
    be one of the enumerated types and not a flexible type.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_CastToType( \
    PyArrayObject* arr, PyArray_Descr* type, int fortran)</pre>


                           <blockquote><p>Return a new array of the <em>type</em> specified, casting the elements     of <em>arr</em> as appropriate. The fortran argument specifies the     ordering of the output array.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CastTo(PyArrayObject* out, PyArrayObject* in)
    As of 1.6, this function simply calls :c:func:`PyArray_CopyInto`,
    which handles the casting.

    Cast the elements of the array *in* into the array *out*. The
    output array should be writeable, have an integer-multiple of the
    number of elements in the input array (more than one copy can be
    placed in out), and have a data type that is one of the builtin
    types.  Returns 0 on success and -1 if an error occurs.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_VectorUnaryFunc* PyArray_GetCastFunc( \
    PyArray_Descr* from, int totype)</pre>


                           <blockquote><p>Return the low-level casting function to cast from the given     descriptor to the builtin type number. If no casting function     exists return         <code class='verbatim'>NULL</code>
 and set an error. Using this function     instead of direct access to <em>from</em> -&gt;f-&gt;cast will allow support of     any user-defined casting functions added to a descriptors casting     dictionary.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CanCastSafely(int fromtype, int totype)
    Returns non-zero if an array of data type *fromtype* can be cast
    to an array of data type *totype* without losing information. An
    exception is that 64-bit integers are allowed to be cast to 64-bit
    floating point values even though this can lose precision on large
    integers so as not to proliferate the use of long doubles without
    explicit requests. Flexible array types are not checked according
    to their lengths with this function.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CanCastTo( \
    PyArray_Descr* fromtype, PyArray_Descr* totype)</pre>


                           <blockquote><p>        <code class='verbatim'>PyArray_CanCastTypeTo</code>
 supersedes this function in     NumPy 1.6 and later.</p>
<p>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CanCastTypeTo( \
    PyArray_Descr* fromtype, PyArray_Descr* totype, NPY_CASTING casting)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>Returns non-zero if an array of data type <em>fromtype</em> (which can     include flexible types) can be cast safely to an array of data     type <em>totype</em> (which can include flexible types) according to     the casting rule <em>casting</em>. For simple types with         <code class='verbatim'>NPY_SAFE_CASTING</code>
,     this is basically a wrapper around         <code class='verbatim'>PyArray_CanCastSafely</code>
, but     for flexible types such as strings or unicode, it produces results     taking into account their sizes. Integer and float types can only be cast     to a string or unicode type using         <code class='verbatim'>NPY_SAFE_CASTING</code>
 if the string     or unicode type is big enough to hold the max value of the integer/float     type being cast from.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CanCastArrayTo( \
    PyArrayObject* arr, PyArray_Descr* totype, NPY_CASTING casting)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>Returns non-zero if <em>arr</em> can be cast to <em>totype</em> according     to the casting rule given in <em>casting</em>.  If <em>arr</em> is an array     scalar, its value is taken into account, and non-zero is also     returned when the value will not overflow or be truncated to     an integer when converting to a smaller type.</p>
<p>This is almost the same as the result of     PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting),     but it also handles a special case arising because the set     of uint values is not a subset of the int values for types with the     same number of bits.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_MinScalarType(PyArrayObject* arr)
    .. versionadded:: 1.6

    If *arr* is an array, returns its data type descriptor, but if
    *arr* is an array scalar (has 0 dimensions), it finds the data type
    of smallest size to which the value may be converted
    without overflow or truncation to an integer.

    This function will not demote complex to float or anything to
    boolean, but will demote a signed integer to an unsigned integer
    when the scalar value is positive.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_PromoteTypes( \
    PyArray_Descr* type1, PyArray_Descr* type2)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>Finds the data type of smallest size and kind to which <em>type1</em> and     <em>type2</em> may be safely converted. This function is symmetric and     associative. A string or unicode result will be the proper size for     storing the max value of the input types converted to a string or unicode.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_ResultType( \
    npy_intp narrs, PyArrayObject **arrs, npy_intp ndtypes, \
    PyArray_Descr **dtypes)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>This applies type promotion to all the inputs,     using the NumPy rules for combining scalars and arrays, to     determine the output type of a set of operands.  This is the     same result type that ufuncs produce. The specific algorithm     used is as follows.</p>
<p>Categories are determined by first checking which of boolean,     integer (int/uint), or floating point (float/complex) the maximum     kind of all the arrays and the scalars are.</p>
<p>If there are only scalars or the maximum category of the scalars     is higher than the maximum category of the arrays,     the data types are combined with         <code class='verbatim'>PyArray_PromoteTypes</code>
     to produce the return value.</p>
<p>Otherwise, PyArray_MinScalarType is called on each array, and     the resulting data types are all combined with             <code class='verbatim'>PyArray_PromoteTypes</code>
 to produce the return value.</p>
<p>The set of int values is not a subset of the uint values for types     with the same number of bits, something not reflected in             <code class='verbatim'>PyArray_MinScalarType</code>
, but handled as a special case in     PyArray_ResultType.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_ObjectType(PyObject* op, int mintype)
    This function is superseded by :c:func:`PyArray_MinScalarType` and/or
    :c:func:`PyArray_ResultType`.

    This function is useful for determining a common type that two or
    more arrays can be converted to. It only works for non-flexible
    array types as no itemsize information is passed. The *mintype*
    argument represents the minimum type acceptable, and *op*
    represents the object that will be converted to an array. The
    return value is the enumerated typenumber that represents the
    data-type that *op* should have.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_ArrayType( \
    PyObject* op, PyArray_Descr* mintype, PyArray_Descr* outtype)</pre>


                           <blockquote><p>This function is superseded by         <code class='verbatim'>PyArray_ResultType</code>
.</p>
<p>This function works similarly to         <code class='verbatim'>PyArray_ObjectType</code>
 (...)     except it handles flexible arrays. The <em>mintype</em> argument can have     an itemsize member and the <em>outtype</em> argument will have an     itemsize member at least as big but perhaps bigger depending on     the object <em>op</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyArrayObject** PyArray_ConvertToCommonType( \
    PyObject* op, int* n)</pre>


                           <blockquote><p>The functionality this provides is largely superseded by iterator             <code class='verbatim'>NpyIter</code>
 introduced in 1.6, with flag             <code class='verbatim'>NPY_ITER_COMMON_DTYPE</code>
 or with the same dtype parameter for     all operands.</p>
<p>Convert a sequence of Python objects contained in <em>op</em> to an array     of ndarrays each having the same data type. The type is selected     in the same way as <code class='not-implemented'>:None:None:`PyArray_ResultType`</code>. The length of the sequence is     returned in <em>n</em>, and an <em>n</em> -length array of         <code class='verbatim'>PyArrayObject</code>
     pointers is the return value (or         <code class='verbatim'>NULL</code>
 if an error occurs).     The returned array must be freed by the caller of this routine     (using         <code class='verbatim'>PyDataMem_FREE</code>
 ) and all the array objects in it             <code class='verbatim'>DECREF</code>
 &#39;d or a memory-leak will occur. The example template-code     below shows a typically usage:</p>
            <div class='admonition'>
    <div>versionchanged</div>
        <!-- deflist -->
           <dl>
               <dt><p>A mix of scalars and zero-dimensional arrays now produces a type</p>
</dt>
               <dd><p>capable of holding the scalar value.     Previously priority was given to the dtype of the arrays.</p>
</dd>
           </dl>

</div>

<pre class='not-implemented'>
.. code-block:: c
    mps = PyArray_ConvertToCommonType(obj, &amp;n);
        if (mps==NULL) return NULL;
        {code}
        &lt;before return&gt;
        for (i=0; i&lt;n; i++) Py_DECREF(mps[i]);
        PyDataMem_FREE(mps);
        {return}</pre>

</blockquote>

               <pre class='not-implemented'>
.. c:function:: char* PyArray_Zero(PyArrayObject* arr)
    A pointer to newly created memory of size *arr* -&gt;itemsize that
    holds the representation of 0 for that type. The returned pointer,
    *ret*, **must be freed** using :c:func:`PyDataMem_FREE` (ret) when it is
    not needed anymore.</pre>


               <pre class='not-implemented'>
.. c:function:: char* PyArray_One(PyArrayObject* arr)
    A pointer to newly created memory of size *arr* -&gt;itemsize that
    holds the representation of 1 for that type. The returned pointer,
    *ret*, **must be freed** using :c:func:`PyDataMem_FREE` (ret) when it
    is not needed anymore.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ValidType(int typenum)
    Returns :c:data:`NPY_TRUE` if *typenum* represents a valid type-number
    (builtin or user-defined or character code). Otherwise, this
    function returns :c:data:`NPY_FALSE`.</pre>



<h3>User-defined data types</h3>
               <pre class='not-implemented'>
.. c:function:: void PyArray_InitArrFuncs(PyArray_ArrFuncs* f)
    Initialize all function pointers and members to ``NULL``.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_RegisterDataType(PyArray_Descr* dtype)
    Register a data-type as a new user-defined data type for
    arrays. The type must have most of its entries filled in. This is
    not always checked and errors can produce segfaults. In
    particular, the typeobj member of the ``dtype`` structure must be
    filled with a Python type that has a fixed-size element-size that
    corresponds to the elsize member of *dtype*. Also the ``f``
    member must have the required functions: nonzero, copyswap,
    copyswapn, getitem, setitem, and cast (some of the cast functions
    may be ``NULL`` if no support is desired). To avoid confusion, you
    should choose a unique character typecode but this is not enforced
    and not relied on internally.

    A user-defined type number is returned that uniquely identifies
    the type. A pointer to the new structure can then be obtained from
    :c:func:`PyArray_DescrFromType` using the returned type number. A -1 is
    returned if an error occurs.  If this *dtype* has already been
    registered (checked only by the address of the pointer), then
    return the previously-assigned type-number.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_RegisterCastFunc( \
    PyArray_Descr* descr, int totype, PyArray_VectorUnaryFunc* castfunc)</pre>


                           <blockquote><p>Register a low-level casting function, <em>castfunc</em>, to convert     from the data-type, <em>descr</em>, to the given data-type number,     <em>totype</em>. Any old casting function is over-written. A         <code class='verbatim'>0</code>
 is     returned on success or a         <code class='verbatim'>-1</code>
 on failure.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_RegisterCanCast( \
    PyArray_Descr* descr, int totype, NPY_SCALARKIND scalar)</pre>


                           <blockquote><p>Register the data-type number, <em>totype</em>, as castable from     data-type object, <em>descr</em>, of the given <em>scalar</em> kind. Use     <em>scalar</em> =         <code class='verbatim'>NPY_NOSCALAR</code>
 to register that an array of data-type     <em>descr</em> can be cast safely to a data-type whose type_number is     <em>totype</em>. The return value is 0 on success or -1 on failure.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_TypeNumFromName( \
    char const *str)</pre>


                           <blockquote><p>Given a string return the type-number for the data-type with that string as    the type-object name.    Returns         <code class='verbatim'>NPY_NOTYPE</code>
 without setting an error if no type can be found.    Only works for user-defined data-types.</p>
</blockquote>


<h3>Special functions for NPY_OBJECT</h3>
               <pre class='not-implemented'>
.. c:function:: int PyArray_INCREF(PyArrayObject* op)
    Used for an array, *op*, that contains any Python objects. It
    increments the reference count of every object in the array
    according to the data-type of *op*. A -1 is returned if an error
    occurs, otherwise 0 is returned.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_Item_INCREF(char* ptr, PyArray_Descr* dtype)
    A function to INCREF all the objects at the location *ptr*
    according to the data-type *dtype*. If *ptr* is the start of a
    structured type with an object at any offset, then this will (recursively)
    increment the reference count of all object-like items in the
    structured type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_XDECREF(PyArrayObject* op)
    Used for an array, *op*, that contains any Python objects. It
    decrements the reference count of every object in the array
    according to the data-type of *op*. Normal return value is 0. A
    -1 is returned if an error occurs.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_Item_XDECREF(char* ptr, PyArray_Descr* dtype)
    A function to XDECREF all the object-like items at the location
    *ptr* as recorded in the data-type, *dtype*. This works
    recursively so that if ``dtype`` itself has fields with data-types
    that contain object-like items, all the object-like fields will be
    XDECREF ``&#39;d``.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_FillObjectArray(PyArrayObject* arr, PyObject* obj)
    Fill a newly created array with a single value obj at all
    locations in the structure with object data-types. No checking is
    performed but *arr* must be of data-type :c:type:`NPY_OBJECT` and be
    single-segment and uninitialized (no previous objects in
    position). Use :c:func:`PyArray_XDECREF` (*arr*) if you need to
    decrement all the items in the object array prior to calling this
    function.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_SetWritebackIfCopyBase(PyArrayObject* arr, PyArrayObject* base)
    Precondition: ``arr`` is a copy of ``base`` (though possibly with different
    strides, ordering, etc.) Sets the :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag
    and ``arr-&gt;base``, and set ``base`` to READONLY. Call
    :c:func:`PyArray_ResolveWritebackIfCopy` before calling
    `Py_DECREF` in order copy any changes back to ``base`` and
    reset the READONLY flag.

    Returns 0 for success, -1 for failure.</pre>


                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _array-flags:&#39;&gt;
           </pre>


<h2>Array flags</h2>
               <p>The         <code class='verbatim'>flags</code>
 attribute of the         <code class='verbatim'>PyArrayObject</code>
 structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</p>

               <p>There are 6 (binary) flags that describe the memory area used by the data buffer.  These constants are defined in         <code class='verbatim'>arrayobject.h</code>
 and determine the bit-position of the flag.  Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</p>

               <p>Memory areas of all kinds can be pointed to by an ndarray, necessitating these flags.  If you get an arbitrary         <code class='verbatim'>PyArrayObject</code>
 in C-code, you need to be aware of the flags that are set.  If you need to guarantee a certain kind of array (like         <code class='verbatim'>NPY_ARRAY_C_CONTIGUOUS</code>
 and         <code class='verbatim'>NPY_ARRAY_BEHAVED</code>
), then pass these requirements into the PyArray_FromAny function.</p>


<h3>Basic Array Flags</h3>
               <p>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</p>

               <p>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_C_CONTIGUOUS
    The data area is in C-style contiguous order (last index varies the
    fastest).</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_F_CONTIGUOUS
    The data area is in Fortran-style contiguous order (first index varies
    the fastest).</pre>


                           <div class='admonition'>
    <div>note</div>
        <p>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</p>

        <p>Even for contiguous arrays a stride for a given dimension         <code class='verbatim'>arr.strides[dim]</code>
 may be <em>arbitrary</em> if         <code class='verbatim'>arr.shape[dim] == 1</code>
 or the array has no elements. It does <em>not</em> generally hold that         <code class='verbatim'>self.strides[-1] == self.itemsize</code>
 for C-style contiguous arrays or         <code class='verbatim'>self.strides[0] == self.itemsize</code>
 for Fortran-style contiguous arrays is true. The correct way to access the         <code class='verbatim'>itemsize</code>
 of an array from the C API is         <code class='verbatim'>PyArray_ITEMSIZE(arr)</code>
.</p>

        <pre class='not-implemented'>
.. seealso:: :ref:`Internal memory layout of an ndarray &lt;arrays.ndarray&gt;`
    </pre>


</div>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_OWNDATA
    The data area is owned by this array. Should never be set manually, instead
    create a ``PyObject`` wrapping the data and set the array&#39;s base to that
    object. For an example, see the test in ``test_mem_policy``.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ALIGNED
    The data area and all array elements are aligned appropriately.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_WRITEABLE
    The data area can be written to.

    Notice that the above 3 flags are defined so that a new, well-
    behaved array has these flags defined as true.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_WRITEBACKIFCOPY
    The data area represents a (well-behaved) copy whose information
    should be transferred back to the original when
    :c:func:`PyArray_ResolveWritebackIfCopy` is called.

    This is a special flag that is set if this array represents a copy
    made because a user required certain flags in
    :c:func:`PyArray_FromAny` and a copy had to be made of some other
    array (and the user asked for this flag to be set in such a
    situation). The base attribute then points to the &#34;misbehaved&#34;
    array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy`
    will copy its contents back to the &#34;misbehaved&#34;
    array (casting if necessary) and will reset the &#34;misbehaved&#34; array
    to :c:data:`NPY_ARRAY_WRITEABLE`. If the &#34;misbehaved&#34; array was not
    :c:data:`NPY_ARRAY_WRITEABLE` to begin with then :c:func:`PyArray_FromAny`
    would have returned an error because :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`
    would not have been possible.</pre>


               <p>        <code class='verbatim'>PyArray_UpdateFlags</code>
 (obj, flags) will update the         <code class='verbatim'>obj-&gt;flags</code>
 for         <code class='verbatim'>flags</code>
 which can be any of         <code class='verbatim'>NPY_ARRAY_C_CONTIGUOUS</code>
,         <code class='verbatim'>NPY_ARRAY_F_CONTIGUOUS</code>
,         <code class='verbatim'>NPY_ARRAY_ALIGNED</code>
, or         <code class='verbatim'>NPY_ARRAY_WRITEABLE</code>
.</p>


<h3>Combinations of array flags</h3>
               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_BEHAVED
    :c:data:`NPY_ARRAY_ALIGNED` \| :c:data:`NPY_ARRAY_WRITEABLE`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_CARRAY
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_BEHAVED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_CARRAY_RO
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FARRAY
    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_BEHAVED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FARRAY_RO
    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_DEFAULT
    :c:data:`NPY_ARRAY_CARRAY`</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_UPDATE_ALL
    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \| :c:data:`NPY_ARRAY_F_CONTIGUOUS` \| :c:data:`NPY_ARRAY_ALIGNED`</pre>



<h3>Flag-like constants</h3>
               <p>These constants are used in         <code class='verbatim'>PyArray_FromAny</code>
 (and its macro forms) to specify desired properties of the new array.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_FORCECAST
    Cast to the desired type, even if it can&#39;t be done without losing
    information.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ENSURECOPY
    Make sure the resulting array is a copy of the original.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_ARRAY_ENSUREARRAY
    Make sure the resulting object is an actual ndarray, and not a sub-class.</pre>



<h3>Flag checking</h3>
               <p>For all of these macros <em>arr</em> must be an instance of a (subclass of)         <code class='verbatim'>PyArray_Type</code>
.</p>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CHKFLAGS(PyObject *arr, int flags)
    The first parameter, arr, must be an ndarray or subclass. The
    parameter, *flags*, should be an integer consisting of bitwise
    combinations of the possible flags an array can have:
    :c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_F_CONTIGUOUS`,
    :c:data:`NPY_ARRAY_OWNDATA`, :c:data:`NPY_ARRAY_ALIGNED`,
    :c:data:`NPY_ARRAY_WRITEABLE`, :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IS_C_CONTIGUOUS(PyObject *arr)
    Evaluates true if *arr* is C-style contiguous.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IS_F_CONTIGUOUS(PyObject *arr)
    Evaluates true if *arr* is Fortran-style contiguous.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISFORTRAN(PyObject *arr)
    Evaluates true if *arr* is Fortran-style contiguous and *not*
    C-style contiguous. :c:func:`PyArray_IS_F_CONTIGUOUS`
    is the correct way to test for Fortran-style contiguity.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISWRITEABLE(PyObject *arr)
    Evaluates true if the data area of *arr* can be written to</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISALIGNED(PyObject *arr)
    Evaluates true if the data area of *arr* is properly aligned on
    the machine.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISBEHAVED(PyObject *arr)
    Evaluates true if the data area of *arr* is aligned and writeable
    and in machine byte-order according to its descriptor.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISBEHAVED_RO(PyObject *arr)
    Evaluates true if the data area of *arr* is aligned and in machine
    byte-order.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISCARRAY(PyObject *arr)
    Evaluates true if the data area of *arr* is C-style contiguous,
    and :c:func:`PyArray_ISBEHAVED` (*arr*) is true.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISFARRAY(PyObject *arr)
    Evaluates true if the data area of *arr* is Fortran-style
    contiguous and :c:func:`PyArray_ISBEHAVED` (*arr*) is true.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISCARRAY_RO(PyObject *arr)
    Evaluates true if the data area of *arr* is C-style contiguous,
    aligned, and in machine byte-order.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISFARRAY_RO(PyObject *arr)
    Evaluates true if the data area of *arr* is Fortran-style
    contiguous, aligned, and in machine byte-order **.**</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ISONESEGMENT(PyObject *arr)
    Evaluates true if the data area of *arr* consists of a single
    (C-style or Fortran-style) contiguous segment.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_UpdateFlags(PyArrayObject* arr, int flagmask)
    The :c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_ALIGNED`, and
    :c:data:`NPY_ARRAY_F_CONTIGUOUS` array flags can be &#34;calculated&#34; from the
    array object itself. This routine updates one or more of these
    flags of *arr* as specified in *flagmask* by performing the
    required calculation.</pre>


                           <div class='admonition'>
    <div>warning</div>
        <p>It is important to keep the flags updated (using <code class='not-implemented'>:c:func:`PyArray_UpdateFlags`</code> can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: int PyArray_FailUnlessWriteable(PyArrayObject *obj, const char *name)
    This function does nothing and returns 0 if *obj* is writeable.
    It raises an exception and returns -1 if *obj* is not writeable.
    It may also do other house-keeping, such as issuing warnings on
    arrays which are transitioning to become views. Always call this
    function at some point before writing to an array.

    *name* is a name for the array, used to give better error messages.
    It can be something like &#34;assignment destination&#34;, &#34;output array&#34;,
    or even just &#34;array&#34;.</pre>



<h2>Array method alternative API</h2>

<h3>Conversion</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_GetField( \
    PyArrayObject* self, PyArray_Descr* dtype, int offset)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.getfield&lt;numpy.ndarray.getfield&gt;</code>
     (<em>self</em>, <em>dtype</em>, <em>offset</em>). This function <a link href="https://docs.python.org/3/c-api/intro.html?reference-count-details" class='external'>steals a reference</a>     to <code class='not-implemented'>:None:None:`PyArray_Descr`</code> and returns a new array of the given <code class='not-implemented'>:None:None:`dtype`</code> using     the data in the current array at a specified <code class='not-implemented'>:None:None:`offset`</code> in bytes. The     <code class='not-implemented'>:None:None:`offset`</code> plus the itemsize of the new array type must be less than         <code class='verbatim'>self
    -&gt;descr-&gt;elsize</code>
 or an error is raised. The same shape and strides     as the original array are used. Therefore, this function has the     effect of returning a field from a structured array. But, it can also     be used to select specific bytes or groups of bytes from any array     type.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_SetField( \
    PyArrayObject* self, PyArray_Descr* dtype, int offset, PyObject* val)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.setfield&lt;numpy.ndarray.setfield&gt;</code>
 (<em>self</em>, <em>val</em>, <em>dtype</em>, <em>offset</em>     ). Set the field starting at <em>offset</em> in bytes and of the given     <em>dtype</em> to <em>val</em>. The <em>offset</em> plus <em>dtype</em> -&gt;elsize must be less     than <em>self</em> -&gt;descr-&gt;elsize or an error is raised. Otherwise, the     <em>val</em> argument is converted to an array and copied into the field     pointed to. If necessary, the elements of <em>val</em> are repeated to     fill the destination array, But, the number of elements in the     destination must be an integer multiple of the number of elements     in <em>val</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Byteswap(PyArrayObject* self, npy_bool inplace)
    Equivalent to :meth:`ndarray.byteswap&lt;numpy.ndarray.byteswap&gt;` (*self*, *inplace*). Return an array
    whose data area is byteswapped. If *inplace* is non-zero, then do
    the byteswap inplace and return a reference to self. Otherwise,
    create a byteswapped copy and leave self unchanged.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_NewCopy(PyArrayObject* old, NPY_ORDER order)
    Equivalent to :meth:`ndarray.copy&lt;numpy.ndarray.copy&gt;` (*self*, *fortran*). Make a copy of the
    *old* array. The returned array is always aligned and writeable
    with data interpreted the same as the old array. If *order* is
    :c:data:`NPY_CORDER`, then a C-style contiguous array is returned. If
    *order* is :c:data:`NPY_FORTRANORDER`, then a Fortran-style contiguous
    array is returned. If *order is* :c:data:`NPY_ANYORDER`, then the array
    returned is Fortran-style contiguous only if the old one is;
    otherwise, it is C-style contiguous.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ToList(PyArrayObject* self)
    Equivalent to :meth:`ndarray.tolist&lt;numpy.ndarray.tolist&gt;` (*self*). Return a nested Python list
    from *self*.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ToString(PyArrayObject* self, NPY_ORDER order)
    Equivalent to :meth:`ndarray.tobytes&lt;numpy.ndarray.tobytes&gt;` (*self*, *order*). Return the bytes
    of this array in a Python string.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ToFile( \
    PyArrayObject* self, FILE* fp, char* sep, char* format)</pre>


                           <blockquote><p>Write the contents of <em>self</em> to the file pointer <em>fp</em> in C-style     contiguous fashion. Write the data as binary bytes if <em>sep</em> is the     string &#34;&#34;or         <code class='verbatim'>NULL</code>
. Otherwise, write the contents of <em>self</em> as     text using the <em>sep</em> string as the item separator. Each item will     be printed to the file.  If the <em>format</em> string is not         <code class='verbatim'>NULL</code>
 or     &#34;&#34;, then it is a Python print statement format string showing how     the items are to be written.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_Dump(PyObject* self, PyObject* file, int protocol)
    Pickle the object in *self* to the given *file* (either a string
    or a Python file object). If *file* is a Python string it is
    considered to be the name of a file which is then opened in binary
    mode. The given *protocol* is used (if *protocol* is negative, or
    the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Dumps(PyObject* self, int protocol)
    Pickle the object in *self* to a Python string and return it. Use
    the Pickle *protocol* provided (or the highest available if
    *protocol* is negative).</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_FillWithScalar(PyArrayObject* arr, PyObject* obj)
    Fill the array, *arr*, with the given scalar object, *obj*. The
    object is first converted to the data type of *arr*, and then
    copied into every location. A -1 is returned if an error occurs,
    otherwise 0 is returned.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_View( \
    PyArrayObject* self, PyArray_Descr* dtype, PyTypeObject *ptype)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.view&lt;numpy.ndarray.view&gt;</code>
 (<em>self</em>, <em>dtype</em>). Return a new     view of the array <em>self</em> as possibly a different data-type, <em>dtype</em>,     and different array subclass <em>ptype</em>.</p>
<p>If <em>dtype</em> is         <code class='verbatim'>NULL</code>
, then the returned array will have the same     data type as <em>self</em>. The new data-type must be consistent with the     size of <em>self</em>. Either the itemsizes must be identical, or <em>self</em> must     be single-segment and the total number of bytes must be the same.     In the latter case the dimensions of the returned array will be     altered in the last (or first for Fortran-style contiguous arrays)     dimension. The data area of the returned array and self is exactly     the same.</p>
</blockquote>


<h3>Shape Manipulation</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Newshape( \
    PyArrayObject* self, PyArray_Dims* newshape, NPY_ORDER order)</pre>


                           <blockquote><p>Result will be a new array (pointing to the same memory location     as <em>self</em> if possible), but having a shape given by <em>newshape</em>.     If the new shape is not compatible with the strides of <em>self</em>,     then a copy of the array with the new specified shape will be     returned.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Reshape(PyArrayObject* self, PyObject* shape)
    Equivalent to :meth:`ndarray.reshape&lt;numpy.ndarray.reshape&gt;` (*self*, *shape*) where *shape* is a
    sequence. Converts *shape* to a :c:type:`PyArray_Dims` structure and
    calls :c:func:`PyArray_Newshape` internally.
    For back-ward compatibility -- Not recommended</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Squeeze(PyArrayObject* self)
    Equivalent to :meth:`ndarray.squeeze&lt;numpy.ndarray.squeeze&gt;` (*self*). Return a new view of *self*
    with all of the dimensions of length 1 removed from the shape.</pre>


                           <div class='admonition'>
    <div>warning</div>
        <p>matrix objects are always 2-dimensional. Therefore, <code class='not-implemented'>:c:func:`PyArray_Squeeze`</code> has no effect on arrays of matrix sub-class.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_SwapAxes(PyArrayObject* self, int a1, int a2)
    Equivalent to :meth:`ndarray.swapaxes&lt;numpy.ndarray.swapaxes&gt;` (*self*, *a1*, *a2*). The returned
    array is a new view of the data in *self* with the given axes,
    *a1* and *a2*, swapped.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Resize( \
    PyArrayObject* self, PyArray_Dims* newshape, int refcheck, \
    NPY_ORDER fortran)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.resize&lt;numpy.ndarray.resize&gt;</code>
 (<em>self</em>, <em>newshape</em>, refcheck             <code class='verbatim'>=</code>
 <em>refcheck</em>, order= fortran ). This function only works on     single-segment arrays. It changes the shape of <em>self</em> inplace and     will reallocate the memory for <em>self</em> if <em>newshape</em> has a     different total number of elements then the old shape. If     reallocation is necessary, then <em>self</em> must own its data, have     <em>self</em> -         <code class='verbatim'>&gt;base==NULL</code>
, have <em>self</em> -         <code class='verbatim'>&gt;weakrefs==NULL</code>
, and     (unless refcheck is 0) not be referenced by any other array.     The fortran argument can be         <code class='verbatim'>NPY_ANYORDER</code>
,         <code class='verbatim'>NPY_CORDER</code>
,     or         <code class='verbatim'>NPY_FORTRANORDER</code>
. It currently has no effect. Eventually     it could be used to determine how the resize operation should view     the data when constructing a differently-dimensioned array.     Returns None on success and NULL on error.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Transpose( \
    PyArrayObject* self, PyArray_Dims* permute)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.transpose&lt;numpy.ndarray.transpose&gt;</code>
 (<em>self</em>, <em>permute</em>). Permute the     axes of the ndarray object <em>self</em> according to the data structure     <em>permute</em> and return the result. If <em>permute</em> is         <code class='verbatim'>NULL</code>
, then     the resulting array has its axes reversed. For example if <em>self</em>     has shape         <span class="tex2jax_process">$10\times20\times30$</span>
, and <em>permute</em>         <code class='verbatim'>.ptr</code>
 is     (0,2,1) the shape of the result is         <span class="tex2jax_process">$10\times30\times20.$</span>
 If     <em>permute</em> is         <code class='verbatim'>NULL</code>
, the shape of the result is             <span class="tex2jax_process">$30\times20\times10.$</span>
</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Flatten(PyArrayObject* self, NPY_ORDER order)
    Equivalent to :meth:`ndarray.flatten&lt;numpy.ndarray.flatten&gt;` (*self*, *order*). Return a 1-d copy
    of the array. If *order* is :c:data:`NPY_FORTRANORDER` the elements are
    scanned out in Fortran order (first-dimension varies the
    fastest). If *order* is :c:data:`NPY_CORDER`, the elements of ``self``
    are scanned in C-order (last dimension varies the fastest). If
    *order* :c:data:`NPY_ANYORDER`, then the result of
    :c:func:`PyArray_ISFORTRAN` (*self*) is used to determine which order
    to flatten.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Ravel(PyArrayObject* self, NPY_ORDER order)
    Equivalent to *self*.ravel(*order*). Same basic functionality
    as :c:func:`PyArray_Flatten` (*self*, *order*) except if *order* is 0
    and *self* is C-style contiguous, the shape is altered but no copy
    is performed.</pre>



<h3>Item selection and manipulation</h3>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_TakeFrom( \
    PyArrayObject* self, PyObject* indices, int axis, PyArrayObject* ret, \
    NPY_CLIPMODE clipmode)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.take&lt;numpy.ndarray.take&gt;</code>
 (<em>self</em>, <em>indices</em>, <em>axis</em>, <em>ret</em>,     <em>clipmode</em>) except <em>axis</em> =None in Python is obtained by setting     <em>axis</em> =         <code class='verbatim'>NPY_MAXDIMS</code>
 in C. Extract the items from self     indicated by the integer-valued <em>indices</em> along the given <em>axis.</em>     The clipmode argument can be         <code class='verbatim'>NPY_RAISE</code>
,         <code class='verbatim'>NPY_WRAP</code>
, or             <code class='verbatim'>NPY_CLIP</code>
 to indicate what to do with out-of-bound indices. The     <em>ret</em> argument can specify an output array rather than having one     created internally.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_PutTo( \
    PyArrayObject* self, PyObject* values, PyObject* indices, \
    NPY_CLIPMODE clipmode)</pre>


                           <blockquote><p>Equivalent to <em>self</em>.put(<em>values</em>, <em>indices</em>, <em>clipmode</em>     ). Put <em>values</em> into <em>self</em> at the corresponding (flattened)     <em>indices</em>. If <em>values</em> is too small it will be repeated as     necessary.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_PutMask( \
    PyArrayObject* self, PyObject* values, PyObject* mask)</pre>


                           <blockquote><p>Place the <em>values</em> in <em>self</em> wherever corresponding positions     (using a flattened context) in <em>mask</em> are true. The <em>mask</em> and     <em>self</em> arrays must have the same total number of elements. If     <em>values</em> is too small, it will be repeated as necessary.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Repeat( \
    PyArrayObject* self, PyObject* op, int axis)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.repeat&lt;numpy.ndarray.repeat&gt;</code>
 (<em>self</em>, <em>op</em>, <em>axis</em>). Copy the     elements of <em>self</em>, <em>op</em> times along the given <em>axis</em>. Either     <em>op</em> is a scalar integer or a sequence of length <em>self</em>     -&gt;dimensions[ <em>axis</em> ] indicating how many times to repeat each     item along the axis.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Choose( \
    PyArrayObject* self, PyObject* op, PyArrayObject* ret, \
    NPY_CLIPMODE clipmode)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.choose&lt;numpy.ndarray.choose&gt;</code>
 (<em>self</em>, <em>op</em>, <em>ret</em>, <em>clipmode</em>).     Create a new array by selecting elements from the sequence of     arrays in <em>op</em> based on the integer values in <em>self</em>. The arrays     must all be broadcastable to the same shape and the entries in     <em>self</em> should be between 0 and len(<em>op</em>). The output is placed     in <em>ret</em> unless it is         <code class='verbatim'>NULL</code>
 in which case a new output is     created. The <em>clipmode</em> argument determines behavior for when     entries in <em>self</em> are not between 0 and len(<em>op</em>).</p>
<pre class='not-implemented'>
.. c:macro:: NPY_RAISE
    raise a ValueError;</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_WRAP
    wrap values &lt; 0 by adding len(*op*) and values &gt;=len(*op*)
        by subtracting len(*op*) until they are in range;</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_CLIP
    all values are clipped to the region [0, len(*op*) ).</pre>

</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Sort(PyArrayObject* self, int axis, NPY_SORTKIND kind)
    Equivalent to :meth:`ndarray.sort&lt;numpy.ndarray.sort&gt;` (*self*, *axis*, *kind*).
    Return an array with the items of *self* sorted along *axis*. The array
    is sorted using the algorithm denoted by *kind*, which is an integer/enum pointing
    to the type of sorting algorithms used.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ArgSort(PyArrayObject* self, int axis)
    Equivalent to :meth:`ndarray.argsort&lt;numpy.ndarray.argsort&gt;` (*self*, *axis*).
    Return an array of indices such that selection of these indices
    along the given ``axis`` would return a sorted version of *self*. If *self* -&gt;descr
    is a data-type with fields defined, then self-&gt;descr-&gt;names is used
    to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a
    structured array, create a new data-type with a different order of names
    and construct a view of the array with that new data-type.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_LexSort(PyObject* sort_keys, int axis)
    Given a sequence of arrays (*sort_keys*) of the same shape,
    return an array of indices (similar to :c:func:`PyArray_ArgSort` (...))
    that would sort the arrays lexicographically. A lexicographic sort
    specifies that when two keys are found to be equal, the order is
    based on comparison of subsequent keys. A merge sort (which leaves
    equal entries unmoved) is required to be defined for the
    types. The sort is accomplished by sorting the indices first using
    the first *sort_key* and then using the second *sort_key* and so
    forth. This is equivalent to the lexsort(*sort_keys*, *axis*)
    Python command. Because of the way the merge-sort works, be sure
    to understand the order the *sort_keys* must be in (reversed from
    the order you would use when comparing two elements).

    If these arrays are all collected in a structured array, then
    :c:func:`PyArray_Sort` (...) can also be used to sort the array
    directly.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_SearchSorted( \
    PyArrayObject* self, PyObject* values, NPY_SEARCHSIDE side, \
    PyObject* perm)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.searchsorted&lt;numpy.ndarray.searchsorted&gt;</code>
 (<em>self</em>, <em>values</em>, <em>side</em>,     <em>perm</em>). Assuming <em>self</em> is a 1-d array in ascending order, then the     output is an array of indices the same shape as <em>values</em> such that, if     the elements in <em>values</em> were inserted before the indices, the order of     <em>self</em> would be preserved. No checking is done on whether or not self is     in ascending order.</p>
<p>The <em>side</em> argument indicates whether the index returned should be that of     the first suitable location (if         <code class='verbatim'>NPY_SEARCHLEFT</code>
) or of the last     (if         <code class='verbatim'>NPY_SEARCHRIGHT</code>
).</p>
<p>The <em>sorter</em> argument, if not         <code class='verbatim'>NULL</code>
, must be a 1D array of integer     indices the same length as <em>self</em>, that sorts it into ascending order.     This is typically the result of a call to         <code class='verbatim'>PyArray_ArgSort</code>
 (...)     Binary search is used to find the required insertion points.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_Partition( \
    PyArrayObject *self, PyArrayObject * ktharray, int axis, \
    NPY_SELECTKIND which)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.partition&lt;numpy.ndarray.partition&gt;</code>
 (<em>self</em>, <em>ktharray</em>, <em>axis</em>,     <em>kind</em>). Partitions the array so that the values of the element indexed by     <em>ktharray</em> are in the positions they would be if the array is fully sorted     and places all elements smaller than the kth before and all elements equal     or greater after the kth element. The ordering of all elements within the     partitions is undefined.     If <em>self</em>-&gt;descr is a data-type with fields defined, then     self-&gt;descr-&gt;names is used to determine the sort order. A comparison where     the first field is equal will use the second field and so on. To alter the     sort order of a structured array, create a new data-type with a different     order of names and construct a view of the array with that new data-type.     Returns zero on success and -1 on failure.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ArgPartition( \
    PyArrayObject *op, PyArrayObject * ktharray, int axis, \
    NPY_SELECTKIND which)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.argpartition&lt;numpy.ndarray.argpartition&gt;</code>
 (<em>self</em>, <em>ktharray</em>, <em>axis</em>,     <em>kind</em>). Return an array of indices such that selection of these indices     along the given         <code class='verbatim'>axis</code>
 would return a partitioned version of <em>self</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Diagonal( \
    PyArrayObject* self, int offset, int axis1, int axis2)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.diagonal&lt;numpy.ndarray.diagonal&gt;</code>
 (<em>self</em>, <em>offset</em>, <em>axis1</em>, <em>axis2</em>     ). Return the <em>offset</em> diagonals of the 2-d arrays defined by     <em>axis1</em> and <em>axis2</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_CountNonzero(PyArrayObject* self)
    .. versionadded:: 1.6

    Counts the number of non-zero elements in the array object *self*.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Nonzero(PyArrayObject* self)
    Equivalent to :meth:`ndarray.nonzero&lt;numpy.ndarray.nonzero&gt;` (*self*). Returns a tuple of index
    arrays that select elements of *self* that are nonzero. If (nd=
    :c:func:`PyArray_NDIM` ( ``self`` ))==1, then a single index array is
    returned. The index arrays have data type :c:data:`NPY_INTP`. If a
    tuple is returned (nd :math:`\neq` 1), then its length is nd.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Compress( \
    PyArrayObject* self, PyObject* condition, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.compress&lt;numpy.ndarray.compress&gt;</code>
 (<em>self</em>, <em>condition</em>, <em>axis</em>     ). Return the elements along <em>axis</em> corresponding to elements of     <em>condition</em> that are true.</p>
</blockquote>


<h3>Calculation</h3>
               <pre class='not-implemented'>
.. tip:: 
    Pass in :c:data:`NPY_MAXDIMS` for axis in order to achieve the same
    effect that is obtained by passing in ``axis=None`` in Python
    (treating the array as a 1-d array).</pre>


                           <div class='admonition'>
    <div>note</div>
        <p>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to         <code class='verbatim'>Py_DECREF</code>
 out if not NULL or a memory-leak will occur.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ArgMax( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.argmax&lt;numpy.ndarray.argmax&gt;</code>
 (<em>self</em>, <em>axis</em>). Return the index of     the largest element of <em>self</em> along <em>axis</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ArgMin( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.argmin&lt;numpy.ndarray.argmin&gt;</code>
 (<em>self</em>, <em>axis</em>). Return the index of     the smallest element of <em>self</em> along <em>axis</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Max( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.max&lt;numpy.ndarray.max&gt;</code>
 (<em>self</em>, <em>axis</em>). Returns the largest     element of <em>self</em> along the given <em>axis</em>. When the result is a single     element, returns a numpy scalar instead of an ndarray.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Min( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.min&lt;numpy.ndarray.min&gt;</code>
 (<em>self</em>, <em>axis</em>). Return the smallest     element of <em>self</em> along the given <em>axis</em>. When the result is a single     element, returns a numpy scalar instead of an ndarray.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Ptp( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.ptp&lt;numpy.ndarray.ptp&gt;</code>
 (<em>self</em>, <em>axis</em>). Return the difference     between the largest element of <em>self</em> along <em>axis</em> and the     smallest element of <em>self</em> along <em>axis</em>. When the result is a single     element, returns a numpy scalar instead of an ndarray.</p>
</blockquote>

                           <div class='admonition'>
    <div>note</div>
        <p>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &#34;large&#34; enough to handle the output. By default, all integer data-types are made at least as large as <code class='not-implemented'>:c:data:`NPY_LONG`</code> for the &#34;add&#34; and &#34;multiply&#34; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</p>

</div>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Mean( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.mean&lt;numpy.ndarray.mean&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Returns the     mean of the elements along the given <em>axis</em>, using the enumerated     type <em>rtype</em> as the data type to sum in. Default sum behavior is     obtained using         <code class='verbatim'>NPY_NOTYPE</code>
 for <em>rtype</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Trace( \
    PyArrayObject* self, int offset, int axis1, int axis2, int rtype, \
    PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.trace&lt;numpy.ndarray.trace&gt;</code>
 (<em>self</em>, <em>offset</em>, <em>axis1</em>, <em>axis2</em>,     <em>rtype</em>). Return the sum (using <em>rtype</em> as the data type of     summation) over the <em>offset</em> diagonal elements of the 2-d arrays     defined by <em>axis1</em> and <em>axis2</em> variables. A positive offset     chooses diagonals above the main diagonal. A negative offset     selects diagonals below the main diagonal.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Clip( \
    PyArrayObject* self, PyObject* min, PyObject* max)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.clip&lt;numpy.ndarray.clip&gt;</code>
 (<em>self</em>, <em>min</em>, <em>max</em>). Clip an array,     <em>self</em>, so that values larger than <em>max</em> are fixed to <em>max</em> and     values less than <em>min</em> are fixed to <em>min</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Conjugate(PyArrayObject* self)
    Equivalent to :meth:`ndarray.conjugate&lt;numpy.ndarray.conjugate&gt;` (*self*).
    Return the complex conjugate of *self*. If *self* is not of
    complex data type, then return *self* with a reference.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Round( \
    PyArrayObject* self, int decimals, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.round&lt;numpy.ndarray.round&gt;</code>
 (<em>self</em>, <em>decimals</em>, <em>out</em>). Returns     the array with elements rounded to the nearest decimal place. The     decimal place is defined as the         <span class="tex2jax_process">$10^{-\textrm{decimals}}$</span>
     digit so that negative <em>decimals</em> cause rounding to the nearest 10&#39;s, 100&#39;s, etc. If out is         <code class='verbatim'>NULL</code>
, then the output array is created, otherwise the output is placed in <em>out</em> which must be the correct size and type.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Std( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.std&lt;numpy.ndarray.std&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return the     standard deviation using data along <em>axis</em> converted to data type     <em>rtype</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Sum( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.sum&lt;numpy.ndarray.sum&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return 1-d     vector sums of elements in <em>self</em> along <em>axis</em>. Perform the sum     after converting data to data type <em>rtype</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_CumSum( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.cumsum&lt;numpy.ndarray.cumsum&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return     cumulative 1-d sums of elements in <em>self</em> along <em>axis</em>. Perform     the sum after converting data to data type <em>rtype</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Prod( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.prod&lt;numpy.ndarray.prod&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return 1-d     products of elements in <em>self</em> along <em>axis</em>. Perform the product     after converting data to data type <em>rtype</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_CumProd( \
    PyArrayObject* self, int axis, int rtype, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.cumprod&lt;numpy.ndarray.cumprod&gt;</code>
 (<em>self</em>, <em>axis</em>, <em>rtype</em>). Return     1-d cumulative products of elements in         <code class='verbatim'>self</code>
 along         <code class='verbatim'>axis</code>
.     Perform the product after converting data to data type         <code class='verbatim'>rtype</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_All( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.all&lt;numpy.ndarray.all&gt;</code>
 (<em>self</em>, <em>axis</em>). Return an array with     True elements for every 1-d sub-array of         <code class='verbatim'>self</code>
 defined by             <code class='verbatim'>axis</code>
 in which all the elements are True.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Any( \
    PyArrayObject* self, int axis, PyArrayObject* out)</pre>


                           <blockquote><p>Equivalent to         <code class='verbatim'>ndarray.any&lt;numpy.ndarray.any&gt;</code>
 (<em>self</em>, <em>axis</em>). Return an array with     True elements for every 1-d sub-array of <em>self</em> defined by <em>axis</em>     in which any of the elements are True.</p>
</blockquote>


<h2>Functions</h2>

<h3>Array Functions</h3>
               <pre class='not-implemented'>
.. c:function:: int PyArray_AsCArray( \
    PyObject** op, void* ptr, npy_intp* dims, int nd, \
    PyArray_Descr* typedescr)</pre>


                           <blockquote><p>Sometimes it is useful to access a multidimensional array as a     C-style multi-dimensional array so that algorithms can be     implemented using C&#39;s a[i][j][k] syntax. This routine returns a     pointer, <em>ptr</em>, that simulates this kind of C-style array, for     1-, 2-, and 3-d ndarrays.</p>
           <dl>               <dt>                           paramop  
               </dt>
               <dd>                <p>The address to any Python object. This Python object will be replaced         with an equivalent well-behaved, C-style contiguous, ndarray of the         given data type specified by the last two arguments. Be sure that         stealing a reference in this way to the input object is justified.</p>

               </dd>
               <dt>                           paramptr  
               </dt>
               <dd>                <p>The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for 3-d)         variable where ctype is the equivalent C-type for the data type. On         return, <em>ptr</em> will be addressable as a 1-d, 2-d, or 3-d array.</p>

               </dd>
               <dt>                           paramdims  
               </dt>
               <dd>                <p>An output array that contains the shape of the array object. This         array gives boundaries on any looping that will take place.</p>

               </dd>
               <dt>                           paramnd  
               </dt>
               <dd>                <p>The dimensionality of the array (1, 2, or 3).</p>

               </dd>
               <dt>                           paramtypedescr  
               </dt>
               <dd>                <p>A         <code class='verbatim'>PyArray_Descr</code>
 structure indicating the desired data-type         (including required byteorder). The call will steal a reference to         the parameter.</p>

               </dd>
           </dl>

</blockquote>

                           <div class='admonition'>
    <div>note</div>
        <p>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: int PyArray_Free(PyObject* op, void* ptr)
    Must be called with the same objects and memory locations returned
    from :c:func:`PyArray_AsCArray` (...). This function cleans up memory
    that otherwise would get leaked.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Concatenate(PyObject* obj, int axis)
    Join the sequence of objects in *obj* together along *axis* into a
    single array. If the dimensions or types are not compatible an
    error is raised.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_InnerProduct(PyObject* obj1, PyObject* obj2)
    Compute a product-sum over the last dimensions of *obj1* and
    *obj2*. Neither array is conjugated.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_MatrixProduct(PyObject* obj1, PyObject* obj)
    Compute a product-sum over the last dimension of *obj1* and the
    second-to-last dimension of *obj2*. For 2-d arrays this is a
    matrix-product. Neither array is conjugated.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_MatrixProduct2( \
    PyObject* obj1, PyObject* obj, PyArrayObject* out)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>Same as PyArray_MatrixProduct, but store the result in <em>out</em>.  The     output array must have the correct shape, type, and be     C-contiguous, or an exception is raised.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_EinsteinSum( \
    char* subscripts, npy_intp nop, PyArrayObject** op_in, \
    PyArray_Descr* dtype, NPY_ORDER order, NPY_CASTING casting, \
    PyArrayObject* out)</pre>


                           <blockquote>            <div class='admonition'>
    <div>versionadded</div>
</div>

<p>Applies the Einstein summation convention to the array operands     provided, returning a new array or placing the result in <em>out</em>.     The string in <em>subscripts</em> is a comma separated list of index     letters. The number of operands is in <em>nop</em>, and <em>op_in</em> is an     array containing those operands. The data type of the output can     be forced with <em>dtype</em>, the output order can be forced with <em>order</em>     (        <code class='verbatim'>NPY_KEEPORDER</code>
 is recommended), and when <em>dtype</em> is specified,     <em>casting</em> indicates how permissive the data conversion should be.</p>
<p>See the         <code class='verbatim'>~numpy.einsum</code>
 function for more details.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_CopyAndTranspose(PyObject * op)
    A specialized copy and transpose function that works only for 2-d
    arrays. The returned array is a transposed copy of *op*.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Correlate( \
    PyObject* op1, PyObject* op2, int mode)</pre>


                           <blockquote><p>Compute the 1-d correlation of the 1-d arrays <em>op1</em> and <em>op2</em>     . The correlation is computed at each output point by multiplying     <em>op1</em> by a shifted version of <em>op2</em> and summing the result. As a     result of the shift, needed values outside of the defined range of     <em>op1</em> and <em>op2</em> are interpreted as zero. The mode determines how     many shifts to return: 0 - return only shifts that did not need to     assume zero- values; 1 - return an object that is the same size as     <em>op1</em>, 2 - return all possible shifts (any overlap at all is     accepted).</p>
<pre class='not-implemented'>
.. rubric:: Notes
    </pre>

<p>This does not compute the usual correlation: if op2 is larger than op1, the     arguments are swapped, and the conjugate is never taken for complex arrays.     See PyArray_Correlate2 for the usual signal processing correlation.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Correlate2( \
    PyObject* op1, PyObject* op2, int mode)</pre>


                           <blockquote><p>Updated version of PyArray_Correlate, which uses the usual definition of     correlation for 1d arrays. The correlation is computed at each output point     by multiplying <em>op1</em> by a shifted version of <em>op2</em> and summing the result.     As a result of the shift, needed values outside of the defined range of     <em>op1</em> and <em>op2</em> are interpreted as zero. The mode determines how many     shifts to return: 0 - return only shifts that did not need to assume zero-     values; 1 - return an object that is the same size as <em>op1</em>, 2 - return all     possible shifts (any overlap at all is accepted).</p>
<pre class='not-implemented'>
.. rubric:: Notes
    </pre>

<p>Compute z as follows:        </p>
<pre>z[k] = sum_n op1[n] * conj(op2[n+k])</pre></blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Where( \
    PyObject* condition, PyObject* x, PyObject* y)</pre>


                           <blockquote><p>If both         <code class='verbatim'>x</code>
 and         <code class='verbatim'>y</code>
 are         <code class='verbatim'>NULL</code>
, then return             <code class='verbatim'>PyArray_Nonzero</code>
 (<em>condition</em>). Otherwise, both <em>x</em> and <em>y</em>     must be given and the object returned is shaped like <em>condition</em>     and has elements of <em>x</em> and <em>y</em> where <em>condition</em> is respectively     True or False.</p>
</blockquote>


<h3>Other functions</h3>
               <pre class='not-implemented'>
.. c:function:: npy_bool PyArray_CheckStrides( \
    int elsize, int nd, npy_intp numbytes, npy_intp const* dims, \
    npy_intp const* newstrides)</pre>


                           <blockquote><p>Determine if <em>newstrides</em> is a strides array consistent with the     memory of an <em>nd</em> -dimensional array with shape         <code class='verbatim'>dims</code>
 and     element-size, <em>elsize</em>. The <em>newstrides</em> array is checked to see     if jumping by the provided number of bytes in each direction will     ever mean jumping more than <em>numbytes</em> which is the assumed size     of the available memory segment. If <em>numbytes</em> is 0, then an     equivalent <em>numbytes</em> is computed assuming <em>nd</em>, <em>dims</em>, and     <em>elsize</em> refer to a single-segment array. Return         <code class='verbatim'>NPY_TRUE</code>
 if     <em>newstrides</em> is acceptable, otherwise return         <code class='verbatim'>NPY_FALSE</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_MultiplyList(npy_intp const* seq, int n)
    </pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_MultiplyIntList(int const* seq, int n)
    Both of these routines multiply an *n* -length array, *seq*, of
    integers and return the result. No overflow checking is performed.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CompareLists(npy_intp const* l1, npy_intp const* l2, int n)
    Given two *n* -length arrays of integers, *l1*, and *l2*, return
    1 if the lists are identical; otherwise, return 0.</pre>



<h2>Auxiliary Data With Object Semantics</h2>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <pre class='not-implemented'>
.. c:type:: NpyAuxData
    </pre>


               <p>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct         <code class='verbatim'>NpyAuxData</code>
, mandating a few conventions so that it is possible to do this.</p>

               <p>Defining an         <code class='verbatim'>NpyAuxData</code>
 is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here&#39;s an example for a function which doubles up an element using an element copier function as a primitive.</p>

               <pre class='not-implemented'>
.. code-block:: c
    typedef struct {
        NpyAuxData base;
        ElementCopier_Func *func;
        NpyAuxData *funcdata;
    } eldoubler_aux_data;

    void free_element_doubler_aux_data(NpyAuxData *data)
    {
        eldoubler_aux_data *d = (eldoubler_aux_data *)data;
        /* Free the memory owned by this auxdata */
        NPY_AUXDATA_FREE(d-&gt;funcdata);
        PyArray_free(d);
    }

    NpyAuxData *clone_element_doubler_aux_data(NpyAuxData *data)
    {
        eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));
        if (ret == NULL) {
            return NULL;
        }

        /* Raw copy of all data */
        memcpy(ret, data, sizeof(eldoubler_aux_data));

        /* Fix up the owned auxdata so we have our own copy */
        ret-&gt;funcdata = NPY_AUXDATA_CLONE(ret-&gt;funcdata);
        if (ret-&gt;funcdata == NULL) {
            PyArray_free(ret);
            return NULL;
        }

        return (NpyAuxData *)ret;
    }

    NpyAuxData *create_element_doubler_aux_data(
                                ElementCopier_Func *func,
                                NpyAuxData *funcdata)
    {
        eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));
        if (ret == NULL) {
            PyErr_NoMemory();
            return NULL;
        }
        memset(&amp;ret, 0, sizeof(eldoubler_aux_data));
        ret-&gt;base-&gt;free = &amp;free_element_doubler_aux_data;
        ret-&gt;base-&gt;clone = &amp;clone_element_doubler_aux_data;
        ret-&gt;func = func;
        ret-&gt;funcdata = funcdata;

        return (NpyAuxData *)ret;
    }</pre>


               <pre class='not-implemented'>
.. c:type:: NpyAuxData_FreeFunc
    The function pointer type for NpyAuxData free functions.</pre>


               <pre class='not-implemented'>
.. c:type:: NpyAuxData_CloneFunc
    The function pointer type for NpyAuxData clone functions. These
    functions should never set the Python exception on error, because
    they may be called from a multi-threaded context.</pre>


               <pre class='not-implemented'>
.. c:function:: void NPY_AUXDATA_FREE(NpyAuxData *auxdata)
    A macro which calls the auxdata&#39;s free function appropriately,
    does nothing if auxdata is NULL.</pre>


               <pre class='not-implemented'>
.. c:function:: NpyAuxData *NPY_AUXDATA_CLONE(NpyAuxData *auxdata)
    A macro which calls the auxdata&#39;s clone function appropriately,
    returning a deep copy of the auxiliary data.</pre>



<h2>Array Iterators</h2>
               <p>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator,         <code class='verbatim'>NpyIter</code>
.</p>

               <p>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section <code class='not-implemented'>:None:None:`2
&lt;#sec-array-iterator&gt;`</code> provides more description and examples of this useful approach to looping over an array.</p>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_IterNew(PyObject* arr)
    Return an array iterator object from the array, *arr*. This is
    equivalent to *arr*. **flat**. The array iterator object makes
    it easy to loop over an N-dimensional non-contiguous array in
    C-style contiguous fashion.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_IterAllButAxis(PyObject* arr, int* axis)
    Return an array iterator that will iterate over all axes but the
    one provided in *\*axis*. The returned iterator cannot be used
    with :c:func:`PyArray_ITER_GOTO1D`. This iterator could be used to
    write something similar to what ufuncs do wherein the loop over
    the largest axis is done by a separate sub-routine. If *\*axis* is
    negative then *\*axis* will be set to the axis having the smallest
    stride and that axis will be used.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject *PyArray_BroadcastToShape( \
    PyObject* arr, npy_intp const *dimensions, int nd)</pre>


                           <blockquote><p>Return an array iterator that is broadcast to iterate as an array     of the shape provided by <em>dimensions</em> and <em>nd</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArrayIter_Check(PyObject* op)
    Evaluates true if *op* is an array iterator (or instance of a
    subclass of the array iterator type).</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_ITER_RESET(PyObject* iterator)
    Reset an *iterator* to the beginning of the array.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_ITER_NEXT(PyObject* iterator)
    Incremement the index and the dataptr members of the *iterator* to
    point to the next element of the array. If the array is not
    (C-style) contiguous, also increment the N-dimensional coordinates
    array.</pre>


               <pre class='not-implemented'>
.. c:function:: void *PyArray_ITER_DATA(PyObject* iterator)
    A pointer to the current element of the array.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_ITER_GOTO( \
    PyObject* iterator, npy_intp* destination)</pre>


                           <blockquote><p>Set the <em>iterator</em> index, dataptr, and coordinates members to the     location in the array indicated by the N-dimensional c-array,     <em>destination</em>, which must have size at least <em>iterator</em>     -&gt;nd_m1+1.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_ITER_GOTO1D(PyObject* iterator, npy_intp index)
    Set the *iterator* index and dataptr to the location in the array
    indicated by the integer *index* which points to an element in the
    C-styled flattened array.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ITER_NOTDONE(PyObject* iterator)
    Evaluates TRUE as long as the iterator has not looped through all of
    the elements, otherwise it evaluates FALSE.</pre>



<h2>Broadcasting (multi-iterators)</h2>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_MultiIterNew(int num, ...)
    A simplified interface to broadcasting. This function takes the
    number of arrays to broadcast and then *num* extra ( :c:type:`PyObject *&lt;PyObject&gt;`
    ) arguments. These arguments are converted to arrays and iterators
    are created. :c:func:`PyArray_Broadcast` is then called on the resulting
    multi-iterator object. The resulting, broadcasted mult-iterator
    object is then returned. A broadcasted operation can then be
    performed using a single loop and using :c:func:`PyArray_MultiIter_NEXT`
    (..)</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_MultiIter_RESET(PyObject* multi)
    Reset all the iterators to the beginning in a multi-iterator
    object, *multi*.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_MultiIter_NEXT(PyObject* multi)
    Advance each iterator in a multi-iterator object, *multi*, to its
    next (broadcasted) element.</pre>


               <pre class='not-implemented'>
.. c:function:: void *PyArray_MultiIter_DATA(PyObject* multi, int i)
    Return the data-pointer of the *i* :math:`^{\textrm{th}}` iterator
    in a multi-iterator object.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_MultiIter_NEXTi(PyObject* multi, int i)
    Advance the pointer of only the *i* :math:`^{\textrm{th}}` iterator.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_MultiIter_GOTO( \
    PyObject* multi, npy_intp* destination)</pre>


                           <blockquote><p>Advance each iterator in a multi-iterator object, <em>multi</em>, to the     given         <span class="tex2jax_process">$N$</span>
 -dimensional <em>destination</em> where         <span class="tex2jax_process">$N$</span>
 is the     number of dimensions in the broadcasted array.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_MultiIter_GOTO1D(PyObject* multi, npy_intp index)
    Advance each iterator in a multi-iterator object, *multi*, to the
    corresponding location of the *index* into the flattened
    broadcasted array.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_MultiIter_NOTDONE(PyObject* multi)
    Evaluates TRUE as long as the multi-iterator has not looped
    through all of the elements (of the broadcasted result), otherwise
    it evaluates FALSE.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_Broadcast(PyArrayMultiIterObject* mit)
    This function encapsulates the broadcasting rules. The *mit*
    container should already contain iterators for all the arrays that
    need to be broadcast. On return, these iterators will be adjusted
    so that iteration over each simultaneously will accomplish the
    broadcasting. A negative number is returned if an error occurs.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_RemoveSmallest(PyArrayMultiIterObject* mit)
    This function takes a multi-iterator object that has been
    previously &#34;broadcasted,&#34; finds the dimension with the smallest
    &#34;sum of strides&#34; in the broadcasted result and adapts all the
    iterators so as not to iterate over that dimension (by effectively
    making them of length-1 in that dimension). The corresponding
    dimension is returned unless *mit* -&gt;nd is 0, then -1 is
    returned. This function is useful for constructing ufunc-like
    routines that broadcast their inputs correctly and then call a
    strided 1-d version of the routine as the inner-loop.  This 1-d
    version is usually optimized for speed and for this reason the
    loop should be performed over the axis that won&#39;t require large
    stride jumps.</pre>



<h2>Neighborhood iterator</h2>
                           <div class='admonition'>
    <div>versionadded</div>
</div>


               <p>Neighborhood iterators are subclasses of the iterator object, and can be used to iter over a neighborhood of a point. For example, you may want to iterate over every voxel of a 3d image, and for every such voxel, iterate over an hypercube. Neighborhood iterator automatically handle boundaries, thus making this kind of code much easier to write than manual boundaries handling, at the cost of a slight overhead.</p>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_NeighborhoodIterNew( \
    PyArrayIterObject* iter, npy_intp bounds, int mode, \
    PyArrayObject* fill_value)</pre>


                           <blockquote><p>This function creates a new neighborhood iterator from an existing     iterator.  The neighborhood will be computed relatively to the position     currently pointed by <em>iter</em>, the bounds define the shape of the     neighborhood iterator, and the mode argument the boundaries handling mode.</p>
<p>The <em>bounds</em> argument is expected to be a (2 * iter-&gt;ao-&gt;nd) arrays, such     as the range bound[2*i]-&gt;bounds[2*i+1] defines the range where to walk for     dimension i (both bounds are included in the walked coordinates). The     bounds should be ordered for each dimension (bounds[2*i] &lt;= bounds[2*i+1]).</p>
<p>The mode should be one of:</p>
<pre class='not-implemented'>
.. c:macro:: NPY_NEIGHBORHOOD_ITER_ZERO_PADDING
    Zero padding. Outside bounds values will be 0.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_NEIGHBORHOOD_ITER_ONE_PADDING
    One padding, Outside bounds values will be 1.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING
    Constant padding. Outside bounds values will be the
        same as the first item in fill_value.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING
    Mirror padding. Outside bounds values will be as if the
        array items were mirrored. For example, for the array [1, 2, 3, 4],
        x[-2] will be 2, x[-2] will be 1, x[4] will be 4, x[5] will be 1,
        etc...</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING
    Circular padding. Outside bounds values will be as if the array
        was repeated. For example, for the array [1, 2, 3, 4], x[-2] will
        be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc...</pre>

<p>If the mode is constant filling (<code class='not-implemented'>:None:None:`NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING`</code>),     fill_value should point to an array object which holds the filling value     (the first item will be the filling value if the array contains more than     one item). For other cases, fill_value may be NULL.</p>
           <ul>               <li>               <p>The iterator holds a reference to iter</p>

</li>
               <li>               <p>Return NULL on failure (in which case the reference count of iter is not       changed)</p>

</li>
               <li>               <p>iter itself can be a Neighborhood iterator: this can be useful for .e.g       automatic boundaries handling</p>

</li>
               <li>               <p>the object returned by this function should be safe to use as a normal       iterator</p>

</li>
               <li>               <p>If the position of iter is changed, any subsequent call to       PyArrayNeighborhoodIter_Next is undefined behavior, and       PyArrayNeighborhoodIter_Reset must be called.</p>

</li>
               <li>               <p>If the position of iter is not the beginning of the data and the       underlying data for iter is contiguous, the iterator will point to the       start of the data instead of position pointed by iter.       To avoid this situation, iter should be moved to the required position       only after the creation of iterator, and PyArrayNeighborhoodIter_Reset       must be called.</p>

</li>
            </ul>
<pre class='not-implemented'>
.. code-block:: c
    PyArrayIterObject *iter;
        PyArrayNeighborhoodIterObject *neigh_iter;
        iter = PyArray_IterNew(x);

        /*For a 3x3 kernel */
        bounds = {-1, 1, -1, 1};
        neigh_iter = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
             iter, bounds, NPY_NEIGHBORHOOD_ITER_ZERO_PADDING, NULL);

        for(i = 0; i &lt; iter-&gt;size; ++i) {
             for (j = 0; j &lt; neigh_iter-&gt;size; ++j) {
                     /* Walk around the item currently pointed by iter-&gt;dataptr */
                     PyArrayNeighborhoodIter_Next(neigh_iter);
             }

             /* Move to the next point of iter */
             PyArrayIter_Next(iter);
             PyArrayNeighborhoodIter_Reset(neigh_iter);
        }</pre>

</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArrayNeighborhoodIter_Reset( \
    PyArrayNeighborhoodIterObject* iter)</pre>


                           <blockquote><p>Reset the iterator position to the first point of the neighborhood. This     should be called whenever the iter argument given at     PyArray_NeighborhoodIterObject is changed (see example)</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArrayNeighborhoodIter_Next( \
    PyArrayNeighborhoodIterObject* iter)</pre>


                           <blockquote><p>After this call, iter-&gt;dataptr points to the next point of the     neighborhood. Calling this function after every point of the     neighborhood has been visited is undefined.</p>
</blockquote>


<h2>Array mapping</h2>
               <p>Array mapping is the machinery behind advanced indexing.</p>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_MapIterArray(PyArrayObject *a, \
    PyObject *index)</pre>


                           <blockquote><p>Use advanced indexing to iterate an array.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_MapIterSwapAxes(PyArrayMapIterObject *mit, \
    PyArrayObject **ret, int getmap)</pre>


                           <blockquote><p>Swap the axes to or from their inserted form.         <code class='verbatim'>MapIter</code>
 always puts the     advanced (array) indices first in the iteration. But if they are     consecutive, it will insert/transpose them back before returning.     This is stored as         <code class='verbatim'>mit-&gt;consec != 0</code>
 (the place where they are inserted).     For assignments, the opposite happens: the values to be assigned are     transposed (        <code class='verbatim'>getmap=1</code>
 instead of         <code class='verbatim'>getmap=0</code>
).         <code class='verbatim'>getmap=0</code>
 and             <code class='verbatim'>getmap=1</code>
 undo the other operation.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_MapIterNext(PyArrayMapIterObject *mit)
    This function needs to update the state of the map iterator
    and point ``mit-&gt;dataptr`` to the memory-location of the next object.

    Note that this function never handles an extra operand but provides
    compatibility for an old (exposed) API.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_MapIterArrayCopyIfOverlap(PyArrayObject *a, \
    PyObject *index, int copy_if_overlap, PyArrayObject *extra_op)</pre>


                           <blockquote><p>Similar to         <code class='verbatim'>PyArray_MapIterArray</code>
 but with an additional             <code class='verbatim'>copy_if_overlap</code>
 argument. If         <code class='verbatim'>copy_if_overlap != 0</code>
, checks if         <code class='verbatim'>a</code>
     has memory overlap with any of the arrays in         <code class='verbatim'>index</code>
 and with             <code class='verbatim'>extra_op</code>
, and make copies as appropriate to avoid problems if the     input is modified during the iteration.         <code class='verbatim'>iter-&gt;array</code>
 may contain a     copied array (WRITEBACKIFCOPY set).</p>
</blockquote>


<h2>Array Scalars</h2>
               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Return(PyArrayObject* arr)
    This function steals a reference to *arr*.

    This function checks to see if *arr* is a 0-dimensional array and,
    if so, returns the appropriate array scalar. It should be used
    whenever 0-dimensional arrays could be returned to Python.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_Scalar( \
    void* data, PyArray_Descr* dtype, PyObject* base)</pre>


                           <blockquote><p>Return an array scalar object of the given <em>dtype</em> by <strong>copying</strong>     from memory pointed to by <em>data</em>.  <em>base</em> is expected to be the     array object that is the owner of the data.  <em>base</em> is required     if <code class='not-implemented'>:None:None:`dtype`</code> is a         <code class='verbatim'>void</code>
 scalar, or if the         <code class='verbatim'>NPY_USE_GETITEM</code>
     flag is set and it is known that the         <code class='verbatim'>getitem</code>
 method uses     the         <code class='verbatim'>arr</code>
 argument without checking if it is         <code class='verbatim'>NULL</code>
.  Otherwise     <code class='not-implemented'>:None:None:`base`</code> may be         <code class='verbatim'>NULL</code>
.</p>
<p>If the data is not in native byte order (as indicated by             <code class='verbatim'>dtype-&gt;byteorder</code>
) then this function will byteswap the data,     because array scalars are always in correct machine-byte order.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_ToScalar(void* data, PyArrayObject* arr)
    Return an array scalar object of the type and itemsize indicated
    by the array object *arr* copied from the memory pointed to by
    *data* and swapping if the data in *arr* is not in machine
    byte-order.</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_FromScalar( \
    PyObject* scalar, PyArray_Descr* outcode)</pre>


                           <blockquote><p>Return a 0-dimensional array of type determined by <em>outcode</em> from     <em>scalar</em> which should be an array-scalar object. If <em>outcode</em> is     NULL, then the type is determined from <em>scalar</em>.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: void PyArray_ScalarAsCtype(PyObject* scalar, void* ctypeptr)
    Return in *ctypeptr* a pointer to the actual value in an array
    scalar. There is no error checking so *scalar* must be an
    array-scalar object, and ctypeptr must have enough space to hold
    the correct type. For flexible-sized types, a pointer to the data
    is copied into the memory of *ctypeptr*, for all other types, the
    actual data is copied into the address pointed to by *ctypeptr*.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_CastScalarToCtype( \
    PyObject* scalar, void* ctypeptr, PyArray_Descr* outcode)</pre>


                           <blockquote><p>Return the data (cast to the data type indicated by <em>outcode</em>)     from the array-scalar, <em>scalar</em>, into the memory pointed to by     <em>ctypeptr</em> (which must be large enough to handle the incoming     memory).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_TypeObjectFromType(int type)
    Returns a scalar type-object from a type-number, *type*
    . Equivalent to :c:func:`PyArray_DescrFromType` (*type*)-&gt;typeobj
    except for reference counting and error-checking. Returns a new
    reference to the typeobject on success or ``NULL`` on failure.</pre>


               <pre class='not-implemented'>
.. c:function:: NPY_SCALARKIND PyArray_ScalarKind( \
    int typenum, PyArrayObject** arr)</pre>


                           <blockquote><p>See the function         <code class='verbatim'>PyArray_MinScalarType</code>
 for an alternative     mechanism introduced in NumPy 1.6.0.</p>
<p>Return the kind of scalar represented by <em>typenum</em> and the array     in <em>\*arr</em> (if <em>arr</em> is not         <code class='verbatim'>NULL</code>
 ). The array is assumed to be     rank-0 and only used if <em>typenum</em> represents a signed integer. If     <em>arr</em> is not         <code class='verbatim'>NULL</code>
 and the first element is negative then             <code class='verbatim'>NPY_INTNEG_SCALAR</code>
 is returned, otherwise             <code class='verbatim'>NPY_INTPOS_SCALAR</code>
 is returned. The possible return values     are the enumerated values in         <code class='verbatim'>NPY_SCALARKIND</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_CanCoerceScalar( \
    char thistype, char neededtype, NPY_SCALARKIND scalar)</pre>


                           <blockquote><p>See the function         <code class='verbatim'>PyArray_ResultType</code>
 for details of     NumPy type promotion, updated in NumPy 1.6.0.</p>
<p>Implements the rules for scalar coercion. Scalars are only     silently coerced from thistype to neededtype if this function     returns nonzero.  If scalar is         <code class='verbatim'>NPY_NOSCALAR</code>
, then this     function is equivalent to         <code class='verbatim'>PyArray_CanCastSafely</code>
. The rule is     that scalars of the same KIND can be coerced into arrays of the     same KIND. This rule means that high-precision scalars will never     cause low-precision arrays of the same KIND to be upcast.</p>
</blockquote>


<h2>Data-type descriptors</h2>
                           <div class='admonition'>
    <div>warning</div>
        <p>Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference.  Functions that take <code class='not-implemented'>:c:expr:`PyArray_Descr *`</code> objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: int PyArray_DescrCheck(PyObject* obj)
    Evaluates as true if *obj* is a data-type object ( :c:expr:`PyArray_Descr *` ).</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrNew(PyArray_Descr* obj)
    Return a new data-type object copied from *obj* (the fields
    reference is just updated so that the new object points to the
    same fields dictionary if any).</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrNewFromType(int typenum)
    Create a new data-type object from the built-in (or
    user-registered) data-type indicated by *typenum*. All builtin
    types should not have any of their fields changed. This creates a
    new copy of the :c:type:`PyArray_Descr` structure so that you can fill
    it in as appropriate. This function is especially needed for
    flexible data-types which need to have a new elsize member in
    order to be meaningful in array construction.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrNewByteorder( \
    PyArray_Descr* obj, char newendian)</pre>


                           <blockquote><p>Create a new data-type object with the byteorder set according to     <em>newendian</em>. All referenced data-type objects (in subdescr and     fields members of the data-type object) are also changed     (recursively).</p>
<p>The value of <em>newendian</em> is one of these macros:</p>
</blockquote>

                          <pre class='not-implemented'>
            &lt;Comment: 
   |value: &#39;..\n    dedent the enumeration of flags to avoid missing references sphinx warnings&#39;
   |&gt;
           </pre>

               <pre class='not-implemented'>
.. c:macro:: NPY_IGNORE
    NPY_SWAP
    NPY_NATIVE
    NPY_LITTLE
    NPY_BIG</pre>


                           <blockquote><p>If a byteorder of         <code class='verbatim'>NPY_IGNORE</code>
 is encountered it     is left alone. If newendian is         <code class='verbatim'>NPY_SWAP</code>
, then all byte-orders     are swapped. Other valid newendian values are         <code class='verbatim'>NPY_NATIVE</code>
,             <code class='verbatim'>NPY_LITTLE</code>
, and         <code class='verbatim'>NPY_BIG</code>
 which all cause     the returned data-typed descriptor (and all it&#39;s     referenced data-type descriptors) to have the corresponding byte-     order.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrFromObject( \
    PyObject* op, PyArray_Descr* mintype)</pre>


                           <blockquote><p>Determine an appropriate data-type object from the object <em>op</em>     (which should be a &#34;nested&#34; sequence object) and the minimum     data-type descriptor mintype (which can be         <code class='verbatim'>NULL</code>
 ). Similar in     behavior to array(<em>op</em>).dtype. Don&#39;t confuse this function with             <code class='verbatim'>PyArray_DescrConverter</code>
. This function essentially looks at     all the objects in the (nested) sequence and determines the     data-type from the elements it finds.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrFromScalar(PyObject* scalar)
    Return a data-type object from an array-scalar object. No checking
    is done to be sure that *scalar* is an array scalar. If no
    suitable data-type can be determined, then a data-type of
    :c:data:`NPY_OBJECT` is returned by default.</pre>


               <pre class='not-implemented'>
.. c:function:: PyArray_Descr* PyArray_DescrFromType(int typenum)
    Returns a data-type object corresponding to *typenum*. The
    *typenum* can be one of the enumerated types, a character code for
    one of the enumerated types, or a user-defined type. If you want to use a
    flexible size array, then you need to ``flexible typenum`` and set the
    results ``elsize`` parameter to the desired size. The typenum is one of the
    :c:data:`NPY_TYPES`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_DescrConverter(PyObject* obj, PyArray_Descr** dtype)
    Convert any compatible Python object, *obj*, to a data-type object
    in *dtype*. A large number of Python objects can be converted to
    data-type objects. See :ref:`arrays.dtypes` for a complete
    description. This version of the converter converts None objects
    to a :c:data:`NPY_DEFAULT_TYPE` data-type object. This function can
    be used with the &#34;O&amp;&#34; character code in :c:func:`PyArg_ParseTuple`
    processing.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_DescrConverter2( \
    PyObject* obj, PyArray_Descr** dtype)</pre>


                           <blockquote><p>Convert any compatible Python object, <em>obj</em>, to a data-type     object in <em>dtype</em>. This version of the converter converts None     objects so that the returned data-type is         <code class='verbatim'>NULL</code>
. This function     can also be used with the &#34;O&amp;&#34; character in PyArg_ParseTuple     processing.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int Pyarray_DescrAlignConverter( \
    PyObject* obj, PyArray_Descr** dtype)</pre>


                           <blockquote><p>Like         <code class='verbatim'>PyArray_DescrConverter</code>
 except it aligns C-struct-like     objects on word-boundaries as the compiler would.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int Pyarray_DescrAlignConverter2( \
    PyObject* obj, PyArray_Descr** dtype)</pre>


                           <blockquote><p>Like         <code class='verbatim'>PyArray_DescrConverter2</code>
 except it aligns C-struct-like     objects on word-boundaries as the compiler would.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: PyObject *PyArray_FieldNames(PyObject* dict)
    Take the fields dictionary, *dict*, such as the one attached to a
    data-type object and construct an ordered-list of field names such
    as is stored in the names field of the :c:type:`PyArray_Descr` object.</pre>



<h2>Conversion Utilities</h2>

<h4>For use with :c:func:`PyArg_ParseTuple`</h4>
               <p>All of these functions can be used in         <code class='verbatim'>PyArg_ParseTuple</code>
 (...) with the &#34;O&amp;&#34; format specifier to automatically convert any Python object to the required C-object. All of these functions return         <code class='verbatim'>NPY_SUCCEED</code>
 if successful and         <code class='verbatim'>NPY_FAIL</code>
 if not. The first argument to all of these function is a Python object. The second argument is the <strong>address</strong> of the C-type to convert the Python object to.</p>

                           <div class='admonition'>
    <div>warning</div>
        <p>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</p>

</div>


               <pre class='not-implemented'>
.. c:function:: int PyArray_Converter(PyObject* obj, PyObject** address)
    Convert any Python object to a :c:type:`PyArrayObject`. If
    :c:func:`PyArray_Check` (*obj*) is TRUE then its reference count is
    incremented and a reference placed in *address*. If *obj* is not
    an array, then convert it to an array using :c:func:`PyArray_FromAny`
    . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_OutputConverter( \
    PyObject* obj, PyArrayObject** address)</pre>


                           <blockquote><p>This is a default converter for output arrays given to     functions. If <em>obj</em> is         <code class='verbatim'>Py_None</code>
 or         <code class='verbatim'>NULL</code>
, then <em>\*address</em>     will be         <code class='verbatim'>NULL</code>
 but the call will succeed. If         <code class='verbatim'>PyArray_Check</code>
 (     <em>obj</em>) is TRUE then it is returned in <em>\*address</em> without     incrementing its reference count.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_IntpConverter(PyObject* obj, PyArray_Dims* seq)
    Convert any Python sequence, *obj*, smaller than :c:data:`NPY_MAXDIMS`
    to a C-array of :c:type:`npy_intp`. The Python object could also be a
    single number. The *seq* variable is a pointer to a structure with
    members ptr and len. On successful return, *seq* -&gt;ptr contains a
    pointer to memory that must be freed, by calling :c:func:`PyDimMem_FREE`,
    to avoid a memory leak. The restriction on memory size allows this
    converter to be conveniently used for sequences intended to be
    interpreted as array shapes.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_BufferConverter(PyObject* obj, PyArray_Chunk* buf)
    Convert any Python object, *obj*, with a (single-segment) buffer
    interface to a variable with members that detail the object&#39;s use
    of its chunk of memory. The *buf* variable is a pointer to a
    structure with base, ptr, len, and flags members. The
    :c:type:`PyArray_Chunk` structure is binary compatible with the
    Python&#39;s buffer object (through its len member on 32-bit platforms
    and its ptr member on 64-bit platforms or in Python 2.5). On
    return, the base member is set to *obj* (or its base if *obj* is
    already a buffer object pointing to another object). If you need
    to hold on to the memory be sure to INCREF the base member. The
    chunk of memory is pointed to by *buf* -&gt;ptr member and has length
    *buf* -&gt;len. The flags member of *buf* is :c:data:`NPY_ARRAY_ALIGNED`
    with the :c:data:`NPY_ARRAY_WRITEABLE` flag set if *obj* has
    a writeable buffer interface.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_AxisConverter(PyObject* obj, int* axis)
    Convert a Python object, *obj*, representing an axis argument to
    the proper value for passing to the functions that take an integer
    axis. Specifically, if *obj* is None, *axis* is set to
    :c:data:`NPY_MAXDIMS` which is interpreted correctly by the C-API
    functions that take axis arguments.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_BoolConverter(PyObject* obj, npy_bool* value)
    Convert any Python object, *obj*, to :c:data:`NPY_TRUE` or
    :c:data:`NPY_FALSE`, and place the result in *value*.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ByteorderConverter(PyObject* obj, char* endian)
    Convert Python strings into the corresponding byte-order
    character:
    &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;s&#39;, &#39;=&#39;, or &#39;\|&#39;.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_SortkindConverter(PyObject* obj, NPY_SORTKIND* sort)
    Convert Python strings into one of :c:data:`NPY_QUICKSORT` (starts
    with &#39;q&#39; or &#39;Q&#39;), :c:data:`NPY_HEAPSORT` (starts with &#39;h&#39; or &#39;H&#39;),
    :c:data:`NPY_MERGESORT` (starts with &#39;m&#39; or &#39;M&#39;) or :c:data:`NPY_STABLESORT`
    (starts with &#39;t&#39; or &#39;T&#39;). :c:data:`NPY_MERGESORT` and :c:data:`NPY_STABLESORT`
    are aliased to each other for backwards compatibility and may refer to one
    of several stable sorting algorithms depending on the data type.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_SearchsideConverter( \
    PyObject* obj, NPY_SEARCHSIDE* side)</pre>


                           <blockquote><p>Convert Python strings into one of         <code class='verbatim'>NPY_SEARCHLEFT</code>
 (starts with &#39;l&#39;     or &#39;L&#39;), or         <code class='verbatim'>NPY_SEARCHRIGHT</code>
 (starts with &#39;r&#39; or &#39;R&#39;).</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_OrderConverter(PyObject* obj, NPY_ORDER* order)
    Convert the Python strings &#39;C&#39;, &#39;F&#39;, &#39;A&#39;, and &#39;K&#39; into the :c:type:`NPY_ORDER`
    enumeration :c:data:`NPY_CORDER`, :c:data:`NPY_FORTRANORDER`,
    :c:data:`NPY_ANYORDER`, and :c:data:`NPY_KEEPORDER`.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_CastingConverter( \
    PyObject* obj, NPY_CASTING* casting)</pre>


                           <blockquote><p>Convert the Python strings &#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, and    &#39;unsafe&#39; into the         <code class='verbatim'>NPY_CASTING</code>
 enumeration         <code class='verbatim'>NPY_NO_CASTING</code>
,            <code class='verbatim'>NPY_EQUIV_CASTING</code>
,         <code class='verbatim'>NPY_SAFE_CASTING</code>
,            <code class='verbatim'>NPY_SAME_KIND_CASTING</code>
, and         <code class='verbatim'>NPY_UNSAFE_CASTING</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_ClipmodeConverter( \
    PyObject* object, NPY_CLIPMODE* val)</pre>


                           <blockquote><p>Convert the Python strings &#39;clip&#39;, &#39;wrap&#39;, and &#39;raise&#39; into the             <code class='verbatim'>NPY_CLIPMODE</code>
 enumeration         <code class='verbatim'>NPY_CLIP</code>
,         <code class='verbatim'>NPY_WRAP</code>
,     and         <code class='verbatim'>NPY_RAISE</code>
.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_ConvertClipmodeSequence( \
    PyObject* object, NPY_CLIPMODE* modes, int n)</pre>


                           <blockquote><p>Converts either a sequence of clipmodes or a single clipmode into    a C array of         <code class='verbatim'>NPY_CLIPMODE</code>
 values. The number of clipmodes <em>n</em>    must be known before calling this function. This function is provided    to help functions allow a different clipmode for each dimension.</p>
</blockquote>


<h4>Other conversions</h4>
               <pre class='not-implemented'>
.. c:function:: int PyArray_PyIntAsInt(PyObject* op)
    Convert all kinds of Python objects (including arrays and array
    scalars) to a standard integer. On error, -1 is returned and an
    exception set. You may find useful the macro:

    .. code-block:: c

        #define error_converting(x) (((x) == -1) &amp;&amp; PyErr_Occurred())</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_PyIntAsIntp(PyObject* op)
    Convert all kinds of Python objects (including arrays and array
    scalars) to a (platform-pointer-sized) integer. On error, -1 is
    returned and an exception set.</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_IntpFromSequence( \
    PyObject* seq, npy_intp* vals, int maxvals)</pre>


                           <blockquote><p>Convert any Python sequence (or single Python number) passed in as     <em>seq</em> to (up to) <em>maxvals</em> pointer-sized integers and place them     in the <em>vals</em> array. The sequence can be smaller then <em>maxvals</em> as     the number of converted objects is returned.</p>
</blockquote>

               <pre class='not-implemented'>
.. c:function:: int PyArray_TypestrConvert(int itemsize, int gentype)
    Convert typestring characters (with *itemsize*) to basic
    enumerated data types. The typestring character corresponding to
    signed and unsigned integers, floating point numbers, and
    complex-floating point numbers are recognized and converted. Other
    values of gentype are returned. This function can be used to
    convert, for example, the string &#39;f4&#39; to :c:data:`NPY_FLOAT32`.</pre>



<h2>Miscellaneous</h2>

<h4>Importing the API</h4>
               <p>In order to make use of the C-API from another extension module, the         <code class='verbatim'>import_array</code>
 function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</p>

               <pre class='not-implemented'>
.. c:function:: void import_array(void)
    This function must be called in the initialization section of a
    module that will make use of the C-API. It imports the module
    where the function-pointer table is stored and points the correct
    variable to it.</pre>


               <pre class='not-implemented'>
.. c:macro:: PY_ARRAY_UNIQUE_SYMBOL
    </pre>


               <pre class='not-implemented'>
.. c:macro:: NO_IMPORT_ARRAY
    Using these #defines you can use the C-API in multiple files for a
    single extension module. In each file you must define
    :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` to some name that will hold the
    C-API (*e.g.* myextension_ARRAY_API). This must be done **before**
    including the numpy/arrayobject.h file. In the module
    initialization routine you call :c:func:`import_array`. In addition,
    in the files that do not have the module initialization
    sub_routine define :c:macro:`NO_IMPORT_ARRAY` prior to including
    numpy/arrayobject.h.

    Suppose I have two files coolmodule.c and coolhelper.c which need
    to be compiled and linked into a single extension module. Suppose
    coolmodule.c contains the required initcool module initialization
    function (with the import_array() function called). Then,
    coolmodule.c would have at the top:

    .. code-block:: c

        #define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
        #include numpy/arrayobject.h

    On the other hand, coolhelper.c would contain at the top:

    .. code-block:: c

        #define NO_IMPORT_ARRAY
        #define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
        #include numpy/arrayobject.h

    You can also put the common two last lines into an extension-local
    header file as long as you make sure that NO_IMPORT_ARRAY is
    #defined before #including that file.

    Internally, these #defines work as follows:

        * If neither is defined, the C-API is declared to be
          ``static void**``, so it is only visible within the
          compilation unit that #includes numpy/arrayobject.h.
        * If :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is #defined, but
          :c:macro:`NO_IMPORT_ARRAY` is not, the C-API is declared to
          be ``void**``, so that it will also be visible to other
          compilation units.
        * If :c:macro:`NO_IMPORT_ARRAY` is #defined, regardless of
          whether :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is, the C-API is
          declared to be ``extern void**``, so it is expected to
          be defined in another compilation unit.
        * Whenever :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is #defined, it
          also changes the name of the variable holding the C-API, which
          defaults to ``PyArray_API``, to whatever the macro is
          #defined to.</pre>



<h4>Checking the API Version</h4>
               <p>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&#39;s why several functions are provided to check for numpy versions. The macros         <code class='verbatim'>NPY_VERSION</code>
  and         <code class='verbatim'>NPY_FEATURE_VERSION</code>
 corresponds to the numpy version used to build the extension, whereas the versions returned by the functions         <code class='verbatim'>PyArray_GetNDArrayCVersion</code>
 and         <code class='verbatim'>PyArray_GetNDArrayCFeatureVersion</code>
 corresponds to the runtime numpy&#39;s version.</p>

               <p>The rules for ABI and API compatibilities can be summarized as follows:</p>

                           <blockquote>           <ul>               <li>               <p>Whenever         <code class='verbatim'>NPY_VERSION</code>
 !=         <code class='verbatim'>PyArray_GetNDArrayCVersion()</code>
, the       extension has to be recompiled (ABI incompatibility).</p>

</li>
               <li>               <p>        <code class='verbatim'>NPY_VERSION</code>
 ==         <code class='verbatim'>PyArray_GetNDArrayCVersion()</code>
 and               <code class='verbatim'>NPY_FEATURE_VERSION</code>
 &lt;=         <code class='verbatim'>PyArray_GetNDArrayCFeatureVersion()</code>
 means       backward compatible changes.</p>

</li>
            </ul>
</blockquote>

               <p>ABI incompatibility is automatically detected in every numpy&#39;s version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest         <code class='verbatim'>NPY_FEATURE_VERSION</code>
 as possible.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_VERSION
    The current version of the ndarray object (check to see if this
    variable is defined to guarantee the ``numpy/arrayobject.h`` header is
    being used).</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_FEATURE_VERSION
    The current version of the C-API.</pre>


               <pre class='not-implemented'>
.. c:function:: unsigned int PyArray_GetNDArrayCVersion(void)
    This just returns the value :c:data:`NPY_VERSION`. :c:data:`NPY_VERSION`
    changes whenever a backward incompatible change at the ABI level. Because
    it is in the C-API, however, comparing the output of this function from the
    value defined in the current header gives a way to test if the C-API has
    changed thus requiring a re-compilation of extension modules that use the
    C-API. This is automatically checked in the function :c:func:`import_array`.</pre>


               <pre class='not-implemented'>
.. c:function:: unsigned int PyArray_GetNDArrayCFeatureVersion(void)
    .. versionadded:: 1.4.0

    This just returns the value :c:data:`NPY_FEATURE_VERSION`.
    :c:data:`NPY_FEATURE_VERSION` changes whenever the API changes (e.g. a
    function is added). A changed value does not always require a recompile.</pre>



<h4>Internal Flexibility</h4>
               <pre class='not-implemented'>
.. c:function:: int PyArray_SetNumericOps(PyObject* dict)
    NumPy stores an internal table of Python callable objects that are
    used to implement arithmetic operations for arrays as well as
    certain array calculation methods. This function allows the user
    to replace any or all of these Python objects with their own
    versions. The keys of the dictionary, *dict*, are the named
    functions to replace and the paired value is the Python callable
    object to use. Care should be taken that the function used to
    replace an internal array operation does not itself call back to
    that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can
    result (possibly causing program crash). The key names that
    represent operations that can be replaced are:

        **add**, **subtract**, **multiply**, **divide**,
        **remainder**, **power**, **square**, **reciprocal**,
        **ones_like**, **sqrt**, **negative**, **positive**,
        **absolute**, **invert**, **left_shift**, **right_shift**,
        **bitwise_and**, **bitwise_xor**, **bitwise_or**,
        **less**, **less_equal**, **equal**, **not_equal**,
        **greater**, **greater_equal**, **floor_divide**,
        **true_divide**, **logical_or**, **logical_and**,
        **floor**, **ceil**, **maximum**, **minimum**, **rint**.


    These functions are included here because they are used at least once
    in the array object&#39;s methods. The function returns -1 (without
    setting a Python Error) if one of the objects being assigned is not
    callable.

    .. deprecated:: 1.16</pre>


               <pre class='not-implemented'>
.. c:function:: PyObject* PyArray_GetNumericOps(void)
    Return a Python dictionary containing the callable Python objects
    stored in the internal arithmetic operation table. The keys of
    this dictionary are given in the explanation for :c:func:`PyArray_SetNumericOps`.

    .. deprecated:: 1.16</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_SetStringFunction(PyObject* op, int repr)
    This function allows you to alter the tp_str and tp_repr methods
    of the array object to any Python function. Thus you can alter
    what happens for all arrays when str(arr) or repr(arr) is called
    from Python. The function to be called is passed in as *op*. If
    *repr* is non-zero, then this function will be called in response
    to repr(arr), otherwise the function will be called in response to
    str(arr). No check on whether or not *op* is callable is
    performed. The callable passed in to *op* should expect an array
    argument and should return a string to be printed.</pre>



<h4>Memory management</h4>
               <pre class='not-implemented'>
.. c:function:: char* PyDataMem_NEW(size_t nbytes)
    </pre>


               <pre class='not-implemented'>
.. c:function:: void PyDataMem_FREE(char* ptr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: char* PyDataMem_RENEW(void * ptr, size_t newbytes)
    Macros to allocate, free, and reallocate memory. These macros are used
    internally to create arrays.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp*  PyDimMem_NEW(int nd)
    </pre>


               <pre class='not-implemented'>
.. c:function:: void PyDimMem_FREE(char* ptr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp* PyDimMem_RENEW(void* ptr, size_t newnd)
    Macros to allocate, free, and reallocate dimension and strides memory.</pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_malloc(size_t nbytes)
    </pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_free(void* ptr)
    </pre>


               <pre class='not-implemented'>
.. c:function:: void* PyArray_realloc(npy_intp* ptr, size_t nbytes)
    These macros use different memory allocators, depending on the
    constant :c:data:`NPY_USE_PYMEM`. The system malloc is used when
    :c:data:`NPY_USE_PYMEM` is 0, if :c:data:`NPY_USE_PYMEM` is 1, then
    the Python memory allocator is used.

    .. c:macro:: NPY_USE_PYMEM</pre>


               <pre class='not-implemented'>
.. c:function:: int PyArray_ResolveWritebackIfCopy(PyArrayObject* obj)
    If ``obj.flags`` has :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, this function
    clears the flags, `DECREF` s
    `obj-&gt;base` and makes it writeable, and sets ``obj-&gt;base`` to NULL. It then
    copies ``obj-&gt;data`` to `obj-&gt;base-&gt;data`, and returns the error state of
    the copy operation. This is the opposite of
    :c:func:`PyArray_SetWritebackIfCopyBase`. Usually this is called once
    you are finished with ``obj``, just before ``Py_DECREF(obj)``. It may be called
    multiple times, or with ``NULL`` input. See also
    :c:func:`PyArray_DiscardWritebackIfCopy`.

    Returns 0 if nothing was done, -1 on error, and 1 if action was taken.</pre>



<h4>Threading support</h4>
               <p>These macros are only meaningful if         <code class='verbatim'>NPY_ALLOW_THREADS</code>
 evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently,         <code class='verbatim'>NPY_ALLOW_THREADS</code>
 is defined to the python-defined         <code class='verbatim'>WITH_THREADS</code>
 constant unless the environment variable         <code class='verbatim'>NPY_NOSMP</code>
 is set in which case         <code class='verbatim'>NPY_ALLOW_THREADS</code>
 is defined to be 0.</p>

               <pre class='not-implemented'>
.. c:macro:: NPY_ALLOW_THREADS
    </pre>


               <pre class='not-implemented'>
.. c:macro:: WITH_THREADS
    </pre>



<h5>Group 1</h5>
                           <blockquote><p>This group is used to call code that may take some time but does not     use any Python C-API calls. Thus, the GIL should be released during     its calculation.</p>
<pre class='not-implemented'>
.. c:macro:: NPY_BEGIN_ALLOW_THREADS
    Equivalent to :c:macro:`Py_BEGIN_ALLOW_THREADS` except it uses
        :c:data:`NPY_ALLOW_THREADS` to determine if the macro if
        replaced with white-space or not.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_END_ALLOW_THREADS
    Equivalent to :c:macro:`Py_END_ALLOW_THREADS` except it uses
        :c:data:`NPY_ALLOW_THREADS` to determine if the macro if
        replaced with white-space or not.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_BEGIN_THREADS_DEF
    Place in the variable declaration area. This macro sets up the
        variable needed for storing the Python state.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_BEGIN_THREADS
    Place right before code that does not need the Python
        interpreter (no Python C-API calls). This macro saves the
        Python state and releases the GIL.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_END_THREADS
    Place right after code that does not need the Python
        interpreter. This macro acquires the GIL and restores the
        Python state from the saved variable.</pre>

<pre class='not-implemented'>
.. c:function:: void NPY_BEGIN_THREADS_DESCR(PyArray_Descr *dtype)
    Useful to release the GIL only if *dtype* does not contain
        arbitrary Python objects which may need the Python interpreter
        during execution of the loop.</pre>

<pre class='not-implemented'>
.. c:function:: void NPY_END_THREADS_DESCR(PyArray_Descr *dtype)
    Useful to regain the GIL in situations where it was released
        using the BEGIN form of this macro.</pre>

<pre class='not-implemented'>
.. c:function:: void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)
    Useful to release the GIL only if *loop_size* exceeds a
        minimum threshold, currently set to 500. Should be matched
        with a :c:macro:`NPY_END_THREADS` to regain the GIL.</pre>

</blockquote>


<h5>Group 2</h5>
                           <blockquote><p>This group is used to re-acquire the Python GIL after it has been     released. For example, suppose the GIL has been released (using the     previous calls), and then some path in the code (perhaps in a     different subroutine) requires use of the Python C-API, then these     macros are useful to acquire the GIL. These macros accomplish     essentially a reverse of the previous three (acquire the LOCK saving     what state it had) and then re-release it with the saved state.</p>
<pre class='not-implemented'>
.. c:macro:: NPY_ALLOW_C_API_DEF
    Place in the variable declaration area to set up the necessary
        variable.</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_ALLOW_C_API
    Place before code that needs to call the Python C-API (when it is
        known that the GIL has already been released).</pre>

<pre class='not-implemented'>
.. c:macro:: NPY_DISABLE_C_API
    Place after code that needs to call the Python C-API (to re-release
        the GIL).</pre>

</blockquote>

               <pre class='not-implemented'>
.. tip:: 
    Never use semicolons after the threading support macros.</pre>



<h4>Priority</h4>
               <pre class='not-implemented'>
.. c:macro:: NPY_PRIORITY
    Default priority for arrays.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_SUBTYPE_PRIORITY
    Default subtype priority.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_SCALAR_PRIORITY
    Default scalar priority (very small)</pre>


               <pre class='not-implemented'>
.. c:function:: double PyArray_GetPriority(PyObject* obj, double def)
    Return the :obj:`~numpy.class.__array_priority__` attribute (converted to a
    double) of *obj* or *def* if no attribute of that name
    exists. Fast returns that avoid the attribute lookup are provided
    for objects of type :c:data:`PyArray_Type`.</pre>



<h4>Default buffers</h4>
               <pre class='not-implemented'>
.. c:macro:: NPY_BUFSIZE
    Default size of the user-settable internal buffers.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_MIN_BUFSIZE
    Smallest size of user-settable internal buffers.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_MAX_BUFSIZE
    Largest size allowed for the user-settable buffers.</pre>



<h4>Other constants</h4>
               <pre class='not-implemented'>
.. c:macro:: NPY_NUM_FLOATTYPE
    The number of floating-point types</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_MAXDIMS
    The maximum number of dimensions allowed in arrays.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_MAXARGS
    The maximum number of array arguments that can be used in functions.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_FALSE
    Defined as 0 for use with Bool.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_TRUE
    Defined as 1 for use with Bool.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_FAIL
    The return value of failed converter functions which are called using
    the &#34;O&amp;&#34; syntax in :c:func:`PyArg_ParseTuple`-like functions.</pre>


               <pre class='not-implemented'>
.. c:macro:: NPY_SUCCEED
    The return value of successful converter functions which are called
    using the &#34;O&amp;&#34; syntax in :c:func:`PyArg_ParseTuple`-like functions.</pre>



<h4>Miscellaneous Macros</h4>
               <pre class='not-implemented'>
.. c:function:: int PyArray_SAMESHAPE(PyArrayObject *a1, PyArrayObject *a2)
    Evaluates as True if arrays *a1* and *a2* have the same shape.</pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_MAX(a,b)
    Returns the maximum of *a* and *b*. If (*a*) or (*b*) are
    expressions they are evaluated twice.</pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_MIN(a,b)
    Returns the minimum of *a* and *b*. If (*a*) or (*b*) are
    expressions they are evaluated twice.</pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CLT(a,b)
    </pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CGT(a,b)
    </pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CLE(a,b)
    </pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CGE(a,b)
    </pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CEQ(a,b)
    </pre>


               <pre class='not-implemented'>
.. c:macro:: PyArray_CNE(a,b)
    Implements the complex comparisons between two complex numbers
    (structures with a real and imag member) using NumPy&#39;s definition
    of the ordering which is lexicographic: comparing the real parts
    first and then the complex parts if the real parts are equal.</pre>


               <pre class='not-implemented'>
.. c:function:: npy_intp PyArray_REFCOUNT(PyObject* op)
    Returns the reference count of any Python object.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_DiscardWritebackIfCopy(PyObject* obj)
    If ``obj.flags`` has :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, this function
    clears the flags, `DECREF` s
    `obj-&gt;base` and makes it writeable, and sets ``obj-&gt;base`` to NULL. In
    contrast to :c:func:`PyArray_DiscardWritebackIfCopy` it makes no attempt
    to copy the data from `obj-&gt;base` This undoes
    :c:func:`PyArray_SetWritebackIfCopyBase`. Usually this is called after an
    error when you are finished with ``obj``, just before ``Py_DECREF(obj)``.
    It may be called multiple times, or with ``NULL`` input.</pre>


               <pre class='not-implemented'>
.. c:function:: void PyArray_XDECREF_ERR(PyObject* obj)
    Deprecated in 1.14, use :c:func:`PyArray_DiscardWritebackIfCopy`
    followed by ``Py_XDECREF``

    DECREF&#39;s an array object which may have the
    :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`
    flag set without causing the contents to be copied back into the
    original array. Resets the :c:data:`NPY_ARRAY_WRITEABLE` flag on the base
    object. This is useful for recovering from an error condition when
    writeback semantics are used, but will lead to wrong results.</pre>



<h4>Enumerated Types</h4>
               <pre class='not-implemented'>
.. c:enum:: NPY_SORTKIND
    A special variable-type which can take on different values to indicate
    the sorting algorithm being used.

    .. c:enumerator:: NPY_QUICKSORT

    .. c:enumerator:: NPY_HEAPSORT

    .. c:enumerator:: NPY_MERGESORT

    .. c:enumerator:: NPY_STABLESORT

        Used as an alias of :c:data:`NPY_MERGESORT` and vica versa.

    .. c:enumerator:: NPY_NSORTS

       Defined to be the number of sorts. It is fixed at three by the need for
       backwards compatibility, and consequently :c:data:`NPY_MERGESORT` and
       :c:data:`NPY_STABLESORT` are aliased to each other and may refer to one
       of several stable sorting algorithms depending on the data type.</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_SCALARKIND
    A special variable type indicating the number of &#34;kinds&#34; of
    scalars distinguished in determining scalar-coercion rules. This
    variable can take on the values:

    .. c:enumerator:: NPY_NOSCALAR

    .. c:enumerator:: NPY_BOOL_SCALAR

    .. c:enumerator:: NPY_INTPOS_SCALAR

    .. c:enumerator:: NPY_INTNEG_SCALAR

    .. c:enumerator:: NPY_FLOAT_SCALAR

    .. c:enumerator:: NPY_COMPLEX_SCALAR

    .. c:enumerator:: NPY_OBJECT_SCALAR

    .. c:enumerator:: NPY_NSCALARKINDS

       Defined to be the number of scalar kinds
       (not including :c:data:`NPY_NOSCALAR`).</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_ORDER
    An enumeration type indicating the element order that an array should be
    interpreted in. When a brand new array is created, generally
    only **NPY_CORDER** and **NPY_FORTRANORDER** are used, whereas
    when one or more inputs are provided, the order can be based on them.

    .. c:enumerator:: NPY_ANYORDER

        Fortran order if all the inputs are Fortran, C otherwise.

    .. c:enumerator:: NPY_CORDER

        C order.

    .. c:enumerator:: NPY_FORTRANORDER

        Fortran order.

    .. c:enumerator:: NPY_KEEPORDER

        An order as close to the order of the inputs as possible, even
        if the input is in neither C nor Fortran order.</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_CLIPMODE
    A variable type indicating the kind of clipping that should be
    applied in certain functions.

    .. c:enumerator:: NPY_RAISE

        The default for most operations, raises an exception if an index
        is out of bounds.

    .. c:enumerator:: NPY_CLIP

        Clips an index to the valid range if it is out of bounds.

    .. c:enumerator:: NPY_WRAP

        Wraps an index to the valid range if it is out of bounds.</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_SEARCHSIDE
    A variable type indicating whether the index returned should be that of
    the first suitable location (if :c:data:`NPY_SEARCHLEFT`) or of the last
    (if :c:data:`NPY_SEARCHRIGHT`).

    .. c:enumerator:: NPY_SEARCHLEFT

    .. c:enumerator:: NPY_SEARCHRIGHT</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_SELECTKIND
    A variable type indicating the selection algorithm being used.

    .. c:enumerator:: NPY_INTROSELECT</pre>


               <pre class='not-implemented'>
.. c:enum:: NPY_CASTING
    .. versionadded:: 1.6

    An enumeration type indicating how permissive data conversions should
    be. This is used by the iterator added in NumPy 1.6, and is intended
    to be used more broadly in a future version.

    .. c:enumerator:: NPY_NO_CASTING

        Only allow identical types.

    .. c:enumerator:: NPY_EQUIV_CASTING

       Allow identical and casts involving byte swapping.

    .. c:enumerator:: NPY_SAFE_CASTING

       Only allow casts which will not cause values to be rounded,
       truncated, or otherwise changed.

    .. c:enumerator:: NPY_SAME_KIND_CASTING

       Allow any safe casts, and casts between types of the same kind.
       For example, float64 -&gt; float32 is permitted with this rule.

    .. c:enumerator:: NPY_UNSAFE_CASTING

       Allow any cast, no matter what kind of data loss may occur.</pre>


               <pre class='not-implemented'>
.. index:: 
    pair: ndarray; C-API</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet"
          href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf"
          crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <script type="text/x-mathjax-config">
      // this should process only math inside  span with tex2jax_process class
      MathJax.Hub.Config({
          extensions: ["tex2jax.js"],
          jax: ["input/TeX", "output/HTML-CSS"],
          tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
          },
          "HTML-CSS": { fonts: ["TeX"] }
      });
    </script>
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js">
    </script>
    <link rel="stylesheet" href="/papyri.css">
    <link rel="stylesheet" href="/pygments.css">
<style>

    header > brand {
        /*border-right: 1px solid #ccc;
          border-left: 1px solid #ccc;*/
        margin-left: 15px;
        padding: 0px;
        display: inline-block; 
        width: 67px;
    }

    brand > a {
        text-decoration: None;

    }
    brand >a> img {
            display: inline-block;
    margin: 0;
    padding: 0;
    position: relative;
    bottom: -10px;

   }
    .container {
       max-width: 800px;
       padding-left: 210px;
       padding-top: 30px;
    }
</style>
</head><body class="tex2jax_ignore">
    <header>
        <brand><a href='/'><img src='/favicon.ico'/></a></brand>
        <nav> / <a href='/' >p</a>  &nbsp;/&nbsp; 
                <div class="dropdown">
                <a href=numpy>numpy</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                     </div>
                </div>
                <div class="dropdown">
                <a href='/p/numpy/1.22.4/api/numpy'>1.22.4</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
<a href="/p/numpy/1.22.4/api/numpy">1.22.4</a>
                    </div>
                </div>

                <div class="dropdown">
                    <a href='/p/numpy/1.22.4/api/numpy'>docs</a>&nbsp;/&nbsp;
                    <div class="dropdown-content">
                        <a href="/p/numpy/1.22.4/api/numpy">API</a>
                        <a href="/p/numpy/1.22.4/gallery">Gallery</a>
                        <a href="/p/numpy/1.22.4/examples">Examples</a>
                        <a href="/p/numpy/1.22.4/docs">Narrative</a>
                     </div>
                </div>

</nav>
    </header>
    <div class='container'>

    <div class="sidenav">
        <img src="/p/numpy/1.22.4/img/numpy_logo.png"/>
    <a href="#">numpy</a>
    <a href="#">1.22.4</a>
        <a class='external'  href="https://pypi.org/project/numpy">Pypi</a>
        <a class='external' href="https://github.com/numpy/numpy">GitHub</a>
        <a class='external' href="https://numpy.org/">Homepage</a>
    <hr/>
        <a class='external' href="https://numpy.org/doc/1.22/">Other Docs</a>
    <hr/>
    </div><!--end sidenav-->







                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;target&#39; &#39;.. _routines.polynomial:&#39;&gt;
           </pre>


<h1>Polynomials</h1>
               <p>Polynomials in NumPy can be <em>created</em>, <em>manipulated</em>, and even <em>fitted</em> using the         <code class='verbatim'>convenience classes &lt;routines.polynomials.classes&gt;</code>
 of the <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
 package, introduced in NumPy 1.4.</p>

               <p>Prior to NumPy 1.4, <code><a href="/p/numpy/*/api/numpy.poly1d.html" class='exists'>numpy.poly1d</a></code>
 was the class of choice and it is still available in order to maintain backward compatibility. However, the newer <code class='not-implemented'>:None:None:`polynomial package &lt;numpy.polynomial&gt;`</code> is more complete and its <code class='not-implemented'>:None:None:`convenience classes &lt;routines.polynomials.classes&gt;`</code> provide a more consistent, better-behaved interface for working with polynomial expressions. Therefore         <code class='verbatim'>numpy.polynomial</code>
 is recommended for new coding.</p>

                           <div class='admonition'>
    <div>note</div>
        <p>The term <em>polynomial module</em> refers to the old API defined in <code class='not-implemented'>:None:None:`numpy.lib.polynomial`</code>, which includes the <code class='not-implemented'>:None:class:`numpy.poly1d`</code> class and the polynomial functions prefixed with <em>poly</em> accessible from the <code class='not-implemented'>:None:None:`numpy`</code> namespace (e.g. <code class='not-implemented'>:None:None:`numpy.polyadd`</code>, <code class='not-implemented'>:None:None:`numpy.polyval`</code>, <code class='not-implemented'>:None:None:`numpy.polyfit`</code>, etc.).</p>

        <p>The term <em>polynomial package</em> refers to the new API defined in  <code class='not-implemented'>:None:None:`numpy.polynomial`</code>, which includes the convenience classes for the different kinds of polynomials (<code class='not-implemented'>:None:None:`numpy.polynomial.Polynomial`</code>, <code class='not-implemented'>:None:None:`numpy.polynomial.Chebyshev`</code>, etc.).</p>

</div>



<h2>Transitioning from `numpy.poly1d` to `numpy.polynomial`</h2>
               <p>As noted above, the         <code class='verbatim'>poly1d class &lt;numpy.poly1d&gt;</code>
 and associated functions defined in         <code class='verbatim'>numpy.lib.polynomial</code>
, such as <code><a href="/p/numpy/*/api/numpy.polyfit.html" class='exists'>numpy.polyfit</a></code>
 and <code><a href="/p/numpy/*/api/numpy.poly.html" class='exists'>numpy.poly</a></code>
, are considered legacy and should <strong>not</strong> be used in new code. Since NumPy version 1.4, the <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
 package is preferred for working with polynomials.</p>


<h3>Quick Reference</h3>
               <p>The following table highlights some of the main differences between the legacy polynomial module and the polynomial package for common tasks. The <code><a href="/p/numpy/*/api/numpy.polynomial.polynomial.Polynomial.html" class='exists'>Polynomial</a></code>
 class is imported for brevity:      </p>

               <pre>from numpy.polynomial import Polynomial</pre>
               <p>+------------------------+------------------------------+---------------------------------------+ |  <strong>How to...</strong>         | Legacy (<code><a href="/p/numpy/*/api/numpy.poly1d.html" class='exists'>numpy.poly1d</a></code>
)      | <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
                    | +------------------------+------------------------------+---------------------------------------+ | Create a               |         <code class='verbatim'>p = np.poly1d([1, 2, 3])</code>
 |         <code class='verbatim'>p = Polynomial([3, 2, 1])</code>
         | | polynomial object      |                              |                                       | | from coefficients  |                              |                                       | +------------------------+------------------------------+---------------------------------------+ | Create a polynomial    |         <code class='verbatim'>r = np.poly([-1, 1])</code>
     |         <code class='verbatim'>p = Polynomial.fromroots([-1, 1])</code>
 | | object from roots      |         <code class='verbatim'>p = np.poly1d(r)</code>
         |                                       | +------------------------+------------------------------+---------------------------------------+ | Fit a polynomial of    |                              |                                       | | degree         <code class='verbatim'>deg</code>
 to data |         <code class='verbatim'>np.polyfit(x, y, deg)</code>
    |         <code class='verbatim'>Polynomial.fit(x, y, deg)</code>
         | +------------------------+------------------------------+---------------------------------------+</p>

                          <pre class='not-implemented'>
            &lt;Unimplemented &#39;footnote&#39; &#39;.. [1] Note the reversed ordering of the coefficients&#39;&gt;
           </pre>


<h3>Transition Guide</h3>
               <p>There are significant differences between         <code class='verbatim'>numpy.lib.polynomial</code>
 and <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
. The most significant difference is the ordering of the coefficients for the polynomial expressions. The  various routines in <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
 all deal with series whose coefficients go from degree zero upward, which is the <em>reverse order</em> of the poly1d convention. The easy way to remember this is that indices correspond to degree, i.e.,         <code class='verbatim'>coef[i]</code>
 is the coefficient of the term of degree <em>i</em>.</p>

               <p>Though the difference in convention may be confusing, it is straightforward to convert from the legacy polynomial API to the new. For example, the following demonstrates how you would convert a <code><a href="/p/numpy/*/api/numpy.poly1d.html" class='exists'>numpy.poly1d</a></code>
 instance representing the expression         <span class="tex2jax_process">$x^{2} + 2x + 3$</span>
 to a <code><a href="/p/numpy/*/api/numpy.polynomial.polynomial.Polynomial.html" class='exists'>Polynomial</a></code>
 instance representing the same expression:      </p>

               <pre>&gt;&gt;&gt; p1d = np.poly1d([1, 2, 3])
&gt;&gt;&gt; p = np.polynomial.Polynomial(p1d.coef[::-1])</pre>
               <p>In addition to the         <code class='verbatim'>coef</code>
 attribute, polynomials from the polynomial package also have         <code class='verbatim'>domain</code>
 and         <code class='verbatim'>window</code>
 attributes. These attributes are most relevant when fitting polynomials to data, though it should be noted that polynomials with different         <code class='verbatim'>domain</code>
 and         <code class='verbatim'>window</code>
 attributes are not considered equal, and can&#39;t be mixed in arithmetic:      </p>

               <pre>&gt;&gt;&gt; p1 = np.polynomial.Polynomial([1, 2, 3])
&gt;&gt;&gt; p1
Polynomial([1., 2., 3.], domain=[-1,  1], window=[-1,  1], symbol=&#39;x&#39;)
&gt;&gt;&gt; p2 = np.polynomial.Polynomial([1, 2, 3], domain=[-2, 2])
&gt;&gt;&gt; p1 == p2
False
&gt;&gt;&gt; p1 + p2
Traceback (most recent call last):
    ...
TypeError: Domains differ</pre>
               <p>See the documentation for the <code class='not-implemented'>:None:None:`convenience classes &lt;routines.polynomials.classes&gt;`</code> for further details on the         <code class='verbatim'>domain</code>
 and         <code class='verbatim'>window</code>
 attributes.</p>

               <p>Another major difference between the legacy polynomial module and the polynomial package is polynomial fitting. In the old module, fitting was done via the <code><a href="/p/numpy/*/api/numpy.polyfit.html" class='exists'>polyfit</a></code>
 function. In the polynomial package, the <code><a href="/p/numpy/*/api/numpy.polynomial._polybase.ABCPolyBase.fit.html" class='exists'>fit</a></code>
 class method is preferred. For example, consider a simple linear fit to the following data:</p>

               <pre class='not-implemented'>
.. ipython:: python
    rng = np.random.default_rng()
    x = np.arange(10)
    y = np.arange(10) + rng.standard_normal(10)</pre>


               <p>With the legacy polynomial module, a linear fit (i.e. polynomial of degree 1) could be applied to these data with <code><a href="/p/numpy/*/api/numpy.polyfit.html" class='exists'>polyfit</a></code>
:</p>

               <pre class='not-implemented'>
.. ipython:: python
    np.polyfit(x, y, deg=1)</pre>


               <p>With the new polynomial API, the <code><a href="/p/numpy/*/api/numpy.polynomial._polybase.ABCPolyBase.fit.html" class='exists'>fit</a></code>
 class method is preferred:</p>

               <pre class='not-implemented'>
.. ipython:: python
    p_fitted = np.polynomial.Polynomial.fit(x, y, deg=1)
    p_fitted</pre>


               <p>Note that the coefficients are given <em>in the scaled domain</em> defined by the linear mapping between the         <code class='verbatim'>window</code>
 and         <code class='verbatim'>domain</code>
. <code><a href="/p/numpy/*/api/numpy.polynomial._polybase.ABCPolyBase.convert.html" class='exists'>convert</a></code>
 can be used to get the coefficients in the unscaled data domain.</p>

               <pre class='not-implemented'>
.. ipython:: python
    p_fitted.convert()</pre>



<h2>Documentation for the `~numpy.polynomial` Package</h2>
               <p>In addition to standard power series polynomials, the polynomial package provides several additional kinds of polynomials including Chebyshev, Hermite (two subtypes), Laguerre, and Legendre polynomials. Each of these has an associated <code class='not-implemented'>:None:None:`convenience class &lt;routines.polynomials.classes&gt;`</code> available from the <code><a href="/p/numpy/*/api/numpy.polynomial.html" class='exists'>numpy.polynomial</a></code>
 namespace that provides a consistent interface for working with polynomials regardless of their type.</p>

               <pre class='not-implemented'>
.. toctree:: 
    (&#39;maxdepth&#39;, &#39;1&#39;)
    routines.polynomials.classes</pre>


               <p>Documentation pertaining to specific functions defined for each kind of polynomial individually can be found in the corresponding module documentation:</p>

               <pre class='not-implemented'>
.. toctree:: 
    (&#39;maxdepth&#39;, &#39;1&#39;)
    routines.polynomials.polynomial
    routines.polynomials.chebyshev
    routines.polynomials.hermite
    routines.polynomials.hermite_e
    routines.polynomials.laguerre
    routines.polynomials.legendre
    routines.polynomials.polyutils</pre>



<h2>Documentation for Legacy Polynomials</h2>
               <pre class='not-implemented'>
.. toctree:: 
    (&#39;maxdepth&#39;, &#39;2&#39;)
    routines.polynomials.poly1d</pre>



<h3 id="section-Examples">Examples</h3>
         See :
    


<h3>Local connectivity graph</h3>
<p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p>

<p> Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows
or text (beyond on hover) </p> 
<canvas class='graph' width="800" height="500"></canvas>
<p> SVG is more flexible but power hungry; and does not scale well to 50 + nodes. </p> 

<svg class='graph' width="600" height="500"></svg>

<p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted
(or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library
they belong to, and scaled with the number of references pointing them</p>

<hr>

    GitHub : <a class='external' href='https://github.com/numpy/numpy/blob/v1.22.3/None#LNone'>None#None</a>
<br/>

type: None <br/>
Commit: <br/>

        <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
    <style type="text/css">
        .node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };
    </style>
<script>
    window._data_graph = {};
</script>
<script type="text/javascript" src='/graph_canvas.js'></script>
<script type="text/javascript" src='/graph_svg.js'></script>


</div>
</body>
</html>
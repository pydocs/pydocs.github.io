<!doctypehtml><html lang=en><meta charset=UTF-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>Document</title><link href=https://fonts.xz.style/serve/inter.css rel=stylesheet><link crossorigin=anonymous href=https://use.fontawesome.com/releases/v5.8.1/css/all.css integrity=sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css rel=stylesheet><script type=text/x-mathjax-config>
        // this should process only math inside  span with tex2jax_process class
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { fonts: ["TeX"] }
    });
    </script><script async src=https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js></script><link href=/papyri.css rel=stylesheet><style>header > brand, header>:first-child {
        border-right: 1px solid #ccc;
        border-left: 1px solid #ccc;
        padding: 16px;
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        display: inline-block; 
        width: 167px;
    }
    pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #cc0000; font-weight: bold } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold; background-color: #fff0f0 } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #333333 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #666666 } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008800 } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #888888; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #0000DD; font-weight: bold } /* Literal.Number */
.highlight .s { color: #dd2200; background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #336699 } /* Name.Attribute */
.highlight .nb { color: #003388 } /* Name.Builtin */
.highlight .nc { color: #bb0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555 } /* Name.Decorator */
.highlight .ne { color: #bb0066; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066bb; font-weight: bold } /* Name.Function */
.highlight .nl { color: #336699; font-style: italic } /* Name.Label */
.highlight .nn { color: #bb0066; font-weight: bold } /* Name.Namespace */
.highlight .py { color: #336699; font-weight: bold } /* Name.Property */
.highlight .nt { color: #bb0066; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #336699 } /* Name.Variable */
.highlight .ow { color: #008800 } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #0000DD; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #0000DD; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #0000DD; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #0000DD; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Char */
.highlight .dl { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Doc */
.highlight .s2 { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #0044dd; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { color: #3333bb; background-color: #fff0f0 } /* Literal.String.Interpol */
.highlight .sx { color: #22bb22; background-color: #f0fff0 } /* Literal.String.Other */
.highlight .sr { color: #008800; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { color: #dd2200; background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #aa6600; background-color: #fff0f0 } /* Literal.String.Symbol */
.highlight .bp { color: #003388 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066bb; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700 } /* Name.Variable.Global */
.highlight .vi { color: #3333bb } /* Name.Variable.Instance */
.highlight .vm { color: #336699 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */</style></head><body class=tex2jax_ignore><header><brand><i class="fab fa-python"></i><a href=/>Home</a></brand><nav>/ <a href=/>p</a>  /  <div class=dropdown><a href=dask>dask</a> /  <div class=dropdown-content><a href=/p/IPython/8.2.0.dev/api/IPython.html>IPython</a><a href=/p/astropy/5.0/api/astropy.html>astropy</a><a href=/p/dask/2021.10.0/api/dask.html>dask</a><a href=/p/distributed/2021.10.0/api/distributed.html>distributed</a><a href=/p/matplotlib/3.5.1/api/matplotlib.html>matplotlib</a><a href=/p/networkx/2.7.2rc1.dev0/api/networkx.html>networkx</a><a href=/p/numpy/1.22.3/api/numpy.html>numpy</a><a href=/p/pandas/1.4.1/api/pandas.html>pandas</a><a href=/p/papyri/0.0.8/api/papyri.html>papyri</a><a href=/p/scipy/1.8.0/api/scipy.html>scipy</a><a href=/p/skimage/0.17.2/api/skimage.html>skimage</a></div></div><div class=dropdown><a href=/p/dask/2021.10.0/api/dask.html>2021.10.0</a> /  <div class=dropdown-content><a href=/p/dask/2021.10.0/api/dask.html>2021.10.0</a></div></div><div class=dropdown><a href=/p/dask/2021.10.0/api/dask.html>api</a> /  <div class=dropdown-content><a href=/p/dask/2021.10.0/api/dask.html>API</a><a href=/p/dask/2021.10.0/gallery>Gallery</a><a href=/p/dask/2021.10.0/examples>Examples</a></div></div><div class=dropdown><a class=dropbtn href=dask.html>dask</a>.</div><div class=dropdown><a class=dropbtn href=dask.array.html>array</a>. <div class=dropdown-content><a href=/p/dask/2021.10.0/api/dask._version.html>_version</a><a href=/p/dask/2021.10.0/api/dask.array.html>array</a><a href=/p/dask/2021.10.0/api/dask.base.html>base</a><a href=/p/dask/2021.10.0/api/dask.blockwise.html>blockwise</a><a href=/p/dask/2021.10.0/api/dask.callbacks.html>callbacks</a><a href=/p/dask/2021.10.0/api/dask.compatibility.html>compatibility</a><a href=/p/dask/2021.10.0/api/dask.config.html>config</a><a href=/p/dask/2021.10.0/api/dask.context.html>context</a><a href=/p/dask/2021.10.0/api/dask.core.html>core</a><a href=/p/dask/2021.10.0/api/dask.datasets.html>datasets</a><a href=/p/?/?/api/dask.delayed.html>delayed</a><a href=/p/dask/2021.10.0/api/dask.hashing.html>hashing</a><a href=/p/dask/2021.10.0/api/dask.highlevelgraph.html>highlevelgraph</a><a href=/p/dask/2021.10.0/api/dask.layers.html>layers</a><a href=/p/dask/2021.10.0/api/dask.local.html>local</a><a href=/p/dask/2021.10.0/api/dask.multiprocessing.html>multiprocessing</a><a href=/p/dask/2021.10.0/api/dask.optimization.html>optimization</a><a href=/p/dask/2021.10.0/api/dask.order.html>order</a><a href=/p/dask/2021.10.0/api/dask.sizeof.html>sizeof</a><a href=/p/dask/2021.10.0/api/dask.system.html>system</a><a href=/p/dask/2021.10.0/api/dask.threaded.html>threaded</a><a href=/p/dask/2021.10.0/api/dask.utils.html>utils</a><a href=/p/dask/2021.10.0/api/dask.utils_test.html>utils_test</a><a href=/p/dask/2021.10.0/api/dask.widgets.html>widgets</a></div></div><div class=dropdown><a class=dropbtn href=dask.array.core.html>core</a>. <div class=dropdown-content><a href=/p/dask/2021.10.0/api/dask.array.backends.html>backends</a><a href=/p/?/?/api/dask.array.blockwise.html>blockwise</a><a href=/p/dask/2021.10.0/api/dask.array.chunk.html>chunk</a><a href=/p/dask/2021.10.0/api/dask.array.chunk_types.html>chunk_types</a><a href=/p/dask/2021.10.0/api/dask.array.core.html>core</a><a href=/p/dask/2021.10.0/api/dask.array.creation.html>creation</a><a href=/p/dask/2021.10.0/api/dask.array.dispatch.html>dispatch</a><a href=/p/dask/2021.10.0/api/dask.array.einsumfuncs.html>einsumfuncs</a><a href=/p/dask/2021.10.0/api/dask.array.fft.html>fft</a><a href=/p/?/?/api/dask.array.gufunc.html>gufunc</a><a href=/p/dask/2021.10.0/api/dask.array.lib.html>lib</a><a href=/p/dask/2021.10.0/api/dask.array.linalg.html>linalg</a><a href=/p/dask/2021.10.0/api/dask.array.ma.html>ma</a><a href=/p/dask/2021.10.0/api/dask.array.numpy_compat.html>numpy_compat</a><a href=/p/dask/2021.10.0/api/dask.array.optimization.html>optimization</a><a href=/p/dask/2021.10.0/api/dask.array.overlap.html>overlap</a><a href=/p/?/?/api/dask.array.percentile.html>percentile</a><a href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><a href=/p/?/?/api/dask.array.rechunk.html>rechunk</a><a href=/p/dask/2021.10.0/api/dask.array.reductions.html>reductions</a><a href=/p/dask/2021.10.0/api/dask.array.routines.html>routines</a><a href=/p/dask/2021.10.0/api/dask.array.slicing.html>slicing</a><a href=/p/dask/2021.10.0/api/dask.array.tiledb_io.html>tiledb_io</a><a href=/p/dask/2021.10.0/api/dask.array.ufunc.html>ufunc</a><a href=/p/dask/2021.10.0/api/dask.array.utils.html>utils</a><a href=/p/dask/2021.10.0/api/dask.array.wrap.html>wrap</a></div></div><div class=dropdown><a class=dropbtn href=dask.array.core.map_blocks.html>map_blocks</a><div class=dropdown-content><a href=/p/dask/2021.10.0/api/dask.array.core.Array.html>Array</a><a href=/p/dask/2021.10.0/api/dask.array.core.PerformanceWarning.html>PerformanceWarning</a><a href=/p/dask/2021.10.0/api/dask.array.core._check_regular_chunks.html>_check_regular_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core._compute_multiplier.html>_compute_multiplier</a><a href=/p/dask/2021.10.0/api/dask.array.core._concatenate2.html>_concatenate2</a><a href=/p/dask/2021.10.0/api/dask.array.core._enforce_dtype.html>_enforce_dtype</a><a href=/p/dask/2021.10.0/api/dask.array.core._get_axis.html>_get_axis</a><a href=/p/dask/2021.10.0/api/dask.array.core._get_chunk_shape.html>_get_chunk_shape</a><a href=/p/dask/2021.10.0/api/dask.array.core._pass_extra_kwargs.html>_pass_extra_kwargs</a><a href=/p/dask/2021.10.0/api/dask.array.core._should_delegate.html>_should_delegate</a><a href=/p/dask/2021.10.0/api/dask.array.core._vindex.html>_vindex</a><a href=/p/dask/2021.10.0/api/dask.array.core._vindex_array.html>_vindex_array</a><a href=/p/dask/2021.10.0/api/dask.array.core._vindex_merge.html>_vindex_merge</a><a href=/p/dask/2021.10.0/api/dask.array.core._vindex_slice.html>_vindex_slice</a><a href=/p/dask/2021.10.0/api/dask.array.core._vindex_transpose.html>_vindex_transpose</a><a href=/p/dask/2021.10.0/api/dask.array.core.apply_infer_dtype.html>apply_infer_dtype</a><a href=/p/dask/2021.10.0/api/dask.array.core.asanyarray.html>asanyarray</a><a href=/p/dask/2021.10.0/api/dask.array.core.asarray.html>asarray</a><a href=/p/dask/2021.10.0/api/dask.array.core.auto_chunks.html>auto_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core.block.html>block</a><a href=/p/dask/2021.10.0/api/dask.array.core.blockdims_from_blockshape.html>blockdims_from_blockshape</a><a href=/p/dask/2021.10.0/api/dask.array.core.broadcast_arrays.html>broadcast_arrays</a><a href=/p/dask/2021.10.0/api/dask.array.core.broadcast_chunks.html>broadcast_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core.broadcast_shapes.html>broadcast_shapes</a><a href=/p/dask/2021.10.0/api/dask.array.core.broadcast_to.html>broadcast_to</a><a href=/p/dask/2021.10.0/api/dask.array.core.check_if_handled_given_other.html>check_if_handled_given_other</a><a href=/p/dask/2021.10.0/api/dask.array.core.chunks_from_arrays.html>chunks_from_arrays</a><a href=/p/dask/2021.10.0/api/dask.array.core.common_blockdim.html>common_blockdim</a><a href=/p/dask/2021.10.0/api/dask.array.core.concatenate.html>concatenate</a><a href=/p/dask/2021.10.0/api/dask.array.core.concatenate3.html>concatenate3</a><a href=/p/dask/2021.10.0/api/dask.array.core.concatenate_axes.html>concatenate_axes</a><a href=/p/dask/2021.10.0/api/dask.array.core.deepfirst.html>deepfirst</a><a href=/p/dask/2021.10.0/api/dask.array.core.dotmany.html>dotmany</a><a href=/p/dask/2021.10.0/api/dask.array.core.elemwise.html>elemwise</a><a href=/p/dask/2021.10.0/api/dask.array.core.ensure_int.html>ensure_int</a><a href=/p/dask/2021.10.0/api/dask.array.core.finalize.html>finalize</a><a href=/p/dask/2021.10.0/api/dask.array.core.from_array.html>from_array</a><a href=/p/dask/2021.10.0/api/dask.array.core.from_delayed.html>from_delayed</a><a href=/p/dask/2021.10.0/api/dask.array.core.from_func.html>from_func</a><a href=/p/dask/2021.10.0/api/dask.array.core.from_npy_stack.html>from_npy_stack</a><a href=/p/dask/2021.10.0/api/dask.array.core.from_zarr.html>from_zarr</a><a href=/p/dask/2021.10.0/api/dask.array.core.getem.html>getem</a><a href=/p/dask/2021.10.0/api/dask.array.core.getter.html>getter</a><a href=/p/dask/2021.10.0/api/dask.array.core.getter_inline.html>getter_inline</a><a href=/p/dask/2021.10.0/api/dask.array.core.getter_nofancy.html>getter_nofancy</a><a href=/p/dask/2021.10.0/api/dask.array.core.handle_out.html>handle_out</a><a href=/p/dask/2021.10.0/api/dask.array.core.implements.html>implements</a><a href=/p/dask/2021.10.0/api/dask.array.core.insert_to_ooc.html>insert_to_ooc</a><a href=/p/dask/2021.10.0/api/dask.array.core.interleave_none.html>interleave_none</a><a href=/p/dask/2021.10.0/api/dask.array.core.is_scalar_for_elemwise.html>is_scalar_for_elemwise</a><a href=/p/dask/2021.10.0/api/dask.array.core.keyname.html>keyname</a><a href=/p/dask/2021.10.0/api/dask.array.core.load_chunk.html>load_chunk</a><a href=/p/dask/2021.10.0/api/dask.array.core.load_store_chunk.html>load_store_chunk</a><a href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><a href=/p/dask/2021.10.0/api/dask.array.core.new_da_object.html>new_da_object</a><a href=/p/dask/2021.10.0/api/dask.array.core.normalize_arg.html>normalize_arg</a><a href=/p/dask/2021.10.0/api/dask.array.core.normalize_chunks.html>normalize_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core.offset_func.html>offset_func</a><a href=/p/dask/2021.10.0/api/dask.array.core.retrieve_from_ooc.html>retrieve_from_ooc</a><a href=/p/dask/2021.10.0/api/dask.array.core.round_to.html>round_to</a><a href=/p/dask/2021.10.0/api/dask.array.core.shapelist.html>shapelist</a><a href=/p/dask/2021.10.0/api/dask.array.core.slices_from_chunks.html>slices_from_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core.stack.html>stack</a><a href=/p/dask/2021.10.0/api/dask.array.core.store.html>store</a><a href=/p/dask/2021.10.0/api/dask.array.core.store_chunk.html>store_chunk</a><a href=/p/dask/2021.10.0/api/dask.array.core.to_hdf5.html>to_hdf5</a><a href=/p/dask/2021.10.0/api/dask.array.core.to_zarr.html>to_zarr</a><a href=/p/dask/2021.10.0/api/dask.array.core.transposelist.html>transposelist</a><a href=/p/dask/2021.10.0/api/dask.array.core.unify_chunks.html>unify_chunks</a><a href=/p/dask/2021.10.0/api/dask.array.core.unpack_singleton.html>unpack_singleton</a></div></div></nav></header><div class=container><div class=sidenav><img src=/p/dask/2021.10.0/img/logo.png><a href=#>dask</a><a href=#>2021.10.0</a><hr><hr><a href=#section-Parameters>Parameters</a><a href=#section-backrefs>BackRef</a></div><code class=signature>map_blocks(func, *args, name=None, token=None, dtype=None, chunks=None, drop_axis=[], new_axis=None, meta=None, **kwargs)</code><p>Note that <code class=verbatim>map_blocks</code> will attempt to automatically determine the output array type by calling <code class=verbatim>func</code> on 0-d versions of the inputs. Please refer to the <code class=verbatim>meta</code> keyword argument below if you expect that the function will not succeed when operating on 0-d arrays.</p><h3 id=section-Parameters>Parameters</h3><dl><dt><a id=func>func</a> : callable</dt><dd><p>Function to apply to every block in the array.</p></dd><dt><a id=args>args</a> : dask arrays or other objects</dt><dd></dd><dt><a id=dtype>dtype</a> : np.dtype, optional</dt><dd><p>The <code class=verbatim>dtype</code> of the output array. It is recommended to provide this. If not provided, will be inferred by applying the function to a small set of fake data.</p></dd><dt><a id=chunks>chunks</a> : tuple, optional</dt><dd><p>Chunk shape of resulting blocks if the function does not preserve shape. If not provided, the resulting array is assumed to have the same block structure as the first input array.</p></dd><dt><a id=drop_axis>drop_axis</a> : number or iterable, optional</dt><dd><p>Dimensions lost by the function.</p></dd><dt><a id=new_axis>new_axis</a> : number or iterable, optional</dt><dd><p>New dimensions created by the function. Note that these are applied after <code class=verbatim>drop_axis</code> (if present).</p></dd><dt><a id=token>token</a> : string, optional</dt><dd><p>The key prefix to use for the output array. If not provided, will be determined from the function name.</p></dd><dt><a id=name>name</a> : string, optional</dt><dd><p>The key name to use for the output array. Note that this fully specifies the output key name, and must be unique. If not provided, will be determined by a hash of the arguments.</p></dd><dt><a id=meta>meta</a> : array-like, optional</dt><dd><p>The <code class=verbatim>meta</code> of the output array, when specified is expected to be an array of the same type and dtype of that returned when calling <code class=verbatim>.compute()</code> on the array returned by this function. When not provided, <code class=verbatim>meta</code> will be inferred by applying the function to a small set of fake data, usually a 0-d array. It's important to ensure that <code class=verbatim>func</code> can successfully complete computation without raising exceptions when 0-d is passed to it, providing <code class=verbatim>meta</code> will be required otherwise. If the output type is known beforehand (e.g., <code class=verbatim>np.ndarray</code> , <code class=verbatim>cupy.ndarray</code> ), an empty array of such type dtype can be passed, for example: <code class=verbatim>meta=np.array((), dtype=np.int32)</code> .</p></dd><dt><a id=**kwargs>**kwargs</a> :</dt><dd><p>Other keyword arguments to pass to function. Values must be constants (not dask.arrays)</p></dd></dl><p>Map a function across all blocks of a dask array.</p><h3 id=section-Examples>Examples</h3><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=kn>import</span><span> </span><a class="foo nn"href=/p/dask/2021.10.0/api/dask.html>dask</a><span class=nn>.</span><a class="foo nn"href=/p/dask/2021.10.0/api/dask.array.html>array</a><span> </span><span class=k>as</span><span> </span><span class=nn>da</span><br><span class=nsl>... </span><span>x</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>6</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span class=mi>3</span><span>)</span>
</pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>x</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span> </span><span class=o>*</span><span> </span><span class=mi>2</span><span>)</span><span class=o>.</span><span>compute</span><span>(</span><span>)</span>
array([ 0,  2,  4,  6,  8, 10])</pre><p>The <code class=verbatim>da.map_blocks</code> function can also accept multiple arrays.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>d</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>5</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span class=mi>2</span><span>)</span><br><span class=nsl>... </span><span>e</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>5</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span class=mi>2</span><span>)</span>
</pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.RandomState.f.html>f</a><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>a</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>a</span><span> </span><span class=o>+</span><span> </span><span>b</span><span class=o>*</span><span class=o>*</span><span class=mi>2</span><span>,</span><span> </span><span>d</span><span>,</span><span> </span><span>e</span><span>)</span><br><span class=nsl>... </span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.RandomState.f.html>f</a><span class=o>.</span><span>compute</span><span>(</span><span>)</span>
array([ 0,  2,  6, 12, 20])</pre><p>If the function changes shape of the blocks then you must provide chunks explicitly.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>y</span><span> </span><span class=o>=</span><span> </span><span>x</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span>[</span><span>:</span><span>:</span><span class=mi>2</span><span>]</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span>(</span><span class=mi>2</span><span>,</span><span> </span><span class=mi>2</span><span>)</span><span>,</span><span>)</span><span>)</span>
</pre><p>You have a bit of freedom in specifying chunks. If all of the output chunk sizes are the same, you can provide just that chunk size as a single tuple.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>a</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>18</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span class=mi>6</span><span>,</span><span>)</span><span>)</span><br><span class=nsl>... </span><span>b</span><span> </span><span class=o>=</span><span> </span><span>a</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span>[</span><span>:</span><span class=mi>3</span><span>]</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span class=mi>3</span><span>,</span><span>)</span><span>)</span>
</pre><p>If the function changes the dimension of the blocks you must specify the created or destroyed dimensions.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>b</span><span> </span><span class=o>=</span><span> </span><span>a</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span>[</span><span class=kc>None</span><span>,</span><span> </span><span>:</span><span>,</span><span> </span><span class=kc>None</span><span>]</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span class=mi>1</span><span>,</span><span> </span><span class=mi>6</span><span>,</span><span> </span><span class=mi>1</span><span>)</span><span>,</span><br><span class=nsl>... </span><span>                 </span><span>new_axis</span><span class=o>=</span><span>[</span><a class="foo mi"href=/p/dask/2021.10.0/api/dask.array.ufunc.log10.html>0</a><span>,</span><span> </span><span class=mi>2</span><span>]</span><span>)</span>
</pre><p>If <code class=verbatim>chunks</code> is specified but <code class=verbatim>new_axis</code> is not, then it is inferred to add the necessary number of axes on the left.</p><p>Map_blocks aligns blocks by block positions without regard to shape. In the following example we have two arrays with the same number of blocks but with different shape and chunk sizes.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>x</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>1000</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span class=mi>100</span><span>,</span><span>)</span><span>)</span><br><span class=nsl>... </span><span>y</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><span>arange</span><span>(</span><span class=mi>100</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><a class="foo mi"href=/p/dask/2021.10.0/api/dask.array.ufunc.log10.html>10</a><span>,</span><span>)</span><span>)</span>
</pre><p>The relevant attribute to match is numblocks.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>x</span><span class=o>.</span><span>numblocks</span>
(10,)</pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>y</span><span class=o>.</span><span>numblocks</span>
(10,)</pre><p>If these match (up to broadcasting rules) then we can map arbitrary functions across blocks</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=k>def</span><span> </span><a class="foo nf"href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html">func</a><span>(</span><span>a</span><span>,</span><span> </span><span>b</span><span>)</span><span>:</span><br><span class=nsl>... </span><span>    </span><span class=k>return</span><span> </span><span>np</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.html>array</a><span>(</span><span>[</span><span>a</span><span class=o>.</span><span>max</span><span>(</span><span>)</span><span>,</span><span> </span><span>b</span><span class=o>.</span><span>max</span><span>(</span><span>)</span><span>]</span><span>)</span>
</pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><a href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html"class=foo>func</a><span>,</span><span> </span><span>x</span><span>,</span><span> </span><span>y</span><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span class=mi>2</span><span>,</span><span>)</span><span>,</span><span> </span><span>dtype</span><span class=o>=</span><span class=s1>'</span><span class=s1>i8</span><span class=s1>'</span><span>)</span>
dask.array&LTfunc, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray></pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>_</span><span class=o>.</span><span>compute</span><span>(</span><span>)</span>
array([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,
        69, 799,  79, 899,  89, 999,  99])</pre><p>Your block function get information about where it is in the array by accepting a special <code class=verbatim>block_info</code> or <code class=verbatim>block_id</code> keyword argument.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=k>def</span><span> </span><a class="foo nf"href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html">func</a><span>(</span><span>block_info</span><span class=o>=</span><span class=kc>None</span><span>)</span><span>:</span><br><span class=nsl>... </span><span>    </span><a class="foo k"href=/p/dask/2021.10.0/api/dask.array.core._pass_extra_kwargs.html>pass</a>
</pre><p>This will receive the following information:</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>block_info</span><span>  </span><span class=c1># doctest: +SKIP</span>
{0: {'shape': (1000,),
     'num-chunks': (10,),
     'chunk-location': (4,),
     'array-location': [(400, 500)]},
 None: {'shape': (1000,),
        'num-chunks': (10,),
        'chunk-location': (4,),
        'array-location': [(400, 500)],
        'chunk-shape': (100,),
        'dtype': dtype('float64')}}</pre><p>For each argument and keyword arguments that are dask arrays (the positions of which are the first index), you will receive the shape of the full array, the number of chunks of the full array in each dimension, the chunk location (for example the fourth chunk over in the first dimension), and the array location (for example the slice corresponding to <code class=verbatim>40:50</code> ). The same information is provided for the output, with the key <code class=verbatim>None</code> , plus the shape and dtype that should be returned.</p><p>These features can be combined to synthesize an array from scratch, for example:</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=k>def</span><span> </span><a class="foo nf"href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html">func</a><span>(</span><span>block_info</span><span class=o>=</span><span class=kc>None</span><span>)</span><span>:</span><br><span class=nsl>... </span><span>    </span><span>loc</span><span> </span><span class=o>=</span><span> </span><span>block_info</span><span>[</span><span class=kc>None</span><span>]</span><span>[</span><span class=s1>'</span><span class=s1>array-location</span><span class=s1>'</span><span>]</span><span>[</span><a class="foo mi"href=/p/dask/2021.10.0/api/dask.array.ufunc.log10.html>0</a><span>]</span><br><span class=nsl>... </span><span>    </span><span class=k>return</span><span> </span><span>np</span><span class=o>.</span><span>arange</span><span>(</span><span>loc</span><span>[</span><a class="foo mi"href=/p/dask/2021.10.0/api/dask.array.ufunc.log10.html>0</a><span>]</span><span>,</span><span> </span><span>loc</span><span>[</span><span class=mi>1</span><span>]</span><span>)</span>
</pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><a href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html"class=foo>func</a><span>,</span><span> </span><span>chunks</span><span class=o>=</span><span>(</span><span>(</span><span class=mi>4</span><span>,</span><span> </span><span class=mi>4</span><span>)</span><span>,</span><span>)</span><span>,</span><span> </span><span>dtype</span><span class=o>=</span><span>np</span><span class=o>.</span><span>float_</span><span>)</span>
dask.array&LTfunc, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray></pre><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>_</span><span class=o>.</span><span>compute</span><span>(</span><span>)</span>
array([0, 1, 2, 3, 4, 5, 6, 7])</pre><p><code class=verbatim>block_id</code> is similar to <code class=verbatim>block_info</code> but contains only the <code class=verbatim>chunk_location</code> :</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=k>def</span><span> </span><a class="foo nf"href="/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func.html">func</a><span>(</span><span>block_id</span><span class=o>=</span><span class=kc>None</span><span>)</span><span>:</span><br><span class=nsl>... </span><span>    </span><a class="foo k"href=/p/dask/2021.10.0/api/dask.array.core._pass_extra_kwargs.html>pass</a>
</pre><p>This will receive the following information:</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>block_id</span><span>  </span><span class=c1># doctest: +SKIP</span>
(4, 3)</pre><p>You may specify the key name prefix of the resulting task in the graph with the optional <code class=verbatim>token</code> keyword argument.</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>x</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span> </span><span class=o>+</span><span> </span><span class=mi>1</span><span>,</span><span> </span><span>name</span><span class=o>=</span><span class=s1>'</span><span class=s1>increment</span><span class=s1>'</span><span>)</span>
dask.array&LTincrement, shape=(1000,), dtype=int64, chunksize=(100,), chunktype=numpy.ndarray></pre><p>For functions that may not handle 0-d arrays, it's also possible to specify <code class=verbatim>meta</code> with an empty array matching the type of the expected result. In the example below, <code class=verbatim>func</code> will result in an <code class=verbatim>IndexError</code> when computing <code class=verbatim>meta</code> :</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span>[</span><span class=mi>2</span><span>]</span><span>,</span><span> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><span>(</span><span class=mi>5</span><span>)</span><span>,</span><span> </span><span>meta</span><span class=o>=</span><span>np</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.html>array</a><span>(</span><span>(</span><span>)</span><span>)</span><span>)</span>
dask.array&LTlambda, shape=(5,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray></pre><p>Similarly, it's possible to specify a non-NumPy array to <code class=verbatim>meta</code> , and provide a <code class=verbatim>dtype</code> :</p><span class=note>This example is valid syntax, but we were not able to check execution</span><pre class="highlight compiled"><span class=nsl>>>> </span><span class=kn>import</span><span> </span><span class=nn>cupy</span><span>  </span><span class=c1># doctest: +SKIP</span><br><span class=nsl>... </span><span>rs</span><span> </span><span class=o>=</span><span> </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.RandomState.html>RandomState</a><span>(</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.RandomState.html>RandomState</a><span class=o>=</span><span>cupy</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.RandomState.html>RandomState</a><span>)</span><span>  </span><span class=c1># doctest: +SKIP</span><br><span class=nsl>... </span><span>dt</span><span> </span><span class=o>=</span><span> </span><span>np</span><span class=o>.</span><span>float32</span><br><span class=nsl>... </span><span>da</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html>map_blocks</a><span>(</span><span class=k>lambda</span><span> </span><span>x</span><span>:</span><span> </span><span>x</span><span>[</span><span class=mi>2</span><span>]</span><span>,</span><span> </span><span>rs</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.random.html>random</a><span>(</span><span class=mi>5</span><span>,</span><span> </span><span>dtype</span><span class=o>=</span><span>dt</span><span>)</span><span>,</span><span> </span><span>meta</span><span class=o>=</span><span>cupy</span><span class=o>.</span><a class=foo href=/p/dask/2021.10.0/api/dask.array.html>array</a><span>(</span><span>(</span><span>)</span><span>,</span><span> </span><span>dtype</span><span class=o>=</span><span>dt</span><span>)</span><span>)</span><span>  </span><span class=c1># doctest: +SKIP</span>
dask.array&LTlambda, shape=(5,), dtype=float32, chunksize=(5,), chunktype=cupy.ndarray></pre> See : <h3 id=section-backrefs>Back References</h3><p>The following pages refer to to this document either explicitly or contain code examples using this.</p><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.overlap.map_overlap.html link>dask.array.overlap.map_overlap</a></code><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.core.unify_chunks.html link>dask.array.core.unify_chunks</a></code><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.routines.apply_along_axis.html link>dask.array.routines.apply_along_axis</a></code><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.core._pass_extra_kwargs.html link>dask.array.core._pass_extra_kwargs</a></code><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.core.Array.map_overlap.html link>dask.array.core.Array.map_overlap</a></code><code><a class=exists href=/p/dask/2021.10.0/api/dask.array.core.map_blocks.html link>dask.array.core.map_blocks</a></code><h3>Local connectivity graph</h3><p>Hover to see nodes names; edges to Self not shown, Caped at 50 nodes.</p><p>Using a canvas is more power efficient and can get hundred of nodes ; but does not allow hyperlinks; , arrows or text (beyond on hover)</p><canvas class=graph height=500 width=800></canvas><p>SVG is more flexible but power hungry; and does not scale well to 50 + nodes.</p><svg class=graph height=500 width=600></svg><p>All aboves nodes referred to, (or are referred from) current nodes; Edges from Self to other have been omitted (or all nodes would be connected to the central node "self" which is not useful). Nodes are colored by the library they belong to, and scaled with the number of references pointing them</p><hr> File: /dask/array/core.py#459 <br> type: &LTclass 'function'> <br> Commit: <br><script src=https://d3js.org/d3.v4.min.js></script><script src=https://d3js.org/d3-selection-multi.v1.js></script><style>.node {};
        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; };</style><script>window._data_graph={nodes:[{id:1,val:11,label:"dask.array.fft.fft_wrap.<locals>.func",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.fft.fft_wrap.<locals>.func"},{id:2,val:14.855654600401044,label:"dask.array.random",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.random"},{id:3,val:20.727922061357855,label:"dask.array.ufunc.log10",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.ufunc.log10"},{id:4,val:19.618950038622252,label:"dask.array",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array"},{id:6,val:9.732050807568877,label:"dask.array.random.RandomState",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.random.RandomState"},{id:7,val:9,label:"dask.array.core.unify_chunks",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.core.unify_chunks"},{id:8,val:15.416198487095663,label:"dask",mod:"dask",url:"/p/dask/2021.10.0/api/dask"},{id:9,val:11.464101615137753,label:"dask.array.random.RandomState.f",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.random.RandomState.f"},{id:10,val:9,label:"dask.array.core.Array.map_overlap",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.core.Array.map_overlap"},{id:11,val:9,label:"dask.array.overlap.map_overlap",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.overlap.map_overlap"},{id:12,val:9.414213562373096,label:"dask.array.routines.apply_along_axis",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.routines.apply_along_axis"},{id:13,val:10,label:"dask.array.core._pass_extra_kwargs",mod:"dask",url:"/p/dask/2021.10.0/api/dask.array.core._pass_extra_kwargs"}],links:[{source:4,target:7,id:57},{source:4,target:12,id:90},{source:4,target:6,id:117},{source:4,target:10,id:146},{source:4,target:11,id:150},{source:2,target:6,id:160},{source:2,target:9,id:163},{source:8,target:7,id:209},{source:8,target:6,id:210},{source:8,target:10,id:238},{source:8,target:11,id:244},{source:3,target:7,id:298},{source:3,target:1,id:328},{source:3,target:9,id:341},{source:3,target:12,id:343},{source:3,target:6,id:391},{source:3,target:10,id:414},{source:3,target:11,id:417},{source:1,target:11,id:430},{source:1,target:13,id:434},{source:1,target:10,id:435}]};</script><script src=/graph_canvas.js></script><script src=/graph_svg.js></script></div></body></html>
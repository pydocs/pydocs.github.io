Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚†Ù¹‚ƒÙ§xChunking of the input data (Ù¡fsampleÙ§y) is only allowed along the 0th (row) axis (the axis corresponding to the total number of samples). Data chunked along the 1st axis (column) axis is not compatible with this function. If weights are used, they must be chunked along the 0th axis identically to the input sample.€Ù¹‚‰Ù§xNAn example setup for a three dimensional histogram, where the sample shape is Ù¡f(8, 3)Ù§w and weights are shape Ù¡d(8,)Ù§x, sample chunks would be Ù¡n((4, 4), (3,))Ù§x! and the weights chunks would be Ù¡i((4, 4),)Ù§x a table of the structure:€Ù¹‚‰Ù§xš+-------+-----------------------+-----------+ |       |      sample (8 x 3)   |  weights  | +=======+=====+=====+=====+=====+=====+=====+ | chunk | row | Ù£ƒaxööÙ§c | Ù£ƒayööÙ§c | Ù£ƒazööÙ§i | row | Ù£ƒawööÙ§y | +-------+-----+-----+-----+-----+-----+-----+ |       |   0 |   5 |   6 |   6 |   0 | 0.5 | |       +-----+-----+-----+-----+-----+-----+ |       |   1 |   8 |   9 |   2 |   1 | 0.8 | |   0   +-----+-----+-----+-----+-----+-----+ |       |   2 |   3 |   3 |   1 |   2 | 0.3 | |       +-----+-----+-----+-----+-----+-----+ |       |   3 |   2 |   5 |   6 |   3 | 0.7 | +-------+-----+-----+-----+-----+-----+-----+ |       |   4 |   3 |   1 |   1 |   4 | 0.3 | |       +-----+-----+-----+-----+-----+-----+ |       |   5 |   3 |   2 |   9 |   5 | 1.3 | |   1   +-----+-----+-----+-----+-----+-----+ |       |   6 |   8 |   1 |   5 |   6 | 0.8 | |       +-----+-----+-----+-----+-----+-----+ |       |   7 |   3 |   5 |   3 |   7 | 0.7 | +-------+-----+-----+-----+-----+-----+-----+€Ù¹‚…Ù§xVIf the sample 0th dimension and weight 0th (row) dimension are chunked differently, a Ù¡jValueErrorÙ§xd will be raised. If coordinate groupings ((x, y, z) trios) are separated by a chunk boundry, then a Ù¡jValueErrorÙ§xM will be raised. We suggest that you rechunk your data if it is of that form.€Ù¹‚‰Ù§x¥The chunks property of the data (and optional weights) are used to check for compatibility with the blocked algorithm (as described above); therefore, you must call Ù£ƒmto_dask_arrayööÙ§v on a collection from Ù¡ndask.dataframeÙ§g, i.e. Ù¢„udask.dataframe.SeriesÙ „ddaska*capixdask.dataframe.core.SeriesfmoduleõÙ§d or Ù¢„xdask.dataframe.DataFrameÙ „ddaska*capixdask.dataframe.core.DataFramefmoduleõÙ§a.€Ù¹‚ˆÙ§x%The function is also compatible with Ù£ƒaxööÙ§b, Ù£ƒayööÙ§f, and Ù£ƒazööÙ§xe being individual 1D arrays with equal chunking. In that case, the data should be passed as a tuple: Ù¡xhistogramdd((x, y, z), ...)€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒfsamplex7dask.array.Array (N, D) or sequence of dask.array.ArrayƒÙ¹‚Ù§x)Multidimensional data to be histogrammed.€Ù¹‚Ù§xQNote the unusual interpretation of a sample when it is a sequence of dask Arrays:€ÙÈ‚Ù¹‚Ù§xcWhen a (N, D) dask Array, each row is an entry in the sample   (coordinate in D dimensional space).€Ù¹‚Ù§xnWhen a sequence of dask Arrays, each element in the sequence   is the array of values for a single coordinate.€Ù°ƒdbinsxAsequence of arrays describing bin edges, int, or sequence of ints„Ù¹‚Ù§vThe bin specification.€Ù¹‚Ù§x(The possible binning configurations are:€ÙÈƒÙ¹‚Ù§x^A sequence of arrays describing the monotonically increasing   bin edges along each dimension.€Ù¹‚ƒÙ§xjA single int describing the total number of bins that will   be used in each dimension (this requires the Ù¡erangeÙ§x   argument to be defined).€Ù¹‚ƒÙ§xiA sequence of ints describing the total number of bins to be   used in each dimension (this requires the Ù¡erangeÙ§x argument   to be defined).€Ù¹‚Ù§xƒWhen bins are described by arrays, the rightmost edge is included. Bins described by arrays also allows for non-uniform bin widths.€Ù°ƒerangexsequence of pairs, optionalÙ¹‚‡Ù§xA sequence of length D, each a (min, max) tuple giving the outer bin edges to be used if the edges are not given explicitly in Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§xT. If defined, this argument is required to have an entry for each dimension. Unlike Ù¢„qnumpy.histogramddÙ „enumpya*capiqnumpy.histogramddfmoduleõÙ§e, if Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§xÁ does not define bin edges, this argument is required (this function will not automatically use the min and max of of the value in a given dimension because the input data may be lazy in dask).€Ù°ƒfnormednbool, optionalÙ¹‚…Ù§xkAn alias for the density argument that behaves identically. To avoid confusion with the broken argument to Ù¢„ihistogramÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramfmoduleõÙ§b, Ù¢„gdensityÙ „ööelocalgdensityelocalõÙ§u should be preferred.€Ù°ƒgweightsxdask.array.Array, optionalÙ¹‚Ù§x£An array of values weighing each sample in the input data. The chunks of the weights must be identical to the chunking along the 0th (row) axis of the data sample.€Ù°ƒgdensitynbool, optionalÙ¹‚…Ù§cIf Ù¡eFalseÙ§xP (default), the returned array represents the number of samples in each bin. If Ù¡dTrueÙ§xM, the returned array represents the probability density function at each bin.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒ`pdask.array.ArrayÙ¹‚Ù§xThe values of the histogram.€Ù°ƒ`vlist(dask.array.Array)Ù¹‚Ù§xCSequence of arrays representing the bin edges along each dimension.€ögSummaryÙ¯‚Ù¹‚ƒÙ§sBlocked variant of Ù¢„qnumpy.histogramddÙ „enumpya*capiqnumpy.histogramddfmoduleõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsogReturnshExamplesw/dask/array/routines.pyhr<class 'function'>vdask.array.histogramddÙ¯‚‹Ù¹‚Ù§xSComputing the histogram in 5 blocks using different bin edges along each dimension:€Ù´ƒ˜‰Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbdaÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„guniformÙ „ddaski2021.10.0fmodulex%dask.array.random.RandomState.uniformfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dsizeÙ±‚aoa=Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmic200Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`eedgesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a
Ù±‚`d    Ù±‚`bnpÙ±‚aoa.Ù±‚`hlinspaceÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bc1s# 4 bins in 1st dimÙ±‚`a
Ù±‚`d    Ù±‚`bnpÙ±‚aoa.Ù±‚`hlinspaceÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bc1n# 5 in the 2ndÙ±‚`a
Ù±‚`d    Ù±‚`bnpÙ±‚aoa.Ù±‚`hlinspaceÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bc1n# 3 in the 3rdÙ±‚`a
Ù±‚`a]Ù±‚`a
Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`eedgesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„khistogramddÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramddfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚aoa=Ù±‚`eedgesÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„fresultÙ „ddaski2021.10.0fmodulexdask.array.routines.result_typefmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`ahÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fresultÙ „ddaski2021.10.0fmodulexdask.array.routines.result_typefmoduleõÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõi(4, 5, 3)hcompiledÙ¹‚Ù§xMDefining the bins by total number and their ranges, along with using weights:€Ù´ƒ˜zÙ±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a
Ù±‚`frangesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia3Ù±‚`b  Ù±‚bc1x%# expands to ((0, 1), (0, 1), (0, 1))Ù±‚`a
Ù±‚`awÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„guniformÙ „ddaski2021.10.0fmodulex%dask.array.random.RandomState.uniformfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dsizeÙ±‚aoa=Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„ichunksizeÙ „ddaski2021.10.0fmodulex+dask.array.overlap.ensure_minimum_chunksizefmoduleõÙ±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`eedgesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„khistogramddÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramddfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚aoa=Ù±‚`dbinsÙ±‚`a,Ù±‚`a Ù±‚bnberangeÙ±‚aoa=Ù±‚`frangesÙ±‚`a,Ù±‚`a Ù±‚`gweightsÙ±‚aoa=Ù±‚`awÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„giscloseÙ „ddaski2021.10.0fmodulexdask.array.routines.isclosefmoduleõÙ±‚`a(Ù±‚`ahÙ±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`awÙ±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`a)dTruehcompiledÙ¹‚Ù§x+Using a sequence of 1D arrays as the input:€Ù´ƒ˜ƒÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia3Ù±‚`a
Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`eedgesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„khistogramddÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramddfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`azÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚`a)Ù±‚`a
Ù±‚`ahxgdask.array<sum-aggregate, shape=(2, 2, 2), dtype=float64, chunksize=(2, 2, 2), chunktype=numpy.ndarray>hcompiledÙ´ƒ„Ù±‚`eedgesÙ±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]xSdask.array<array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray>hcompiledÙ´ƒ…Ù±‚`ahÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xVarray([[[0., 2.],
        [0., 1.]],
<BLANKLINE>
       [[1., 0.],
        [2., 0.]]])hcompiledÙ´ƒˆÙ±‚`eedgesÙ±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)parray([0, 3, 6])hcompiledÙ´ƒˆÙ±‚`eedgesÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)parray([0, 3, 6])hcompiledÙ´ƒˆÙ±‚`eedgesÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)parray([0, 3, 6])hcompiledöÙ¼ƒÙ»ƒihistogramxdask.array.routines.histogramõ€öi2021.10.0Ù«xNhistogramdd(sample, bins, range=None, normed=None, weights=None, density=None)öxdask.array.routines.histogramdd€
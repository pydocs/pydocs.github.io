Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‡Ù§jNote that Ù¡jmap_blocksÙ§xJ will attempt to automatically determine the output array type by calling Ù¡dfuncÙ§x4 on 0-d versions of the inputs. Please refer to the Ù¡dmetaÙ§xf keyword argument below if you expect that the function will not succeed when operating on 0-d arrays.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŠÙ°ƒdfunchcallableÙ¹‚Ù§x.Function to apply to every block in the array.€Ù°ƒdargsxdask arrays or other objects€Ù°ƒedtypernp.dtype, optionalÙ¹‚ƒÙ§dThe Ù¡edtypeÙ§x of the output array. It is recommended to provide this. If not provided, will be inferred by applying the function to a small set of fake data.€Ù°ƒfchunksotuple, optionalÙ¹‚Ù§x³Chunk shape of resulting blocks if the function does not preserve shape. If not provided, the resulting array is assumed to have the same block structure as the first input array.€Ù°ƒidrop_axisxnumber or iterable, optionalÙ¹‚Ù§x Dimensions lost by the function.€Ù°ƒhnew_axisxnumber or iterable, optionalÙ¹‚ƒÙ§xJNew dimensions created by the function. Note that these are applied after Ù¡idrop_axisÙ§n (if present).€Ù°ƒetokenpstring, optionalÙ¹‚Ù§xgThe key prefix to use for the output array. If not provided, will be determined from the function name.€Ù°ƒdnamepstring, optionalÙ¹‚Ù§x±The key name to use for the output array. Note that this fully specifies the output key name, and must be unique. If not provided, will be determined by a hash of the arguments.€Ù°ƒdmetatarray-like, optionalÙ¹‚‘Ù§dThe Ù¡dmetaÙ§xy of the output array, when specified is expected to be an array of the same type and dtype of that returned when calling Ù¡j.compute()Ù§x< on the array returned by this function. When not provided, Ù¡dmetaÙ§x{ will be inferred by applying the function to a small set of fake data, usually a 0-d array. It's important to ensure that Ù¡dfuncÙ§xf can successfully complete computation without raising exceptions when 0-d is passed to it, providing Ù¡dmetaÙ§xK will be required otherwise. If the output type is known beforehand (e.g., Ù¡jnp.ndarrayÙ§b, Ù¡lcupy.ndarrayÙ§xA), an empty array of such type dtype can be passed, for example: Ù¡x!meta=np.array((), dtype=np.int32)Ù§a.€Ù°ƒh**kwargs`Ù¹‚Ù§xWOther keyword arguments to pass to function. Values must be constants (not dask.arrays)€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x1Map a function across all blocks of a dask array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametershSee AlsohExampless/dask/array/core.pyËr<class 'function'>ƒudask.array.map_blocksxdask.array.Array.map_blocksxdask.array.core.map_blocksÙ¯‚˜(Ù´ƒ˜Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbdaÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia3Ù±‚`a)`hcompiledÙ´ƒ“Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xarray([ 0,  2,  4,  6,  8, 10])hcompiledÙ¹‚ƒÙ§dThe Ù¡mda.map_blocksÙ§x* function can also accept multiple arrays.€Ù´ƒ˜Ù±‚`adÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`aeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia2Ù±‚`a)`hcompiledÙ´ƒ˜%Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a:Ù±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`abÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`adÙ±‚`a,Ù±‚`a Ù±‚`aeÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xarray([ 0,  2,  6, 12, 20])hcompiledÙ¹‚Ù§xTIf the function changes shape of the blocks then you must provide chunks explicitly.€Ù´ƒ˜!Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a)Ù±‚`a)`hcompiledÙ¹‚Ù§x—You have a bit of freedom in specifying chunks.  If all of the output chunk sizes are the same, you can provide just that chunk size as a single tuple.€Ù´ƒ˜.Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib18Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚`a:Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a)Ù±‚`a)`hcompiledÙ¹‚Ù§xiIf the function changes the dimension of the blocks you must specify the created or destroyed dimensions.€Ù´ƒ˜0Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bkcdNoneÙ±‚`a,Ù±‚`a Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚bkcdNoneÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`q                 Ù±‚`hnew_axisÙ±‚aoa=Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)`hcompiledÙ¹‚…Ù§cIf Ù¡fchunksÙ§r is specified but Ù¡hnew_axisÙ§xM is not, then it is inferred to add the necessary number of axes on the left.€Ù¹‚Ù§x¹Map_blocks aligns blocks by block positions without regard to shape. In the following example we have two arrays with the same number of blocks but with different shape and chunk sizes.€Ù´ƒ˜%Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmic100Ù±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmic100Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a)Ù±‚`a)`hcompiledÙ¹‚Ù§x-The relevant attribute to match is numblocks.€Ù´ƒƒÙ±‚`axÙ±‚aoa.Ù±‚`inumblockse(10,)hcompiledÙ´ƒƒÙ±‚`ayÙ±‚aoa.Ù±‚`inumblockse(10,)hcompiledÙ¹‚Ù§x[If these match (up to broadcasting rules) then we can map arbitrary functions across blocks€Ù´ƒ˜!Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`aaÙ±‚aoa.Ù±‚`cmaxÙ±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚aoa.Ù±‚`cmaxÙ±‚`a(Ù±‚`a)Ù±‚`a]Ù±‚`a)`hcompiledÙ´ƒ˜Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bi8Ù±‚bs1a'Ù±‚`a)xSdask.array<func, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray>hcompiledÙ´ƒ…Ù±‚`a_Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xrarray([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,
        69, 799,  79, 899,  89, 999,  99])hcompiledÙ¹‚…Ù§xZYour block function get information about where it is in the array by accepting a special Ù¡jblock_infoÙ§d or Ù¡hblock_idÙ§r keyword argument.€Ù´ƒŒÙ±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a(Ù±‚`jblock_infoÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„dpassÙ „ddaski2021.10.0fmodulex"dask.array.core._pass_extra_kwargsfmoduleõ`hcompiledÙ¹‚Ù§x,This will receive the following information:€Ù´ƒƒÙ±‚`jblock_infoÙ±‚`b  Ù±‚bc1p# doctest: +SKIPy5{0: {'shape': (1000,),
     'num-chunks': (10,),
     'chunk-location': (4,),
     'array-location': [(400, 500)]},
 None: {'shape': (1000,),
        'num-chunks': (10,),
        'chunk-location': (4,),
        'array-location': [(400, 500)],
        'chunk-shape': (100,),
        'dtype': dtype('float64')}}hcompiledÙ¹‚…Ù§yaFor each argument and keyword arguments that are dask arrays (the positions of which are the first index), you will receive the shape of the full array, the number of chunks of the full array in each dimension, the chunk location (for example the fourth chunk over in the first dimension), and the array location (for example the slice corresponding to Ù¡e40:50Ù§xA). The same information is provided for the output, with the key Ù¡dNoneÙ§x3, plus the shape and dtype that should be returned.€Ù¹‚Ù§xPThese features can be combined to synthesize an array from scratch, for example:€Ù´ƒ˜.Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a(Ù±‚`jblock_infoÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`clocÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`jblock_infoÙ±‚`a[Ù±‚bkcdNoneÙ±‚`a]Ù±‚`a[Ù±‚bs1a'Ù±‚bs1narray-locationÙ±‚bs1a'Ù±‚`a]Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚`clocÙ±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`clocÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)`hcompiledÙ´ƒ˜Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`ffloat_Ù±‚`a)xTdask.array<func, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray>hcompiledÙ´ƒ…Ù±‚`a_Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xarray([0, 1, 2, 3, 4, 5, 6, 7])hcompiledÙ¹‚†Ù¡hblock_idÙ§o is similar to Ù¡jblock_infoÙ§w but contains only the Ù¡nchunk_locationÙ§a:€Ù´ƒŒÙ±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a(Ù±‚`hblock_idÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„dpassÙ „ddaski2021.10.0fmodulex"dask.array.core._pass_extra_kwargsfmoduleõ`hcompiledÙ¹‚Ù§x,This will receive the following information:€Ù´ƒƒÙ±‚`hblock_idÙ±‚`b  Ù±‚bc1p# doctest: +SKIPf(4, 3)hcompiledÙ¹‚ƒÙ§xYYou may specify the key name prefix of the resulting task in the graph with the optional Ù¡etokenÙ§r keyword argument.€Ù´ƒ–Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dnameÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1iincrementÙ±‚bs1a'Ù±‚`a)x\dask.array<increment, shape=(1000,), dtype=int64, chunksize=(100,), chunktype=numpy.ndarray>hcompiledÙ¹‚‰Ù§xLFor functions that may not handle 0-d arrays, it's also possible to specify Ù¡dmetaÙ§xU with an empty array matching the type of the expected result. In the example below, Ù¡dfuncÙ§s will result in an Ù¡jIndexErrorÙ§p when computing Ù¡dmetaÙ§a:€Ù´ƒ˜#Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dmetaÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚`a)xVdask.array<lambda, shape=(5,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray>hcompiledÙ¹‚…Ù§x9Similarly, it's possible to specify a non-NumPy array to Ù¡dmetaÙ§p, and provide a Ù¡edtypeÙ§a:€Ù´ƒ˜PÙ±‚bknfimportÙ±‚`a Ù±‚bnndcupyÙ±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`brsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kRandomStateÙ „ddaski2021.10.0fmodulexdask.array.random.RandomStatefmoduleõÙ±‚`a(Ù±‚`Ù¢„kRandomStateÙ „ddaski2021.10.0fmodulexdask.array.random.RandomStatefmoduleõÙ±‚aoa=Ù±‚`dcupyÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kRandomStateÙ „ddaski2021.10.0fmodulexdask.array.random.RandomStatefmoduleõÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bdtÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`gfloat32Ù±‚`a
Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`brsÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bdtÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dmetaÙ±‚aoa=Ù±‚`dcupyÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bdtÙ±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxUdask.array<lambda, shape=(5,), dtype=float32, chunksize=(5,), chunktype=cupy.ndarray>hcompiledöÙ¼ƒÙ»ƒtdask.array.blockwisexdask.array.blockwise.blockwiseõÙ¹‚Ù§x8Generalized operation with control over block alignment.€öi2021.10.0Ù«xymap_blocks(func, *args, name=None, token=None, dtype=None, chunks=None, drop_axis=[], new_axis=None, meta=None, **kwargs)öxdask.array.core.map_blocks€
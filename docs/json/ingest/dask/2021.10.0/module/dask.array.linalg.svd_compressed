Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§yThis computes the approximate singular value decomposition of a large array.  This algorithm is generally faster than the normal algorithm but does not provide exact results.  One can balance between performance and accuracy with input parameters (see below).€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒha: Array`Ù¹‚Ù§kInput array€Ù°ƒfk: int`Ù¹‚Ù§x+Rank of the desired thin SVD decomposition.€Ù°ƒx*iterator: {'power', 'QR'}, default='power'`Ù¹‚Ù§xsDefine the technique used for iterations to cope with flat singular spectra or when the input matrix is very large.€Ù°ƒxn_power_iter: int, default=0`Ù¹‚…Ù§xkNumber of power iterations, useful when the singular values decay slowly. Error decreases exponentially as Ù£ƒln_power_iterööÙ§x increases. In practice, set Ù£ƒln_power_iterööÙ§f <= 4.€Ù°ƒxn_oversamples: int, default=10`Ù¹‚Ù§yNumber of oversamples used for generating the sampling matrix. This value increases the size of the subspace computed, which is more accurate at the cost of efficiency.  Results are rarely sensitive to this choice though and in practice a value of 10 is very commonly high enough.€Ù°ƒgcomputedboolÙ¹‚Ù§yWhether or not to compute data at each use. Recomputing the input while performing several passes reduces memory pressure, but means that we have to compute the input multiple times. This is a good choice if the data is larger than memory and cheap to recreate.€Ù°ƒlcoerce_signsdboolÙ¹‚Ù§xvWhether or not to apply sign coercion to singular vectors in order to maintain deterministic results, by default True.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒ`xu:  Array, unitary / orthogonal€Ù°ƒ`x>s:  Array, singular values in decreasing order (largest first)€Ù°ƒ`xv:  Array, unitary / orthogonal€ögSummaryÙ¯‚Ù¹‚Ù§x=Randomly compressed rank-k thin Singular Value Decomposition.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershExamplesgReturnsjReferencesu/dask/array/linalg.pyär<class 'function'>x dask.array.linalg.svd_compressedÙ¯‚Ù´ƒ“Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„nsvd_compressedÙ „ddaski2021.10.0fmodulex dask.array.linalg.svd_compressedfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bmib20Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledö€i2021.10.0Ù«xusvd_compressed(a, k, iterator='power', n_power_iter=0, n_oversamples=10, seed=None, compute=False, coerce_signs=True)öx dask.array.linalg.svd_compressed€
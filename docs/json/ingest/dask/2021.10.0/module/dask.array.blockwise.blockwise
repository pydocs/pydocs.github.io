Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§xlA broad class of blocked algorithms and patterns can be specified with a concise multi-index notation.  The Ù¡iblockwiseÙ§xì function applies an in-memory function across multiple blocks of multiple inputs in a variety of ways. Many dask.array operations are special cases of blockwise including elementwise, broadcasting, reductions, tensordot, and transpose.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒdfunchcallableÙ¹‚Ù§x0Function to apply to individual tuples of blocks€Ù°ƒgout_indhiterableÙ¹‚Ù§x>Block pattern of the output, something like 'ijk' or (1, 2, 3)€Ù°ƒe*argsxsequence of Array, index pairsÙ¹‚Ù§x(Sequence like (x, 'ij', y, 'jk', z, 'i')€Ù°ƒh**kwargsddictÙ¹‚Ù§x+Extra keyword arguments to pass to function€Ù°ƒedtypehnp.dtypeÙ¹‚Ù§xDatatype of resulting array.€Ù°ƒkconcatenaterbool, keyword onlyÙ¹‚Ù§xBIf true concatenate arrays along dummy indices, else provide lists€Ù°ƒmadjust_chunksddictÙ¹‚Ù§xADictionary mapping index to function to be applied to chunk sizes€Ù°ƒhnew_axesrdict, keyword onlyÙ¹‚Ù§x'New indexes and their dimension lengths€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x6Tensor operation: Generalized inner and outer products€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExamplesx/dask/array/blockwise.pyr<class 'function'>tdask.array.blockwiseÙ¯‚˜Ù¹‚Ù§x?2D embarrassingly parallel operation from two arrays, x, and y.€Ù´ƒ˜€Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„hoperatorÙ „ddaski2021.10.0fmodulex;dask.delayed.Delayed._get_binary_operator.<locals>.<lambda>fmoduleõÙ±‚aoa,Ù±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbnpÙ±‚aoa,Ù±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbdaÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmib20Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`Ù¢„hoperatorÙ „ddaski2021.10.0fmodulex;dask.delayed.Delayed._get_binary_operator.<locals>.<lambda>fmoduleõÙ±‚aoa.Ù±‚`caddÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bf8Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)x"array([[11, 22],
       [ 3,  4]])hcompiledÙ¹‚Ù§x1Outer product multiplying a by b, two 1-d vectors€Ù´ƒ˜\Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmib50Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`eouterÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1ajÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bf8Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xHarray([[  0,   0,   0],
       [ 10,  50, 100],
       [ 20, 100, 200]])hcompiledÙ¹‚Ù§gz = x.T€Ù´ƒ˜$Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`itransposeÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bjiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xarray([[1, 3],
       [2, 4]])hcompiledÙ¹‚…Ù§xoThe transpose case above is illustrative because it does transposition both on each in-memory block by calling Ù¡lnp.transposeÙ§xP and on the order of the blocks themselves, by switching the order of the index Ù¡hij -> jiÙ§a.€Ù¹‚Ù§x[We can compose these same patterns with more variables and more complex in-memory functions€Ù¹‚Ù§kz = X + Y.T€Ù´ƒ˜8Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`ayÙ±‚aoa.Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bjiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bf8Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)x"array([[11,  2],
       [23,  4]])hcompiledÙ¹‚…Ù§pAny index, like Ù¡aiÙ§y` missing from the output index is interpreted as a contraction (note that this differs from Einstein convention; repeated indices do not imply contraction.)  In the case of a contraction the passed function should expect an iterable of blocks on any array that holds that index.  To receive arrays concatenated along contracted dimensions instead pass Ù¡pconcatenate=TrueÙ§a.€Ù¹‚Ù§x1Inner product multiplying a by b, two 1-d vectors€Ù´ƒ˜6Ù±‚akcdefÙ±‚`a Ù±‚bnflsequence_dotÙ±‚`a(Ù±‚`ha_blocksÙ±‚`a,Ù±‚`a Ù±‚`hb_blocksÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`Ù¢„fresultÙ „ddaski2021.10.0fmodulexdask.array.routines.result_typefmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a
Ù±‚`d    Ù±‚akcforÙ±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnbÙ¢„czipÙ „ddaski2021.10.0fmodulex"dask.array.random.RandomState.zipffmoduleõÙ±‚`a(Ù±‚`ha_blocksÙ±‚`a,Ù±‚`a Ù±‚`hb_blocksÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚`Ù¢„fresultÙ „ddaski2021.10.0fmodulexdask.array.routines.result_typefmoduleõÙ±‚`a Ù±‚aoa+Ù±‚aoa=Ù±‚`a Ù±‚`aaÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`abÙ±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`Ù¢„fresultÙ „ddaski2021.10.0fmodulexdask.array.routines.result_typefmoduleõ`hcompiledÙ´ƒ˜)Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`lsequence_dotÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bf8Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)c250hcompiledÙ¹‚ƒÙ§x)Add new single-chunk dimensions with the Ù¡inew_axes=Ù§xf keyword, including the length of the new dimension.  New dimensions will always be in a single chunk.€Ù´ƒ˜ Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`aaÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚bkcdNoneÙ±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „ddaski2021.10.0fmodulexdask.array.creation.ones_likefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a)`hcompiledÙ´ƒ˜(Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bazÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`hnew_axesÙ±‚aoa=Ù±‚`a{Ù±‚bs1a'Ù±‚bs1azÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bmia5Ù±‚`a}Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`aaÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)`hcompiledÙ¹‚ƒÙ§xàNew dimensions can also be multi-chunk by specifying a tuple of chunk sizes.  This has limited utility as is (because the chunks are all the same), but the resulting graph can be modified to achieve more useful results (see Ù¡mda.map_blocksÙ§b).€Ù´ƒ˜1Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bazÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`hnew_axesÙ±‚aoa=Ù±‚`a{Ù±‚bs1a'Ù±‚bs1azÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a}Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`fchunkss((1, 1, 1), (5, 5))hcompiledÙ¹‚ƒÙ§xSIf the applied function changes the size of each chunk you can specify this with a Ù¡sadjust_chunks={...}Ù§x] dictionary holding a function for each index that modifies the dimension size in that index.€Ù´ƒ–Ù±‚akcdefÙ±‚`a Ù±‚bnffdoubleÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`kconcatenateÙ±‚`a(Ù±‚`a[Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a]Ù±‚`a)`hcompiledÙ´ƒ˜6Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`fdoubleÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`madjust_chunksÙ±‚aoa=Ù±‚`a{Ù±‚bs1a'Ù±‚bs1aiÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`anÙ±‚`a:Ù±‚`a Ù±‚bmia2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`anÙ±‚`a}Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚aoa.Ù±‚`fchunksn((2, 2), (2,))hcompiledÙ¹‚Ù§x&Include literals by indexing with None€Ù´ƒ˜*Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iblockwiseÙ „ddaski2021.10.0fmodulendask.blockwisefmoduleõÙ±‚`a(Ù±‚`Ù¢„hoperatorÙ „ddaski2021.10.0fmodulex;dask.delayed.Delayed._get_binary_operator.<locals>.<lambda>fmoduleõÙ±‚aoa.Ù±‚`caddÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmid1234Ù±‚`a,Ù±‚`a Ù±‚bkcdNoneÙ±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)Ù±‚`a
Ù±‚`azÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)x*array([[1235, 1236],
       [1237, 1238]])hcompiledö€i2021.10.0Ù«xŸblockwise(func, out_ind, *args, name=None, token=None, dtype=None, adjust_chunks=None, new_axes=None, align_arrays=True, concatenate=None, meta=None, **kwargs)öxdask.array.blockwise.blockwise€
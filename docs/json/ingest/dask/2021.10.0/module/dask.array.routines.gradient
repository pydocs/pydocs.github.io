Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x.This docstring was copied from numpy.gradient.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§yThe gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.€ögMethodsÙ¯‚€öeNotesÙ¯‚‰Ù¹‚‰Ù§nAssuming that Ù¥jf\in C^{3}Ù§h (i.e., Ù¥afÙ§x0 has at least 3 continuous derivatives) and let Ù¥eh_{*}Ù§xD be a non-homogeneous stepsize, we minimize the "consistency error" Ù¥h\eta_{i}Ù§xe between the true gradient and its estimate from a linear combination of the neighboring grid-points:€Ù¤x°\eta_ { i} = f_ { i}^ { \left ( 1\right)} - \left [ \alpha f\left ( x_ { i}\right) + \beta f\left ( x_ { i} + h_ { d}\right) + \gamma f\left ( x_ { i} - h_ { s}\right) \right] Ù¹‚…Ù§pBy substituting Ù¥pf(x_{i} + h_{d})Ù§e and Ù¥pf(x_{i} - h_{s})Ù§xb with their Taylor series expansion, this translates into solving the following the linear system:€Ù¤xœ\left\ { \begin { array} { r} \alpha+\beta+\gamma=0 \\ \beta h_ { d} - \gamma h_ { s}=1 \\ \beta h_ { d}^ { 2}+\gamma h_ { s}^ { 2}=0 \end { array} \right. Ù¹‚ƒÙ§xThe resulting approximation of Ù¥kf_{i}^{(1)}Ù§r is the following:€Ù¤ya\hat f_ { i}^ { ( 1)} = \frac { h_ { s}^ { 2}f\left ( x_ { i} + h_ { d}\right) + \left ( h_ { d}^ { 2} - h_ { s}^ { 2}\right)f\left ( x_ { i}\right) - h_ { d}^ { 2}f\left ( x_ { i} - h_ { s}\right)} { h_ { s}h_ { d}\left ( h_ { d} + h_ { s}\right)} + \mathcal { O}\left ( \frac { h_ { d}h_ { s}^ { 2} + h_ { s}h_ { d}^ { 2}} { h_ { d} + h_ { s}}\right) Ù¹‚ƒÙ§xIt is worth noting that if Ù¥kh_{s}=h_{d}Ù§xP (i.e., data are evenly spaced) we find the standard second order approximation:€Ù¤x„\hat f_ { i}^ { ( 1)}= \frac { f\left ( x_ { i+1}\right) - f\left ( x_ { i - 1}\right)} { 2h} + \mathcal { O}\left ( h^ { 2}\right) Ù¹‚Ù§x`With a similar procedure the forward/backward approximations used for boundaries can be derived.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒafjarray_likeÙ¹‚Ù§x?An N-dimensional array containing samples of a scalar function.€Ù°ƒgvarargsx!list of scalar or array, optionalƒÙ¹‚Ù§xeSpacing between f values. Default unitary spacing for all dimensions. Spacing can be specified using:€ÙÇ„Ù¹‚Ù§x>single scalar to specify a sample distance for all dimensions.€Ù¹‚‡Ù§xLN scalars to specify a constant sample distance for each dimension.    i.e. Ù£ƒbdxööÙ§b, Ù£ƒbdyööÙ§b, Ù£ƒbdzööÙ§e, ...€Ù¹‚Ù§xN arrays to specify the coordinates of the values along each    dimension of F. The length of the array must match the size of    the corresponding dimension€Ù¹‚Ù§xAAny combination of N scalars/arrays with the meaning of 2. and 3.€Ù¹‚ƒÙ§cIf Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§xK is given, the number of varargs must equal the number of axes. Default: 1.€Ù°ƒjedge_orderx){1, 2}, optional  (Not supported in Dask)‚Ù¹‚Ù§x[Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.9.1 €Ù°ƒdaxisx?None or int or tuple of ints, optional  (Not supported in Dask)‚Ù¹‚Ù§xãGradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.11.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒhgradientxndarray or list of ndarrayÙ¹‚Ù§x¶A list of ndarrays (or a single ndarray if there is only one dimension) corresponding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.€ögSummaryÙ¯‚Ù¹‚Ù§x.Return the gradient of an N-dimensional array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshExampleseNotesjReferencesw/dask/array/routines.pydr<class 'function'>sdask.array.gradientÙ¯‚Ù´ƒ˜+Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmib11Ù±‚`a,Ù±‚`a Ù±‚bmib16Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx%array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])hcompiledÙ¹‚Ù§x‘Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:€Ù´ƒ˜Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚aoa.Ù±‚`dsizeÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])hcompiledÙ¹‚Ù§uOr a non uniform one:€Ù´ƒ˜.Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmfc3.5Ù±‚`a,Ù±‚`a Ù±‚bmfb4.Ù±‚`a,Ù±‚`a Ù±‚bmfb6.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])hcompiledÙ¹‚Ù§x³For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:€Ù´ƒ˜'Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxd[array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
       [1. , 1. , 1. ]])]hcompiledÙ¹‚Ù§x\In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1€Ù´ƒ˜EÙ±‚`bdxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfb2.Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmfc3.5Ù±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`bdxÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxj[array([[ 1. ,  1. , -0.5],
       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
       [2. , 1.7, 0.5]])]hcompiledÙ¹‚‚Ù§x;It is possible to specify how boundaries are treated using Ù¢„jedge_orderÙ „ööelocaljedge_orderelocalõ€Ù´ƒ˜3Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`axÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`jedge_orderÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([1.,  2.,  4.,  6.,  7.])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`jedge_orderÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([0., 2., 4., 6., 8.])hcompiledÙ¹‚ƒÙ§dThe Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§xT keyword can be used to specify a subset of axes of which the gradient is calculated€Ù´ƒ˜,Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „ddaski2021.10.0fmodulexdask.array.routines.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])hcompiledö€i2021.10.0Ù«xgradient(f, *varargs, **kwargs)öxdask.array.routines.gradient€
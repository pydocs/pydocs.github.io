Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x.This docstring was copied from numpy.meshgrid.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§x™Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,..., xn.€ÙÆƒnversionchangedc1.9Ù¹‚Ù§x#1 - D and 0 - D cases are allowed. €ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§yThis function supports both indexing conventions through the indexing keyword argument.  Giving the string 'ij' returns a meshgrid with matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for 'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is illustrated by the following code snippet::      €ÙÀxîxv, yv = np.meshgrid(x, y, indexing='ij')
for i in range(nx):
    for j in range(ny):
        # treat xv[i,j], yv[i,j]

xv, yv = np.meshgrid(x, y, indexing='xy')
for i in range(nx):
    for j in range(ny):
        # treat xv[j,i], yv[j,i]Ù¹‚Ù§xIIn the 1-D and 0-D case, the indexing and sparse keywords have no effect.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒnx1, x2,..., xnjarray_likeÙ¹‚Ù§x21-D arrays representing the coordinates of a grid.€Ù°ƒhindexingx/{'xy', 'ij'}, optional  (Not supported in Dask)‚Ù¹‚Ù§xZCartesian ('xy', default) or matrix ('ij') indexing of output. See Notes for more details.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒfsparsex'bool, optional  (Not supported in Dask)ƒÙ¹‚‰Ù§xAIf True the shape of the returned coordinate array for dimension Ù¨Ù§aiÙ§q is reduced from Ù¡u(N1, ..., Ni, ... Nn)Ù§d to Ù¡x(1, ..., 1, Ni, 1, ..., 1)Ù§x=.  These sparse coordinate grids are intended to be use with Ù£ƒsbasics.broadcastingöcrefÙ§xo.  When all coordinates are used in an expression, broadcasting still leads to a fully-dimensonal result array.€Ù¹‚Ù§qDefault is False.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒdcopyx'bool, optional  (Not supported in Dask)‚Ù¹‚ƒÙ§xxIf False, a view into the original arrays are returned in order to conserve memory.  Default is True.  Please note that Ù¡xsparse=False, copy=FalseÙ§xÂ will likely return non-contiguous arrays.  Furthermore, more than one element of a broadcast array may refer to a single memory location.  If you need to write to the arrays, make copies first.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒnX1, X2,..., XNgndarrayÙ¹‚‘Ù§lFor vectors Ù¢„bx1Ù „ööelocalbx1elocalõÙ§b, Ù¢„bx2Ù „ööelocalbx2elocalõÙ§x,..., 'xn' with lengths Ù¡jNi=len(xi)Ù§j , return Ù¡r(N1, N2, N3,...Nn)Ù§x# shaped arrays if indexing='ij' or Ù¡r(N2, N1, N3,...Nn)Ù§x5 shaped arrays if indexing='xy' with the elements of Ù£ƒbxiööÙ§x; repeated to fill the matrix along the first dimension for Ù¢„bx1Ù „ööelocalbx1elocalõÙ§q, the second for Ù¢„bx2Ù „ööelocalbx2elocalõÙ§k and so on.€ögSummaryÙ¯‚Ù¹‚Ù§x3Return coordinate matrices from coordinate vectors.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshSee AlsohExamplesw/dask/array/creation.py¡r<class 'function'>sdask.array.meshgridÙ¯‚‰Ù´ƒ˜LÙ±‚`bnxÙ±‚`a,Ù±‚`a Ù±‚`bnyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „ddaski2021.10.0fmodulexdask.array.creation.linspacefmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`bnxÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „ddaski2021.10.0fmodulexdask.array.creation.linspacefmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`bnyÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bxvÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„byvÙ „ddaski2021.10.0fmodulexdask.sizeof.sizeof_memoryviewfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „ddaski2021.10.0fmodulexdask.array.creation.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bxvÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])hcompiledÙ´ƒƒÙ±‚`Ù¢„byvÙ „ddaski2021.10.0fmodulexdask.sizeof.sizeof_memoryviewfmoduleõÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx.array([[0.,  0.,  0.],
       [1.,  1.,  1.]])hcompiledÙ´ƒ˜Ù±‚`bxvÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„byvÙ „ddaski2021.10.0fmodulexdask.sizeof.sizeof_memoryviewfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „ddaski2021.10.0fmodulexdask.array.creation.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`fsparseÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1x-# make sparse output arrays  # doctest: +SKIPÙ±‚`a
Ù±‚`bxvÙ±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([[0. ,  0.5,  1. ]])hcompiledÙ´ƒƒÙ±‚`Ù¢„byvÙ „ddaski2021.10.0fmodulexdask.sizeof.sizeof_memoryviewfmoduleõÙ±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([[0.],
       [1.]])hcompiledÙ¹‚„Ù¢„hmeshgridÙ „ddaski2021.10.0fmodulexdask.array.creation.meshgridfmoduleõÙ§xx is very useful to evaluate functions on a grid.  If the function depends on all coordinates, you can use the parameter Ù¡ksparse=TrueÙ§x% to save memory and computation time.€Ù´ƒ˜cÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „ddaski2021.10.0fmodulexdask.array.creation.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmic101Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „ddaski2021.10.0fmodulexdask.array.creation.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmic101Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚bc1x# full coorindate arraysÙ±‚`a
Ù±‚`bxxÙ±‚`a,Ù±‚`a Ù±‚`byyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „ddaski2021.10.0fmodulexdask.array.creation.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bzzÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „ddaski2021.10.0fmoduleudask.array.ufunc.sqrtfmoduleõÙ±‚`a(Ù±‚`bxxÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`byyÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bxxÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`byyÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bzzÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx$((101, 101), (101, 101), (101, 101))hcompiledÙ´ƒ˜@Ù±‚bc1x# sparse coordinate arraysÙ±‚`a
Ù±‚`bxsÙ±‚`a,Ù±‚`a Ù±‚`bysÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „ddaski2021.10.0fmodulexdask.array.creation.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`fsparseÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bzsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „ddaski2021.10.0fmoduleudask.array.ufunc.sqrtfmoduleõÙ±‚`a(Ù±‚`bxsÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`bysÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bxsÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bysÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx ((1, 101), (101, 1), (101, 101))hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`karray_equalÙ±‚`a(Ù±‚`bzzÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPdTruehcompiledÙ´ƒ˜9Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnfpyplotÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnncpltÙ±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ahÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cpltÙ±‚aoa.Ù±‚`hcontourfÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`cpltÙ±‚aoa.Ù±‚`daxisÙ±‚`a(Ù±‚bs1a'Ù±‚bs1fscaledÙ±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`cpltÙ±‚aoa.Ù±‚`hcolorbarÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`cpltÙ±‚aoa.Ù±‚`dshowÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledö‚Ù¼ƒÙ»ƒemgridööÙ¹‚Ù§xAConstruct a multi-dimensional "meshgrid" using indexing notation.€öÙ¼ƒÙ»ƒeogridööÙ¹‚Ù§xGConstruct an open multi-dimensional "meshgrid" using indexing notation.€öi2021.10.0Ù«wmeshgrid(*xi, **kwargs)öxdask.array.creation.meshgrid€
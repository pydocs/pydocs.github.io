Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‰Ù¹‚Ù§x.This docstring was copied from numpy.diagonal.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚‘Ù§cIf Ù¢„aaÙ „ööelocalaaelocalõÙ§x! is 2-D, returns the diagonal of Ù¢„aaÙ „ööelocalaaelocalõÙ§xE with the given offset, i.e., the collection of elements of the form Ù¡na[i, i+offset]Ù§f.  If Ù¢„aaÙ „ööelocalaaelocalõÙ§x: has more than two dimensions, then the axes specified by Ù¢„eaxis1Ù „ööelocaleaxis1elocalõÙ§e and Ù¢„eaxis2Ù „ööelocaleaxis2elocalõÙ§x… are used to determine the 2-D sub-array whose diagonal is returned.  The shape of the resulting array can be determined by removing Ù¢„eaxis1Ù „ööelocaleaxis1elocalõÙ§e and Ù¢„eaxis2Ù „ööelocaleaxis2elocalõÙ§xR and appending an index to the right equal to the size of the resulting diagonals.€Ù¹‚Ù§xŠIn versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.€Ù¹‚Ù§xÍIn NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.€Ù¹‚Ù§xŠStarting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.€Ù¹‚Ù§xºIn some future release, it will return a read/write view and writing to the returned array will alter your original array.  The returned array will have the same type as the input array.€Ù¹‚Ù§xeIf you don't write to the array returned by this function, then you can just ignore all of the above.€Ù¹‚…Ù§xhIf you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use Ù¡unp.diagonal(a).copy()Ù§q instead of just Ù¡nnp.diagonal(a)Ù§x=. This will work with both past and future versions of NumPy.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚Ù§x)Array from which the diagonals are taken.€Ù°ƒfoffsetmint, optionalÙ¹‚Ù§xlOffset of the diagonal from the main diagonal.  Can be positive or negative.  Defaults to main diagonal (0).€Ù°ƒeaxis1mint, optionalÙ¹‚Ù§x~Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken.  Defaults to first axis (0).€Ù°ƒeaxis2mint, optionalÙ¹‚Ù§xAxis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).€öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚ƒÙ§tIf the dimension of Ù¢„aaÙ „ööelocalaaelocalõÙ§p is less than 2.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒrarray_of_diagonalsgndarray‚Ù¹‚‹Ù§cIf Ù¢„aaÙ „ööelocalaaelocalõÙ§xJ is 2-D, then a 1-D array containing the diagonal and of the same type as Ù¢„aaÙ „ööelocalaaelocalõÙ§t is returned unless Ù¢„aaÙ „ööelocalaaelocalõÙ§f is a Ù£ƒfmatrixööÙ§x0, in which case a 1-D array rather than a (2-D) Ù£ƒfmatrixööÙ§x9 is returned in order to maintain backward compatibility.€Ù¹‚‡Ù§cIf Ù¡ja.ndim > 2Ù§x#, then the dimensions specified by Ù¢„eaxis1Ù „ööelocaleaxis1elocalõÙ§e and Ù¢„eaxis2Ù „ööelocaleaxis2elocalõÙ§xO are removed, and a new axis inserted at the end corresponding to the diagonal.€ögSummaryÙ¯‚Ù¹‚Ù§xReturn specified diagonals.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsohExamplesw/dask/array/creation.pyhr<class 'function'>sdask.array.diagonalÙ¯‚Ù´ƒ—Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „ddaski2021.10.0fmodulexdask.array.creation.arangefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([[0, 1],
       [2, 3]])hcompiledÙ´ƒ‡Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„hdiagonalÙ „ddaski2021.10.0fmodulexdask.array.creation.diagonalfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPmarray([0, 3])hcompiledÙ´ƒˆÙ±‚`aaÙ±‚aoa.Ù±‚`Ù¢„hdiagonalÙ „ddaski2021.10.0fmodulexdask.array.creation.diagonalfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPjarray([1])hcompiledÙ¹‚Ù§nA 3-D example:€Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „ddaski2021.10.0fmodulexdask.array.creation.arangefmoduleõÙ±‚`a(Ù±‚bmia8Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`aaÙ±‚`b  Ù±‚bc1p# doctest: +SKIPxBarray([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])hcompiledÙ´ƒ”Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„hdiagonalÙ „ddaski2021.10.0fmodulexdask.array.creation.diagonalfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`b  Ù±‚bc1xD# Main diagonals of two arrays created by skipping  # doctest: +SKIPÙ±‚`a
Ù±‚`k           Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`b  Ù±‚bc1x+# across the outer(left)-most axis last andÙ±‚`a
Ù±‚`k           Ù±‚bmia1Ù±‚`a)Ù±‚`b  Ù±‚bc1x # the "middle" (row) axis first.xarray([[0, 6],
       [1, 7]])hcompiledÙ¹‚Ù§x¥The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are "packed" in rows.€Ù´ƒŠÙ±‚`aaÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a:Ù±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`b  Ù±‚bc1x*# main diagonal is [0 6]  # doctest: +SKIPxarray([[0, 2],
       [4, 6]])hcompiledÙ´ƒŠÙ±‚`aaÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a:Ù±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`b  Ù±‚bc1x*# main diagonal is [1 7]  # doctest: +SKIPxarray([[1, 3],
       [5, 7]])hcompiledÙ¹‚…Ù§xRThe anti-diagonal can be obtained by reversing the order of elements using either Ù¢„lnumpy.flipudÙ „enumpya*capilnumpy.flipudfmoduleõÙ§d or Ù¢„lnumpy.fliplrÙ „enumpya*capilnumpy.fliplrfmoduleõÙ§a.€Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „ddaski2021.10.0fmodulexdask.array.creation.arangefmoduleõÙ±‚`a(Ù±‚bmia9Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx6array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])hcompiledÙ´ƒŒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ffliplrÙ „ddaski2021.10.0fmodulexdask.array.routines.fliplrfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚aoa.Ù±‚`Ù¢„hdiagonalÙ „ddaski2021.10.0fmodulexdask.array.creation.diagonalfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1x## Horizontal flip  # doctest: +SKIPparray([2, 4, 6])hcompiledÙ´ƒŒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fflipudÙ „ddaski2021.10.0fmodulexdask.array.routines.flipudfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚aoa.Ù±‚`Ù¢„hdiagonalÙ „ddaski2021.10.0fmodulexdask.array.creation.diagonalfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1x!# Vertical flip  # doctest: +SKIPparray([6, 4, 2])hcompiledÙ¹‚Ù§x]Note that the order in which the diagonal is retrieved varies depending on the flip function.€öƒÙ¼ƒÙ»ƒddiagxdask.array.creation.diagõÙ¹‚Ù§x*MATLAB work-a-like for 1-D and 2-D arrays.€öÙ¼ƒÙ»ƒhdiagflatööÙ¹‚Ù§wCreate diagonal arrays.€öÙ¼ƒÙ»ƒetraceööÙ¹‚Ù§tSum along diagonals.€öi2021.10.0Ù«x'diagonal(a, offset=0, axis1=0, axis2=1)öxdask.array.creation.diagonal€
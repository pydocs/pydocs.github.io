Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒaapdask.array.ArrayÙ¹‚Ù§xGInput data; the histogram is computed over the flattened array. If the Ù¡gweightsÙ§x! argument is used, the chunks of Ù¡aaÙ§x6 are accessed to check chunking compatibility between Ù¡aaÙ§e and Ù¡gweightsÙ§e. If Ù¡gweightsÙ§d is Ù¡dNoneÙ§d, a Ù¢„udask.dataframe.SeriesÙ „ddaska*capixdask.dataframe.core.SeriesfmoduleõÙ§x$ object can be passed as input data.€Ù°ƒdbinsx$int or sequence of scalars, optionalÙ¹‚Ù§x"Either an iterable specifying the Ù¡dbinsÙ§r or the number of Ù¡dbinsÙ§g and a Ù¡erangeÙ§x# argument is required as computing Ù¡cminÙ§e and Ù¡cmaxÙ§xU over blocked arrays is an expensive operation that must be performed explicitly. If Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§x^ is an int, it defines the number of equal-width bins in the given range (10, by default). If Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§xŒ is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.€Ù°ƒerangex(float, float), optionalÙ¹‚‡Ù§xIThe lower and upper range of the bins.  If not provided, range is simply Ù¡r(a.min(), a.max())Ù§xr.  Values outside the range are ignored. The first element of the range must be less than or equal to the second. Ù¢„erangeÙ „ööelocalerangeelocalõÙ§xz affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within Ù¢„erangeÙ „ööelocalerangeelocalõÙ§xQ, the bin count will fill the entire range including portions containing no data.€Ù°ƒfnormednbool, optionalÙ¹‚ƒÙ§xThis is equivalent to the Ù¡gdensityÙ§xX argument, but produces incorrect results for unequal bin widths. It should not be used.€Ù°ƒgweightsxdask.array.Array, optionalÙ¹‚‡Ù§x>A dask.array.Array of weights, of the same block structure as Ù¡aaÙ§q.  Each value in Ù¡aaÙ§xQ only contributes its associated weight towards the bin count (instead of 1). If Ù¡gdensityÙ§xc is True, the weights are normalized, so that the integral of the density over the range remains 1.€Ù°ƒgdensitynbool, optionalÙ¹‚‘Ù§cIf Ù¡eFalseÙ§x@, the result will contain the number of samples in each bin. If Ù¡dTrueÙ§x-, the result is the value of the probability Ù¨Ù§gdensityÙ§x/ function at the bin, normalized such that the Ù¨Ù§hintegralÙ§x– over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability Ù¨Ù§dmassÙ§x function. Overrides the Ù¡fnormedÙ§v keyword if given. If Ù¡gdensityÙ§j is True, Ù¡dbinsÙ§x€ cannot be a single-number delayed value. It must be a concrete number, or a (possibly-delayed) array/sequence of the bin edges.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒdhistjdask ArrayÙ¹‚…Ù§x!The values of the histogram. See Ù¢„gdensityÙ „ööelocalgdensityelocalõÙ§e and Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§x- for a description of the possible semantics.€Ù°ƒibin_edgesxdask Array of dtype floatÙ¹‚ƒÙ§uReturn the bin edges Ù¡p(length(hist)+1)Ù§a.€ögSummaryÙ¯‚Ù¹‚ƒÙ§sBlocked variant of Ù¢„onumpy.histogramÙ „enumpya*capionumpy.histogramfmoduleõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummaryjParametersgReturnshExamplesw/dask/array/routines.py8r<class 'function'>tdask.array.histogramÙ¯‚†Ù¹‚Ù§xUsing number of bins and range:€Ù´ƒ˜EÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbdaÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbnpÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmie10000Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„ihistogramÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚aoa=Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bnberangeÙ±‚aoa=Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmie10000Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`dbinsxfarray([    0.,  1000.,  2000.,  3000.,  4000.,  5000.,  6000.,  7000.,
        8000.,  9000., 10000.])hcompiledÙ´ƒ…Ù±‚`ahÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xCarray([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])hcompiledÙ¹‚Ù§xExplicitly specifying the bins:€Ù´ƒ˜!Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„ihistogramÙ „ddaski2021.10.0fmodulexdask.array.routines.histogramfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmid5000Ù±‚`a,Ù±‚`a Ù±‚bmie10000Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`dbinsxarray([    0,  5000, 10000])hcompiledÙ´ƒ…Ù±‚`ahÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)sarray([5000, 5000])hcompiledö€i2021.10.0Ù«xMhistogram(a, bins=None, range=None, normed=False, weights=None, density=None)öxdask.array.routines.histogram€
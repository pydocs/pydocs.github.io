Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‡Ù§rInput must have a Ù¡f.shapeÙ§b, Ù¡e.ndimÙ§b, Ù¡f.dtypeÙ§x! and support numpy-style slicing.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaxjarray_like€Ù°ƒfchunksjint, tupleƒÙ¹‚Ù§x;How to chunk the array. Must be one of the following forms:€ÙÈ…Ù¹‚Ù§vA blocksize like 1000.€Ù¹‚Ù§xA blockshape like (1000, 1000).€Ù¹‚Ù§xYExplicit sizes of all blocks along all dimensions like   ((1000, 1000, 500), (400, 400)).€Ù¹‚Ù§xNA size in bytes, like "100 MiB" which will choose a uniform   block-like shape€Ù¹‚ƒÙ§xLThe word "auto" which acts like the above, but uses a configuration   value Ù¡parray.chunk-sizeÙ§s for the chunk size€Ù¹‚Ù§xK-1 or None as a blocksize indicate the size of the corresponding dimension.€Ù°ƒdnameustr or bool, optional…Ù¹‚ƒÙ§x9The key name to use for the array. Defaults to a hash of Ù¡axÙ§a.€Ù¹‚‡Ù§x'Hashing is useful if the same value of Ù¡axÙ§xû is used to create multiple arrays, as Dask can then recognise that they're the same and avoid duplicate computations. However, it can also be slow, and if the array is not contiguous it is copied for hashing. If the array uses stride tricks (such as Ù¢„rnumpy.broadcast_toÙ „enumpya*capirnumpy.broadcast_tofmoduleõÙ§d or Ù¢„xskimage.util.view_as_windowsÙ „gskimagea*capix"skimage.util.shape.view_as_windowsfmoduleõÙ§xZ) to have a larger logical than physical size, this copy can cause excessive memory usage.€Ù¹‚…Ù§x=If you don't need the deduplication provided by hashing, use Ù¡jname=FalseÙ§x` to generate a random name instead of hashing, which avoids the pitfalls described above. Using Ù¡iname=TrueÙ§x is equivalent to the default.€Ù¹‚Ù§xËBy default, hashing uses python's standard sha1. This behaviour can be changed by installing cityhash, xxhash or murmurhash. If installed, a large-factor speedup can be obtained in the tokenisation step.€ÙÆƒdnote`Ù¹‚Ù§y<Because this ``name`` is used as the key in task graphs, you should ensure that it uniquely identifies the data contained within. If you ' d like to provide a descriptive name that is still unique, combine the descriptive name with : func : `dask.base.tokenize` of the ``array_like``. See : ref : `graphs` for more. €Ù°ƒdlockvbool or Lock, optionalÙ¹‚ƒÙ§cIf Ù¡axÙ§xr doesn't support concurrent reads then provide a lock here, or pass in True to have dask.array create one for you.€Ù°ƒgasarraynbool, optionalÙ¹‚ƒÙ§x¥If True then call np.asarray on chunks to convert them to numpy arrays. If False then chunks are passed through unchanged. If None (default) then we use True if the Ù¡r__array_function__Ù§u method is undefined.€Ù°ƒefancynbool, optionalÙ¹‚ƒÙ§cIf Ù¡axÙ§xh doesn't support fancy indexing (e.g. indexing with lists or arrays) then set to False. Default is True.€Ù°ƒdmetatArray-like, optionalÙ¹‚Ù§x‘The metadata for the resulting dask array.  This is the kind of array that will result from slicing the input array. Defaults to the input array.€Ù°ƒlinline_arraysbool, default False‡Ù¹‚ƒÙ§x8How to include the array in the task graph. By default (Ù¡rinline_array=FalseÙ§x[) the array is included in a task by itself, and each chunk refers to that task by its key.€Ù¿ƒjcode-blockfpythonÙ¹‚Ù§yu>>> x = h5py.File ( " data.h5 " ) [ " / x " ] # doctest : +SKIP >>> a = da.from_array ( x, chunks=500) # doctest : +SKIP >>> dict ( a.dask) # doctest : +SKIP { ' array - original - < name> ' : < HDF5 dataset ...>, ( ' array - < name> ' , 0) : ( getitem, " array - original - < name> " , ...), ( ' array - < name> ' , 1) : ( getitem, " array - original - < name> " , ...) } €Ù¹‚ƒÙ§eWith Ù¡qinline_array=TrueÙ§xN, Dask will instead inline the array directly in the values of the task graph.€Ù¿ƒjcode-blockfpythonÙ¹‚Ù§xú>>> a = da.from_array ( x, chunks=500, inline_array=True) # doctest : +SKIP >>> dict ( a.dask) # doctest : +SKIP { ( ' array - < name> ' , 0) : ( getitem, < HDF5 dataset ...>, ...), ( ' array - < name> ' , 1) : ( getitem, < HDF5 dataset ...>, ...) } €Ù¹‚ƒÙ§x?Note that there's no key in the task graph with just the array Ù¢„axÙ „ööelocalaxelocalõÙ§x5 anymore. Instead it's placed directly in the values.€Ù¹‚‹Ù§uThe right choice for Ù¡linline_arrayÙ§x3 depends on several factors, including the size of Ù¡axÙ§x{, how expensive it is to create, which scheduler you're using, and the pattern of downstream computations. As a heuristic, Ù¡qinline_array=TrueÙ§x( may be the right choice when the array Ù¡axÙ§x… is cheap to serialize and deserialize (since it's included in the graph many times) and if you're experiencing ordering issues (see Ù£ƒeorderöcrefÙ§k for more).€Ù¹‚ƒÙ§xThis has no effect when Ù¡axÙ§r is a NumPy array.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x:Create dask array from something that looks like an array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExampless/dask/array/core.pyÑr<class 'function'>udask.array.from_arrayÙ¯‚‹Ù´ƒ˜*Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`dh5pyÙ±‚aoa.Ù±‚`dFileÙ±‚`a(Ù±‚bs1a'Ù±‚bs1c...Ù±‚bs1a'Ù±‚`a)Ù±‚`a[Ù±‚bs1a'Ù±‚bs1j/data/pathÙ±‚bs1a'Ù±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmid1000Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚…Ù§xPIf your underlying datastore does not support concurrent reads then include the Ù¡ilock=TrueÙ§u keyword argument or Ù¡klock=mylockÙ§x@ if you want multiple arrays to coordinate around the same lock.€Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmid1000Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dlockÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚ƒÙ§x#If your underlying datastore has a Ù¡g.chunksÙ§x attribute (as h5py and zarr datasets do) then a multiple of that chunk shape will be used if you do not provide a chunk shape.€Ù´ƒ˜4Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„dautoÙ „ddaski2021.10.0fmodulexdask.array.core.auto_chunksfmoduleõÙ±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1g100 MiBÙ±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚Ù§x-If providing a name, ensure that it is unique€Ù´ƒ˜'Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„dbaseÙ „ddaski2021.10.0fmoduleidask.basefmoduleõÙ±‚`a
Ù±‚`etokenÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dbaseÙ „ddaski2021.10.0fmoduleidask.basefmoduleõÙ±‚aoa.Ù±‚`Ù¢„htokenizeÙ „ddaski2021.10.0fmodulerdask.base.tokenizefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1hmyarray-Ù±‚bs1a'Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`etokenÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚Ù§xANumPy ndarrays are eagerly sliced and then embedded in the graph.€Ù´ƒ˜AÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚`a[Ù±‚`aaÙ±‚aoa.Ù±‚`dnameÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]jarray([1])hcompiledÙ¹‚Ù§x>Chunks with exactly-specified, different sizes can be created.€Ù´ƒ˜@Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbnpÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbdaÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „ddaski2021.10.0fmoduleqdask.array.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmic100Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚`a(Ù±‚bmib67Ù±‚`a,Ù±‚`a Ù±‚bmib33Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a)`hcompiledö€i2021.10.0Ù«xzfrom_array(x, chunks='auto', name=None, lock=False, asarray=None, fancy=True, getitem=None, meta=None, inline_array=False)öxdask.array.core.from_array€
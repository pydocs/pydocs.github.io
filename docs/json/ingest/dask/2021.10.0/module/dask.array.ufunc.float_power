Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§xFFirst array elements raised to powers from second array, element-wise.€Ù¹‚‰Ù§sRaise each base in Ù¢„bx1Ù „ööelocalbx1elocalõÙ§x, to the positionally-corresponding power in Ù¢„bx2Ù „ööelocalbx2elocalõÙ§b. Ù¢„bx1Ù „ööelocalbx1elocalõÙ§e and Ù¢„bx2Ù „ööelocalbx2elocalõÙ§yQ must be broadcastable to the same shape. This differs from the power function in that integers, float16, and float32  are promoted to floats with a minimum precision of float64 so that the result is always inexact.  The intent is that the function will return a usable result for negative powers and seldom overflow for positive powers.€Ù¹‚‡Ù§x;Negative values raised to a non-integral value will return Ù¡cnanÙ§xD. To get complex results, cast the input to complex, or specify the Ù¡edtypeÙ§g to be Ù¡gcomplexÙ§x (see the example below).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.12.0 €ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒbx1jarray_likeÙ¹‚Ù§jThe bases.€Ù°ƒbx2jarray_likeÙ¹‚ƒÙ§rThe exponents. If Ù¡tx1.shape != x2.shapeÙ§xW, they must be broadcastable to a common shape (which becomes the shape of the output).€Ù°ƒcoutx5ndarray, None, or tuple of ndarray and None, optionalÙ¹‚Ù§y
A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.€Ù°ƒewheretarray_like, optionalÙ¹‚‰Ù§xZThis condition is broadcast over the input. At locations where the condition is True, the Ù¢„coutÙ „ööelocalcoutelocalõÙ§x7 array will be set to the ufunc result. Elsewhere, the Ù¢„coutÙ „ööelocalcoutelocalõÙ§xE array will retain its original value. Note that if an uninitialized Ù¢„coutÙ „ööelocalcoutelocalõÙ§x" array is created via the default Ù¡hout=NoneÙ§xM, locations within it where the condition is False will remain uninitialized.€Ù°ƒh**kwargs`Ù¹‚ƒÙ§x*For other keyword-only arguments, see the Ù£ƒxufunc docs <ufuncs.kwargs>öcrefÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaygndarrayÙ¹‚‰Ù§mThe bases in Ù¢„bx1Ù „ööelocalbx1elocalõÙ§x raised to the exponents in Ù¢„bx2Ù „ööelocalbx2elocalõÙ§x. This is a scalar if both Ù¢„bx1Ù „ööelocalbx1elocalõÙ§e and Ù¢„bx2Ù „ööelocalbx2elocalõÙ§m are scalars.€ögSummaryÙ¯‚Ù¹‚Ù§x1This docstring was copied from numpy.float_power.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡iSignaturegSummarypExtended SummaryjParametersgReturnshSee AlsohExamplest/dask/array/ufunc.pyöx <class 'dask.array.ufunc.ufunc'>vdask.array.float_powerÙ¯‚Ù¹‚Ù§xCube each element in a list.€Ù´ƒÙ±‚`bx1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bx1Ù±‚`b  Ù±‚bc1p# doctest: +SKIPr[0, 1, 2, 3, 4, 5]hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kfloat_powerÙ „ddaski2021.10.0fmodulexdask.array.ufunc.float_powerfmoduleõÙ±‚`a(Ù±‚`bx1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx1array([   0.,    1.,    8.,   27.,   64.,  125.])hcompiledÙ¹‚Ù§x'Raise the bases to different exponents.€Ù´ƒ˜$Ù±‚`bx2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc2.0Ù±‚`a,Ù±‚`a Ù±‚bmfc3.0Ù±‚`a,Ù±‚`a Ù±‚bmfc3.0Ù±‚`a,Ù±‚`a Ù±‚bmfc2.0Ù±‚`a,Ù±‚`a Ù±‚bmfc1.0Ù±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kfloat_powerÙ „ddaski2021.10.0fmodulexdask.array.ufunc.float_powerfmoduleõÙ±‚`a(Ù±‚`bx1Ù±‚`a,Ù±‚`a Ù±‚`bx2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx+array([  0.,   1.,   8.,  27.,  16.,   5.])hcompiledÙ¹‚Ù§xThe effect of broadcasting.€Ù´ƒ˜7Ù±‚`bx2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bx2Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx6array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kfloat_powerÙ „ddaski2021.10.0fmodulexdask.array.ufunc.float_powerfmoduleõÙ±‚`a(Ù±‚`bx1Ù±‚`a,Ù±‚`a Ù±‚`bx2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxZarray([[  0.,   1.,   8.,  27.,  16.,   5.],
       [  0.,   1.,   8.,  27.,  16.,   5.]])hcompiledÙ¹‚ƒÙ§x>Negative values raised to a non-integral value will result in Ù¡cnanÙ§x# (and a warning will be generated).€Ù´ƒ˜2Ù±‚`bx3Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚akdwithÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`herrstateÙ±‚`a(Ù±‚`ginvalidÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„fignoreÙ „ddaski2021.10.0fmodulexdask.utils.ignore_warningfmoduleõÙ±‚bs1a'Ù±‚`a)Ù±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚`apÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kfloat_powerÙ „ddaski2021.10.0fmodulexdask.array.ufunc.float_powerfmoduleõÙ±‚`a(Ù±‚`bx3Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a)c...hcompiledÙ´ƒƒÙ±‚`apÙ±‚`b  Ù±‚bc1p# doctest: +SKIPqarray([nan, nan])hcompiledÙ¹‚ƒÙ§x*To get complex results, give the argument Ù¡mdtype=complexÙ§a.€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kfloat_powerÙ „ddaski2021.10.0fmodulexdask.array.ufunc.float_powerfmoduleõÙ±‚`a(Ù±‚`bx3Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbgcomplexÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx1array([-1.83697020e-16-1.j, -1.46957616e-15-8.j])hcompiledöÙ¼ƒÙ»ƒepowervdask.array.ufunc.powerõÙ¹‚Ù§x"power function that preserves type€öi2021.10.0Ù«x|float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])öxdask.array.ufunc.float_power€
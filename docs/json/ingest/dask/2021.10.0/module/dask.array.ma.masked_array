Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§x5This docstring was copied from numpy.ma.masked_array.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§xMMasked values of True exclude the corresponding element from any computation.€Ù¹‚Ù§rConstruction::    €ÙÀx¹x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                shrink=True, order=None)ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒddatajarray_likeÙ¹‚Ù§kInput data.€Ù°ƒdmaskrsequence, optionalÙ¹‚ƒÙ§xIMask. Must be convertible to an array of booleans with the same shape as Ù¢„ddataÙ „ööelocalddataelocalõÙ§x.. True indicates a masked (i.e. invalid) data.€Ù°ƒedtypex(dtype, optional  (Not supported in Dask)Ù¹‚‰Ù§xData type of the output. If Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§x) is None, the type of the data argument (Ù¡jdata.dtypeÙ§n) is used. If Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§x  is not None and different from Ù¡jdata.dtypeÙ§v, a copy is performed.€Ù°ƒdcopyx'bool, optional  (Not supported in Dask)Ù¹‚Ù§xWWhether to copy the input data (True), or to use a reference instead. Default is False.€Ù°ƒesubokx'bool, optional  (Not supported in Dask)Ù¹‚…Ù§x Whether to return a subclass of Ù£ƒkMaskedArrayööÙ§x if possible (True) or a plain Ù£ƒkMaskedArrayööÙ§r. Default is True.€Ù°ƒendminx&int, optional  (Not supported in Dask)Ù¹‚Ù§x+Minimum number of dimensions. Default is 0.€Ù°ƒjfill_valuepscalar, optionalÙ¹‚Ù§xjValue used to fill in the masked values when necessary. If None, a default based on the data-type is used.€Ù°ƒikeep_maskx'bool, optional  (Not supported in Dask)Ù¹‚…Ù§sWhether to combine Ù¢„dmaskÙ „ööelocaldmaskelocalõÙ§x@ with the mask of the input data, if any (True), or to use only Ù¢„dmaskÙ „ööelocaldmaskelocalõÙ§x) for the output (False). Default is True.€Ù°ƒihard_maskx'bool, optional  (Not supported in Dask)Ù¹‚Ù§xhWhether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.€Ù°ƒfshrinkx'bool, optional  (Not supported in Dask)Ù¹‚Ù§x?Whether to force compression of an empty mask. Default is True.€Ù°ƒeorderx2{'C', 'F', 'A'}, optional  (Not supported in Dask)Ù¹‚Ù§y¯Specify the order of the array.  If order is 'C', then the array will be in C-contiguous order (last-index varies the fastest). If order is 'F', then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is 'A' (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x+An array class with possibly masked values.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExamplesq/dask/array/ma.pyzr<class 'function'>xdask.array.ma.masked_arrayÙ¯‚‡Ù¹‚…Ù§dThe Ù¡dmaskÙ§xK can be initialized with an array of boolean values with the same shape as Ù¡ddataÙ§a.€Ù´ƒ˜<Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „ddaski2021.10.0fmodulemdask.array.mafmoduleõÙ±‚aoa.Ù±‚`kMaskedArrayÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚`a[Ù±‚`a[Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a]Ù±‚`a,Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`x                              Ù±‚`a[Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkcdTrueÙ±‚`a]Ù±‚`a]Ù±‚`a)xŠmasked_array(
  data=[[0, --, 2],
        [3, 4, --]],
  mask=[[False,  True, False],
        [False, False,  True]],
  fill_value=999999)hcompiledÙ¹‚…Ù§sAlternatively, the Ù¡dmaskÙ§xH can be initialized to homogeneous boolean array with the same shape as Ù¡ddataÙ§x& by passing in a scalar boolean value:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „ddaski2021.10.0fmodulemdask.array.mafmoduleõÙ±‚aoa.Ù±‚`kMaskedArrayÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxˆmasked_array(
  data=[[0, 1, 2],
        [3, 4, 5]],
  mask=[[False, False, False],
        [False, False, False]],
  fill_value=999999)hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „ddaski2021.10.0fmodulemdask.array.mafmoduleõÙ±‚aoa.Ù±‚`kMaskedArrayÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxmasked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=999999,
  dtype=int64)hcompiledÙÆƒdnote`Ù¹‚Ù§xäThe recommended practice for initializing ``mask`` with a scalar boolean value is to use ``True`` / ``False`` rather than ``np.True_`` / ``np.False_``. The reason is : attr : `nomask` is represented internally as ``np.False_``. €Ù·‚x/>>> np.False_ is np.ma.nomask  # doctest: +SKIPdTrueö€i2021.10.0Ù«x9masked_array(data, mask=False, fill_value=None, **kwargs)öxdask.array.ma.masked_array€
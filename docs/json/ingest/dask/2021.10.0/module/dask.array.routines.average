Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x-This docstring was copied from numpy.average.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚ƒÙ§x)Array containing data to be averaged. If Ù¢„aaÙ „ööelocalaaelocalõÙ§x, is not an array, a conversion is attempted.€Ù°ƒdaxisx&None or int or tuple of ints, optionalƒÙ¹‚ƒÙ§x$Axis or axes along which to average Ù¢„aaÙ „ööelocalaaelocalõÙ§x“.  The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù¹‚Ù§xIf axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.€Ù°ƒgweightstarray_like, optionalƒÙ¹‚Ù§x2An array of weights associated with the values in Ù¢„aaÙ „ööelocalaaelocalõÙ§p. Each value in Ù¢„aaÙ „ööelocalaaelocalõÙ§x’ contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of Ù¢„aaÙ „ööelocalaaelocalõÙ§x/ along the given axis) or of the same shape as Ù¢„aaÙ „ööelocalaaelocalõÙ§e. If Ù£ƒlweights=NoneööÙ§s, then all data in Ù¢„aaÙ „ööelocalaaelocalõÙ§xK are assumed to have a weight equal to one.  The 1-D calculation is::      €ÙÀx%avg = sum(a * weights) / sum(weights)Ù¹‚…Ù§wThe only constraint on Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§i is that Ù£ƒlsum(weights)ööÙ§o must not be 0.€Ù°ƒhreturnednbool, optionalÙ¹‚Ù§kDefault is Ù¡eFalseÙ§e. If Ù¡dTrueÙ§m, the tuple (Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ§b, Ù£ƒnsum_of_weightsööÙ§x:) is returned, otherwise only the average is returned. If Ù£ƒlweights=NoneööÙ§b, Ù£ƒnsum_of_weightsööÙ§xI is equivalent to the number of elements over which the average is taken.€öfRaisesÙ¯‚‚Ù°ƒ`qZeroDivisionErrorÙ¹‚ƒÙ§x*When all weights along axis are zero. See Ù¢„pnumpy.ma.averageÙ „enumpya*capiwnumpy.ma.extras.averagefmoduleõÙ§x, for a version robust to this type of error.€Ù°ƒ`iTypeErrorÙ¹‚…Ù§vWhen the length of 1D Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§x! is not the same as the shape of Ù¢„aaÙ „ööelocalaaelocalõÙ§l along axis.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒxretval, [sum_of_weights]tarray_type or doubleÙ¹‚˜Ù§x2Return the average along the specified axis. When Ù¢„hreturnedÙ „ööelocalhreturnedelocalõÙ§d is Ù¡dTrueÙ§xi, return a tuple with the average as the first element and the sum of the weights as the second element. Ù£ƒnsum_of_weightsööÙ§x is of the same type as Ù¢„fretvalÙ „ööelocalfretvalelocalõÙ§x2. The result dtype follows a genereal pattern. If Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§x+ is None, the result dtype will be that of Ù¢„aaÙ „ööelocalaaelocalõÙ§f , or Ù¡gfloat64Ù§d if Ù¢„aaÙ „ööelocalaaelocalõÙ§x is integral. Otherwise, if Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§q is not None and Ù¢„aaÙ „ööelocalaaelocalõÙ§xo is non- integral, the result type will be the type of lowest precision capable of representing values of both Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„gweightsÙ „ööelocalgweightselocalõÙ§e. If Ù¢„aaÙ „ööelocalaaelocalõÙ§x` happens to be integral, the previous rules still applies but the result dtype will at least be Ù¡gfloat64Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§x6Compute the weighted average along the specified axis.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsohExamplesw/dask/array/routines.py	tr<class 'function'>rdask.array.averageÙ¯‚‡Ù´ƒ“Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ddataÙ±‚`b  Ù±‚bc1p# doctest: +SKIPsarray([1, 2, 3, 4])hcompiledÙ´ƒˆÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPc2.5hcompiledÙ´ƒ˜!Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib11Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`gweightsÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPc4.0hcompiledÙ´ƒ˜Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ddataÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx-array([[0, 1],
       [2, 3],
       [4, 5]])hcompiledÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`gweightsÙ±‚aoa=Ù±‚`a[Ù±‚bmfb1.Ù±‚aoa/Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚aoa/Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([0.75, 2.75, 4.75])hcompiledÙ´ƒ–Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`gweightsÙ±‚aoa=Ù±‚`a[Ù±‚bmfb1.Ù±‚aoa/Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚aoa/Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxqTraceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.hcompiledÙ´ƒ˜BÙ±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „ddaski2021.10.0fmodulexdask.array.creation.ones_likefmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`hfloat128Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`awÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „ddaski2021.10.0fmodulexdask.array.creation.ones_likefmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`icomplex64Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`cavgÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „ddaski2021.10.0fmodulexdask.array.routines.averagefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`gweightsÙ±‚aoa=Ù±‚`awÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`cavgÙ±‚aoa.Ù±‚`edtypeÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPjcomplex256hcompiledöƒÙ¼ƒÙ»ƒjma.averageudask.array.ma.averageõÙ¹‚Ù§xJaverage for masked arrays -- useful if your data contains "missing" values€öÙ¼ƒÙ»ƒdmeanöö€öÙ¼ƒÙ»ƒqnumpy.result_typeqnumpy.result_typeõÙ¹‚Ù§x\Returns the type that results from applying the numpy type promotion rules to the arguments.€öi2021.10.0Ù«x3average(a, axis=None, weights=None, returned=False)öxdask.array.routines.average€
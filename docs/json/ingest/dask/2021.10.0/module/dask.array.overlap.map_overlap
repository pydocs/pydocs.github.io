Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§xÊWe share neighboring zones between blocks of the array, map a function, and then trim away the neighboring strips. If depth is larger than any chunk along a particular axis, then the array is rechunked.€Ù¹‚…Ù§xNote that this function will attempt to automatically determine the output array type before computing it, please refer to the Ù¡dmetaÙ§u keyword argument in Ù¡jmap_blocksÙ§xO if you expect that the function will not succeed when operating on 0-d arrays.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒnfunc: function`Ù¹‚Ù§x¡The function to apply to each extended block. If multiple arrays are provided, then the function should expect to receive chunks of each array in the same order.€Ù°ƒdargskdask arrays€Ù°ƒxdepth: int, tuple, dict or list`Ù¹‚…Ù§xôThe number of elements that each block should share with its neighbors If a tuple or dict then this can be different per axis. If a list then each element of that list must be an int, tuple or dict defining depth for the corresponding array in Ù¢„dargsÙ „ööelocaldargselocalõÙ§x‡. Asymmetric depths may be specified using a dict value of (-/+) tuples. Note that asymmetric depths are currently only supported when Ù¡hboundaryÙ§x# is 'none'. The default value is 0.€Ù°ƒx"boundary: str, tuple, dict or list`Ù¹‚ƒÙ§xíHow to handle the boundaries. Values include 'reflect', 'periodic', 'nearest', 'none', or any constant value like 0 or np.nan. If a list then each element must be a str, tuple or dict defining the boundary for the corresponding array in Ù¢„dargsÙ „ööelocaldargselocalõÙ§x!. The default value is 'reflect'.€Ù°ƒjtrim: bool`Ù¹‚ƒÙ§wWhether or not to trim Ù¡edepthÙ§x~ elements from each block after calling the map function. Set this to False if your mapping function already does this for you€Ù°ƒralign_arrays: bool`Ù¹‚Ù§yˆWhether or not to align chunks along equally sized dimensions when multiple arrays are provided.  This allows for larger chunks in some arrays to be broken into smaller ones that match chunk sizes in other arrays such that they are compatible for block function mapping. If this is false, then an error will be thrown if arrays do not already have the same number of blocks in each dimension.€Ù°ƒi**kwargs:`Ù¹‚‚Ù§x!Other keyword arguments valid in Ù¡jmap_blocks€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x6Map a function over blocks of arrays with some overlap€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExamplesv/dask/array/overlap.pyØr<class 'function'>vdask.array.map_overlapÙ¯‚”Ù´ƒ‘Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbnpÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbda`hcompiledÙ´ƒ˜MÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia5Ù±‚`a)Ù±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfjderivativeÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„drollÙ „ddaski2021.10.0fmodulexdask.array.routines.rollfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)`hcompiledÙ´ƒ˜Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`jderivativeÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„hboundaryÙ „ddaski2021.10.0fmodulex"dask.array.overlap.coerce_boundaryfmoduleõÙ±‚aoa=Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)x+array([ 1,  0,  1,  1,  0,  0, -1, -1,  0])hcompiledÙ´ƒ˜DÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib16Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`adÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`adÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dsizeÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xdarray([[16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])hcompiledÙ´ƒ˜IÙ±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dsizeÙ±‚`a
Ù±‚`edepthÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a{Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a:Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a:Ù±‚`a Ù±‚bmia1Ù±‚`a}Ù±‚`a
Ù±‚`Ù¢„hboundaryÙ „ddaski2021.10.0fmodulex"dask.array.overlap.coerce_boundaryfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a{Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1Ù¢„greflectÙ „ddaski2021.10.0fmodulexdask.array.overlap.reflectfmoduleõÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1dnoneÙ±‚bs1a'Ù±‚`a}Ù±‚`a
Ù±‚`adÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„hboundaryÙ „ddaski2021.10.0fmodulex"dask.array.overlap.coerce_boundaryfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1x # doctest: +NORMALIZE_WHITESPACExparray([[12,  13,  14,  15],
       [16,  17,  18,  19],
       [20,  21,  22,  23],
       [24,  25,  26,  27]])hcompiledÙ¹‚ƒÙ§dThe Ù¡nda.map_overlapÙ§x* function can also accept multiple arrays.€Ù´ƒ˜VÙ±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`ayÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia8Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚aoa.Ù±‚`grechunkÙ±‚`a(Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚aoa.Ù±‚`grechunkÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`a Ù±‚bc1x # doctest: +NORMALIZE_WHITESPACEx3array([[ 0,  2,  4,  6],
       [ 4,  6,  8,  10]])hcompiledÙ¹‚…Ù§x§When multiple arrays are given, they do not need to have the same number of dimensions but they must broadcast together. Arrays are aligned block by block (just as in Ù¡mda.map_blocksÙ§xl) so the blocks must have a common chunk size.  This common chunking is determined automatically as long as Ù¡lalign_arraysÙ§i is True.€Ù´ƒ˜CÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`arÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`lalign_arraysÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚bnbclenÙ±‚`a(Ù±‚`arÙ±‚aoa.Ù±‚`Ù¢„jto_delayedÙ „ddaski2021.10.0fmodulex dask.array.core.Array.to_delayedfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a)a4hcompiledÙ´ƒ˜Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`lalign_arraysÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xYTraceback (most recent call last):
    ...
ValueError: Shapes do not align {'.0': {2, 4}}hcompiledÙ¹‚‡Ù§x.Note also that this function is equivalent to Ù¡jmap_blocksÙ§x by default.  A non-zero Ù¡edepthÙ§xE must be defined for any overlap to appear in the arrays provided to Ù¡dfuncÙ§a.€Ù´ƒ˜DÙ±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„donesÙ „ddaski2021.10.0fmodulexdask.array.creation.ones_likefmoduleõÙ±‚`a(Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1cintÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`jblock_argsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbddictÙ±‚`a(Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`idrop_axisÙ±‚aoa=Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jmap_blocksÙ „ddaski2021.10.0fmodulexdask.array.core.map_blocksfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`jblock_argsÙ±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)b10hcompiledÙ´ƒ’Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`jblock_argsÙ±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)b10hcompiledÙ´ƒ—Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚`Ù¢„dfuncÙ „ddaski2021.10.0fmodulex%dask.array.fft.fft_wrap.<locals>.funcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`jblock_argsÙ±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)b12hcompiledÙ¹‚‰Ù§xLFor functions that may not handle 0-d arrays, it's also possible to specify Ù¡dmetaÙ§xU with an empty array matching the type of the expected result. In the example below, Ù¡dfuncÙ§s will result in an Ù¡jIndexErrorÙ§p when computing Ù¡dmetaÙ§a:€Ù´ƒ˜RÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib16Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`adÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`adÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dmetaÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ayxYdask.array<_trim, shape=(4, 4), dtype=float64, chunksize=(2, 2), chunktype=numpy.ndarray>hcompiledÙ´ƒ…Ù±‚`ayÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)xdarray([[ 4,  6,  8, 10],
       [ 8, 10, 12, 14],
       [20, 22, 24, 26],
       [24, 26, 28, 30]])hcompiledÙ¹‚ƒÙ§x9Similarly, it's possible to specify a non-NumPy array to Ù¡dmetaÙ§a:€Ù´ƒ˜`Ù±‚bknfimportÙ±‚`a Ù±‚bnndcupyÙ±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`dcupyÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib16Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`adÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdaÙ±‚aoa.Ù±‚`Ù¢„jfrom_arrayÙ „ddaski2021.10.0fmodulexdask.array.core.from_arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fchunksÙ±‚aoa=Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`adÙ±‚aoa.Ù±‚`Ù¢„kmap_overlapÙ „ddaski2021.10.0fmodulexdask.array.overlap.map_overlapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edepthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dmetaÙ±‚aoa=Ù±‚`dcupyÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ayÙ±‚`b  Ù±‚bc1p# doctest: +SKIPxXdask.array<_trim, shape=(4, 4), dtype=float64, chunksize=(2, 2), chunktype=cupy.ndarray>hcompiledÙ´ƒ‡Ù±‚`ayÙ±‚aoa.Ù±‚`gcomputeÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxdarray([[ 4,  6,  8, 10],
       [ 8, 10, 12, 14],
       [20, 22, 24, 26],
       [24, 26, 28, 30]])hcompiledö€i2021.10.0Ù«x[map_overlap(func, *args, depth=None, boundary=None, trim=True, align_arrays=True, **kwargs)öxdask.array.overlap.map_overlap€
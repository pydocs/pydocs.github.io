Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§x<Evaluates the Einstein summation convention on the operands.€Ù¹‚…Ù§x•Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In Ù¨Ù§himplicitÙ§f mode Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§w computes these values.€Ù¹‚…Ù§cIn Ù¨Ù§hexplicitÙ§g mode, Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§xÉ provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.€Ù¹‚Ù§x-See the notes and examples for clarification.€ögMethodsÙ¯‚€öeNotesÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.6.0 €Ù¹‚ƒÙ§xtThe Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x/ provides a succinct way of representing these.€Ù¹‚ƒÙ§xDA non-exhaustive list of these operations, which can be computed by Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x%, is shown below along with examples:€ÙÈ‰Ù¹‚ƒÙ§sTrace of an array, Ù£ƒknumpy.traceödfuncÙ§a.€Ù¹‚ƒÙ§sReturn a diagonal, Ù£ƒjnumpy.diagödfuncÙ§a.€Ù¹‚ƒÙ§wArray axis summations, Ù£ƒinumpy.sumödfuncÙ§a.€Ù¹‚ƒÙ§x!Transpositions and permutations, Ù£ƒonumpy.transposeödfuncÙ§a.€Ù¹‚…Ù§x'Matrix multiplication and dot product, Ù£ƒlnumpy.matmulödfuncÙ§a Ù£ƒinumpy.dotödfuncÙ§a.€Ù¹‚…Ù§x!Vector inner and outer products, Ù£ƒknumpy.innerödfuncÙ§a Ù£ƒknumpy.outerödfuncÙ§a.€Ù¹‚ƒÙ§x6Broadcasting, element-wise and scalar multiplication, Ù£ƒnnumpy.multiplyödfuncÙ§a.€Ù¹‚ƒÙ§uTensor contractions, Ù£ƒonumpy.tensordotödfuncÙ§a.€Ù¹‚ƒÙ§x:Chained array operations, in efficient calculation order, Ù£ƒqnumpy.einsum_pathödfuncÙ§a.€Ù¹‚‘Ù§x¸The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so Ù¡vnp.einsum('i,i', a, b)Ù§r is equivalent to Ù¢„mnp.inner(a,b)Ù „enumpyf1.22.3fmoduleknumpy.innerfmoduleõÙ§x5. If a label appears only once, it is not summed, so Ù¡qnp.einsum('i', a)Ù§t produces a view of Ù¡aaÙ§x$ with no changes. A further example Ù¡xnp.einsum('ij,jk', a, b)Ù§xB describes traditional matrix multiplication and is equivalent to Ù£ƒxnp.matmul(a,b) <numpy.matmul>ödfuncÙ§xK. Repeated subscript labels in one operand take the diagonal. For example, Ù¡rnp.einsum('ii', a)Ù§r is equivalent to Ù¢„knp.trace(a)Ù „enumpyf1.22.3fmoduleknumpy.tracefmoduleõÙ§a.€Ù¹‚‹Ù§cIn Ù¨Ù§mimplicit modeÙ§xr, the chosen subscripts are important since the axes of the output are reordered alphabetically.  This means that Ù¡rnp.einsum('ij', a)Ù§x" doesn't affect a 2D array, while Ù¡rnp.einsum('ji', a)Ù§x$ takes its transpose. Additionally, Ù¡xnp.einsum('ij,jk', a, b)Ù§x) returns a matrix multiplication, while, Ù¡xnp.einsum('ij,jh', a, b)Ù§xX returns the transpose of the multiplication since subscript 'h' precedes subscript 'i'.€Ù¹‚Ù§cIn Ù¨Ù§mexplicit modeÙ§y the output can be directly controlled by specifying output subscript labels.  This requires the identifier '->' as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call Ù¡snp.einsum('i->', a)Ù§i is like Ù¢„rnp.sum(a, axis=-1)Ù „enumpyf1.22.3fmoduleinumpy.sumfmoduleõÙ§f, and Ù¡unp.einsum('ii->i', a)Ù§i is like Ù¢„jnp.diag(a)Ù „enumpyf1.22.3fmodulejnumpy.diagfmoduleõÙ§x. The difference is that Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x6 does not allow broadcasting by default. Additionally Ù¡xnp.einsum('ij,jh->ih', a, b)Ù§x” directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.€Ù¹‚‡Ù§x”To enable and control broadcasting, use an ellipsis.  Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like Ù¡xnp.einsum('...ii->...i', a)Ù§x>. To take the trace along the first and last axes, you can do Ù¡unp.einsum('i...i', a)Ù§x_, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do Ù¡x%np.einsum('ij...,jk...->ik...', a, b)Ù§a.€Ù¹‚ƒÙ§x³When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array.  Thus, taking the diagonal as Ù¡unp.einsum('ii->i', a)Ù§x- produces a view (changed in version 1.10.0).€Ù¹‚ˆÙ¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§xL also provides an alternative way to provide the subscripts and operands as Ù¡x7einsum(op0, sublist0, op1, sublist1, ..., [sublistout])Ù§x5. If the output shape is not provided in this format Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§xw will be calculated in implicit mode, otherwise it will be performed explicitly. The examples below have corresponding Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x& calls with the two parameter methods.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.10.0 €Ù¹‚‡Ù§xaViews returned from einsum are now writeable whenever the input array is writeable. For example, Ù¡xnp.einsum('ijk...->kji...', a)Ù§x" will now have the same effect as Ù¢„tnp.swapaxes(a, 0, 2)Ù „enumpyf1.22.3fmodulennumpy.swapaxesfmoduleõÙ§e and Ù¡unp.einsum('ii->i', a)Ù§x< will return a writeable view of the diagonal of a 2D array.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.12.0 €Ù¹‚ƒÙ§jAdded the Ù¡hoptimizeÙ§xî argument which will optimize the contraction order of an einsum expression. For a contraction with three or more operands this can greatly increase the computational efficiency at the cost of a larger memory footprint during computation.€Ù¹‚Ù§y„Typically a 'greedy' algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases 'optimal' will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.€Ù¹‚ƒÙ§dSee Ù¢„qnumpy.einsum_pathÙ „enumpya*capiqnumpy.einsum_pathfmoduleõÙ§r for more details.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒjsubscriptscstrÙ¹‚Ù§xşSpecifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator '->' is included as well as subscript labels of the precise output form.€Ù°ƒhoperandsrlist of array_likeÙ¹‚Ù§x'These are the arrays for the operation.€Ù°ƒcoutx*ndarray, optional  (Not supported in Dask)Ù¹‚Ù§x5If provided, the calculation is done into this array.€Ù°ƒedtypex{data-type, None}, optionalÙ¹‚ƒÙ§xwIf provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal Ù¢„gcastingÙ „ööelocalgcastingelocalõÙ§x5 parameter to allow the conversions. Default is None.€Ù°ƒeorderx{'C', 'F', 'A', 'K'}, optionalÙ¹‚Ù§y?Controls the memory layout of the output. 'C' means it should be C contiguous. 'F' means it should be Fortran contiguous, 'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise. 'K' means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is 'K'.€Ù°ƒgcastingx8{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optionalƒÙ¹‚Ù§x…Controls what kind of data casting may occur.  Setting this to 'unsafe' is not recommended, as it can adversely affect accumulations.€Ù·†x6* 'no' means the data types should not be cast at all.x4* 'equiv' means only byte-order changes are allowed.x@* 'safe' means only casts which can preserve values are allowed.x;* 'same_kind' means only safe casts or casts within a kind,x'  like float64 to float32, are allowed.x2* 'unsafe' means any data conversions may be done.Ù¹‚Ù§rDefault is 'safe'.€Ù°ƒhoptimizexE{False, True, 'greedy', 'optimal'}, optional  (Not supported in Dask)Ù¹‚…Ù§x¼Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the 'greedy' algorithm. Also accepts an explicit contraction list from the Ù¡nnp.einsum_pathÙ§o function. See Ù¡nnp.einsum_pathÙ§x% for more details. Defaults to False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfoutputgndarrayÙ¹‚Ù§x;The calculation based on the Einstein summation convention.€ögSummaryÙ¯‚Ù¹‚Ù§x,This docstring was copied from numpy.einsum.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆiSignaturegSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/dask/array/einsumfuncs.pyÄr<class 'function'>qdask.array.einsumÙ¯‚˜;Ù´ƒ˜4Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib25Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚bmia5Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia5Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`acÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚Ù§rTrace of a matrix:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1Ù¢„biiÙ „ddaski2021.10.0fmoduleudask.utils.asciitablefmoduleõÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb60hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb60hcompiledÙ´ƒˆÙ±‚`bnpÙ±‚aoa.Ù±‚`etraceÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb60hcompiledÙ¹‚Ù§x.Extract the diagonal (requires explicit form):€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1eii->iÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([ 0,  6, 12, 18, 24])hcompiledÙ´ƒ”Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([ 0,  6, 12, 18, 24])hcompiledÙ´ƒˆÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ddiagÙ „ddaski2021.10.0fmodulexdask.array.creation.diagfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([ 0,  6, 12, 18, 24])hcompiledÙ¹‚Ù§x*Sum over an axis (requires explicit form):€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1eij->iÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 10,  35,  60,  85, 110])hcompiledÙ´ƒ”Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 10,  35,  60,  85, 110])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 10,  35,  60,  85, 110])hcompiledÙ¹‚Ù§xNFor higher dimensional arrays summing a single axis can be done with ellipsis:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1i...j->...Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 10,  35,  60,  85, 110])hcompiledÙ´ƒ”Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bbphEllipsisÙ±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bbphEllipsisÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 10,  35,  60,  85, 110])hcompiledÙ¹‚Ù§x:Compute a matrix transpose, or reorder any number of axes:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1bjiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx-array([[0, 3],
       [1, 4],
       [2, 5]])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1fij->jiÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx-array([[0, 3],
       [1, 4],
       [2, 5]])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx-array([[0, 3],
       [1, 4],
       [2, 5]])hcompiledÙ´ƒˆÙ±‚`bnpÙ±‚aoa.Ù±‚`itransposeÙ±‚`a(Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx-array([[0, 3],
       [1, 4],
       [2, 5]])hcompiledÙ¹‚Ù§vVector inner products:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1ci,iÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb30hcompiledÙ´ƒ•Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb30hcompiledÙ´ƒŠÙ±‚`bnpÙ±‚aoa.Ù±‚`einnerÙ±‚`a(Ù±‚`abÙ±‚`a,Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPb30hcompiledÙ¹‚Ù§xMatrix vector multiplication:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1dij,jÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 30,  80, 130, 180, 230])hcompiledÙ´ƒ—Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 30,  80, 130, 180, 230])hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 30,  80, 130, 180, 230])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1f...j,jÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx array([ 30,  80, 130, 180, 230])hcompiledÙ¹‚Ù§x'Broadcasting and scalar multiplication:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1h..., ...Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([[ 0,  3,  6],
       [ 9, 12, 15]])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1c,ijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([[ 0,  3,  6],
       [ 9, 12, 15]])hcompiledÙ´ƒ•Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bbphEllipsisÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bbphEllipsisÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([[ 0,  3,  6],
       [ 9, 12, 15]])hcompiledÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmultiplyÙ „ddaski2021.10.0fmodulexdask.array.ufunc.multiplyfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([[ 0,  3,  6],
       [ 9, 12, 15]])hcompiledÙ¹‚Ù§uVector outer product:€Ù´ƒ—Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1ci,jÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚aoa+Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])hcompiledÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚aoa+Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])hcompiledÙ´ƒ’Ù±‚`bnpÙ±‚aoa.Ù±‚`eouterÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚aoa+Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx0array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])hcompiledÙ¹‚Ù§sTensor contraction:€Ù´ƒ˜<Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmfc60.Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia4Ù±‚`a,Ù±‚bmia5Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmfc24.Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1kijk,jil->klÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxsarray([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])hcompiledÙ´ƒ˜$Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxsarray([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])hcompiledÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`itensordotÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`daxesÙ±‚aoa=Ù±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxsarray([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])hcompiledÙ¹‚Ù§x1Writeable returned arrays (since version 1.10.0):€Ù´ƒ˜*Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „ddaski2021.10.0fmodulexdask.array.creation.zeros_likefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1eii->iÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`a[Ù±‚`a:Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`b  Ù±‚bc1p# doctest: +SKIPx?array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])hcompiledÙ¹‚Ù§xExample of ellipsis use:€Ù´ƒ˜<Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`farangeÙ±‚`a(Ù±‚bmib12Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1iki,jk->ijÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx2array([[10, 28, 46, 64],
       [13, 40, 67, 94]])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1mki,...k->i...Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx2array([[10, 28, 46, 64],
       [13, 40, 67, 94]])hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1gk...,jkÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx2array([[10, 28, 46, 64],
       [13, 40, 67, 94]])hcompiledÙ¹‚ƒÙ§xÊChained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a 'greedy' path or pre-computing the 'optimal' path and repeatedly applying it, using an Ù£ƒkeinsum_pathööÙ§xo insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:€Ù´ƒ•Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „ddaski2021.10.0fmodulexdask.array.creation.ones_likefmoduleõÙ±‚`a(Ù±‚bmib64Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „ddaski2021.10.0fmodulexdask.array.core.Array.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia4Ù±‚`a,Ù±‚bmia8Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚ƒÙ§fBasic Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x,: ~1520ms  (benchmarked on 3.1GHz Intel i5.)€Ù´ƒ˜%Ù±‚akcforÙ±‚`a Ù±‚`iiterationÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bmic500Ù±‚`a)Ù±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uijk,ilm,njm,nlk,abc->Ù±‚bs1a'Ù±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a)`hcompiledÙ¹‚ƒÙ§lSub-optimal Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x0 (due to repeated path calculation time): ~330ms€Ù´ƒ˜,Ù±‚akcforÙ±‚`a Ù±‚`iiterationÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bmic500Ù±‚`a)Ù±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uijk,ilm,njm,nlk,abc->Ù±‚bs1a'Ù±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`hoptimizeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1goptimalÙ±‚bs1a'Ù±‚`a)`hcompiledÙ¹‚ƒÙ§gGreedy Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x, (faster optimal path approximation): ~160ms€Ù´ƒ˜,Ù±‚akcforÙ±‚`a Ù±‚`iiterationÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bmic500Ù±‚`a)Ù±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uijk,ilm,njm,nlk,abc->Ù±‚bs1a'Ù±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`hoptimizeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fgreedyÙ±‚bs1a'Ù±‚`a)`hcompiledÙ¹‚ƒÙ§hOptimal Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ§x/ (best usage pattern in some use cases): ~110ms€Ù´ƒ˜MÙ±‚`dpathÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`keinsum_pathÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uijk,ilm,njm,nlk,abc->Ù±‚bs1a'Ù±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`hoptimizeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1goptimalÙ±‚bs1a'Ù±‚`a)Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚akcforÙ±‚`a Ù±‚`iiterationÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bmic500Ù±‚`a)Ù±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„feinsumÙ „ddaski2021.10.0fmodulexdask.array.einsumfuncs.einsumfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uijk,ilm,njm,nlk,abc->Ù±‚bs1a'Ù±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`hoptimizeÙ±‚aoa=Ù±‚`dpathÙ±‚`a)`hcompiledöˆÙ¼ƒÙ»ƒcdotöö€öÙ¼ƒÙ»ƒfeinopsööÙ¹‚ƒÙ§x)similar verbose interface is provided by ÙË‚feinopsx&https://github.com/arogozhnikov/einopsÙ§xs package to cover additional operations: transpose, reshape/flatten, repeat/tile, squeeze/unsqueeze and reductions.€öÙ¼ƒÙ»ƒkeinsum_pathöö€öÙ¼ƒÙ»ƒeinneröö€öÙ¼ƒÙ»ƒplinalg.multi_dotöö€öÙ¼ƒÙ»ƒjopt_einsumööÙ¹‚‚ÙË‚jopt_einsumx2https://optimized-einsum.readthedocs.io/en/stable/Ù§xT optimizes contraction order for einsum-like expressions in backend-agnostic manner.€öÙ¼ƒÙ»ƒeouteröö€öÙ¼ƒÙ»ƒitensordotöö€öi2021.10.0Ù«x^einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe', optimize=False)öxdask.array.einsumfuncs.einsum€
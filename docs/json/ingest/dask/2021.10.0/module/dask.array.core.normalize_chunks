Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xÉThis takes in a variety of input types and information and produces a full tuple-of-tuples result for chunks, suitable to be passed to Array or rechunk or any other operation that creates a Dask array.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒx#chunks: tuple, int, dict, or string`Ù¹‚Ù§xAThe chunks to be normalized.  See examples below for more details€Ù°ƒqshape: Tuple[int]`Ù¹‚Ù§vThe shape of the array€Ù°ƒulimit: int (optional)`Ù¹‚Ù§xHThe maximum block size to target in bytes, if freedom is given to choose€Ù°ƒodtype: np.dtype`€Ù°ƒx+previous_chunks: Tuple[Tuple[int]] optional`Ù¹‚Ù§xÅChunks from a previous array that we should use for inspiration when rechunking auto dimensions.  If not provided but auto-chunking exists then auto-dimensions will prefer square-like chunk shapes.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x#Normalize chunks to tuple of tuples€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExampless/dask/array/core.py
Šr<class 'function'>x dask.array.core.normalize_chunksÙ¯‚’Ù¹‚Ù§xSpecify uniform chunk sizes€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„ddaskÙ „ddaski2021.10.0fmoduleddaskfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„dcoreÙ „ddaski2021.10.0fmoduleidask.corefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a
Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a)v((2, 2, 1), (2, 2, 2))hcompiledÙ¹‚Ù§x2Also passes through fully explicit tuple-of-tuples€Ù´ƒ˜#Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a)v((2, 2, 1), (2, 2, 2))hcompiledÙ¹‚Ù§xCleans up lists to tuples€Ù´ƒ“Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a]Ù±‚`a)p((2, 2), (3, 3))hcompiledÙ¹‚Ù§x%Expands integer inputs 10 -> (10, 10)€Ù´ƒÙ±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmib30Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a)t((10, 10, 10), (5,))hcompiledÙ¹‚Ù§sExpands dict inputs€Ù´ƒ˜Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a:Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a:Ù±‚`a Ù±‚bmia3Ù±‚`a}Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a)s((2, 2, 2), (3, 3))hcompiledÙ¹‚Ù§x.The values -1 and None get mapped to full size€Ù´ƒ”Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„b10Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`a)o((5, 5), (10,))hcompiledÙ¹‚…Ù§xeUse the value "auto" to automatically determine chunk sizes along certain dimensions.  This uses the Ù¡flimit=Ù§e and Ù¡fdtype=Ù§xª keywords to determine how large to make the chunks.  The term "auto" can be used anywhere an integer can be used.  See array chunking documentation for more information.€Ù´ƒ˜Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bs2a"Ù±‚bs2Ù¢„dautoÙ „ddaski2021.10.0fmodulexdask.array.core.auto_chunksfmoduleõÙ±‚bs2a"Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmib20Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„elimitÙ „ddaski2021.10.0fmodulex9dask.utils_test.GetFunctionTestMixin.test_get_stack_limitfmoduleõÙ±‚aoa=Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1euint8Ù±‚bs1a'Ù±‚`a)o((5, 5, 5, 5),)hcompiledÙ¹‚ƒÙ§x!You can also use byte sizes (see Ù¢„vdask.utils.parse_bytesÙ „ddaski2021.10.0fmodulevdask.utils.parse_bytesfmoduleõÙ§x1) in place of "auto" to ask for a particular size€Ù´ƒ•Ù±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2d1kiBÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmid2000Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gfloat32Ù±‚bs1a'Ù±‚`a)x+((250, 250, 250, 250, 250, 250, 250, 250),)hcompiledÙ¹‚Ù§xRespects null dimensions€Ù´ƒÙ±‚`Ù¢„pnormalize_chunksÙ „ddaski2021.10.0fmodulex dask.array.core.normalize_chunksfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a)Ù±‚`a)l((0,), (0,))hcompiledö€i2021.10.0Ù«xRnormalize_chunks(chunks, shape=None, limit=None, dtype=None, previous_chunks=None)öx dask.array.core.normalize_chunks€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x‰This compression matrix returned by this algorithm can be used to compute both the QR decomposition and the Singular Value Decomposition.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒkdata: Array`€Ù°ƒfq: int`Ù¹‚ƒÙ§x[Size of the desired subspace (the actual size will be bigger, because of oversampling, see Ù¡xda.linalg.compression_levelÙ§a)€Ù°ƒx*iterator: {'power', 'QR'}, default='power'`Ù¹‚Ù§xsDefine the technique used for iterations to cope with flat singular spectra or when the input matrix is very large.€Ù°ƒqn_power_iter: int`Ù¹‚…Ù§xkNumber of power iterations, useful when the singular values decay slowly. Error decreases exponentially as Ù£ƒln_power_iterööÙ§x increases. In practice, set Ù£ƒln_power_iterööÙ§f <= 4.€Ù°ƒxn_oversamples: int, default=10`Ù¹‚Ù§yNumber of oversamples used for generating the sampling matrix. This value increases the size of the subspace computed, which is more accurate at the cost of efficiency.  Results are rarely sensitive to this choice though and in practice a value of 10 is very commonly high enough.€Ù°ƒgcomputedboolÙ¹‚Ù§yWhether or not to compute data at each use. Recomputing the input while performing several passes reduces memory pressure, but means that we have to compute the input multiple times. This is a good choice if the data is larger than memory and cheap to recreate.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x3Randomly sample matrix to find most active subspace€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersjReferencesu/dask/array/linalg.py‰r<class 'function'>x$dask.array.linalg.compression_matrixÙ¯‚€ö€i2021.10.0Ù«xicompression_matrix(data, q, iterator='power', n_power_iter=0, n_oversamples=10, seed=None, compute=False)öx$dask.array.linalg.compression_matrix€
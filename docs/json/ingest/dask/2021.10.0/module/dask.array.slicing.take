Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§x'Handles a single index by a single list€Ù¹‚‚Ù§gMimics Ù¡gnp.take€ÙÀyq>>> from pprint import pprint
>>> chunks, dsk = take('y', 'x', [(20, 20, 20, 20)], [5, 1, 47, 3], 8, axis=0)
>>> chunks
((2, 1, 1),)
>>> pprint(dsk)   # doctest: +ELLIPSIS
{('y', 0): (<function getitem at ...>, ('x', 0), (array([5, 1]),)),
 ('y', 1): (<function getitem at ...>, ('x', 2), (array([7]),)),
 ('y', 2): (<function getitem at ...>, ('x', 0), (array([3]),))}Ù¹‚Ù§x6When list is sorted we retain original block structure€ÙÀy,>>> chunks, dsk = take('y', 'x', [(20, 20, 20, 20)], [1, 3, 5, 47], 8, axis=0)
>>> chunks
((3, 1),)
>>> pprint(dsk)     # doctest: +ELLIPSIS
{('y', 0): (<function getitem at ...>,
            ('x', 0),
            (array([1, 3, 5]),)),
 ('y', 1): (<function getitem at ...>, ('x', 2), (array([7]),))}Ù¹‚ƒÙ§x†When any indexed blocks would otherwise grow larger than dask.config.array.chunk-size, we might split them, depending on the value of Ù¡x&dask.config.slicing.split-large-chunksÙ§a.€ÙÀy>>> import dask
>>> with dask.config.set({"array.slicing.split-large-chunks": True}):
...      chunks, dsk = take('y', 'x', [(1, 1, 1), (1000, 1000), (1000, 1000)],
...                        [0] + [1] * 6 + [2], axis=0, itemsize=8)
>>> chunks
((1, 3, 3, 1), (1000, 1000), (1000, 1000))ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x%Index array with an iterable of index€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryv/dask/array/slicing.pyIr<class 'function'>wdask.array.slicing.takeÙ¯‚€ö€i2021.10.0Ù«x6take(outname, inname, chunks, index, itemsize, axis=0)öwdask.array.slicing.take€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§yThis stores dask arrays into object that supports numpy-style setitem indexing.  It stores values chunk by chunk so that it does not have to fill up memory.  For best performance you can align the block size of the storage target with the block size of your array.€Ù¹‚ƒÙ§x8If your data fits in memory then you may prefer calling Ù¡qnp.array(myarray)Ù§i instead.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒx&sources: Array or collection of Arrays`€Ù°ƒxKtargets: array-like or Delayed or collection of array-likes and/or Delayeds`Ù¹‚‚Ù§x$These should support setitem syntax Ù¡starget[10:20] = ...€Ù°ƒx)lock: boolean or threading.Lock, optional`Ù¹‚ƒÙ§x‚Whether or not to lock the data stores while storing. Pass True (lock each file individually), False (don't lock) or a particular Ù¢„nthreading.LockÙ „g_threada*capiu_thread.allocate_lockfmoduleõÙ§x& object to be shared among all writes.€Ù°ƒx:regions: tuple of slices or collection of tuples of slices`Ù¹‚‡Ù§eEach Ù¡fregionÙ§j tuple in Ù¡gregionsÙ§u should be such that Ù¡x#target[region].shape = source.shapeÙ§x² for the corresponding source and target in sources and targets, respectively. If this is a tuple, the contents will be assumed to be slices, so do not provide a tuple of tuples.€Ù°ƒxcompute: boolean, optional`Ù¹‚ƒÙ§x$If true compute immediately; return Ù¢„tdask.delayed.DelayedÙ „ddaski2021.10.0fmoduletdask.delayed.DelayedfmoduleõÙ§k otherwise.€Ù°ƒx return_stored: boolean, optional`Ù¹‚Ù§x4Optionally return the stored result (default False).€Ù°ƒgkwargs:`Ù¹‚Ù§x@Parameters passed to compute/persist (only used if compute=True)€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒ`uIf return_stored=TrueÙ¹‚Ù§otuple of Arrays€Ù°ƒ`x'If return_stored=False and compute=TrueÙ¹‚Ù§dNone€Ù°ƒ`x(If return_stored=False and compute=FalseÙ¹‚Ù§gDelayed€ögSummaryÙ¯‚Ù¹‚Ù§xAStore dask arrays in array-like objects, overwrite data in target€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersgReturnshExampless/dask/array/core.py’r<class 'function'>ƒpdask.array.storevdask.array.Array.storeudask.array.core.storeÙ¯‚„Ù´ƒ˜AÙ±‚bknfimportÙ±‚`a Ù±‚bnndh5pyÙ±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`dh5pyÙ±‚aoa.Ù±‚`dFileÙ±‚`a(Ù±‚bs1a'Ù±‚bs1kmyfile.hdf5Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`ddsetÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„afÙ „ddaski2021.10.0fmodulexdask.array.random.RandomState.ffmoduleõÙ±‚aoa.Ù±‚`ncreate_datasetÙ±‚`a(Ù±‚bs1a'Ù±‚bs1e/dataÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „ddaski2021.10.0fmodulexdask.array.routines.shapefmoduleõÙ±‚`a,Ù±‚`a
Ù±‚`x!                                 Ù±‚`fchunksÙ±‚aoa=Ù±‚`axÙ±‚aoa.Ù±‚`fchunksÙ±‚`a,Ù±‚`a
Ù±‚`x!                                 Ù±‚`edtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bf8Ù±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ´ƒ‰Ù±‚`Ù¢„estoreÙ „ddaski2021.10.0fmoduleudask.array.core.storefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ddsetÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledÙ¹‚Ù§x0Alternatively store many arrays at the same time€Ù´ƒ˜Ù±‚`Ù¢„estoreÙ „ddaski2021.10.0fmoduleudask.array.core.storefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`azÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`edset1Ù±‚`a,Ù±‚`a Ù±‚`edset2Ù±‚`a,Ù±‚`a Ù±‚`edset3Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`hcompiledö€i2021.10.0Ù«xİstore(sources: 'Array | Collection[Array]', targets, lock: 'bool | Lock' = True, regions: 'tuple[slice, ...] | Collection[tuple[slice, ...]] | None' = None, compute: 'bool' = True, return_stored: 'bool' = False, **kwargs)öudask.array.core.store€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚ƒÙ§nFor instance, Ù¡xmap_reduce([[1, 2], 3, 4])Ù§k is::      €ÙÀxSf_reduce([
  f_reduce([
    f_map(1),
    f_map(2)
  ]),
  f_map(3),
  f_map(4)
]])Ù¹‚…Ù§x0State can be passed down through the calls with Ù£ƒhf_kwargsööÙ§x>, to iterables of mapped items. When kwargs are passed, as in Ù¡x map_reduce([[1, 2], 3, 4], **kw)Ù§v, this becomes::      €ÙÀx±kw1 = f_kwargs(**kw)
kw2 = f_kwargs(**kw1)
f_reduce([
  f_reduce([
    f_map(1), **kw2)
    f_map(2,  **kw2)
  ],      **kw1),
  f_map(3, **kw1),
  f_map(4, **kw1)
]],     **kw)ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚…Ù§x*Iterate over the nested list, applying: * Ù¡ef_mapÙ§u (T -> U) to items * Ù¡hf_reduceÙ§x# (Iterable[U] -> U) to mapped items€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryx/dask/array/numpy_compat.py=r<class 'function'>x$dask.array.core._Recurser.map_reduceÙ¯‚€ö€i2021.10.0Ù«x¹map_reduce(self, x, f_map=<function _Recurser.<lambda> at 0x0000000>, f_reduce=<function _Recurser.<lambda> at 0x0000000>, f_kwargs=<function _Recurser.<lambda> at 0x0000000>, **kwargs)öx,dask.array.numpy_compat._Recurser.map_reduce€
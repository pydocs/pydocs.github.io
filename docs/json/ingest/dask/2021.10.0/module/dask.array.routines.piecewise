Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x/This docstring was copied from numpy.piecewise.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§xGiven a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚…Ù§xXThis is similar to choose or select, except that functions are evaluated on elements of Ù¢„axÙ „ööelocalaxelocalõÙ§x/ that satisfy the corresponding condition from Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§a.€Ù¹‚Ù§xThe result is::          €ÙÀxe|--
|funclist[0](x[condlist[0]])
|funclist[1](x[condlist[1]])
|...
|funclist[n2](x[condlist[n2]])
|--öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaxqndarray or scalarÙ¹‚Ù§qThe input domain.€Ù°ƒhcondlistx#list of bool arrays or bool scalarsƒÙ¹‚‡Ù§x0Each boolean array corresponds to a function in Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§l.  Wherever Ù£ƒkcondlist[i]ööÙ§j is True, Ù£ƒnfunclist[i](x)ööÙ§x is used as the output value.€Ù¹‚‡Ù§vEach boolean array in Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§t selects a piece of Ù¢„axÙ „ööelocalaxelocalõÙ§x/, and should therefore be of the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§a.€Ù¹‚‡Ù§nThe length of Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§x must correspond to that of Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§x*. If one extra function is given, i.e. if Ù¡x"len(funclist) == len(condlist) + 1Ù§xX, then that extra function is the default value, used wherever all conditions are false.€Ù°ƒhfunclistx.list of callables, f(x,*args,**kw), or scalarsÙ¹‚…Ù§x Each function is evaluated over Ù¢„axÙ „ööelocalaxelocalõÙ§xĞ wherever its corresponding condition is True.  It should take a 1d array as input and give an 1d array or a scalar value as output.  If, instead of a callable, a scalar is provided then a constant function (Ù¡plambda x: scalarÙ§m) is assumed.€Ù°ƒdargsotuple, optionalÙ¹‚‡Ù§xAny further arguments given to Ù¢„ipiecewiseÙ „ddaski2021.10.0fmodulexdask.array.routines.piecewisefmoduleõÙ§x= are passed to the functions upon execution, i.e., if called Ù¡xpiecewise(..., ..., 1, 'a')Ù§x", then each function is called as Ù¡lf(x, 1, 'a')Ù§a.€Ù°ƒbkwndict, optionalÙ¹‚‡Ù§x"Keyword arguments used in calling Ù¢„ipiecewiseÙ „ddaski2021.10.0fmodulexdask.array.routines.piecewisefmoduleõÙ§x= are passed to the functions upon execution, i.e., if called Ù¡xpiecewise(..., ..., alpha=1)Ù§x", then each function is called as Ù¡mf(x, alpha=1)Ù§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚‡Ù§xTThe output is the same shape and type as x and is found by calling the functions in Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§x  on the appropriate portions of Ù¢„axÙ „ööelocalaxelocalõÙ§x&, as defined by the boolean arrays in Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§xC.  Portions not covered by any condition have a default value of 0.€ögSummaryÙ¯‚Ù¹‚Ù§x&Evaluate a piecewise-defined function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesw/dask/array/routines.pyIr<class 'function'>tdask.array.piecewiseÙ¯‚†Ù¹‚…Ù§x+Define the sigma function, which is -1 for Ù¡ex < 0Ù§l and +1 for Ù¡fx >= 0Ù§a.€Ù´ƒ˜6Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`hlinspaceÙ±‚`a(Ù±‚aoa-Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „ddaski2021.10.0fmodulexdask.array.routines.piecewisefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx%array([-1., -1., -1.,  1.,  1.,  1.])hcompiledÙ¹‚‰Ù§x$Define the absolute value, which is Ù¡b-xÙ§e for Ù¡dx <0Ù§e and Ù¡axÙ§e for Ù¡fx >= 0Ù§a.€Ù´ƒ˜,Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „ddaski2021.10.0fmodulexdask.array.routines.piecewisefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚aoa-Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx*array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])hcompiledÙ¹‚Ù§x*Apply the same function to a scalar value.€Ù´ƒ˜5Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia2Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „ddaski2021.10.0fmodulexdask.array.routines.piecewisefmoduleõÙ±‚`a(Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`ayÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚aoa-Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPharray(2)hcompiledöƒÙ¼ƒÙ»ƒfchoosexdask.array.routines.chooseõ€öÙ¼ƒÙ»ƒfselectxdask.array.routines.selectõ€öÙ¼ƒÙ»ƒewherexdask.array.routines.whereõ€öi2021.10.0Ù«x-piecewise(x, condlist, funclist, *args, **kw)öxdask.array.routines.piecewise€
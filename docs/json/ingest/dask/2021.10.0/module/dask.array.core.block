Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x½Blocks in the innermost lists are concatenated along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached€Ù¹‚‡Ù§xŠBlocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make Ù¡jblock.ndimÙ§xf the same for all blocks. This is primarily useful for working with scalars, and means that code like Ù¡mblock([v, 1])Ù§q is valid, where Ù¡kv.ndim == 1Ù§a.€Ù¹‚Ù§xlWhen the nested list is two levels deep, this allows block matrices to be constructed from their components.€ögMethodsÙ¯‚€öeNotesÙ¯‚ˆÙ¹‚‡Ù§xWhen called with only scalars, Ù¡eblockÙ§x& is equivalent to an ndarray call. So Ù¡wblock([[1, 2], [3, 4]])Ù§r is equivalent to Ù¡warray([[1, 2], [3, 4]])Ù§a.€Ù¹‚ƒÙ§xDThis function does not enforce that the blocks lie on a fixed grid. Ù¡wblock([[a, b], [c, d]])Ù§x0 is not restricted to arrays of the form::      €ÙÀqAAAbb
AAAbb
cccDDÙ¹‚ƒÙ§x)But is also allowed to produce, for some Ù¡ja, b, c, dÙ§f      €ÙÀqAAAbb
AAAbb
cDDDDÙ¹‚ƒÙ§x7Since concatenation happens along the last axis first, Ù¢„eblockÙ „ddaski2021.10.0fmoduleudask.array.core.blockfmoduleõÙ§x= is _not_ capable of producing the following directly::      €ÙÀqAAAbb
cccbb
cccDDÙ¹‚…Ù§x$Matlab's "square bracket stacking", Ù¡v[A, B, ...; p, q, ...]Ù§s, is equivalent to Ù¡x!block([[A, B, ...], [p, q, ...]])Ù§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒfarraysx5nested list of array_like or scalars (but not tuples)‚Ù¹‚Ù§xnIf passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).€Ù¹‚Ù§x¦Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.€Ù°ƒxallow_unknown_chunksizes: bool`Ù¹‚Ù§xÙAllow unknown chunksizes, such as come from converting from dask dataframes.  Dask.array is unable to verify that chunks line up.  If data comes from differently aligned sources then this can cause unexpected results.€öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙÈ‚Ù¹‚„Ù§x.If list depths are mismatched - for instance, Ù¡k[[a, b], c]Ù§x# is   illegal, and should be spelt Ù¡m[[a, b], [c]]€Ù¹‚‚Ù§x#If lists are empty - for instance, Ù¡l[[a, b], []]€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒkblock_arraygndarray‚Ù¹‚Ù§x*The array assembled from the given blocks.€Ù¹‚Ù§x’The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested€ögSummaryÙ¯‚Ù¹‚Ù§x1Assemble an nd-array from nested lists of blocks.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotess/dask/array/core.py|r<class 'function'>pdask.array.blockÙ¯‚€ö†Ù¼ƒÙ»ƒkconcatenatexdask.array.core.concatenateõÙ¹‚Ù§x#Join a sequence of arrays together.€öÙ¼ƒÙ»ƒfdstackxdask.array.routines.dstackõÙ¹‚Ù§x<Stack arrays in sequence depth wise (along third dimension).€öÙ¼ƒÙ»ƒfhstackxdask.array.routines.hstackõÙ¹‚Ù§x4Stack arrays in sequence horizontally (column wise).€öÙ¼ƒÙ»ƒestackudask.array.core.stackõÙ¹‚Ù§x/Stack arrays in sequence along a new dimension.€öÙ¼ƒÙ»ƒfvsplitööÙ¹‚Ù§x:Split array into a list of multiple sub-arrays vertically.€öÙ¼ƒÙ»ƒfvstackxdask.array.routines.vstackõÙ¹‚Ù§x/Stack arrays in sequence vertically (row wise).€öi2021.10.0Ù«x-block(arrays, allow_unknown_chunksizes=False)öudask.array.core.block€
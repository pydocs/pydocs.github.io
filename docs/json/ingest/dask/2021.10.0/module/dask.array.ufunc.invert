Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚Ù§x:Compute bit-wise inversion, or bit-wise NOT, element-wise.€Ù¹‚ƒÙ§x“Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator Ù¡a~Ù§a.€Ù¹‚…Ù§yBFor signed integer inputs, the two's complement is returned.  In a two's-complement system negative numbers are represented by the two's complement of the absolute value. This is the most common method of representing signed integers on computers . A N-bit two's-complement system can represent every integer in the range Ù¥h-2^{N-1}Ù§d to Ù¥j+2^{N-1}-1Ù§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚„Ù£ƒkbitwise_notööÙ§q is an alias for Ù¢„finvertÙ „ddaski2021.10.0fmodulewdask.array.ufunc.invertfmoduleõÙ§a:€ÙÀx6>>> np.bitwise_not is np.invert  # doctest: +SKIP
TrueöpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaxjarray_likeÙ¹‚Ù§x+Only integer and boolean types are handled.€Ù°ƒcoutx5ndarray, None, or tuple of ndarray and None, optionalÙ¹‚Ù§y
A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.€Ù°ƒewheretarray_like, optionalÙ¹‚‰Ù§xZThis condition is broadcast over the input. At locations where the condition is True, the Ù¢„coutÙ „ööelocalcoutelocalõÙ§x7 array will be set to the ufunc result. Elsewhere, the Ù¢„coutÙ „ööelocalcoutelocalõÙ§xE array will retain its original value. Note that if an uninitialized Ù¢„coutÙ „ööelocalcoutelocalõÙ§x" array is created via the default Ù¡hout=NoneÙ§xM, locations within it where the condition is False will remain uninitialized.€Ù°ƒh**kwargs`Ù¹‚ƒÙ§x*For other keyword-only arguments, see the Ù£ƒxufunc docs <ufuncs.kwargs>öcrefÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutqndarray or scalarÙ¹‚ƒÙ§xResult. This is a scalar if Ù¢„axÙ „ööelocalaxelocalõÙ§m is a scalar.€ögSummaryÙ¯‚Ù¹‚Ù§x,This docstring was copied from numpy.invert.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰iSignaturegSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplest/dask/array/ufunc.pyöx <class 'dask.array.ufunc.ufunc'>vdask.array.bitwise_notÙ¯‚Ù¹‚ƒÙ§x%We've seen that 13 is represented by Ù¡h00001101Ù§x+. The invert or bit-wise NOT of 13 is then:€Ù´ƒ˜Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„finvertÙ „ddaski2021.10.0fmodulewdask.array.ufunc.invertfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚bmib13Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`euint8Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`axÙ±‚`b  Ù±‚bc1p# doctest: +SKIPc242hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`kbinary_reprÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ewidthÙ±‚aoa=Ù±‚bmia8Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPj'11110010'hcompiledÙ¹‚Ù§x$The result depends on the bit-width:€Ù´ƒ˜Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„finvertÙ „ddaski2021.10.0fmodulewdask.array.ufunc.invertfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚bmib13Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`fuint16Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`axÙ±‚`b  Ù±‚bc1p# doctest: +SKIPe65522hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`kbinary_reprÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ewidthÙ±‚aoa=Ù±‚bmib16Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPr'1111111111110010'hcompiledÙ¹‚Ù§xgWhen using signed integer types the result is the two's complement of the result for the unsigned type:€Ù´ƒ–Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„finvertÙ „ddaski2021.10.0fmodulewdask.array.ufunc.invertfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmib13Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`dint8Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([-14], dtype=int8)hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`kbinary_reprÙ±‚`a(Ù±‚aoa-Ù±‚bmib14Ù±‚`a,Ù±‚`a Ù±‚`ewidthÙ±‚aoa=Ù±‚bmia8Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPj'11110010'hcompiledÙ¹‚Ù§xBooleans are accepted as well:€Ù´ƒ’Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„finvertÙ „ddaski2021.10.0fmodulewdask.array.ufunc.invertfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPuarray([False,  True])hcompiledÙ¹‚…Ù§dThe Ù¡a~Ù§x) operator can be used as a shorthand for Ù¡inp.invertÙ§m on ndarrays.€Ù´ƒ–Ù±‚`bx1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚aoa~Ù±‚`bx1Ù±‚`b  Ù±‚bc1p# doctest: +SKIPuarray([False,  True])hcompiledö…Ù¼ƒÙ»ƒkbinary_reprööÙ¹‚Ù§xAReturn the binary representation of the input number as a string.€öÙ¼ƒÙ»ƒkbitwise_andxdask.array.ufunc.bitwise_andõ€öÙ¼ƒÙ»ƒjbitwise_orxdask.array.ufunc.bitwise_orõ€öÙ¼ƒÙ»ƒkbitwise_xorxdask.array.ufunc.bitwise_xorõ€öÙ¼ƒÙ»ƒklogical_notxdask.array.ufunc.logical_notõ€öi2021.10.0Ù«xrinvert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])öwdask.array.ufunc.invert€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§x*This docstring was copied from numpy.take.€Ù¹‚Ù§x5Some inconsistencies with the Dask version may exist.€Ù¹‚…Ù§xÆWhen axis is not None, this function does the same thing as "fancy" indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as Ù¡xnp.take(arr, indices, axis=3)Ù§r is equivalent to Ù¡varr[:,:,:,indices,...]Ù§a.€Ù¹‚‰Ù§xMExplained without fancy indexing, this is equivalent to the following use of Ù£ƒgndindexööÙ§u, which sets each of Ù¡biiÙ§b, Ù¡bjjÙ§f, and Ù¡bkkÙ§x to a tuple of indices::      €ÙÀxÉNi, Nk = a.shape[:axis], a.shape[axis+1:]
Nj = indices.shape
for ii in ndindex(Ni):
    for jj in ndindex(Nj):
        for kk in ndindex(Nk):
            out[ii + jj + kk] = a[ii + (indices[jj],) + kk]ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚…Ù§xBBy eliminating the inner loop in the description above, and using Ù£ƒbs_ööÙ§x  to build simple slice objects, Ù¢„dtakeÙ „ddaski2021.10.0fmodulexdask.array.routines.takefmoduleõÙ§xP can be expressed  in terms of applying fancy indexing to each 1-d slice::      €ÙÀxšNi, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
    for kk in ndindex(Nj):
        out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]Ù¹‚ƒÙ§xLFor this reason, it is equivalent to (but faster than) the following use of Ù¢„papply_along_axisÙ „ddaski2021.10.0fmodulex$dask.array.routines.apply_along_axisfmoduleõÙ§f      €ÙÀx>out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaaxarray_like (Ni..., M, Nk...)Ù¹‚Ù§qThe source array.€Ù°ƒgindicesrarray_like (Nj...)ƒÙ¹‚Ù§x%The indices of the values to extract.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.8.0 €Ù¹‚Ù§xAlso allow scalars for indices.€Ù°ƒdaxismint, optionalÙ¹‚Ù§xTThe axis over which to select values. By default, the flattened input array is used.€Ù°ƒcoutx'ndarray, optional (Ni..., Nj..., Nk...)Ù¹‚…Ù§xqIf provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that Ù¢„coutÙ „ööelocalcoutelocalõÙ§w is always buffered if Ù£ƒlmode='raise'ööÙ§x); use other modes for better performance.€Ù°ƒdmodex<{'raise', 'wrap', 'clip'}, optional  (Not supported in Dask)ƒÙ¹‚Ù§x0Specifies how out-of-bounds indices will behave.€ÙÈƒÙ¹‚Ù§x#'raise' -- raise an error (default)€Ù¹‚Ù§u'wrap' -- wrap around€Ù¹‚Ù§x'clip' -- clip to the range€Ù¹‚Ù§x¸'clip' mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutxndarray (Ni..., Nj..., Nk...)Ù¹‚ƒÙ§x(The returned array has the same type as Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x*Take elements from an array along an axis.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesw/dask/array/routines.py|r<class 'function'>odask.array.takeÙ¯‚…Ù´ƒ˜4Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`Ù¢„gindicesÙ „ddaski2021.10.0fmodulexdask.array.creation.indicesfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtakeÙ „ddaski2021.10.0fmodulexdask.array.routines.takefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„gindicesÙ „ddaski2021.10.0fmodulexdask.array.creation.indicesfmoduleõÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPparray([4, 3, 6])hcompiledÙ¹‚ƒÙ§sIn this example if Ù¢„aaÙ „ööelocalaaelocalõÙ§x- is an ndarray, "fancy" indexing can be used.€Ù´ƒ“Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „ddaski2021.10.0fmodulejdask.arrayfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`aaÙ±‚`a[Ù±‚`Ù¢„gindicesÙ „ddaski2021.10.0fmodulexdask.array.creation.indicesfmoduleõÙ±‚`a]Ù±‚`b  Ù±‚bc1p# doctest: +SKIPparray([4, 3, 6])hcompiledÙ¹‚ƒÙ§cIf Ù¢„gindicesÙ „ddaski2021.10.0fmodulexdask.array.creation.indicesfmoduleõÙ§x> is not one dimensional, the output also has these dimensions.€Ù´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtakeÙ „ddaski2021.10.0fmodulexdask.array.routines.takefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „ddaski2021.10.0fmodulevdask.array.ufunc.log10fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxarray([[4, 3],
       [5, 7]])hcompiledöƒÙ¼ƒÙ»ƒhcompressxdask.array.routines.compressõÙ¹‚Ù§x"Take elements using a boolean mask€öÙ¼ƒÙ»ƒlndarray.takeööÙ¹‚Ù§qequivalent method€öÙ¼ƒÙ»ƒotake_along_axisööÙ¹‚Ù§x8Take elements by matching the array and the index arrays€öi2021.10.0Ù«xtake(a, indices, axis=0)öxdask.array.routines.take€
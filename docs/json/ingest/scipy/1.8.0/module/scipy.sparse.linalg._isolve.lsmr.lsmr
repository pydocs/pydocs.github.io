Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‰Ù§x+lsmr solves the system of linear equations Ù¡fAx = bÙ§xE. If the system is inconsistent, it solves the least-squares problem Ù¡pmin ||b - Ax||_2Ù§b. Ù¡aAÙ§xc is a rectangular matrix of dimension m-by-n, where all cases are allowed: m = n, m > n, or m < n. Ù¡abÙ§xO is a vector of length m. The matrix A may be dense or sparse (usually sparse).€ögMethodsÙ¯‚€öeNotesÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaAx({sparse matrix, ndarray, LinearOperator}Ù¹‚‰Ù§x.Matrix A in the linear system. Alternatively, Ù¡aAÙ§x, can be a linear operator which can produce Ù¡bAxÙ§e and Ù¡eA^H xÙ§n using, e.g., Ù¡x"scipy.sparse.linalg.LinearOperatorÙ§a.€Ù°ƒabvarray_like, shape (m,)Ù¹‚ƒÙ§gVector Ù¡abÙ§v in the linear system.€Ù°ƒddampefloatƒÙ¹‚ƒÙ§x.Damping factor for regularized least-squares. Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§x2 solves the regularized least-squares problem::   €ÙÀx1min ||(b) - (  A   )x||
    ||(0)   (damp*I) ||_2Ù¹‚Ù§xiwhere damp is a scalar.  If damp is None or 0, the system is solved without regularization. Default is 0.€Ù°ƒjatol, btolofloat, optionalÙ¹‚˜#Ù§uStopping tolerances. Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§x} continues iterations until a certain backward error estimate is smaller than some quantity depending on atol and btol.  Let Ù¡jr = b - AxÙ§x= be the residual vector for the current approximate solution Ù¡axÙ§e. If Ù¡fAx = bÙ§x seems to be consistent, Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§q terminates when Ù¡x4norm(r) <= atol * norm(A) * norm(x) + btol * norm(b)Ù§m. Otherwise, Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§q terminates when Ù¡x'norm(A^H r) <=
atol * norm(A) * norm(r)Ù§x6.  If both tolerances are 1.0e-6 (default), the final Ù¡gnorm(r)Ù§x2 should be accurate to about 6 digits. (The final Ù¡axÙ§x6 will usually have fewer correct digits, depending on Ù¡gcond(A)Ù§x and the size of LAMBDA.)  If Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§d or Ù¢„dbtolÙ „ööelocaldbtolelocalõÙ§x| is None, a default value of 1.0e-6 will be used. Ideally, they should be estimates of the relative error in the entries of Ù¡aAÙ§e and Ù¡abÙ§x/ respectively.  For example, if the entries of Ù¡aAÙ§x have 7 correct digits, set Ù¡katol = 1e-7Ù§xc. This prevents the algorithm from doing unnecessary work beyond the uncertainty of the input data.€Ù°ƒfconlimofloat, optionalÙ¹‚Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§x terminates if an estimate of Ù¡gcond(A)Ù§i exceeds Ù¢„fconlimÙ „ööelocalfconlimelocalõÙ§x.  For compatible systems Ù¡fAx = bÙ§xJ, conlim could be as large as 1.0e+12 (say).  For least-squares problems, Ù¢„fconlimÙ „ööelocalfconlimelocalõÙ§x  should be less than 1.0e+8. If Ù¢„fconlimÙ „ööelocalfconlimelocalõÙ§xS is None, the default value is 1e+8.  Maximum precision can be obtained by setting Ù¡xatol = btol = conlim = 0Ù§xE, but the number of iterations may then be excessive. Default is 1e8.€Ù°ƒgmaxitermint, optionalÙ¹‚ˆÙ¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§x0 terminates if the number of iterations reaches Ù¢„gmaxiterÙ „ööelocalgmaxiterelocalõÙ§r.  The default is Ù¡smaxiter = min(m, n)Ù§x2.  For ill-conditioned systems, a larger value of Ù¢„gmaxiterÙ „ööelocalgmaxiterelocalõÙ§x! may be needed. Default is False.€Ù°ƒdshownbool, optionalÙ¹‚ƒÙ§xPrint iterations logs if Ù¡ishow=TrueÙ§s. Default is False.€Ù°ƒbx0x array_like, shape (n,), optional‚Ù¹‚ƒÙ§qInitial guess of Ù¡axÙ§x*, if None zeros are used. Default is None.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.0.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ˆÙ°ƒaxpndarray of floatÙ¹‚Ù§xLeast-square solution returned.€Ù°ƒeistopcint‚Ù¹‚Ù§x)istop gives the reason for stopping::    €ÙÀyvistop   = 0 means x=0 is a solution.  If x0 was given, then x=x0 is a
            solution.
        = 1 means x is an approximate solution to A@x = B,
            according to atol and btol.
        = 2 means x approximately solves the least-squares problem
            according to atol.
        = 3 means COND(A) seems to be greater than CONLIM.
        = 4 is the same as 1 with atol = btol = eps (machine
            precision)
        = 5 is the same as 2 with atol = eps.
        = 6 is the same as 3 with CONLIM = 1/eps.
        = 7 means ITN reached maxiter before the other stopping
            conditions were satisfied.Ù°ƒcitncintÙ¹‚Ù§xNumber of iterations used.€Ù°ƒenormrefloatÙ¹‚Ù¡jnorm(b-Ax)€Ù°ƒfnormarefloatÙ¹‚Ù¡rnorm(A^H (b - Ax))€Ù°ƒenormaefloatÙ¹‚Ù¡gnorm(A)€Ù°ƒecondaefloatÙ¹‚Ù§vCondition number of A.€Ù°ƒenormxefloatÙ¹‚Ù¡gnorm(x)€ögSummaryÙ¯‚Ù¹‚Ù§x,Iterative solver for least-squares problems.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshExamplesx$/scipy/sparse/linalg/_isolve/lsmr.pyr<class 'function'>x5scipy.signal._filter_design.optimize._lsq.dogbox.lsmrÙ¯‚Ù´ƒ˜:Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)`fexecedÙ¹‚‚Ù§x+The first example has the trivial solution Ù£ƒf[0, 0]öö€Ù´ƒ˜2Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`eistopÙ±‚`a,Ù±‚`a Ù±‚`citnÙ±‚`a,Ù±‚`a Ù±‚`enormrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a[Ù±‚`a:Ù±‚bmia4Ù±‚`a]Ù±‚`a
Ù±‚`eistopa0fexecedÙ´ƒÙ±‚`axoarray([0., 0.])fexecedÙ¹‚‡Ù§rThe stopping code Ù£ƒgistop=0ööÙ§xZ returned indicates that a vector of zeros was found as a solution. The returned solution Ù¢„axÙ „ööelocalaxelocalõÙ§q indeed contains Ù£ƒh[0., 0.]ööÙ§x.. The next example has a non-trivial solution:€Ù´ƒ˜3Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfb1.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`eistopÙ±‚`a,Ù±‚`a Ù±‚`citnÙ±‚`a,Ù±‚`a Ù±‚`enormrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a[Ù±‚`a:Ù±‚bmia4Ù±‚`a]Ù±‚`a
Ù±‚`eistopa1fexecedÙ´ƒÙ±‚`axqarray([ 1., -1.])fexecedÙ´ƒÙ±‚`citna1fexecedÙ´ƒÙ±‚`enormru4.440892098500627e-16fexecedÙ¹‚‰Ù§pAs indicated by Ù£ƒgistop=1ööÙ§b, Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ§xC found a solution obeying the tolerance limits. The given solution Ù£ƒi[1., -1.]ööÙ§xp obviously solves the equation. The remaining return values include information about the number of iterations (Ù£ƒeitn=1ööÙ§x²) and the remaining difference of left and right side of the solved equation. The final example demonstrates the behavior in the case where there is no solution for the equation:€Ù´ƒ˜3Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfd0.01Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfb1.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`eistopÙ±‚`a,Ù±‚`a Ù±‚`citnÙ±‚`a,Ù±‚`a Ù±‚`enormrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dlsmrÙ „escipye1.8.0fmodulex%scipy.sparse.linalg._isolve.lsmr.lsmrfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a[Ù±‚`a:Ù±‚bmia4Ù±‚`a]Ù±‚`a
Ù±‚`eistopa2fexecedÙ´ƒÙ±‚`axx!array([ 1.00333333, -0.99666667])fexecedÙ´ƒˆÙ±‚`aAÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚aoa-Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx.array([ 0.00333333, -0.00333333,  0.00333333])fexecedÙ´ƒÙ±‚`enormrt0.005773502691896255fexecedÙ¹‚†Ù¢„eistopÙ „ööelocaleistopelocalõÙ§x4 indicates that the system is inconsistent and thus Ù¢„axÙ „ööelocalaxelocalõÙ§xO is rather an approximate solution to the corresponding least-squares problem. Ù¢„enormrÙ „ööelocalenormrelocalõÙ§x. contains the minimal distance that was found.€ö€e1.8.0Ù«xclsmr(A, b, damp=0.0, atol=1e-06, btol=1e-06, conlim=100000000.0, maxiter=None, show=False, x0=None)öx%scipy.sparse.linalg._isolve.lsmr.lsmr€
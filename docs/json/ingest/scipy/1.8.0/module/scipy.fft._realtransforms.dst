Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚—ÙÆƒgwarningx:For ``type in {2, 3}``, ``norm="ortho"`` breaks the directÙ¹‚Ù§xjcorrespondence with the direct Fourier transform. To recover it you must specify ``orthogonalize=False``. €Ù¹‚‡Ù§dFor Ù¡lnorm="ortho"Ù§j both the Ù¢„cdstÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dstfmoduleõÙ§e and Ù¢„didstÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.idstfmoduleõÙ§xã are scaled by the same overall factor in both directions. By default, the transform is also orthogonalized which for types 2 and 3 means the transform definition is modified to give orthogonality of the DST matrix (see below).€Ù¹‚‹Ù§dFor Ù¡onorm="backward"Ù§x, there is no scaling on the Ù¢„cdstÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dstfmoduleõÙ§i and the Ù¢„didstÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.idstfmoduleõÙ§n is scaled by Ù¡c1/NÙ§g where Ù¡aNÙ§x" is the "logical" size of the DST.€Ù¹‚Ù§x°There are, theoretically, 8 types of the DST for different combinations of even/odd boundary conditions and boundary off sets , only the first 4 types are implemented in SciPy.€Ù¹‚Ù©Ù§fType I€Ù¹‚‡Ù§xEThere are several definitions of the DST-I; we use the following for Ù¡onorm="backward"Ù§x(. DST-I assumes the input is odd around Ù¥dn=-1Ù§e and Ù¥cn=NÙ§a.€Ù¤xXy_k = 2 \sum_ { n=0}^ { N - 1} x_n \sin\left ( \frac { \pi ( k+1) ( n+1)} { N+1}\right) Ù¹‚ƒÙ§xvNote that the DST-I is only supported for input size > 1. The (unnormalized) DST-I is its own inverse, up to a factor Ù¥f2(N+1)Ù§x7. The orthonormalized DST-I is exactly its own inverse.€Ù¹‚„Ù¡morthogonalizeÙ§xW has no effect here, as the DST-I matrix is already orthogonal up to a scale factor of Ù¡b2NÙ§a.€Ù¹‚Ù©Ù§gType II€Ù¹‚ŠÙ§xFThere are several definitions of the DST-II; we use the following for Ù¡onorm="backward"Ù§x). DST-II assumes the input is odd around Ù¥fn=-1/2Ù§e and Ù¥gn=N-1/2Ù§x; the output is odd around Ù¥dk=-1Ù§q and even around Ù¥ek=N-1€Ù¤xXy_k = 2 \sum_ { n=0}^ { N - 1} x_n \sin\left ( \frac { \pi ( k+1) ( 2n+1)} { 2N}\right) Ù¹‚‹Ù§cIf Ù¡rorthogonalize=TrueÙ§b, Ù¡dy[0]Ù§l is divided Ù¥h\sqrt{2}Ù§x which, when combined with Ù¡lnorm="ortho"Ù§x>, makes the corresponding matrix of coefficients orthonormal (Ù¡sO @ O.T = np.eye(N)Ù§b).€Ù¹‚Ù©Ù§hType III€Ù¹‚†Ù§xHThere are several definitions of the DST-III, we use the following (for Ù¡onorm="backward"Ù§x+). DST-III assumes the input is odd around Ù¥dn=-1Ù§q and even around Ù¥en=N-1€Ù¤xoy_k = ( - 1)^k x_ { N - 1} + 2 \sum_ { n=0}^ { N - 2} x_n \sin\left ( \frac { \pi ( 2k+1) ( n+1)} { 2N}\right) Ù¹‚‹Ù§cIf Ù¡rorthogonalize=TrueÙ§b, Ù¡dx[0]Ù§r is multiplied by Ù¥h\sqrt{2}Ù§x which, when combined with Ù¡lnorm="ortho"Ù§x>, makes the corresponding matrix of coefficients orthonormal (Ù¡sO @ O.T = np.eye(N)Ù§b).€Ù¹‚ƒÙ§xWThe (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up to a factor Ù¥b2NÙ§xS. The orthonormalized DST-III is exactly the inverse of the orthonormalized DST-II.€Ù¹‚Ù©Ù§gType IV€Ù¹‚†Ù§xGThere are several definitions of the DST-IV, we use the following (for Ù¡onorm="backward"Ù§x*). DST-IV assumes the input is odd around Ù¥fn=-0.5Ù§q and even around Ù¥gn=N-0.5€Ù¤xYy_k = 2 \sum_ { n=0}^ { N - 1} x_n \sin\left ( \frac { \pi ( 2k+1) ( 2n+1)} { 4N}\right) Ù¹‚„Ù¡morthogonalizeÙ§xX has no effect here, as the DST-IV matrix is already orthogonal up to a scale factor of Ù¡b2NÙ§a.€Ù¹‚ƒÙ§x=The (unnormalized) DST-IV is its own inverse, up to a factor Ù¥b2NÙ§x8. The orthonormalized DST-IV is exactly its own inverse.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaxjarray_likeÙ¹‚Ù§pThe input array.€Ù°ƒdtypev{1, 2, 3, 4}, optionalÙ¹‚Ù§x/Type of the DST (see Notes). Default type is 2.€Ù°ƒanmint, optionalÙ¹‚‹Ù§xLength of the transform. If Ù¡qn < x.shape[axis]Ù§b, Ù¢„axÙ „ööelocalaxelocalõÙ§s is truncated.  If Ù¡qn > x.shape[axis]Ù§b, Ù¢„axÙ „ööelocalaxelocalõÙ§x( is zero-padded. The default results in Ù¡qn = x.shape[axis]Ù§a.€Ù°ƒdaxismint, optionalÙ¹‚ƒÙ§xOAxis along which the dst is computed; the default is over the last axis (i.e., Ù¡gaxis=-1Ù§b).€Ù°ƒdnormx*{"backward", "ortho", "forward"}, optionalÙ¹‚Ù§x6Normalization mode (see Notes). Default is "backward".€Ù°ƒkoverwrite_xnbool, optionalÙ¹‚ƒÙ§xIf True, the contents of Ù¢„axÙ „ööelocalaxelocalõÙ§x( can be destroyed; the default is False.€Ù°ƒgworkersmint, optionalÙ¹‚…Ù§xdMaximum number of workers to use for parallel computation. If negative, the value wraps around from Ù¡nos.cpu_count()Ù§f. See Ù¢„cfftÙ „escipya*capitscipy.fft._basic.fftfmoduleõÙ§r for more details.€Ù°ƒmorthogonalizenbool, optional‚Ù¹‚‡Ù§xGWhether to use the orthogonalized DST variant (see Notes). Defaults to Ù¡dTrueÙ§f when Ù¡mnorm=="ortho"Ù§e and Ù¡eFalseÙ§k otherwise.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.8.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcdstpndarray of realsÙ¹‚Ù§xThe transformed input array.€ögSummaryÙ¯‚Ù¹‚Ù§x@Return the Discrete Sine Transform of arbitrary type sequence x.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNotesjReferencesx/scipy/fft/_realtransforms.pyìx<class 'uarray._Function'>x&scipy.signal._filter_design.sp_fft.dstÙ¯‚€öÙ¼ƒÙ»ƒdidstxscipy.fft._realtransforms.idstõÙ¹‚Ù§kInverse DST€öe1.8.0Ù«ööxscipy.fft._realtransforms.dst€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x'This function uses the SuperLU library.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒaAmsparse matrixÙ¹‚Ù§x;Sparse matrix to factorize. Should be in CSR or CSC format.€Ù°ƒjpermc_specmstr, optional‚Ù¹‚Ù§xWHow to permute the columns of the matrix for sparsity preservation. (default: 'COLAMD')€ÙÈ„Ù¹‚‚Ù¡gNATURALÙ§s: natural ordering.€Ù¹‚‚Ù¡gMMD_ATAÙ§x4: minimum degree ordering on the structure of A^T A.€Ù¹‚‚Ù¡mMMD_AT_PLUS_AÙ§x4: minimum degree ordering on the structure of A^T+A.€Ù¹‚‚Ù¡fCOLAMDÙ§x,: approximate minimum degree column ordering€Ù°ƒqdiag_pivot_threshofloat, optionalÙ¹‚Ù§xcThreshold used for a diagonal entry to be an acceptable pivot. See SuperLU user's guide for details€Ù°ƒerelaxmint, optionalÙ¹‚Ù§xeExpert option for customizing the degree of relaxing supernodes. See SuperLU user's guide for details€Ù°ƒjpanel_sizemint, optionalÙ¹‚Ù§xRExpert option for customizing the panel size. See SuperLU user's guide for details€Ù°ƒgoptionsndict, optionalÙ¹‚ƒÙ§x«Dictionary containing additional expert options to SuperLU. See SuperLU user guide  (section 2.4 on the 'Options' argument) for more details. For example, you can specify Ù¡x/options=dict(Equil=False, IterRefine='SINGLE'))Ù§xE to turn equilibration off and perform a single iterative refinement.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdinvAxscipy.sparse.linalg.SuperLUÙ¹‚ƒÙ§tObject, which has a Ù¡esolveÙ§h method.€ögSummaryÙ¯‚Ù¹‚Ù§x8Compute the LU decomposition of a sparse, square matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx(/scipy/sparse/linalg/_dsolve/linsolve.pyør<class 'function'>x(scipy.signal._ltisys.integrate._bvp.spluÙ¯‚ƒÙ´ƒ˜lÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„dspluÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._dsolve.linsolve.splufmoduleõÙ±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb5.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb2.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`aBÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dspluÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._dsolve.linsolve.splufmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb2.Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`aBÙ±‚aoa.Ù±‚`esolveÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)xarray([ 1. , -3. , -1.5])fexecedÙ´ƒ‹Ù±‚`aAÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`aBÙ±‚aoa.Ù±‚`esolveÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)varray([ 1.,  2.,  3.])fexecedÙ´ƒ‹Ù±‚`aBÙ±‚aoa.Ù±‚`esolveÙ±‚`a(Ù±‚`aAÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)varray([ 1.,  2.,  3.])fexecedöÙ¼ƒÙ»ƒespilux*scipy.sparse.linalg._dsolve.linsolve.spiluõÙ¹‚Ù§xincomplete LU decomposition€öe1.8.0Ù«xYsplu(A, permc_spec=None, diag_pivot_thresh=None, relax=None, panel_size=None, options={})öx)scipy.sparse.linalg._dsolve.linsolve.splu€
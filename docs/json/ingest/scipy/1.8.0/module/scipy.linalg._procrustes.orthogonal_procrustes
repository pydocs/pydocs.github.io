Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xGiven matrices A and B of equal shape, find an orthogonal matrix R that most closely maps A to B using the algorithm given in .€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§xÁNote that unlike higher level Procrustes analyses of spatial data, this function only uses orthogonal transformations like rotations and reflections, and it does not use scaling or translation.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.15.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaAq(M, N) array_likeÙ¹‚Ù§tMatrix to be mapped.€Ù°ƒaBq(M, N) array_likeÙ¹‚Ù§nTarget matrix.€Ù°ƒlcheck_finitenbool, optionalÙ¹‚Ù§xÏWhether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.€öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚Ù§xcIf the input array shapes don't match or if check_finite is True and the arrays contain Inf or NaN.€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaRn(N, N) ndarrayÙ¹‚…Ù§xZThe matrix solution of the orthogonal Procrustes problem. Minimizes the Frobenius norm of Ù¡k(A @ R) - BÙ§m, subject to Ù¡kR.T @ R = IÙ§a.€Ù°ƒescaleefloatÙ¹‚ƒÙ§xSum of the singular values of Ù¡gA.T @ BÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§xACompute the matrix solution of the orthogonal Procrustes problem.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseseNotesjReferenceshExamplesx/scipy/linalg/_procrustes.pyr<class 'function'>x9scipy.signal._lti_conversion.linalg.orthogonal_procrustesÙ¯‚„Ù´ƒ˜+Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„uorthogonal_procrustesÙ „escipye1.8.0fmodulex.scipy.linalg._procrustes.orthogonal_procrustesfmoduleõÙ±‚`a
Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`b  Ù±‚bmia0Ù±‚`a,Ù±‚`b  Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia2Ù±‚`a,Ù±‚`b  Ù±‚bmia0Ù±‚`a,Ù±‚`b  Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚Ù§xAFlip the order of columns and check for the anti-diagonal mapping€Ù´ƒ•Ù±‚`aRÙ±‚`a,Ù±‚`a Ù±‚`cscaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„uorthogonal_procrustesÙ „escipye1.8.0fmodulex.scipy.linalg._procrustes.orthogonal_procrustesfmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffliplrÙ „enumpyf1.22.3fmodulelnumpy.fliplrfmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aRÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx´array([[-5.34384992e-17,  0.00000000e+00,  1.00000000e+00],
       [ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
       [ 1.00000000e+00,  0.00000000e+00, -7.85941422e-17]])fexecedÙ´ƒÙ±‚`Ù¢„cscaÙ „enumpyf1.22.3fmodulennumpy.floatingfmoduleõc9.0fexecedö€e1.8.0Ù«x.orthogonal_procrustes(A, B, check_finite=True)öx.scipy.linalg._procrustes.orthogonal_procrustes€
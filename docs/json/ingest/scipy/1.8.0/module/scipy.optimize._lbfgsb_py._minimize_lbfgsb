Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§kThe option Ù¢„dftolÙ „ööelocaldftolelocalõÙ§t is exposed via the Ù¢„wscipy.optimize.minimizeÙ „escipya*capix!scipy.optimize._minimize.minimizefmoduleõÙ§x interface, but calling Ù¢„xscipy.optimize.fmin_l_bfgs_bÙ „escipya*capix'scipy.optimize._lbfgsb_py.fmin_l_bfgs_bfmoduleõÙ§r directly exposes Ù£ƒefactrööÙ§x&. The relationship between the two is Ù¡x%ftol = factr * numpy.finfo(float).epsÙ§h. I.e., Ù£ƒefactrööÙ§xF multiplies the default machine floating-point precision to arrive at Ù¢„dftolÙ „ööelocaldftolelocalõÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒddispkNone or intÙ¹‚‰Ù§cIf Ù£ƒldisp is NoneööÙ§x- (the default), then the supplied version of Ù¢„fiprintÙ „ööelocalfiprintelocalõÙ§m is used. If Ù£ƒpdisp is not NoneööÙ§x,, then it overrides the supplied version of Ù¢„fiprintÙ „ööelocalfiprintelocalõÙ§x! with the behaviour you outlined.€Ù°ƒfmaxcorcintÙ¹‚Ù§xĞThe maximum number of variable metric corrections used to define the limited memory matrix. (The limited memory BFGS method does not store the full hessian but uses this many terms in an approximation to it.)€Ù°ƒdftolefloatÙ¹‚ƒÙ§xThe iteration stops when Ù¡x.(f^k -
f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= ftolÙ§a.€Ù°ƒdgtolefloatÙ¹‚…Ù§xThe iteration will stop when Ù¡x&max{|proj g_i | i = 1, ..., n}
<= gtolÙ§g where Ù¡dpg_iÙ§x1 is the i-th component of the projected gradient.€Ù°ƒcepspfloat or ndarrayÙ¹‚ƒÙ§cIf Ù£ƒkjac is NoneööÙ§xa the absolute step size used for numerical approximation of the jacobian via forward differences.€Ù°ƒfmaxfuncintÙ¹‚Ù§x'Maximum number of function evaluations.€Ù°ƒgmaxitercintÙ¹‚Ù§xMaximum number of iterations.€Ù°ƒfiprintmint, optionalÙ¹‚Ù§x"Controls the frequency of output. Ù¡jiprint < 0Ù§r means no output; Ù¡jiprint = 0Ù§x/    print only one line at the last iteration; Ù¡o0 < iprint < 99Ù§r print also f and Ù¡h|proj g|Ù§x every iprint iterations; Ù¡kiprint = 99Ù§x6   print details of every iteration except n-vectors; Ù¡liprint = 100Ù§x4  print also the changes of active set and final x; Ù¡liprint > 100Ù§x5  print details of every iteration including x and g.€Ù°ƒhcallbackrcallable, optionalÙ¹‚…Ù§x Called after each iteration, as Ù¡lcallback(xk)Ù§h, where Ù¡bxkÙ§x! is the current parameter vector.€Ù°ƒemaxlsmint, optionalÙ¹‚Ù§xCMaximum number of line search steps (per iteration). Default is 20.€Ù°ƒtfinite_diff_rel_stepxNone or array_like, optionalÙ¹‚‰Ù§cIf Ù£ƒx#jac in ['2-point', '3-point', 'cs']ööÙ§xr the relative step size to use for numerical approximation of the jacobian. The absolute step size is computed as Ù¡x)h = rel_step * sign(x0) * max(1, abs(x0))Ù§x0, possibly adjusted to fit into the bounds. For Ù¡pmethod='3-point'Ù§m the sign of Ù£ƒahööÙ§xC is ignored. If None (default) then step is selected automatically.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xQMinimize a scalar function of one or more variables using the L-BFGS-B algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummaryjParameterseNotesx/scipy/optimize/_lbfgsb_py.pyÔr<class 'function'>x@scipy.signal._filter_design.optimize._lbfgsb_py._minimize_lbfgsbÙ¯‚€ö€e1.8.0Ù«xñ_minimize_lbfgsb(fun, x0, args=(), jac=None, bounds=None, disp=None, maxcor=10, ftol=2.220446049250313e-09, gtol=1e-05, eps=1e-08, maxfun=15000, maxiter=15000, iprint=-1, callback=None, maxls=20, finite_diff_rel_step=None, **unknown_options)öx*scipy.optimize._lbfgsb_py._minimize_lbfgsb€
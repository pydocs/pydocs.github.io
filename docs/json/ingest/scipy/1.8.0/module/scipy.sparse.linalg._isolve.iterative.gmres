Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚ƒÙ§x‰A preconditioner, P, is chosen such that P is close to A but easy to solve for. The preconditioner parameter required by this routine is Ù¡hM = P^-1Ù§xt. The inverse should preferably not be calculated explicitly.  Rather, use the following template to produce M::    €ÙÀx # Construct a linear operator that computes P^-1 @ x.
import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)öpOther ParametersÙ¯‚ˆÙ°ƒbx0gndarrayÙ¹‚Ù§x?Starting guess for the solution (a vector of zeros by default).€Ù°ƒitol, atolofloat, optional‚Ù¹‚‡Ù§xTolerances for convergence, Ù¡x(norm(residual) <= max(tol*norm(b), atol)Ù§r. The default for Ù¡datolÙ§d is Ù¡h'legacy'Ù§x-, which emulates a different legacy behavior.€ÙÆƒgwarning`Ù¹‚Ù§xwThe default value for `atol` will be changed in a future release. For future compatibility, specify `atol` explicitly. €Ù°ƒgrestartmint, optionalÙ¹‚Ù§x‚Number of iterations between restarts. Larger values increase iteration cost, but may be necessary for convergence. Default is 20.€Ù°ƒgmaxitermint, optionalÙ¹‚Ù§xMaximum number of iterations (restart cycles).  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.€Ù°ƒaMx({sparse matrix, ndarray, LinearOperator}Ù¹‚Ù§y3Inverse of the preconditioner of A.  M should approximate the inverse of A and be easy to solve for (see Notes).  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance.  By default, no preconditioner is used.€Ù°ƒhcallbackhfunctionÙ¹‚‡Ù§xFUser-supplied function to call after each iteration.  It is called as Ù£ƒncallback(args)ööÙ§h, where Ù£ƒdargsööÙ§q are selected by Ù¢„mcallback_typeÙ „ööelocalmcallback_typeelocalõÙ§a.€Ù°ƒmcallback_typex${'x', 'pr_norm', 'legacy'}, optionalÙÁÙÅ‚Ù¹‚Ù§x%Callback function argument requested:€ÙÈƒÙ¹‚‚Ù¡axÙ§x4: current iterate (ndarray), called on every restart€Ù¹‚‚Ù¡gpr_normÙ§xV: relative (preconditioned) residual norm (float),     called on every inner iteration€Ù¹‚„Ù¡flegacyÙ§t (default): same as Ù¡gpr_normÙ§xh, but also changes the     meaning of 'maxiter' to count inner iterations instead of restart     cycles.€Ù°ƒfrestrtmint, optionalÙ¹‚ƒÙ§qDEPRECATED - use Ù¢„grestartÙ „escipye1.8.0fmodulex3scipy.optimize._nonlin.LowRankMatrix.restart_reducefmoduleõÙ§i instead.€öjParametersÙ¯‚‚Ù°ƒaAx({sparse matrix, ndarray, LinearOperator}Ù¹‚‡Ù§xGThe real or complex N-by-N matrix of the linear system. Alternatively, Ù¡aAÙ§x, can be a linear operator which can produce Ù¡bAxÙ§n using, e.g., Ù¡x"scipy.sparse.linalg.LinearOperatorÙ§a.€Ù°ƒabgndarrayÙ¹‚Ù§x>Right hand side of the linear system. Has shape (N,) or (N,1).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaxgndarrayÙ¹‚Ù§wThe converged solution.€Ù°ƒdinfocint€ögSummaryÙ¯‚Ù¹‚ƒÙ§x4Use Generalized Minimal RESidual iteration to solve Ù¡fAx = bÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnspOther ParametershSee AlsoeNoteshExamplesx)/scipy/sparse/linalg/_isolve/iterative.py¯r<class 'function'>xOscipy.signal._filter_design.optimize._differentiable_functions.sps.linalg.gmresÙ¯‚‚Ù´ƒ˜sÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„egmresÙ „escipye1.8.0fmodulex+scipy.sparse.linalg._isolve.iterative.gmresfmoduleõÙ±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`hexitCodeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„egmresÙ „escipye1.8.0fmodulex+scipy.sparse.linalg._isolve.iterative.gmresfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`hexitCodeÙ±‚`a)Ù±‚`l            Ù±‚bc1x$# 0 indicates successful convergencea0fexecedÙ´ƒÙ±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aAÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedöÙ¼ƒÙ»ƒnLinearOperatorx-scipy.sparse.linalg._interface.LinearOperatorõ€öe1.8.0Ù«x~gmres(A, b, x0=None, tol=1e-05, restart=None, maxiter=None, M=None, callback=None, restrt=None, atol=None, callback_type=None)öx+scipy.sparse.linalg._isolve.iterative.gmres€
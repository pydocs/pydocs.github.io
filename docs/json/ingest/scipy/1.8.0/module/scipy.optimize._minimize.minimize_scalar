Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‰Ù¹‚ƒÙ§xsThis section describes the available solvers that can be selected by the 'method' parameter. The default method is Ù¨Ù§eBrentÙ§a.€Ù¹‚ƒÙ§gMethod Ù£ƒx&Brent <optimize.minimize_scalar-brent>öcrefÙ§x¨ uses Brent's algorithm to find a local minimum.  The algorithm uses inverse parabolic interpolation when possible to speed up convergence of the golden section method.€Ù¹‚…Ù§gMethod Ù£ƒx(Golden <optimize.minimize_scalar-golden>öcrefÙ§xš uses the golden section search technique. It uses analog of the bisection method to decrease the bracketed interval. It is usually preferable to use the Ù¨Ù§eBrentÙ§h method.€Ù¹‚ƒÙ§gMethod Ù£ƒx*Bounded <optimize.minimize_scalar-bounded>öcrefÙ§xs can perform bounded minimization. It uses the Brent method to find a local minimum in the interval x1 < xopt < x2.€Ù¹‚Ù©Ù§qCustom minimizers€Ù¹‚ƒÙ§xIt may be useful to pass a custom minimization method, for example when using some library frontend to minimize_scalar. You can simply pass a callable as the Ù¡fmethodÙ§k parameter.€Ù¹‚‘Ù§xThe callable is called as Ù¡x&method(fun, args, **kwargs, **options)Ù§g where Ù¡fkwargsÙ§x/ corresponds to any other parameters passed to Ù¢„hminimizeÙ „escipye1.8.0fmodulex!scipy.optimize._minimize.minimizefmoduleõÙ§j (such as Ù¢„gbracketÙ „escipye1.8.0fmodulex scipy.optimize._optimize.bracketfmoduleõÙ§b, Ù¢„ctolÙ „ööelocalctolelocalõÙ§t, etc.), except the Ù¢„goptionsÙ „ööelocalgoptionselocalõÙ§x- dict, which has its contents also passed as Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§x6 parameters pair by pair.  The method shall return an Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§h object.€Ù¹‚…Ù§mThe provided Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§xo callable must be able to accept (and possibly ignore) arbitrary parameters; the set of parameters accepted by Ù¢„hminimizeÙ „escipye1.8.0fmodulex!scipy.optimize._minimize.minimizefmoduleõÙ§x may expand in future versions and then these parameters will be passed to the method. You can find an example in the scipy.optimize tutorial.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒcfunhcallableÙ¹‚Ù§x:Objective function. Scalar function, must return a scalar.€Ù°ƒgbracketrsequence, optionalÙ¹‚‘Ù§x"For methods 'brent' and 'golden', Ù¢„gbracketÙ „escipye1.8.0fmodulex scipy.optimize._optimize.bracketfmoduleõÙ§xA defines the bracketing interval and can either have three items Ù¡i(a, b, c)Ù§i so that Ù¡ia < b < cÙ§e and Ù¡wfun(b) < fun(a), fun(c)Ù§n or two items Ù¡aaÙ§e and Ù¡acÙ§xP which are assumed to be a starting interval for a downhill bracket search (see Ù¢„gbracketÙ „escipye1.8.0fmodulex scipy.optimize._optimize.bracketfmoduleõÙ§xB); it doesn't always mean that the obtained solution will satisfy Ù¡ka <= x <= cÙ§a.€Ù°ƒfboundsrsequence, optionalÙ¹‚ƒÙ§vFor method 'bounded', Ù¢„fboundsÙ „ööelocalfboundselocalõÙ§xO is mandatory and must have two items corresponding to the optimization bounds.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§x1Extra arguments passed to the objective function.€Ù°ƒfmethodxstr or callable, optionalƒÙ¹‚Ù§x"Type of solver.  Should be one of:€Ù·„x/- :ref:`Brent <optimize.minimize_scalar-brent>`x3- :ref:`Bounded <optimize.minimize_scalar-bounded>`x1- :ref:`Golden <optimize.minimize_scalar-golden>`xA- custom - a callable object (added in version 0.14.0), see belowÙ¹‚Ù§x3See the 'Notes' section for details of each solver.€Ù°ƒctolofloat, optionalÙ¹‚Ù§xMTolerance for termination. For detailed control, use solver-specific options.€Ù°ƒgoptionsndict, optionalƒÙ¹‚Ù§xA dictionary of solver options.€Ù·„mmaxiter : intx,    Maximum number of iterations to perform.kdisp : boolx.    Set to True to print convergence messages.Ù¹‚ƒÙ§dSee Ù£ƒnshow_options()ödfuncÙ§x for solver-specific options.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcresnOptimizeResultÙ¹‚‹Ù§x)The optimization result represented as a Ù¡nOptimizeResultÙ§x# object. Important attributes are: Ù¡axÙ§u the solution array, Ù¡gsuccessÙ§xD a Boolean flag indicating if the optimizer exited successfully and Ù¡gmessageÙ§x3 which describes the cause of the termination. See Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x' for a description of other attributes.€ögSummaryÙ¯‚Ù¹‚Ù§x0Minimization of scalar function of one variable.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/optimize/_minimize.pyĞr<class 'function'>x4scipy.signal._filter_design.optimize.minimize_scalarÙ¯‚†Ù¹‚Ù§x:Consider the problem of minimizing the following function.€Ù´ƒ˜#Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2`fexecedÙ¹‚ƒÙ§jUsing the Ù¨Ù§eBrentÙ§x& method, we find the local minimum as:€Ù´ƒ–Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ominimize_scalarÙ „escipye1.8.0fmodulex(scipy.optimize._minimize.minimize_scalarfmoduleõÙ±‚`a
Ù±‚`cresÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ominimize_scalarÙ „escipye1.8.0fmodulex(scipy.optimize._minimize.minimize_scalarfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`cresÙ±‚aoa.Ù±‚`axm1.28077640403fexecedÙ¹‚ƒÙ§jUsing the Ù¨Ù§gBoundedÙ§x: method, we find a local minimum with specified bounds as:€Ù´ƒ˜Ù±‚`cresÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ominimize_scalarÙ „escipye1.8.0fmodulex(scipy.optimize._minimize.minimize_scalarfmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚aoa=Ù±‚`a(Ù±‚aoa-Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„gboundedÙ „escipye1.8.0fmodulex1scipy.optimize._optimize._minimize_scalar_boundedfmoduleõÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`cresÙ±‚aoa.Ù±‚`axm-2.0000002026fexecedö‚Ù¼ƒÙ»ƒhminimizex!scipy.optimize._minimize.minimizeõÙ¹‚Ù§xFInterface to minimization algorithms for scalar multivariate functions€öÙ¼ƒÙ»ƒlshow_optionsx%scipy.optimize._optimize.show_optionsõÙ¹‚Ù§x*Additional options accepted by the solvers€öe1.8.0Ù«x`minimize_scalar(fun, bracket=None, bounds=None, args=(), method='brent', tol=None, options=None)öx(scipy.optimize._minimize.minimize_scalar€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚Ù§y`The linear sum assignment problem  is also known as minimum weight matching in bipartite graphs. A problem instance is described by a matrix C, where each C[i,j] is the cost of matching vertex i of the first partite set (a "worker") and vertex j of the second set (a "job"). The goal is to find a complete assignment of workers to jobs of minimal cost.€Ù¹‚ƒÙ§x*Formally, let X be a boolean matrix where Ù¥jX[i,j] = 1Ù§xH iff row i is assigned to column j. Then the optimal assignment has cost€Ù¤x'\min \sum_i \sum_j C_ { i,j} X_ { i,j} Ù¹‚Ù§x€where, in the case where the matrix X is square, each row is assigned to exactly one column, and each column to exactly one row.€Ù¹‚Ù§xÜThis function can also solve a generalization of the classic assignment problem where the cost matrix is rectangular. If it has more rows than columns, then not every row needs to be assigned to a column, and vice versa.€Ù¹‚Ù§xhThis implementation is a modified Jonker-Volgenant algorithm with no initialization, described in ref. .€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.17.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒkcost_matrixearrayÙ¹‚Ù§x'The cost matrix of the bipartite graph.€Ù°ƒhmaximizeubool (default: False)Ù¹‚Ù§x-Calculates a maximum weight matching if true.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒprow_ind, col_indearrayÙ¹‚…Ù§xAn array of row indices and one of corresponding column indices giving the optimal assignment. The cost of the assignment can be computed as Ù¡x#cost_matrix[row_ind, col_ind].sum()Ù§x\. The row indices will be sorted; in the case of a square cost matrix they will be equal to Ù¡x"numpy.arange(cost_matrix.shape[0])Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§x(Solve the linear sum assignment problem.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/optimize/_lsap.pyr<class 'function'>x:scipy.signal._filter_design.optimize.linear_sum_assignmentÙ¯‚‚Ù´ƒ˜BÙ±‚`Ù¢„dcostÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ulinear_sum_assignmentÙ „escipye1.8.0fmodulex*scipy.optimize._lsap.linear_sum_assignmentfmoduleõÙ±‚`a
Ù±‚`Ù¢„grow_indÙ „escipye1.8.0fmodulex'scipy.sparse._sparsetools.csr_row_indexfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`gcol_indÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ulinear_sum_assignmentÙ „escipye1.8.0fmodulex*scipy.optimize._lsap.linear_sum_assignmentfmoduleõÙ±‚`a(Ù±‚`Ù¢„dcostÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„gcol_indÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõparray([1, 0, 2])fexecedÙ´ƒ‹Ù±‚`Ù¢„dcostÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`Ù¢„grow_indÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„gcol_indÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a]Ù±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`a)a5fexecedöÙ¼ƒÙ»ƒx7scipy.sparse.csgraph.min_weight_full_bipartite_matchingööÙ¹‚Ù§qfor sparse inputs€öe1.8.0Ù«x2linear_sum_assignment(cost_matrix, maximize=False)öx*scipy.optimize._lsap.linear_sum_assignment€
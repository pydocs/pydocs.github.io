Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ§a/Ù¢„eihfftÙ „escipye1.8.0fmodulevscipy.fft._basic.ihfftfmoduleõÙ§x are a pair analogous to Ù¢„drfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.rfftfmoduleõÙ§a/Ù¢„eirfftÙ „escipye1.8.0fmodulevscipy.fft._basic.irfftfmoduleõÙ§x‹, but for the opposite case: here the signal has Hermitian symmetry in the time domain and is real in the frequency domain. So, here, it's Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ§xQ, for which you must supply the length of the result if it is to be odd. * even: Ù¡x ihfft(hfft(a, 2*len(a) - 2) == aÙ§x , within roundoff error, * odd: Ù¡x ihfft(hfft(a, 2*len(a) - 1) == aÙ§x, within roundoff error.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaxjarray_likeÙ¹‚Ù§pThe input array.€Ù°ƒanmint, optionalÙ¹‚Ù§x2Length of the transformed axis of the output. For Ù¢„anÙ „ööelocalanelocalõÙ§p output points, Ù¡hn//2 + 1Ù§x† input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If Ù¢„anÙ „ööelocalanelocalõÙ§x! is not given, it is taken to be Ù¡g2*(m-1)Ù§h, where Ù¡amÙ§x8 is the length of the input along the axis specified by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§a.€Ù°ƒdaxismint, optionalÙ¹‚Ù§xHAxis over which to compute the FFT. If not given, the last axis is used.€Ù°ƒdnormx*{"backward", "ortho", "forward"}, optionalÙ¹‚ƒÙ§xNormalization mode (see Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ§x). Default is "backward".€Ù°ƒkoverwrite_xnbool, optionalÙ¹‚…Ù§xIf True, the contents of Ù¢„axÙ „ööelocalaxelocalõÙ§x- can be destroyed; the default is False. See Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ§r for more details.€Ù°ƒgworkersmint, optionalÙ¹‚…Ù§xdMaximum number of workers to use for parallel computation. If negative, the value wraps around from Ù¡nos.cpu_count()Ù§f. See Ù¢„cfftÙ „escipya*capitscipy.fft._basic.fftfmoduleõÙ§r for more details.€Ù°ƒdplanpobject, optional‚Ù¹‚Ù§x‚This argument is reserved for passing in a precomputed plan provided by downstream FFT vendors. It is currently not used in SciPy.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.5.0 €öfRaisesÙ¯‚Ù°ƒ`jIndexErrorÙ¹‚…Ù§cIf Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x! is larger than the last axis of Ù£ƒaaööÙ§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚‘Ù§xLThe truncated or zero-padded input, transformed along the axis indicated by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§u, or the last one if Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x9 is not specified. The length of the transformed axis is Ù¢„anÙ „ööelocalanelocalõÙ§i, or, if Ù¢„anÙ „ööelocalanelocalõÙ§o is not given, Ù¡g2*m - 2Ù§h, where Ù¡amÙ§x\ is the length of the transformed axis of the input. To get an odd number of output points, Ù¢„anÙ „ööelocalanelocalõÙ§x% must be specified, for instance, as Ù¡g2*m - 1Ù§u in the typical case,€ögSummaryÙ¯‚Ù¹‚Ù§xOCompute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplest/scipy/fft/_basic.pyÓx<class 'uarray._Function'>x'scipy.signal._filter_design.sp_fft.hfftÙ¯‚ƒÙ´ƒ˜LÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmib10Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmib10Ù±‚`a
Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia3Ù±‚`ajÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`Ù¢„eroundÙ „escipye1.8.0fmodulex"scipy.special.cython_special.roundfmoduleõÙ±‚`a(Ù±‚bmib10Ù±‚`a)xrarray([ -0.+0.j,   5.+0.j,  -0.+0.j,  15.-0.j,   0.+0.j,   0.+0.j,
        -0.+0.j, -15.-0.j,   0.+0.j,   5.+0.j])fexecedÙ´ƒÙ±‚`Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ±‚`a(Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a[Ù±‚`a:Ù±‚bmia6Ù±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„eroundÙ „escipye1.8.0fmodulex"scipy.special.cython_special.roundfmoduleõÙ±‚`a(Ù±‚bmib10Ù±‚`a)Ù±‚`a Ù±‚bc1x# Input first half of signalxCarray([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])fexecedÙ´ƒ‰Ù±‚`Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ±‚`a(Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a)Ù±‚`b  Ù±‚bc1x"# Input entire signal and truncatexCarray([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])fexecedöƒÙ¼ƒÙ»ƒehfftnvscipy.fft._basic.hfftnõÙ¹‚Ù§x*Compute the N-D FFT of a Hermitian signal.€öÙ¼ƒÙ»ƒeihfftvscipy.fft._basic.ihfftõÙ¹‚ƒÙ§oThe inverse of Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ§a.€öÙ¼ƒÙ»ƒdrfftuscipy.fft._basic.rfftõÙ¹‚Ù§x#Compute the 1-D FFT for real input.€öe1.8.0Ù«ööuscipy.fft._basic.hfft€
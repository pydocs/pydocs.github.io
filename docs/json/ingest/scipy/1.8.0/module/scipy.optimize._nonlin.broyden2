Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x4This method is also known as "Broyden's bad method".€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§xBThis algorithm implements the inverse Jacobian Quasi-Newton update€Ù¤x5H_+ = H + ( dx - H df) df^\dagger / ( df^\dagger df) Ù¹‚Ù§x)corresponding to Broyden's second method.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒaFpfunction(x) -> fÙ¹‚Ù§xIFunction whose root to find; should take and return an array-like object.€Ù°ƒcxinjarray_likeÙ¹‚Ù§xInitial guess for the solution€Ù°ƒealphaofloat, optionalÙ¹‚ƒÙ§x"Initial guess for the Jacobian is Ù¡j(-1/alpha)Ù§a.€Ù°ƒpreduction_methodvstr or tuple, optionalƒÙ¹‚ƒÙ§x”Method used in ensuring that the rank of the Broyden matrix stays low. Can either be a string giving the name of the method, or a tuple of the form Ù¡x(method, param1, param2, ...)Ù§xH that gives the name of the method and values for additional parameters.€Ù¹‚Ù§rMethods available:€Ù·†x@- ``restart``: drop all matrix columns. Has no extra parameters.xA- ``simple``: drop oldest matrix column. Has no extra parameters.x9- ``svd``: keep only the most significant SVD components.x?  Takes an extra parameter, ``to_retain``, which determines thexA  number of SVD components to retain when rank reduction is done.x  Default is ``max_rank - 2``.Ù°ƒhmax_rankmint, optionalÙ¹‚Ù§xSMaximum rank for the Broyden matrix. Default is infinity (i.e., no rank reduction).€Ù°ƒditermint, optionalÙ¹‚Ù§x`Number of iterations to make. If omitted (default), make as many as required to meet tolerances.€Ù°ƒgverbosenbool, optionalÙ¹‚Ù§x*Print status to stdout on every iteration.€Ù°ƒgmaxitermint, optionalÙ¹‚ƒÙ§xNMaximum number of iterations to make. If more are needed to meet convergence, Ù¢„mNoConvergenceÙ „escipye1.8.0fmodulex$scipy.optimize._nonlin.NoConvergencefmoduleõÙ§k is raised.€Ù°ƒef_tolofloat, optionalÙ¹‚Ù§xOAbsolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6.€Ù°ƒff_rtolofloat, optionalÙ¹‚Ù§x:Relative tolerance for the residual. If omitted, not used.€Ù°ƒex_tolofloat, optionalÙ¹‚Ù§x±Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used.€Ù°ƒfx_rtolofloat, optionalÙ¹‚Ù§x1Relative minimum step size. If omitted, not used.€Ù°ƒhtol_normx$function(vector) -> scalar, optionalÙ¹‚Ù§x>Norm to use in convergence check. Default is the maximum norm.€Ù°ƒkline_searchx-{None, 'armijo' (default), 'wolfe'}, optionalÙ¹‚Ù§x‰Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to 'armijo'.€Ù°ƒhcallbackrfunction, optionalÙ¹‚‡Ù§x?Optional callback function. It is called on every iteration as Ù¡ncallback(x, f)Ù§g where Ù£ƒaxööÙ§x is the current solution and Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ§x the corresponding residual.€öfRaisesÙ¯‚Ù°ƒ`mNoConvergenceÙ¹‚Ù§xWhen a solution was not found.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcsolgndarrayÙ¹‚ƒÙ§x#An array (of similar array type as Ù£ƒbx0ööÙ§x ) containing the final solution.€ögSummaryÙ¯‚Ù¹‚Ù§xIFind a root of a function, using Broyden's second Jacobian approximation.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotesjReferenceshExamplest/dev/papyri/<string>ör<class 'function'>x-scipy.signal._filter_design.optimize.broyden2Ù¯‚„Ù¹‚Ù§x>The following functions define a system of nonlinear equations€Ù´ƒ˜JÙ±‚akcdefÙ±‚`a Ù±‚bnfcfunÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`b  Ù±‚aoa+Ù±‚`a Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia3Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a
Ù±‚`l            Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia3Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a]`fexecedÙ¹‚Ù§x&A solution can be obtained as follows.€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚aoa.Ù±‚`Ù¢„hbroyden2Ù „escipye1.8.0fmodulexscipy.optimize._nonlin.broyden2fmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„csolÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxarray([0.84116365, 0.15883529])fexecedöÙ¼ƒÙ»ƒdrootööÙ¹‚ƒÙ§xEInterface to root finding algorithms for multivariate functions. See Ù¡rmethod=='broyden2'Ù§o in particular.€öe1.8.0Ù«xÛbroyden2(F, xin, iter=None, alpha=None, reduction_method='restart', max_rank=None, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)öxscipy.optimize._nonlin.broyden2€
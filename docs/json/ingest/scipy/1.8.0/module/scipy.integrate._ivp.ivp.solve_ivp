Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§xoThis function numerically integrates a system of ordinary differential equations given an initial value::      €ÙÀxdy / dt = f(t, y)
y(t0) = y0Ù¹‚Ù§yHere t is a 1-D independent variable (time), y(t) is an N-D vector-valued function (state), and an N-D vector-valued function f(t, y) determines the differential equations. The goal is to find y(t) approximately satisfying the differential equations, given an initial value y(t0)=y0.€Ù¹‚Ù§ykSome of the solvers support integration in the complex domain, but note that for stiff ODE solvers, the right-hand side must be complex-differentiable (satisfy Cauchy-Riemann equations ). To solve a problem in the complex domain, pass y0 with a complex data type. Another option always available is to rewrite your problem for real and imaginary parts separately.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‘Ù°ƒcfunhcallableÙ¹‚Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(t, y)Ù§g. Here Ù¢„atÙ „ööelocalatelocalõÙ§x8 is a scalar, and there are two options for the ndarray Ù¢„ayÙ „ööelocalayelocalõÙ§x&: It can either have shape (n,); then Ù¢„cfunÙ „ööelocalcfunelocalõÙ§xW must return array_like with shape (n,). Alternatively, it can have shape (n, k); then Ù¢„cfunÙ „ööelocalcfunelocalõÙ§xb must return an array_like with shape (n, k), i.e., each column corresponds to a single column in Ù¢„ayÙ „ööelocalayelocalõÙ§x6. The choice between the two options is determined by Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§x– argument (see below). The vectorized implementation allows a faster approximation of the Jacobian by finite differences (required for stiff solvers).€Ù°ƒft_spanq2-tuple of floatsÙ¹‚Ù§xcInterval of integration (t0, tf). The solver starts with t=t0 and integrates until it reaches t=tf.€Ù°ƒby0varray_like, shape (n,)Ù¹‚ƒÙ§x8Initial state. For problems in the complex domain, pass Ù¢„by0Ù „escipye1.8.0fmodulexscipy.special.cython_special.y0fmoduleõÙ§xE with a complex data type (even if the initial value is purely real).€Ù°ƒfmethodxstring or `OdeSolver`, optional…Ù¹‚Ù§xIntegration method to use:€Ù·˜xC* 'RK45' (default): Explicit Runge-Kutta method of order 5(4) [1]_.x?  The error is controlled assuming accuracy of the fourth-orderx<  method, but steps are taken using the fifth-order accuratex@  formula (local extrapolation is done). A quartic interpolationxA  polynomial is used for the dense output [2]_. Can be applied inu  the complex domain.xC* 'RK23': Explicit Runge-Kutta method of order 3(2) [3]_. The errorxA  is controlled assuming accuracy of the second-order method, butx?  steps are taken using the third-order accurate formula (localxD  extrapolation is done). A cubic Hermite polynomial is used for thex5  dense output. Can be applied in the complex domain.x9* 'DOP853': Explicit Runge-Kutta method of order 8 [13]_.x<  Python implementation of the "DOP853" algorithm originallyxA  written in Fortran [14]_. A 7-th order interpolation polynomialx6  accurate to 7-th order is used for the dense output.x'  Can be applied in the complex domain.xA* 'Radau': Implicit Runge-Kutta method of the Radau IIA family ofxC  order 5 [4]_. The error is controlled with a third-order accuratex:  embedded formula. A cubic polynomial which satisfies thex6  collocation conditions is used for the dense output.xA* 'BDF': Implicit multi-step variable-order (1 to 5) method basedx:  on a backward differentiation formula for the derivativexB  approximation [5]_. The implementation follows the one describedx?  in [6]_. A quasi-constant step scheme is used and accuracy isx<  enhanced using the NDF modification. Can be applied in theq  complex domain.xB* 'LSODA': Adams/BDF method with automatic stiffness detection andx?  switching [7]_, [8]_. This is a wrapper of the Fortran solvero  from ODEPACK.Ù¹‚…Ù§xûExplicit Runge-Kutta methods ('RK23', 'RK45', 'DOP853') should be used for non-stiff problems and implicit methods ('Radau', 'BDF') for stiff problems . Among Runge-Kutta methods, 'DOP853' is recommended for solving with high precision (low values of Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§e and Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§b).€Ù¹‚Ù§y)If not sure, first try to run 'RK45'. If it makes unusually many iterations, diverges, or fails, your problem is likely to be stiff and you should use 'Radau' or 'BDF'. 'LSODA' can also be a good universal choice, but it might be somewhat less convenient to work with as it wraps old Fortran code.€Ù¹‚ƒÙ§x2You can also pass an arbitrary class derived from Ù¢„iOdeSolverÙ „escipye1.8.0fmodulex#scipy.integrate._ivp.base.OdeSolverfmoduleõÙ§x which implements the solver.€Ù°ƒft_evalxarray_like or None, optionalÙ¹‚ƒÙ§xMTimes at which to store the computed solution, must be sorted and lie within Ù¢„ft_spanÙ „ööelocalft_spanelocalõÙ§x7. If None (default), use points selected by the solver.€Ù°ƒldense_outputnbool, optionalÙ¹‚Ù§x;Whether to compute a continuous solution. Default is False.€Ù°ƒfeventsx(callable, or list of callables, optionalƒÙ¹‚‰Ù§x°Events to track. If None (default), no events will be tracked. Each event occurs at the zeros of a continuous function of time and state. Each function must have the signature Ù¡kevent(t, y)Ù§x? and return a float. The solver will find an accurate value of Ù¢„atÙ „ööelocalatelocalõÙ§j at which Ù¡revent(t, y(t)) = 0Ù§xÖ using a root-finding algorithm. By default, all zeros will be found. The solver looks for a sign change over each step, so if multiple zero crossings occur within one step, events may be missed. Additionally each Ù£ƒeeventööÙ§x. function might have the following attributes:€Ù·ˆxterminal: bool, optionalx:    Whether to terminate integration if this event occurs.x%    Implicitly False if not assigned.xdirection: float, optionalx=    Direction of a zero crossing. If `direction` is positive,xC    `event` will only trigger when going from negative to positive,x@    and vice versa if `direction` is negative. If 0, then eitherx?    direction will trigger event. Implicitly 0 if not assigned.Ù¹‚ƒÙ§xYou can assign attributes like Ù¡uevent.terminal = TrueÙ§x to any function in Python.€Ù°ƒjvectorizednbool, optionalÙ¹‚ƒÙ§hWhether Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x: is implemented in a vectorized fashion. Default is False.€Ù°ƒdargsotuple, optionalÙ¹‚‰Ù§xAdditional arguments to pass to the user-defined functions.  If given, the additional arguments are passed to all user-defined functions. So if, for example, Ù¢„cfunÙ „ööelocalcfunelocalõÙ§s has the signature Ù¡rfun(t, y, a, b, c)Ù§g, then Ù¢„cjacÙ „ööelocalcjacelocalõÙ§xF (if given) and any event functions must have the same signature, and Ù¢„dargsÙ „ööelocaldargselocalõÙ§x must be a tuple of length 3.€Ù°ƒgoptions`Ù¹‚Ù§xjOptions passed to a chosen solver. All options available for already implemented solvers are listed below.€Ù°ƒjfirst_stepwfloat or None, optionalÙ¹‚ƒÙ§xInitial step size. Default is Ù¡dNoneÙ§x. which means that the algorithm should choose.€Ù°ƒhmax_stepofloat, optionalÙ¹‚Ù§xuMaximum allowed step size. Default is np.inf, i.e., the step size is not bounded and determined solely by the solver.€Ù°ƒjrtol, atolxfloat or array_like, optionalÙ¹‚˜#Ù§xWRelative and absolute tolerances. The solver keeps the local error estimates less than Ù¡tatol + rtol * abs(y)Ù§g. Here Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x@ controls a relative accuracy (number of correct digits), while Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xW controls absolute accuracy (number of correct decimal places). To achieve the desired Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§f, set Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x= to be lower than the lowest value that can be expected from Ù¡mrtol * abs(y)Ù§i so that Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x# dominates the allowable error. If Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§p is larger than Ù¡mrtol * abs(y)Ù§xT the number of correct digits is not guaranteed. Conversely, to achieve the desired Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e set Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§k such that Ù¡mrtol * abs(y)Ù§v is always lower than Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xT. If components of y have different scales, it might be beneficial to set different Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xK values for different components by passing array_like with shape (n,) for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x. Default values are 1e-3 for Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§n and 1e-6 for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§a.€Ù°ƒcjacx5array_like, sparse_matrix, callable or None, optionalƒÙ¹‚ƒÙ§xÃJacobian matrix of the right-hand side of the system with respect to y, required by the 'Radau', 'BDF' and 'LSODA' method. The Jacobian matrix has shape (n, n) and its element (i, j) is equal to Ù¡md f_i / d y_jÙ§x/.  There are three ways to define the Jacobian:€Ù·ˆx<* If array_like or sparse_matrix, the Jacobian is assumed tox(  be constant. Not supported by 'LSODA'.x8* If callable, the Jacobian is assumed to depend on bothx<  t and y; it will be called as ``jac(t, y)``, as necessary.x<  For 'Radau' and 'BDF' methods, the return value might be ap  sparse matrix.x9* If None (default), the Jacobian will be approximated byu  finite differences.Ù¹‚Ù§xmIt is generally recommended to provide the Jacobian rather than relying on a finite-difference approximation.€Ù°ƒljac_sparsityx+array_like, sparse matrix or None, optionalÙ¹‚‹Ù§x’Defines a sparsity structure of the Jacobian matrix for a finite- difference approximation. Its shape must be (n, n). This argument is ignored if Ù¢„cjacÙ „ööelocalcjacelocalõÙ§h is not Ù¡dNoneÙ§x4. If the Jacobian has only few non-zero elements in Ù¨Ù§deachÙ§xö row, providing the sparsity structure will greatly speed up the computations . A zero entry means that a corresponding element in the Jacobian is always zero. If None (default), the Jacobian is assumed to be dense. Not supported by 'LSODA', see Ù¢„elbandÙ „ööelocalelbandelocalõÙ§e and Ù¢„eubandÙ „ööelocaleubandelocalõÙ§i instead.€Ù°ƒllband, ubanduint or None, optionalÙ¹‚Ù§xPParameters defining the bandwidth of the Jacobian for the 'LSODA' method, i.e., Ù¡x3jac[i, j] != 0 only for i - lband <= j <= i + ubandÙ§x…. Default is None. Setting these requires your jac routine to return the Jacobian in the packed format: the returned array must have Ù¡anÙ§m columns and Ù¡quband + lband + 1Ù§x< rows in which Jacobian diagonals are written. Specifically Ù¡x)jac_packed[uband + i - j , j] = jac[i, j]Ù§x. The same format is used in Ù¢„xscipy.linalg.solve_bandedÙ „escipya*capix scipy.linalg._basic.solve_bandedfmoduleõÙ§xF (check for an illustration).  These parameters can be also used with Ù¡hjac=NoneÙ§xK to reduce the number of Jacobian elements estimated by finite differences.€Ù°ƒhmin_stepofloat, optionalÙ¹‚ƒÙ§x=The minimum allowed step size for 'LSODA' method. By default Ù¢„hmin_stepÙ „ööelocalhmin_stepelocalõÙ§i is zero.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ŒÙ°ƒ`x/Bunch object with the following fields defined:€Ù°ƒatxndarray, shape (n_points,)Ù¹‚Ù§lTime points.€Ù°ƒayxndarray, shape (n, n_points)Ù¹‚ƒÙ§xValues of the solution at Ù¢„atÙ „ööelocalatelocalõÙ§a.€Ù°ƒcsolu`OdeSolution` or NoneÙ¹‚…Ù§rFound solution as Ù¢„kOdeSolutionÙ „escipye1.8.0fmodulex'scipy.integrate._ivp.common.OdeSolutionfmoduleõÙ§s instance; None if Ù¢„ldense_outputÙ „escipye1.8.0fmodulex0scipy.integrate._ivp.base.OdeSolver.dense_outputfmoduleõÙ§r was set to False.€Ù°ƒht_eventswlist of ndarray or NoneÙ¹‚ƒÙ§xiContains for each event type a list of arrays at which an event of that type event was detected. None if Ù¢„feventsÙ „ööelocalfeventselocalõÙ§j was None.€Ù°ƒhy_eventswlist of ndarray or NoneÙ¹‚…Ù§rFor each value of Ù¢„ht_eventsÙ „ööelocalht_eventselocalõÙ§x3, the corresponding value of the solution. None if Ù¢„feventsÙ „ööelocalfeventselocalõÙ§j was None.€Ù°ƒdnfevcintÙ¹‚Ù§x-Number of evaluations of the right-hand side.€Ù°ƒdnjevcintÙ¹‚Ù§x&Number of evaluations of the Jacobian.€Ù°ƒcnlucintÙ¹‚Ù§xNumber of LU decompositions.€Ù°ƒfstatuscint‚Ù¹‚Ù§x!Reason for algorithm termination:€Ù·ƒx* -1: Integration step failed.x9*  0: The solver successfully reached the end of `tspan`.x#*  1: A termination event occurred.Ù°ƒgmessagefstringÙ¹‚Ù§x5Human-readable description of the termination reason.€Ù°ƒgsuccessdboolÙ¹‚ƒÙ§xMTrue if the solver reached the interval end or a termination event occurred (Ù¡kstatus >= 0Ù§b).€ögSummaryÙ¯‚Ù¹‚Ù§x4Solve an initial value problem for a system of ODEs.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnsjReferenceshExamplesx/scipy/integrate/_ivp/ivp.pyœr<class 'function'>x(scipy.signal._ltisys.integrate.solve_ivpÙ¯‚•Ù¹‚Ù§xABasic exponential decay showing automatically chosen time points.€Ù´ƒ˜@Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„iintegrateÙ „escipye1.8.0fmoduleoscipy.integratefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfqexponential_decayÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a:Ù±‚`a Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚aoa-Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`ayÙ±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a(Ù±‚`qexponential_decayÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`atÙ±‚`a)xb[ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806
  8.33328988 10.        ]fexecedÙ´ƒ†Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`ayÙ±‚`a)y[[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045
  0.03107158 0.01350781]
 [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091
  0.06214316 0.02701561]
 [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181
  0.12428631 0.05403123]]fexecedÙ¹‚Ù§x0Specifying points where the solution is desired.€Ù´ƒ˜6Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a(Ù±‚`qexponential_decayÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`p                Ù±‚`ft_evalÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`atÙ±‚`a)p[ 0  1  2  4 10]fexecedÙ´ƒ†Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`ayÙ±‚`a)x®[[2.         1.21305369 0.73534021 0.27066736 0.01350938]
 [4.         2.42610739 1.47068043 0.54133472 0.02701876]
 [8.         4.85221478 2.94136085 1.08266944 0.05403753]]fexecedÙ¹‚‰Ù§x9Cannon fired upward with terminal event upon impact. The Ù¡hterminalÙ§e and Ù¡idirectionÙ§xD fields of an event are applied by monkey patching a function. Here Ù¡dy[0]Ù§q is position and Ù¡dy[1]Ù§x‘ is velocity. The projectile starts at position 0 with velocity +10. Note that the integration never reaches t=100 because the event is terminal.€Ù´ƒ˜_Ù±‚akcdefÙ±‚`a Ù±‚bnfmupward_cannonÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a:Ù±‚`a Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`ayÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfjhit_groundÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a:Ù±‚`a Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`ayÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`jhit_groundÙ±‚aoa.Ù±‚`hterminalÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bkcdTrueÙ±‚`a
Ù±‚`jhit_groundÙ±‚aoa.Ù±‚`idirectionÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a(Ù±‚`mupward_cannonÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`feventsÙ±‚aoa=Ù±‚`jhit_groundÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`ht_eventsÙ±‚`a)n[array([40.])]fexecedÙ´ƒ†Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`atÙ±‚`a)xz[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]fexecedÙ¹‚‰Ù§dUse Ù¢„ldense_outputÙ „escipye1.8.0fmodulex0scipy.integrate._ivp.base.OdeSolver.dense_outputfmoduleõÙ§e and Ù¢„feventsÙ „ööelocalfeventselocalõÙ§y to find position, which is 100, at the apex of the cannonball's trajectory. Apex is not defined as terminal, so both apex and hit_ground are found. There is no information at t=20, so the sol attribute is used to evaluate the solution. The sol attribute is returned by setting Ù¡qdense_output=TrueÙ§u. Alternatively, the Ù¢„hy_eventsÙ „ööelocalhy_eventselocalõÙ§xG attribute can be used to access the solution at the time of the event.€Ù´ƒ˜AÙ±‚akcdefÙ±‚`a Ù±‚bnfdapexÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a:Ù±‚`a Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`ayÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a(Ù±‚`mupward_cannonÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`p                Ù±‚`feventsÙ±‚aoa=Ù±‚`a(Ù±‚`jhit_groundÙ±‚`a,Ù±‚`a Ù±‚`dapexÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„ldense_outputÙ „escipye1.8.0fmodulex0scipy.integrate._ivp.base.OdeSolver.dense_outputfmoduleõÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`ht_eventsÙ±‚`a)x[array([40.]), array([20.])]fexecedÙ´ƒ†Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`atÙ±‚`a)xz[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]fexecedÙ´ƒ‘Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`csolÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`ht_eventsÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a)k[100.   0.]fexecedÙ´ƒ†Ù±‚bnbeprintÙ±‚`a(Ù±‚`csolÙ±‚aoa.Ù±‚`hy_eventsÙ±‚`a)xX[array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]fexecedÙ¹‚Ù§xdAs an example of a system with additional parameters, we'll implement the Lotka-Volterra equations .€Ù´ƒ˜?Ù±‚akcdefÙ±‚`a Ù±‚bnfmlotkavolterraÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`azÙ±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`aaÙ±‚aoa*Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`abÙ±‚aoa*Ù±‚`axÙ±‚aoa*Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`acÙ±‚aoa*Ù±‚`ayÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚aoa*Ù±‚`axÙ±‚aoa*Ù±‚`ayÙ±‚`a]c...fexecedÙ¹‚ƒÙ§xAWe pass in the parameter values a=1.5, b=1, c=3 and d=1 with the Ù¢„dargsÙ „ööelocaldargselocalõÙ§j argument.€Ù´ƒ˜.Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_ivpÙ „escipye1.8.0fmodulex"scipy.integrate._ivp.ivp.solve_ivpfmoduleõÙ±‚`a(Ù±‚`mlotkavolterraÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„b15Ù „escipye1.8.0fmodulex*scipy.integrate._quad_vec._quadrature_gk15fmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dargsÙ±‚aoa=Ù±‚`a(Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`p                Ù±‚`Ù¢„ldense_outputÙ „escipye1.8.0fmodulex0scipy.integrate._ivp.base.OdeSolver.dense_outputfmoduleõÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)`fexecedÙ¹‚Ù§x%Compute a dense solution and plot it.€Ù´ƒ˜^Ù±‚`atÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„b15Ù „escipye1.8.0fmodulex*scipy.integrate._quad_vec._quadrature_gk15fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmic300Ù±‚`a)Ù±‚`a
Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`csolÙ±‚aoa.Ù±‚`csolÙ±‚`a(Ù±‚`atÙ±‚`a)Ù±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„azÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1atÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1ayÙ±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`fshadowÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„etitleÙ „jmatplotlibe3.5.1fmodulewmatplotlib.pyplot.titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1uLotka-Volterra SystemÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x,fig-scipy.integrate._ivp.ivp.solve_ivp-0.pngö€e1.8.0Ù«xsolve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)öx"scipy.integrate._ivp.ivp.solve_ivp€
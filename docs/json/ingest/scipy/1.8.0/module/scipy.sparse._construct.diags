Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚ƒÙ§xThis function differs from Ù¢„gspdiagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.spdiagsfmoduleõÙ§x% in the way it handles off-diagonals.€Ù¹‚ƒÙ§pThe result from Ù¢„ediagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.diagsfmoduleõÙ§x$ is the sparse equivalent of::      €ÙÀxKnp.diag(diagonals[0], offsets[0])
+ ...
+ np.diag(diagonals[k], offsets[k])Ù¹‚Ù§x)Repeated diagonal offsets are disallowed.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.11 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒidiagonalsvsequence of array_likeÙ¹‚ƒÙ§xESequence of arrays containing the matrix diagonals, corresponding to Ù¢„goffsetsÙ „escipye1.8.0fmodulex,scipy.sparse._sparsetools.csr_sample_offsetsfmoduleõÙ§a.€Ù°ƒgoffsetsx#sequence of int or an int, optionalÙÁÙÅ‚Ù¹‚Ù§qDiagonals to set:€ÙÈƒÙ¹‚Ù§x"k = 0  the main diagonal (default)€Ù¹‚Ù§xk > 0  the kth upper diagonal€Ù¹‚Ù§xk < 0  the kth lower diagonal€Ù°ƒeshapevtuple of int, optionalÙ¹‚Ù§xcShape of the result. If omitted, a square matrix large enough to contain the diagonals is returned.€Ù°ƒfformatx+{"dia", "csr", "csc", "lil", ...}, optionalÙ¹‚Ù§xˆMatrix format of the result. By default (format=None) an appropriate sparse matrix format is returned. This choice is subject to change.€Ù°ƒedtypeodtype, optionalÙ¹‚Ù§xData type of the matrix.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x)Construct a sparse matrix from diagonals.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametershSee AlsoeNoteshExamplesx/scipy/sparse/_construct.pyBr<class 'function'>xHscipy.signal._filter_design.optimize._differentiable_functions.sps.diagsÙ¯‚…Ù´ƒ˜DÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ediagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.diagsfmoduleõÙ±‚`a
Ù±‚`idiagonalsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„ediagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.diagsfmoduleõÙ±‚`a(Ù±‚`idiagonalsÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`gtoarrayÙ±‚`a(Ù±‚`a)xTarray([[1, 0, 1, 0],
       [1, 2, 0, 2],
       [0, 2, 3, 0],
       [0, 0, 3, 4]])fexecedÙ¹‚Ù§xGBroadcasting of scalars is supported (but shape needs to be specified):€Ù´ƒ˜'Ù±‚`Ù¢„ediagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.diagsfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`eshapeÙ±‚aoa=Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`gtoarrayÙ±‚`a(Ù±‚`a)xtarray([[-2.,  1.,  0.,  0.],
       [ 1., -2.,  1.,  0.],
       [ 0.,  1., -2.,  1.],
       [ 0.,  0.,  1., -2.]])fexecedÙ¹‚ƒÙ§x&If only one diagonal is wanted (as in Ù¢„jnumpy.diagÙ „enumpya*capijnumpy.diagfmoduleõÙ§x), the following works as well:€Ù´ƒ“Ù±‚`Ù¢„ediagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.diagsfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚aoa.Ù±‚`gtoarrayÙ±‚`a(Ù±‚`a)xtarray([[ 0.,  1.,  0.,  0.],
       [ 0.,  0.,  2.,  0.],
       [ 0.,  0.,  0.,  3.],
       [ 0.,  0.,  0.,  0.]])fexecedöÙ¼ƒÙ»ƒgspdiagsxscipy.sparse._construct.spdiagsõÙ¹‚Ù§xconstruct matrix from diagonals€öe1.8.0Ù«x@diags(diagonals, offsets=0, shape=None, format=None, dtype=None)öxscipy.sparse._construct.diags€
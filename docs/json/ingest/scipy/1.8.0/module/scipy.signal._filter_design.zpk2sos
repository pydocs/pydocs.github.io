Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ŒÙ¹‚Ù§yThe algorithm used to convert ZPK to SOS format is designed to minimize errors due to numerical precision issues. The pairing algorithm attempts to minimize the peak gain of each biquadratic section. This is done by pairing poles with the nearest zeros, starting with the poles closest to the unit circle for discrete-time systems, and poles closest to the imaginary axis for continuous-time systems.€Ù¹‚ˆÙ¡qpairing='minimal'Ù§x! outputs may not be suitable for Ù¢„gsosfiltÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.sosfiltfmoduleõÙ§f, and Ù¡kanalog=TrueÙ§x$ outputs will never be suitable for Ù¢„gsosfiltÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.sosfiltfmoduleõÙ§a.€Ù¹‚Ù¨Ù§jAlgorithms€Ù¹‚Ù§qThe steps in the Ù¡qpairing='nearest'Ù§b, Ù¡rpairing='keep_odd'Ù§f, and Ù¡qpairing='minimal'Ù§x# algorithms are mostly shared. The Ù¡i'nearest'Ù§x5 algorithm attempts to minimize the peak gain, while Ù¡j'keep_odd'Ù§xk minimizes peak gain under the constraint that odd-order systems should retain one section as first order. Ù¡i'minimal'Ù§o is similar to Ù¡j'keep_odd'Ù§x1, but no additional poles or zeros are introduced€Ù¹‚Ù§x#The algorithm steps are as follows:€Ù¹‚‡Ù§xAs a pre-processing step for Ù¡qpairing='nearest'Ù§b, Ù¡rpairing='keep_odd'Ù§xn, add poles or zeros to the origin as necessary to obtain the same number of poles and zeros for pairing.  If Ù¡tpairing == 'nearest'Ù§xW and there are an odd number of poles, add an additional pole and a zero at the origin.€Ù¹‚Ù§xOThe following steps are then iterated over until no more poles or zeros remain:€ÙÇÙ¹‚ƒÙ§xgTake the (next remaining) pole (complex or real) closest to the    unit circle (or imaginary axis, for Ù¡kanalog=TrueÙ§x#) to    begin a new filter section.€ÙÇÙ¹‚Ù§yGIf the pole is real and there are no other remaining real poles ,    add the closest real zero to the section and leave it as a first    order section. Note that after this step we are guaranteed to be    left with an even number of real poles, complex poles, real zeros,    and complex zeros for subsequent pairing iterations.€ÙÇ‚Ù¹‚Ù§eElse:€Ù·˜xA1. If the pole is complex and the zero is the only remaining realx9   zero*, then pair the pole with the *next* closest zerox?   (guaranteed to be complex). This is necessary to ensure thatx=   there will be a real zero remaining to eventually create ax4   first-order section (thus keeping the odd order).`xA2. Else pair the pole with the closest remaining zero (complex ori   real).`xA3. Proceed to complete the second-order section by adding anotherx=   pole and zero to the current pole and zero in the section:`x?    1. If the current pole and zero are both complex, add theirr       conjugates.`x@    2. Else if the pole is complex and the zero is real, add thex5       conjugate pole and the next closest real zero.`x@    3. Else if the pole is real and the zero is complex, add thex?       conjugate zero and the real pole closest to those zeros.`xA    4. Else (we must have a real pole and real zero) add the nextxB       real pole closest to the unit circle, and then add the realx!       zero closest to that pole.Ù²‚xˆ.. [#] This conditional can only be met for specific odd-order inputs
       with the ``pairing = 'keep_odd'`` or ``'minimal'`` methods.hfootnoteÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.16.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒazjarray_likeÙ¹‚Ù§xZeros of the transfer function.€Ù°ƒapjarray_likeÙ¹‚Ù§xPoles of the transfer function.€Ù°ƒakefloatÙ¹‚Ù§lSystem gain.€Ù°ƒgpairingx2{None, 'nearest', 'keep_odd', 'minimal'}, optionalÙ¹‚Ù§xÙThe method to use to combine pairs of poles and zeros into sections. If analog is False and pairing is None, pairing is set to 'nearest'; if analog is True, pairing must be 'minimal', and is set to that if it is None.€Ù°ƒfanalognbool, optional‚Ù¹‚Ù§x.If True, system is analog, otherwise discrete.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.8.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcsosgndarrayÙ¹‚…Ù§x6Array of second-order filter coefficients, with shape Ù¡o(n_sections, 6)Ù§f. See Ù¢„gsosfiltÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.sosfiltfmoduleõÙ§x) for the SOS filter format specification.€ögSummaryÙ¯‚Ù¹‚Ù§xDReturn second-order sections from zeros, poles, and gain of a system€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/signal/_filter_design.py	r<class 'function'>tscipy.signal.zpk2sosÙ¯‚”Ù¹‚Ù§y	Design a 6th order low-pass elliptic digital filter for a system with a sampling rate of 8000 Hz that has a pass-band corner frequency of 1000 Hz. The ripple in the pass-band should not exceed 0.087 dB, and the attenuation in the stop-band should be at least 90 dB.€Ù¹‚‰Ù§xIn the following call to Ù¢„eellipÙ „escipye1.8.0fmodulex!scipy.signal._filter_design.ellipfmoduleõÙ§o, we could use Ù¡loutput='sos'Ù§x", but for this example, we'll use Ù¡loutput='zpk'Ù§x&, and then convert to SOS format with Ù¢„gzpk2sosÙ „escipye1.8.0fmodulex#scipy.signal._filter_design.zpk2sosfmoduleõÙ§a:€Ù´ƒ˜.Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚`Ù¢„azÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`apÙ±‚`a,Ù±‚`a Ù±‚`akÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„eellipÙ „escipye1.8.0fmodulex!scipy.signal._filter_design.ellipfmoduleõÙ±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmfe0.087Ù±‚`a,Ù±‚`a Ù±‚bmib90Ù±‚`a,Ù±‚`a Ù±‚bmid1000Ù±‚aoa/Ù±‚`a(Ù±‚bmfc0.5Ù±‚aoa*Ù±‚bmid8000Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`foutputÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1czpkÙ±‚bs1a'Ù±‚`a)`fexecedÙ¹‚Ù§xNow convert to SOS format.€Ù´ƒÙ±‚`Ù¢„csosÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gzpk2sosÙ „escipye1.8.0fmodulex#scipy.signal._filter_design.zpk2sosfmoduleõÙ±‚`a(Ù±‚`Ù¢„azÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„apÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„akÙ „enumpyf1.22.3fmodulennumpy.floatingfmoduleõÙ±‚`a)`fexecedÙ¹‚Ù§x3The coefficients of the numerators of the sections:€Ù´ƒˆÙ±‚`Ù¢„csosÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚`a:Ù±‚bmia3Ù±‚`a]xarray([[ 0.0014154 ,  0.00248707,  0.0014154 ],
       [ 1.        ,  0.72965193,  1.        ],
       [ 1.        ,  0.17594966,  1.        ]])fexecedÙ¹‚Ù§xUThe symmetry in the coefficients occurs because all the zeros are on the unit circle.€Ù¹‚Ù§x5The coefficients of the denominators of the sections:€Ù´ƒˆÙ±‚`Ù¢„csosÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a:Ù±‚`a]xarray([[ 1.        , -1.32543251,  0.46989499],
       [ 1.        , -1.26117915,  0.6262586 ],
       [ 1.        , -1.25707217,  0.86199667]])fexecedÙ¹‚ƒÙ§x)The next example shows the effect of the Ù¢„gpairingÙ „ööelocalgpairingelocalõÙ§xÍ option.  We have a system with three poles and three zeros, so the SOS array will have shape (2, 6). The means there is, in effect, an extra pole and an extra zero at the origin in the SOS representation.€Ù´ƒ˜4Ù±‚`Ù¢„bz1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfc0.5Ù±‚aoa-Ù±‚bmfc0.5Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfc0.5Ù±‚aoa+Ù±‚bmfc0.5Ù±‚`ajÙ±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„bp1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfd0.75Ù±‚`a,Ù±‚`a Ù±‚bmfc0.8Ù±‚aoa+Ù±‚bmfc0.1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚bmfc0.8Ù±‚aoa-Ù±‚bmfc0.1Ù±‚`ajÙ±‚`a]Ù±‚`a)`fexecedÙ¹‚ƒÙ§eWith Ù¡qpairing='nearest'Ù§x (the default), we obtain€Ù´ƒŒÙ±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gzpk2sosÙ „escipye1.8.0fmodulex#scipy.signal._filter_design.zpk2sosfmoduleõÙ±‚`a(Ù±‚`Ù¢„bz1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bp1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)xfarray([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])fexecedÙ¹‚Ù§x÷The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles {0, 0.75}, and the second section has the zeros {-1, 0} and poles {0.8+0.1j, 0.8-0.1j}. Note that the extra pole and zero at the origin have been assigned to different sections.€Ù¹‚ƒÙ§eWith Ù¡rpairing='keep_odd'Ù§l, we obtain:€Ù´ƒ“Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gzpk2sosÙ „escipye1.8.0fmodulex#scipy.signal._filter_design.zpk2sosfmoduleõÙ±‚`a(Ù±‚`Ù¢„bz1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bp1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`gpairingÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1hkeep_oddÙ±‚bs1a'Ù±‚`a)xfarray([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])fexecedÙ¹‚Ù§xvThe extra pole and zero at the origin are in the same section. The first section is, in effect, a first-order section.€Ù¹‚ƒÙ§eWith Ù¡qpairing='minimal'Ù§xM, the first-order section doesn't have the extra pole and zero at the origin:€Ù´ƒ“Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gzpk2sosÙ „escipye1.8.0fmodulex#scipy.signal._filter_design.zpk2sosfmoduleõÙ±‚`a(Ù±‚`Ù¢„bz1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bp1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`gpairingÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gminimalÙ±‚bs1a'Ù±‚`a)xfarray([[ 0.  ,  1.  ,  1.  ,  0.  ,  1.  , -0.75],
       [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])fexecedöÙ¼ƒÙ»ƒgsosfiltx!scipy.signal._signaltools.sosfiltõ€öe1.8.0Ù«x/zpk2sos(z, p, k, pairing=None, *, analog=False)öx#scipy.signal._filter_design.zpk2sos€
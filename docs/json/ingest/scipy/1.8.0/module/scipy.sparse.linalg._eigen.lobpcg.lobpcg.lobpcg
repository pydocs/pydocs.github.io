Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xmLOBPCG is a preconditioned eigensolver for large symmetric positive definite (SPD) generalized eigenproblems.€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚‡Ù§hIf both Ù¡pretLambdaHistoryÙ§e and Ù¡wretResidualNormsHistoryÙ§x5 are True, the return tuple has the following format Ù¡x3(lambda, V, lambda history, residual norms history)Ù§a.€Ù¹‚…Ù§qIn the following Ù¡anÙ§x denotes the matrix size and Ù¡amÙ§x: the number of required eigenvalues (smallest or largest).€Ù¹‚‰Ù§x<The LOBPCG code internally solves eigenproblems of the size Ù¡b3mÙ§xG on every iteration by calling the "standard" dense eigensolver, so if Ù¡amÙ§x! is not small enough compared to Ù¡anÙ§x¹, it does not make sense to call the LOBPCG code, but rather one should use the "standard" eigensolver, e.g. numpy or scipy function in this case. If one calls the LOBPCG algorithm for Ù¡f5m > nÙ§x`, it will most likely break internally, so the code tries to call the standard function instead.€Ù¹‚Ù§oIt is not that Ù¡anÙ§x> should be large for the LOBPCG to work, but rather the ratio Ù¡en / mÙ§x* should be large. It you call LOBPCG with Ù¡cm=1Ù§e and Ù¡dn=10Ù§r, it works though Ù¡anÙ§x6 is small. The method is intended for extremely large Ù¡en / mÙ§a.€Ù¹‚Ù§x7The convergence speed depends basically on two factors:€ÙÇÙ¹‚ƒÙ§xsHow well relatively separated the seeking eigenvalues are from the rest    of the eigenvalues. One can try to vary Ù¡amÙ§u to make this better.€ÙÇÙ¹‚…Ù§x¿How well conditioned the problem is. This can be changed by using proper    preconditioning. For example, a rod vibration test problem (under tests    directory) is ill-conditioned for large Ù¡anÙ§x¯, so convergence will be    slow, unless efficient preconditioning is used. For this specific    problem, a good simple preconditioner function would be a linear solve    for Ù¢„aAÙ „ööelocalaAelocalõÙ§x/, which is easy to code since A is tridiagonal.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒaAx-{sparse matrix, dense matrix, LinearOperator}Ù¹‚Ù§xlThe symmetric linear operator of the problem, usually a sparse matrix.  Often called the "stiffness matrix".€Ù°ƒaXxndarray, float32 or float64Ù¹‚‹Ù§xInitial approximation to the Ù¡akÙ§x eigenvectors (non-sparse). If Ù¢„aAÙ „ööelocalaAelocalõÙ§e has Ù¡kshape=(n,n)Ù§f then Ù¢„aXÙ „ööelocalaXelocalõÙ§s should have shape Ù¡kshape=(n,k)Ù§a.€Ù°ƒaBx7{dense matrix, sparse matrix, LinearOperator}, optionalÙ¹‚ƒÙ§xHThe right hand side operator in a generalized eigenproblem. By default, Ù¡lB = IdentityÙ§x".  Often called the "mass matrix".€Ù°ƒaMx7{dense matrix, sparse matrix, LinearOperator}, optionalÙ¹‚‰Ù§rPreconditioner to Ù¢„aAÙ „ööelocalaAelocalõÙ§m; by default Ù¡lM = IdentityÙ§b. Ù¢„aMÙ „ööelocalaMelocalõÙ§x# should approximate the inverse of Ù¢„aAÙ „ööelocalaAelocalõÙ§a.€Ù°ƒaYx%ndarray, float32 or float64, optionalÙ¹‚Ù§x§n-by-sizeY matrix of constraints (non-sparse), sizeY < n The iterations will be performed in the B-orthogonal complement of the column-space of Y. Y must be full rank.€Ù°ƒctolpscalar, optionalÙ¹‚ƒÙ§x6Solver tolerance (stopping criterion). The default is Ù¡otol=n*sqrt(eps)Ù§a.€Ù°ƒgmaxitermint, optionalÙ¹‚ƒÙ§x.Maximum number of iterations.  The default is Ù¡lmaxiter = 20Ù§a.€Ù°ƒglargestnbool, optionalÙ¹‚Ù§xEWhen True, solve for the largest eigenvalues, otherwise the smallest.€Ù°ƒnverbosityLevelmint, optionalÙ¹‚ƒÙ§x(Controls solver output.  The default is Ù¡pverbosityLevel=0Ù§a.€Ù°ƒpretLambdaHistorynbool, optionalÙ¹‚Ù§x8Whether to return eigenvalue history.  Default is False.€Ù°ƒwretResidualNormsHistorynbool, optionalÙ¹‚Ù§x?Whether to return history of residual norms.  Default is False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚„Ù°ƒawgndarrayÙ¹‚ƒÙ§iArray of Ù¡akÙ§l eigenvalues€Ù°ƒavgndarrayÙ¹‚‡Ù§lAn array of Ù¡akÙ§p eigenvectors.  Ù¢„avÙ „ööelocalavelocalõÙ§w has the same shape as Ù¢„aXÙ „ööelocalaXelocalõÙ§a.€Ù°ƒglambdasxlist of ndarray, optionalÙ¹‚ƒÙ§xThe eigenvalue history, if Ù¢„pretLambdaHistoryÙ „ööelocalpretLambdaHistoryelocalõÙ§i is True.€Ù°ƒfrnormsxlist of ndarray, optionalÙ¹‚ƒÙ§x"The history of residual norms, if Ù¢„wretResidualNormsHistoryÙ „ööelocalwretResidualNormsHistoryelocalõÙ§i is True.€ögSummaryÙ¯‚Ù¹‚Ù§xGLocally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshExamplesx,/scipy/sparse/linalg/_eigen/lobpcg/lobpcg.py€r<class 'function'>xPscipy.signal._filter_design.optimize._differentiable_functions.sps.linalg.lobpcgÙ¯‚Ù¹‚ƒÙ§fSolve Ù¡nA x = lambda xÙ§x& with constraints and preconditioning.€Ù´ƒ˜SÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„gspdiagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.spdiagsfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`hissparseÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flobpcgÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._eigen.lobpcg.lobpcg.lobpcgfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„nLinearOperatorÙ „escipye1.8.0fmodulex-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ±‚`a
Ù±‚`anÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmic100Ù±‚`a
Ù±‚`Ù¢„dvalsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„gspdiagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.spdiagsfmoduleõÙ±‚`a(Ù±‚`Ù¢„dvalsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a
Ù±‚`aAÙ±‚aoa.Ù±‚`gtoarrayÙ±‚`a(Ù±‚`a)y8array([[  1.,   0.,   0., ...,   0.,   0.,   0.],
       [  0.,   2.,   0., ...,   0.,   0.,   0.],
       [  0.,   0.,   3., ...,   0.,   0.,   0.],
       ...,
       [  0.,   0.,   0., ...,  98.,   0.,   0.],
       [  0.,   0.,   0., ...,   0.,  99.,   0.],
       [  0.,   0.,   0., ...,   0.,   0., 100.]])fexecedÙ¹‚Ù§lConstraints:€Ù´ƒÙ±‚`Ù¢„aYÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ceyeÙ „escipye1.8.0fmodulexscipy.sparse._construct.eyefmoduleõÙ±‚`a(Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)`fexecedÙ¹‚Ù§x}Initial guess for eigenvectors, should have linearly independent columns. Column dimension = number of requested eigenvalues.€Ù´ƒ˜Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aXÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)`fexecedÙ¹‚Ù§x3Preconditioner in the inverse of A in this example:€Ù´ƒ•Ù±‚`dinvAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„gspdiagsÙ „escipye1.8.0fmodulexscipy.sparse._construct.spdiagsfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb1.Ù±‚aoa/Ù±‚`Ù¢„dvalsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)`fexecedÙ¹‚Ù§x0The preconditiner must be defined by a function:€Ù´ƒ’Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„gprecondÙ „escipye1.8.0fmodulex0scipy.optimize._nonlin.Jacobian.aspreconditionerfmoduleõÙ±‚`a(Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`dinvAÙ±‚`a Ù±‚aoa@Ù±‚`a Ù±‚`ax`fexecedÙ¹‚…Ù§xAThe argument x of the preconditioner function is a matrix inside Ù¢„flobpcgÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._eigen.lobpcg.lobpcg.lobpcgfmoduleõÙ§x(, thus the use of matrix-matrix product Ù¡a@Ù§a.€Ù¹‚ƒÙ§x5The preconditioner function is passed to lobpcg as a Ù¢„nLinearOperatorÙ „escipye1.8.0fmodulex-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ§a:€Ù´ƒ˜!Ù±‚`aMÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„nLinearOperatorÙ „escipye1.8.0fmodulex-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ±‚`a(Ù±‚`fmatvecÙ±‚aoa=Ù±‚`Ù¢„gprecondÙ „escipye1.8.0fmodulex0scipy.optimize._nonlin.Jacobian.aspreconditionerfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fmatmatÙ „escipye1.8.0fmodulex4scipy.sparse.linalg._interface.LinearOperator.matmatfmoduleõÙ±‚aoa=Ù±‚`Ù¢„gprecondÙ „escipye1.8.0fmodulex0scipy.optimize._nonlin.Jacobian.aspreconditionerfmoduleõÙ±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚`eshapeÙ±‚aoa=Ù±‚`a(Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gfloat64Ù „enumpyf1.22.3fmodulennumpy.floatingfmoduleõÙ±‚`a)`fexecedÙ¹‚Ù§x9Let us now solve the eigenvalue problem for the matrix A:€Ù´ƒ˜Ù±‚`keigenvaluesÙ±‚`a,Ù±‚`a Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flobpcgÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._eigen.lobpcg.lobpcg.lobpcgfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`aXÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aYÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa=Ù±‚`Ù¢„aYÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aMÙ±‚aoa=Ù±‚`aMÙ±‚`a,Ù±‚`a Ù±‚`glargestÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„keigenvaluesÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõsarray([4., 5., 6.])fexecedÙ¹‚Ù§xƒNote that the vectors passed in Y are the eigenvectors of the 3 smallest eigenvalues. The results returned are orthogonal to those.€ö€e1.8.0Ù«x“lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False)öx/scipy.sparse.linalg._eigen.lobpcg.lobpcg.lobpcg€
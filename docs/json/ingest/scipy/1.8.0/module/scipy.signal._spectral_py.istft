Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚ƒÙ§xBIn order to enable inversion of an STFT via the inverse STFT with Ù¢„eistftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.istftfmoduleõÙ§xP, the signal windowing must obey the constraint of "nonzero overlap add" (NOLA):€Ù¤x"\sum_ { t}w^ { 2} [ n - tH] \ne 0 Ù¹‚Ù§xuThis ensures that the normalization factors that appear in the denominator of the overlap-add reconstruction equation€Ù¤xQx [ n]=\frac { \sum_ { t}x_ { t} [ n]w [ n - tH]} { \sum_ { t}w^ { 2} [ n - tH]} Ù¹‚ƒÙ§x:are not zero. The NOLA constraint can be checked with the Ù¢„jcheck_NOLAÙ „escipye1.8.0fmodulex$scipy.signal._spectral_py.check_NOLAfmoduleõÙ§j function.€Ù¹‚Ù§ySAn STFT which has been modified (via masking or otherwise) is not guaranteed to correspond to a exactly realizible signal. This function implements the iSTFT via the least-squares estimation algorithm detailed in , which produces a signal that minimizes the mean squared error between the STFT of the returned signal and the modified STFT.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.19.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŠÙ°ƒcZxxjarray_likeÙ¹‚Ù§xqSTFT of the signal to be reconstructed. If a purely real array is passed, it will be cast to a complex data type.€Ù°ƒbfsofloat, optionalÙ¹‚Ù§x7Sampling frequency of the time series. Defaults to 1.0.€Ù°ƒfwindowx$str or tuple or array_like, optionalÙ¹‚‰Ù§xDesired window to use. If Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§x' is a string or tuple, it is passed to Ù¢„jget_windowÙ „escipye1.8.0fmodulex(scipy.signal.windows._windows.get_windowfmoduleõÙ§xC to generate the window values, which are DFT-even by default. See Ù¢„jget_windowÙ „escipye1.8.0fmodulex(scipy.signal.windows._windows.get_windowfmoduleõÙ§x3 for a list of windows and required parameters. If Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§x¸ is array_like it will be used directly as the window and its length must be nperseg. Defaults to a Hann window. Must match the window used to generate the STFT for faithful inversion.€Ù°ƒgnpersegmint, optionalÙ¹‚“Ù§xªNumber of data points corresponding to each STFT segment. This parameter must be specified if the number of data points per segment is odd, or if the STFT was padded via Ù¡nnfft >
npersegÙ§e. If Ù¡dNoneÙ§x$, the value depends on the shape of Ù¢„cZxxÙ „ööelocalcZxxelocalõÙ§e and Ù¢„ninput_onesidedÙ „ööelocalninput_onesidedelocalõÙ§e. If Ù¢„ninput_onesidedÙ „ööelocalninput_onesidedelocalõÙ§d is Ù¡dTrueÙ§b, Ù¡x$nperseg=2*(Zxx.shape[freq_axis] - 1)Ù§m. Otherwise, Ù¡xnperseg=Zxx.shape[freq_axis]Ù§n. Defaults to Ù¡dNoneÙ§a.€Ù°ƒhnoverlapmint, optionalÙ¹‚‡Ù§x1Number of points to overlap between segments. If Ù¡dNoneÙ§x*, half of the segment length. Defaults to Ù¡dNoneÙ§x‹. When specified, the COLA constraint must be met (see Notes below), and should match the parameter used to generate the STFT. Defaults to Ù¡dNoneÙ§a.€Ù°ƒdnfftmint, optionalÙ¹‚‘Ù§xuNumber of FFT points corresponding to each STFT segment. This parameter must be specified if the STFT was padded via Ù¡nnfft >
npersegÙ§e. If Ù¡dNoneÙ§x), the default values are the same as for Ù¢„gnpersegÙ „ööelocalgnpersegelocalõÙ§x), detailed above, with one exception: if Ù¢„ninput_onesidedÙ „ööelocalninput_onesidedelocalõÙ§m is True and Ù¡x#nperseg==2*Zxx.shape[freq_axis] - 1Ù§b, Ù¢„dnfftÙ „ööelocaldnfftelocalõÙ§xf also takes on that value. This case allows the proper inversion of an odd-length unpadded STFT using Ù¡infft=NoneÙ§n. Defaults to Ù¡dNoneÙ§a.€Ù°ƒninput_onesidednbool, optionalÙ¹‚Ù§cIf Ù¡dTrueÙ§xF, interpret the input array as one-sided FFTs, such as is returned by Ù¢„dstftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.stftfmoduleõÙ§f with Ù¡treturn_onesided=TrueÙ§e and Ù¢„nnumpy.fft.rfftÙ „enumpya*capinnumpy.fft.rfftfmoduleõÙ§e. If Ù¡eFalseÙ§x8, interpret the input as a a two-sided FFT. Defaults to Ù¡dTrueÙ§a.€Ù°ƒhboundarynbool, optionalÙ¹‚‰Ù§xUSpecifies whether the input signal was extended at its boundaries by supplying a non-Ù¡dNoneÙ§a Ù¡hboundaryÙ§m argument to Ù¢„dstftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.stftfmoduleõÙ§n. Defaults to Ù¡dTrueÙ§a.€Ù°ƒitime_axismint, optionalÙ¹‚ƒÙ§xSWhere the time segments of the STFT is located; the default is the last axis (i.e. Ù¡gaxis=-1Ù§b).€Ù°ƒifreq_axismint, optionalÙ¹‚ƒÙ§x[Where the frequency axis of the STFT is located; the default is the penultimate axis (i.e. Ù¡gaxis=-2Ù§b).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒatgndarrayÙ¹‚Ù§xArray of output data times.€Ù°ƒaxgndarrayÙ¹‚ƒÙ§iiSTFT of Ù¢„cZxxÙ „ööelocalcZxxelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x9Perform the inverse Short Time Fourier transform (iSTFT).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/signal/_spectral_py.pyr<class 'function'>rscipy.signal.istftÙ¯‚Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¹‚Ù§xpGenerate a test signal, a 2 Vrms sine wave at 50Hz corrupted by 0.001 V**2/Hz of white noise sampled at 1024 Hz.€Ù´ƒ˜}Ù±‚`bfsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmid1024Ù±‚`a
Ù±‚`aNÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmib10Ù±‚aoa*Ù±‚`bfsÙ±‚`a
Ù±‚`gnpersegÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmic512Ù±‚`a
Ù±‚`campÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`knoise_powerÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfe0.001Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`bfsÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmia2Ù±‚`a
Ù±‚`dtimeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚`aNÙ±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bnbefloatÙ±‚`a(Ù±‚`bfsÙ±‚`a)Ù±‚`a
Ù±‚`gcarrierÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`campÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmib50Ù±‚aoa*Ù±‚`dtimeÙ±‚`a)Ù±‚`a
Ù±‚`enoiseÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`fnormalÙ±‚`a(Ù±‚`escaleÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`knoise_powerÙ±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚`dsizeÙ±‚aoa=Ù±‚`dtimeÙ±‚aoa.Ù±‚`eshapeÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`gcarrierÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`enoise`fexecedÙ¹‚Ù§x(Compute the STFT, and plot its magnitude€Ù´ƒ˜€Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`cZxxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dstftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.stftfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`bfsÙ±‚aoa=Ù±‚`bfsÙ±‚`a,Ù±‚`a Ù±‚`gnpersegÙ±‚aoa=Ù±‚`gnpersegÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffigureÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.figurefmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jpcolormeshÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.pcolormeshfmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dvminÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`dvmaxÙ±‚aoa=Ù±‚`campÙ±‚`a,Ù±‚`a Ù±‚`gshadingÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1ggouraudÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dylimÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.ylimfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„etitleÙ „jmatplotlibe3.5.1fmodulewmatplotlib.pyplot.titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1nSTFT MagnitudeÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1nFrequency [Hz]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1jTime [sec]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fyscaleÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.yscalefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1clogÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x)fig-scipy.signal._spectral_py.istft-0.pngÙ¹‚Ù§xvZero the components that are 10% or less of the carrier magnitude, then convert back to a time series via inverse STFT€Ù´ƒ˜-Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ewhereÙ „escipye1.8.0fmodulexscipy._lib._util._lazywherefmoduleõÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚`campÙ±‚aoa/Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`a_Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„dxrecÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„eistftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.istftfmoduleõÙ±‚`a(Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bfsÙ±‚`a)`fexecedÙ¹‚Ù§xFCompare the cleaned signal with the original and true carrier signals.€Ù´ƒ˜TÙ±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffigureÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.figurefmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dxrecÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`gcarrierÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dxlimÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.xlimfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmfc2.1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1jTime [sec]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1fSignalÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1oCarrier + NoiseÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1qFiltered via STFTÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1lTrue CarrierÙ±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x)fig-scipy.signal._spectral_py.istft-1.pngÙ¹‚Ù§x‹Note that the cleaned signal does not start as abruptly as the original, since some of the coefficients of the transient were also removed:€Ù´ƒ˜TÙ±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffigureÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.figurefmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dxrecÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dtimeÙ±‚`a,Ù±‚`a Ù±‚`gcarrierÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dxlimÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.xlimfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1jTime [sec]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1fSignalÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1oCarrier + NoiseÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1qFiltered via STFTÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1lTrue CarrierÙ±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x)fig-scipy.signal._spectral_py.istft-2.pngöƒÙ¼ƒÙ»ƒjcheck_COLAx$scipy.signal._spectral_py.check_COLAõÙ¹‚Ù§x?Check whether the Constant OverLap Add (COLA) constraint is met€öÙ¼ƒÙ»ƒjcheck_NOLAx$scipy.signal._spectral_py.check_NOLAõÙ¹‚Ù§x>Check whether the Nonzero Overlap Add (NOLA) constraint is met€öÙ¼ƒÙ»ƒdstftxscipy.signal._spectral_py.stftõÙ¹‚Ù§xShort Time Fourier Transform€öe1.8.0Ù«x‰istft(Zxx, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, input_onesided=True, boundary=True, time_axis=-1, freq_axis=-2)öxscipy.signal._spectral_py.istft€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x)See Notes for common calling conventions.€ögMethodsÙ¯‚€öeNotesÙ¯‚˜Ù¹‚Ù§x-The following are common calling conventions:€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'euclidean')€Ù¹‚‡Ù§xComputes the distance between Ù¥amÙ§xv points using    Euclidean distance (2-norm) as the distance metric between the    points. The points are arranged as Ù¥amÙ§d    Ù¥anÙ§x)-dimensional row vectors in the matrix X.€ÙÇ‚Ù¹‚Ù¡x$Y = cdist(XA, XB, 'minkowski', p=2.)€Ù¹‚‰Ù§x7Computes the distances using the Minkowski distance    Ù¥i\|u-v\|_pÙ§b (Ù¥apÙ§m-norm) where Ù¥ep > 0Ù§x. (note    that this is only a quasi-metric if Ù¥i0 < p < 1Ù§b).€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'cityblock')€Ù¹‚Ù§xDComputes the city block or Manhattan distance between the    points.€ÙÇ„Ù¹‚Ù¡x'Y = cdist(XA, XB, 'seuclidean', V=None)€Ù¹‚…Ù§xkComputes the standardized Euclidean distance. The standardized    Euclidean distance between two n-vectors Ù¡auÙ§e and Ù¡avÙ§c is€Ù¤x,\sqrt { \sum { ( u_i - v_i)^2 / V [ x_i]}}. Ù¹‚Ù§x–V is the variance vector; V[i] is the variance computed over all    the i'th components of the points. If not passed, it is    automatically computed.€ÙÇ‚Ù¹‚Ù¡x Y = cdist(XA, XB, 'sqeuclidean')€Ù¹‚ƒÙ§x(Computes the squared Euclidean distance Ù¥k\|u-v\|_2^2Ù§x between    the vectors.€ÙÇ„Ù¹‚Ù¡xY = cdist(XA, XB, 'cosine')€Ù¹‚Ù§x5Computes the cosine distance between vectors u and v,€Ù¤x01 - \frac { u \cdot v} { { \|u\|}_2 { \|v\|}_2} Ù¹‚‹Ù§fwhere Ù¥g\|*\|_2Ù§x is the 2-norm of its argument Ù¡a*Ù§i, and    Ù¥iu \cdot vÙ§w is the dot product of Ù¥auÙ§e and Ù¥avÙ§a.€ÙÇ„Ù¹‚Ù¡x Y = cdist(XA, XB, 'correlation')€Ù¹‚Ù§xBComputes the correlation distance between vectors u and v. This is€Ù¤xn1 - \frac { ( u - \bar { u}) \cdot ( v - \bar { v})} { { \| ( u - \bar { u})\|}_2 { \| ( v - \bar { v})\|}_2} Ù¹‚‰Ù§fwhere Ù¥g\bar{v}Ù§x1 is the mean of the elements of vector v,    and Ù¥ix \cdot yÙ§w is the dot product of Ù¥axÙ§e and Ù¥ayÙ§a.€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'hamming')€Ù¹‚‡Ù§xnComputes the normalized Hamming distance, or the proportion of    those vector elements between two n-vectors Ù¡auÙ§e and Ù¡avÙ§x/    which disagree. To save memory, the matrix Ù¡aXÙ§x can be of type    boolean.€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'jaccard')€Ù¹‚‰Ù§xHComputes the Jaccard distance between the points. Given two    vectors, Ù¡auÙ§e and Ù¡avÙ§x>, the Jaccard distance is the    proportion of those elements Ù¡du[i]Ù§e and Ù¡dv[i]Ù§x9 that    disagree where at least one of them is non-zero.€ÙÇ„Ù¹‚Ù¡x"Y = cdist(XA, XB, 'jensenshannon')€Ù¹‚…Ù§xhComputes the Jensen-Shannon distance between two probability arrays.     Given two probability vectors, Ù¥apÙ§e and Ù¥aqÙ§x$, the     Jensen-Shannon distance is€Ù¤x?\sqrt { \frac { D ( p \parallel m) + D ( q \parallel m)} { 2}} Ù¹‚‰Ù§fwhere Ù¥amÙ§x is the pointwise mean of Ù¥apÙ§e and Ù¥aqÙ§i     and Ù¥aDÙ§x$ is the Kullback-Leibler divergence.€ÙÇƒÙ¹‚Ù¡xY = cdist(XA, XB, 'chebyshev')€Ù¹‚…Ù§xeComputes the Chebyshev distance between the points. The     Chebyshev distance between two n-vectors Ù¡auÙ§e and Ù¡avÙ§xs is the     maximum norm-1 distance between their respective elements. More     precisely, the distance is given by€Ù¤x"d ( u,v) = \max_i { |u_i - v_i|}. ÙÇƒÙ¹‚Ù¡xY = cdist(XA, XB, 'canberra')€Ù¹‚…Ù§x`Computes the Canberra distance between the points. The     Canberra distance between two points Ù¡auÙ§e and Ù¡avÙ§c is€Ù¤x7d ( u,v) = \sum_i \frac { |u_i - v_i|} { |u_i|+|v_i|}. ÙÇƒÙ¹‚Ù¡xY = cdist(XA, XB, 'braycurtis')€Ù¹‚…Ù§xfComputes the Bray-Curtis distance between the points. The     Bray-Curtis distance between two points Ù¡auÙ§e and Ù¡avÙ§c is€Ù¤xAd ( u,v) = \frac { \sum_i ( |u_i - v_i|)} { \sum_i ( |u_i+v_i|)} ÙÇ‚Ù¹‚Ù¡x)Y = cdist(XA, XB, 'mahalanobis', VI=None)€Ù¹‚Ù§xfComputes the Mahalanobis distance between the points. The     Mahalanobis distance between two points Ù¡auÙ§e and Ù¡avÙ§h is     Ù¥x\sqrt{(u-v)(1/V)(u-v)^T}Ù§g where Ù¥e(1/V)Ù§f (the Ù¡bVIÙ§x-     variable) is the inverse covariance. If Ù¡bVIÙ§r is not None,     Ù¡bVIÙ§x/ will be used as the inverse covariance matrix.€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'yule')€Ù¹‚ƒÙ§xAComputes the Yule distance between the boolean     vectors. (see Ù¢„dyuleÙ „escipye1.8.0fmodulexscipy.spatial.distance.yulefmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'matching')€Ù¹‚Ù§vSynonym for 'hamming'.€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'dice')€Ù¹‚ƒÙ§xAComputes the Dice distance between the boolean vectors. (see     Ù¢„ddiceÙ „escipye1.8.0fmodulexscipy.spatial.distance.dicefmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'kulsinski')€Ù¹‚ƒÙ§xFComputes the Kulsinski distance between the boolean     vectors. (see Ù¢„ikulsinskiÙ „escipye1.8.0fmodulex scipy.spatial.distance.kulsinskifmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡x#Y = cdist(XA, XB, 'rogerstanimoto')€Ù¹‚ƒÙ§xLComputes the Rogers-Tanimoto distance between the boolean     vectors. (see Ù¢„nrogerstanimotoÙ „escipye1.8.0fmodulex%scipy.spatial.distance.rogerstanimotofmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡xY = cdist(XA, XB, 'russellrao')€Ù¹‚ƒÙ§xHComputes the Russell-Rao distance between the boolean     vectors. (see Ù¢„jrussellraoÙ „escipye1.8.0fmodulex!scipy.spatial.distance.russellraofmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡x"Y = cdist(XA, XB, 'sokalmichener')€Ù¹‚ƒÙ§xKComputes the Sokal-Michener distance between the boolean     vectors. (see Ù¢„msokalmichenerÙ „escipye1.8.0fmodulex$scipy.spatial.distance.sokalmichenerfmoduleõÙ§x function documentation)€ÙÇ‚Ù¹‚Ù¡x Y = cdist(XA, XB, 'sokalsneath')€Ù¹‚ƒÙ§xAComputes the Sokal-Sneath distance between the vectors. (see     Ù¢„ksokalsneathÙ „escipye1.8.0fmodulex"scipy.spatial.distance.sokalsneathfmoduleõÙ§x function documentation)€ÙÇ‡Ù¹‚Ù¡tY = cdist(XA, XB, f)€Ù¹‚Ù§xÊComputes the distance between all pairs of vectors in X     using the user supplied 2-arity function f. For example,     Euclidean distance between the vectors could be computed     as follows::        €ÙÀx:dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))Ù¹‚Ù§xƒNote that you should avoid passing a reference to one of     the distance functions defined in this library. For example,::        €ÙÀxdm = cdist(XA, XB, sokalsneath)Ù¹‚…Ù§x_would calculate the pair-wise distances between the vectors in     X using the Python function Ù¢„ksokalsneathÙ „escipye1.8.0fmodulex"scipy.spatial.distance.sokalsneathfmoduleõÙ§x4. This would result in     sokalsneath being called Ù¥m{n \choose 2}Ù§x times, which     is inefficient. Instead, the optimized C version is more     efficient, and we call it using the following syntax::        €ÙÀx!dm = cdist(XA, XB, 'sokalsneath')öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒbXAjarray_likeÙ¹‚‰Ù§cAn Ù¥cm_AÙ§d by Ù¥anÙ§j array of Ù¥cm_AÙ§x original observations in an Ù¥anÙ§x7-dimensional space. Inputs are converted to float type.€Ù°ƒbXBjarray_likeÙ¹‚‰Ù§cAn Ù¥cm_BÙ§d by Ù¥anÙ§j array of Ù¥cm_BÙ§x original observations in an Ù¥anÙ§x7-dimensional space. Inputs are converted to float type.€Ù°ƒfmetricxstr or callable, optionalÙ¹‚Ù§ywThe distance metric to use. If a string, the distance function can be 'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation', 'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon', 'kulsinski', 'kulczynski1', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'.€Ù°ƒh**kwargsndict, optional‚Ù¹‚ƒÙ§sExtra arguments to Ù¢„fmetricÙ „ööelocalfmetricelocalõÙ§xJ: refer to each metric documentation for a list of all possible arguments.€Ù¹‚Ù§xSome possible arguments:€öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚…Ù§xAn exception is thrown if Ù¢„bXAÙ „ööelocalbXAelocalõÙ§e and Ù¢„bXBÙ „ööelocalbXBelocalõÙ§x( do not have the same number of columns.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaYgndarrayÙ¹‚Ù§bA Ù¥cm_AÙ§d by Ù¥cm_BÙ§x' distance matrix is returned. For each Ù¥aiÙ§e and Ù¥ajÙ§m, the metric Ù¡vdist(u=XA[i], v=XB[j])Ù§x is computed and stored in the Ù¥bijÙ§j th entry.€ögSummaryÙ¯‚Ù¹‚Ù§xDCompute distance between each pair of the two collections of inputs.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseseNoteshExamplesx/scipy/spatial/distance.py
9r<class 'function'>x+scipy.signal._ltisys.interpolate._rbf.cdistÙ¯‚„Ù¹‚Ù§x:Find the Euclidean distances between four 2-D coordinates:€Ù´ƒ˜DÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„gspatialÙ „escipye1.8.0fmodulemscipy.spatialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hdistanceÙ „escipye1.8.0fmodulevscipy.spatial.distancefmoduleõÙ±‚`a
Ù±‚`Ù¢„fcoordsÙ „escipye1.8.0fmodulex3scipy.interpolate.interpnd._ndim_coords_from_arraysfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚bmfg35.0456Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfg85.2672Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`j          Ù±‚`a(Ù±‚bmfg35.1174Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfg89.9711Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`j          Ù±‚`a(Ù±‚bmfg35.9728Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfg83.9422Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`j          Ù±‚`a(Ù±‚bmfg36.1667Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfg86.7833Ù±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„hdistanceÙ „escipye1.8.0fmodulevscipy.spatial.distancefmoduleõÙ±‚aoa.Ù±‚`Ù¢„ecdistÙ „escipye1.8.0fmodulexscipy.spatial.distance.cdistfmoduleõÙ±‚`a(Ù±‚`Ù¢„fcoordsÙ „escipye1.8.0fmodulex3scipy.interpolate.interpnd._ndim_coords_from_arraysfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fcoordsÙ „escipye1.8.0fmodulex3scipy.interpolate.interpnd._ndim_coords_from_arraysfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1Ù¢„ieuclideanÙ „escipye1.8.0fmodulex scipy.spatial.distance.euclideanfmoduleõÙ±‚bs1a'Ù±‚`a)x´array([[ 0.    ,  4.7044,  1.6172,  1.8856],
       [ 4.7044,  0.    ,  6.0893,  3.3561],
       [ 1.6172,  6.0893,  0.    ,  2.8477],
       [ 1.8856,  3.3561,  2.8477,  0.    ]])fexecedÙ¹‚Ù§xMFind the Manhattan distance from a 3-D point to the corners of the unit cube:€Ù´ƒ˜Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚`a Ù±‚bmfc0.1Ù±‚`a,Ù±‚`b  Ù±‚bmfc0.2Ù±‚`a,Ù±‚`b  Ù±‚bmfc0.4Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„hdistanceÙ „escipye1.8.0fmodulevscipy.spatial.distancefmoduleõÙ±‚aoa.Ù±‚`Ù¢„ecdistÙ „escipye1.8.0fmodulexscipy.spatial.distance.cdistfmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1Ù¢„icityblockÙ „escipye1.8.0fmodulex scipy.spatial.distance.cityblockfmoduleõÙ±‚bs1a'Ù±‚`a)xxarray([[ 0.7],
       [ 0.9],
       [ 1.3],
       [ 1.5],
       [ 1.5],
       [ 1.7],
       [ 2.1],
       [ 2.3]])fexecedö€e1.8.0Ù«x8cdist(XA, XB, metric='euclidean', *, out=None, **kwargs)öxscipy.spatial.distance.cdist€
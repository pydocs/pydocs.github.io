Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x‰The LGMRES algorithm   is designed to avoid some problems in the convergence in restarted GMRES, and often converges in fewer iterations.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§xúThe LGMRES algorithm   is designed to avoid the slowing of convergence in restarted GMRES, due to alternating residual vectors. Typically, it often outperforms GMRES(m) of comparable memory requirements by some measure, or at least is not much worse.€Ù¹‚ƒÙ§xZAnother advantage in this algorithm is that you can supply it with 'guess' vectors in the Ù¢„gouter_vÙ „ööelocalgouter_velocalõÙ§yI argument that augment the Krylov subspace. If the solution lies close to the span of these vectors, the algorithm converges faster. This can be useful if several very similar matrices need to be inverted one after another, such as in Newton-Krylov iteration where the Jacobian matrix often changes little in the nonlinear steps.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŒÙ°ƒaAx({sparse matrix, ndarray, LinearOperator}Ù¹‚‡Ù§xGThe real or complex N-by-N matrix of the linear system. Alternatively, Ù¡aAÙ§x, can be a linear operator which can produce Ù¡bAxÙ§n using, e.g., Ù¡x"scipy.sparse.linalg.LinearOperatorÙ§a.€Ù°ƒabgndarrayÙ¹‚Ù§x>Right hand side of the linear system. Has shape (N,) or (N,1).€Ù°ƒbx0gndarrayÙ¹‚Ù§x Starting guess for the solution.€Ù°ƒitol, atolofloat, optional‚Ù¹‚‡Ù§xTolerances for convergence, Ù¡x(norm(residual) <= max(tol*norm(b), atol)Ù§r. The default for Ù¡datolÙ§d is Ù¢„ctolÙ „ööelocalctolelocalõÙ§a.€ÙÆƒgwarning`Ù¹‚Ù§xwThe default value for `atol` will be changed in a future release. For future compatibility, specify `atol` explicitly. €Ù°ƒgmaxitermint, optionalÙ¹‚Ù§x}Maximum number of iterations.  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.€Ù°ƒaMx2{sparse matrix, ndarray, LinearOperator}, optionalÙ¹‚Ù§xéPreconditioner for A.  The preconditioner should approximate the inverse of A.  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance.€Ù°ƒhcallbackrfunction, optionalÙ¹‚Ù§x|User-supplied function to call after each iteration.  It is called as callback(xk), where xk is the current solution vector.€Ù°ƒginner_mmint, optionalÙ¹‚Ù§x:Number of inner GMRES iterations per each outer iteration.€Ù°ƒgouter_kmint, optionalÙ¹‚Ù§xÿNumber of vectors to carry between inner GMRES iterations. According to , good values are in the range of 1...3. However, note that if you want to use the additional vectors to accelerate solving multiple similar problems, larger values may be beneficial.€Ù°ƒgouter_vxlist of tuples, optionalÙ¹‚‰Ù§wList containing tuples Ù¡g(v, Av)Ù§x“ of vectors and corresponding matrix-vector products, used to augment the Krylov subspace, and carried between inner GMRES iterations. The element Ù¡bAvÙ§h can be Ù¡dNoneÙ§x] if the matrix-vector product should be re-evaluated. This parameter is modified in-place by Ù¢„flgmresÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§xd, and can be used to pass "guess" vectors in and out of the algorithm when solving similar problems.€Ù°ƒnstore_outer_Avnbool, optionalÙ¹‚…Ù§x<Whether LGMRES should store also A@v in addition to vectors Ù£ƒavööÙ§h in the Ù¢„gouter_vÙ „ööelocalgouter_velocalõÙ§w list. Default is True.€Ù°ƒoprepend_outer_vnbool, optionalÙ¹‚Ù§xnWhether to put outer_v augmentation vectors before Krylov iterates. In standard LGMRES, prepend_outer_v=False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaxgndarrayÙ¹‚Ù§wThe converged solution.€Ù°ƒdinfocintÙ¹‚Ù§x!Provides convergence information:€ögSummaryÙ¯‚Ù¹‚Ù§x3Solve a matrix equation using the LGMRES algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshExamplesx&/scipy/sparse/linalg/_isolve/lgmres.pyr<class 'function'>xPscipy.signal._filter_design.optimize._differentiable_functions.sps.linalg.lgmresÙ¯‚‚Ù´ƒ˜sÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flgmresÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`hexitCodeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flgmresÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`hexitCodeÙ±‚`a)Ù±‚`l            Ù±‚bc1x$# 0 indicates successful convergencea0fexecedÙ´ƒÙ±‚`kjedi faileddTruefexecedö€e1.8.0Ù«x¡lgmres(A, b, x0=None, tol=1e-05, maxiter=1000, M=None, callback=None, inner_m=30, outer_k=3, outer_v=None, store_outer_Av=True, prepend_outer_v=False, atol=None)öx)scipy.sparse.linalg._isolve.lgmres.lgmres€
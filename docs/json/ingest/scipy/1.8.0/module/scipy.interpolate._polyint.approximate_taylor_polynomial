Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§y/The appropriate choice of "scale" is a trade-off; too large and the function differs from its Taylor polynomial too much to get a good answer, too small and round-off errors overwhelm the higher-order terms. The algorithm used becomes numerically unstable around order 30 even under ideal circumstances.€Ù¹‚Ù§xNChoosing order somewhat larger than degree may improve the higher-order terms.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒafhcallableÙ¹‚ƒÙ§xJThe function whose Taylor polynomial is sought. Should accept a vector of Ù¢„axÙ „ööelocalaxelocalõÙ§h values.€Ù°ƒaxfscalarÙ¹‚Ù§x5The point at which the polynomial is to be evaluated.€Ù°ƒfdegreecintÙ¹‚Ù§x#The degree of the Taylor polynomial€Ù°ƒescalefscalarÙ¹‚Ù§x«The width of the interval to use to evaluate the Taylor polynomial. Function values spread over a range this wide are used to fit the polynomial. Must be chosen carefully.€Ù°ƒeorderuint or None, optionalÙ¹‚‡Ù§x7The order of the polynomial to be used in the fitting; Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ§s will be evaluated Ù¡gorder+1Ù§u times. If None, use Ù¢„fdegreeÙ „escipye1.8.0fmodulex,scipy.signal._filter_design._relative_degreefmoduleõÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒapopoly1d instanceÙ¹‚Ù§xPThe Taylor polynomial (translated to the origin, so that for example p(0)=f(x)).€ögSummaryÙ¯‚Ù¹‚Ù§x?Estimate the Taylor polynomial of f at x by polynomial fitting.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametersgReturnseNoteshExamplesx/scipy/interpolate/_polyint.py¨r<class 'function'>x>scipy.signal._ltisys.interpolate.approximate_taylor_polynomialÙ¯‚ƒÙ¹‚Ù§xWWe can calculate Taylor approximation polynomials of sin function with various degrees:€Ù´ƒ˜ËÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„kinterpolateÙ „escipye1.8.0fmoduleqscipy.interpolatefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„xapproximate_taylor_polynomialÙ „escipye1.8.0fmodulex8scipy.interpolate._polyint.approximate_taylor_polynomialfmoduleõÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmfd10.0Ù±‚`a,Ù±‚`a Ù±‚bmfd10.0Ù±‚`a,Ù±‚`a Ù±‚`cnumÙ±‚aoa=Ù±‚bmic100Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`csinÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2isin curveÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚akcforÙ±‚`a Ù±‚`Ù¢„fdegreeÙ „escipye1.8.0fmodulex,scipy.signal._filter_design._relative_degreefmoduleõÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„b15Ù „escipye1.8.0fmodulex*scipy.integrate._quad_vec._quadrature_gk15fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dstepÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`jsin_taylorÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„xapproximate_taylor_polynomialÙ „escipye1.8.0fmodulex8scipy.interpolate._polyint.approximate_taylor_polynomialfmoduleõÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`csinÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„fdegreeÙ „enumpyf1.22.3fmoduleknumpy.int64fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a
Ù±‚`x/                                               Ù±‚`eorderÙ±‚aoa=Ù±‚`Ù¢„fdegreeÙ „enumpyf1.22.3fmoduleknumpy.int64fmoduleõÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„jsin_taylorÙ „enumpyf1.22.3fmodulelnumpy.poly1dfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bsaÙ¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚bs2a"Ù±‚bs2gdegree=Ù±‚bsia{Ù±‚`Ù¢„fdegreeÙ „enumpyf1.22.3fmoduleknumpy.int64fmoduleõÙ±‚bsia}Ù±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`nbbox_to_anchorÙ±‚aoa=Ù±‚`a(Ù±‚bmfd1.05Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`clocÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1jupper leftÙ±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`k           Ù±‚`mborderaxespadÙ±‚aoa=Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚`fshadowÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ltight_layoutÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.tight_layoutfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„daxisÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.axisfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚aoa-Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸xBfig-scipy.interpolate._polyint.approximate_taylor_polynomial-0.pngö€e1.8.0Ù«x>approximate_taylor_polynomial(f, x, degree, scale, order=None)öx8scipy.interpolate._polyint.approximate_taylor_polynomial€
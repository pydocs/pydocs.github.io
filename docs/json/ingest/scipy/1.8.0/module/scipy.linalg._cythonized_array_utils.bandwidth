Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù·xGThis helper function simply runs over the array looking for the nonzeroxKentries whether there exists a banded structure in the array or not. Hence,xBthe performance depends on the density of nonzero entries and alsoxDmemory-layout. Fortran- or C- contiguous arrays are handled best andx7otherwise suffers from extra random memory access cost.`xDThe strategy is to look for only untested band elements in the upperxEand lower triangular parts separately; depending on the memory layoutxCwe scan row-wise or column-wise. Moreover, say we are scanning rowsxEand in the 6th row, 4th entry is nonzero then, on the succeeding rowsxHthe horizontal search is done only up to that band entries since we knowxHthat band is occupied. Therefore, a completely dense matrix scan cost isvin the the order of n.öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒaagndarrayÙ¹‚Ù§xInput array of size (N, M)€öfRaisesÙ¯‚Ù°ƒ`iTypeErrorÙ¹‚Ù§xiIf the dtype of the array is not supported, in particular, NumPy float16, float128 and complex256 dtypes.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒbluetupleÙ¹‚Ù§xí2-tuple of ints indicating the lower and upper bandwith. A zero denotes no sub- or super-diagonal on that side (triangular), and, say for N rows (N-1) means that side is full. Same example applies to the upper triangular part with (M-1).€ögSummaryÙ¯‚Ù¹‚Ù§xHbandwidth(a) Return the lower and upper bandwidth of a 2D numeric array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNotesfRaiseshExamplesööx$<class 'builtin_function_or_method'>x-scipy.signal._lti_conversion.linalg.bandwidthÙ¯‚Ù·ˆx&>>> from scipy.linalg import bandwidthx'>>> A = np.array([[3., 0., 0., 0., 0.],x'...               [0., 4., 0., 0., 0.],x'...               [0., 0., 5., 1., 0.],x'...               [8., 0., 0., 6., 2.],x(...               [0., 9., 0., 0., 7.]])p>>> bandwidth(A)f(3, 1)ö€e1.8.0Ù«ööx.scipy.linalg._cythonized_array_utils.bandwidth€
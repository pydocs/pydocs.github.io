Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚„Ù£ƒaCööÙ§x4 is the circulant matrix associated with the vector Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù¹‚Ù§xSThe system is solved by doing division in Fourier space. The calculation is::      €ÙÀxx = ifft(fft(b) / fft(c))Ù¹‚‰Ù§fwhere Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ§e and Ù¢„difftÙ „escipye1.8.0fmoduleuscipy.fft._basic.ifftfmoduleõÙ§xR are the fast Fourier transform and its inverse, respectively. For a large vector Ù¢„acÙ „ööelocalacelocalõÙ§j, this is Ù¨Ù§dmuchÙ§x? faster than solving the system with the full circulant matrix.€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚‰Ù§qFor a 1-D vector Ù¢„acÙ „ööelocalacelocalõÙ§m with length Ù£ƒamööÙ§o, and an array Ù¢„abÙ „ööelocalabelocalõÙ§l with shape Ù¡h(m, ...)Ù§a,€Ù·usolve_circulant(c, b)Ù¹‚Ù§xreturns the same result as€Ù·vsolve(circulant(c), b)Ù¹‚‡Ù§fwhere Ù¢„esolveÙ „escipye1.8.0fmodulexscipy.linalg._basic.solvefmoduleõÙ§e and Ù¢„icirculantÙ „escipye1.8.0fmodulex(scipy.linalg._special_matrices.circulantfmoduleõÙ§j are from Ù¢„lscipy.linalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.16.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒacjarray_likeÙ¹‚Ù§x)The coefficients of the circulant matrix.€Ù°ƒabjarray_likeÙ¹‚ƒÙ§xRight-hand side matrix in Ù¡ga x = bÙ§a.€Ù°ƒhsingularmstr, optionalÙ¹‚‡Ù§xLThis argument controls how a near singular circulant matrix is handled.  If Ù¢„hsingularÙ „ööelocalhsingularelocalõÙ§x9 is "raise" and the circulant matrix is near singular, a Ù£ƒkLinAlgErrorööÙ§o is raised. If Ù¢„hsingularÙ „ööelocalhsingularelocalõÙ§xH is "lstsq", the least squares solution is returned. Default is "raise".€Ù°ƒctolofloat, optionalƒÙ¹‚…Ù§x^If any eigenvalue of the circulant matrix has an absolute value that is less than or equal to Ù¢„ctolÙ „ööelocalctolelocalõÙ§x>, the matrix is considered to be near singular. If not given, Ù¢„ctolÙ „ööelocalctolelocalõÙ§r is set to::      €ÙÀx?tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).epsÙ¹‚ƒÙ§fwhere Ù£ƒhabs_eigsööÙ§xL is the array of absolute values of the eigenvalues of the circulant matrix.€Ù°ƒecaxiscintÙ¹‚‡Ù§eWhen Ù¢„acÙ „ööelocalacelocalõÙ§x` has dimension greater than 1, it is viewed as a collection of circulant vectors. In this case, Ù¢„ecaxisÙ „ööelocalecaxiselocalõÙ§p is the axis of Ù¢„acÙ „ööelocalacelocalõÙ§x2 that holds the vectors of circulant coefficients.€Ù°ƒebaxiscintÙ¹‚‡Ù§eWhen Ù¢„abÙ „ööelocalabelocalõÙ§xV has dimension greater than 1, it is viewed as a collection of vectors. In this case, Ù¢„ebaxisÙ „ööelocalebaxiselocalõÙ§p is the axis of Ù¢„abÙ „ööelocalabelocalõÙ§x( that holds the right-hand side vectors.€Ù°ƒgoutaxiscintÙ¹‚‰Ù§eWhen Ù¢„acÙ „ööelocalacelocalõÙ§d or Ù¢„abÙ „ööelocalabelocalõÙ§x- are multidimensional, the value returned by Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ§x$ is multidimensional. In this case, Ù¢„goutaxisÙ „ööelocalgoutaxiselocalõÙ§x; is the axis of the result that holds the solution vectors.€öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚ƒÙ§x(If the circulant matrix associated with Ù¢„acÙ „ööelocalacelocalõÙ§r is near singular.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaxgndarrayÙ¹‚ƒÙ§wSolution to the system Ù¡gC x = bÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x3Solve C x = b for x, where C is a circulant matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesw/scipy/linalg/_basic.py¾r<class 'function'>x3scipy.signal._lti_conversion.linalg.solve_circulantÙ¯‚’Ù´ƒ’Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„esolveÙ „escipye1.8.0fmodulexscipy.linalg._basic.solvefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„icirculantÙ „escipye1.8.0fmodulex(scipy.linalg._special_matrices.circulantfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõ`fexecedÙ´ƒ˜-Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)xarray([ 0.75, -0.25,  0.25])fexecedÙ¹‚ƒÙ§x/Compare that result to solving the system with Ù¢„rscipy.linalg.solveÙ „escipya*capixscipy.linalg._basic.solvefmoduleõÙ§a:€Ù´ƒŠÙ±‚`Ù¢„esolveÙ „escipye1.8.0fmodulexscipy.linalg._basic.solvefmoduleõÙ±‚`a(Ù±‚`Ù¢„icirculantÙ „escipye1.8.0fmodulex(scipy.linalg._special_matrices.circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)xarray([ 0.75, -0.25,  0.25])fexecedÙ¹‚Ù§sA singular example:€Ù´ƒ˜+Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚‡Ù§hCalling Ù¡usolve_circulant(c, b)Ù§n will raise a Ù£ƒkLinAlgErrorööÙ§x1.  For the least square solution, use the option Ù¡psingular='lstsq'Ù§a:€Ù´ƒÙ±‚`Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`hsingularÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚bs1a'Ù±‚`a)x#array([ 0.25,  1.25,  2.25,  1.25])fexecedÙ¹‚ƒÙ§kCompare to Ù¢„rscipy.linalg.lstsqÙ „escipya*capixscipy.linalg._basic.lstsqfmoduleõÙ§a:€Ù´ƒ˜Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`eresidÙ±‚`a,Ù±‚`a Ù±‚`crnkÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚`a(Ù±‚`Ù¢„icirculantÙ „escipye1.8.0fmodulex(scipy.linalg._special_matrices.circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx#array([ 0.25,  1.25,  2.25,  1.25])fexecedÙ¹‚Ù§wA broadcasting example:€Ù¹‚ƒÙ§xfSuppose we have the vectors of two circulant matrices stored in an array with shape (2, 5), and three Ù¢„abÙ „ööelocalabelocalõÙ§x< vectors stored in an array with shape (3, 5).  For example,€Ù´ƒ˜?Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmiÙ¢„b15Ù „escipye1.8.0fmodulex*scipy.integrate._quad_vec._quadrature_gk15fmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`greshapeÙ±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)`fexecedÙ¹‚˜Ù§x<We want to solve all combinations of circulant matrices and Ù¢„abÙ „ööelocalabelocalõÙ§xa vectors, with the result stored in an array with shape (2, 3, 5). When we disregard the axes of Ù¢„acÙ „ööelocalacelocalõÙ§e and Ù¢„abÙ „ööelocalabelocalõÙ§xŞ that hold the vectors of coefficients, the shapes of the collections are (2,) and (3,), respectively, which are not compatible for broadcasting. To have a broadcast result with shape (2, 3), we add a trivial dimension to Ù¢„acÙ „ööelocalacelocalõÙ§b: Ù¡sc[:, np.newaxis, :]Ù§xk has shape (2, 1, 5). The last dimension holds the coefficients of the circulant matrices, so when we call Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ§x, we can use the default Ù¡hcaxis=-1Ù§x. The coefficients of the Ù¢„abÙ „ööelocalabelocalõÙ§x0 vectors are in the last dimension of the array Ù¢„abÙ „ööelocalabelocalõÙ§l, so we use Ù¡hbaxis=-1Ù§x. If we use the default Ù¢„goutaxisÙ „ööelocalgoutaxiselocalõÙ§x5, the result will have shape (5, 2, 3), so we'll use Ù¡joutaxis=-1Ù§x3 to put the solution vectors in the last dimension.€Ù´ƒ˜&Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`gnewaxisÙ±‚`a,Ù±‚`a Ù±‚`a:Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`ebaxisÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`goutaxisÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapei(2, 3, 5)fexecedÙ´ƒŒÙ±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pset_printoptionsÙ „enumpyf1.22.3fmodulevnumpy.set_printoptionsfmoduleõÙ±‚`a(Ù±‚`Ù¢„iprecisionÙ „escipye1.8.0fmodulex*scipy.optimize._shgo.SHGO.finite_precisionfmoduleõÙ±‚aoa=Ù±‚bmia3Ù±‚`a)Ù±‚`b  Ù±‚bc1x # For compact output of numbers.Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõy.array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
        [ 0.651,  0.989,  2.046,  0.627,  1.072],
        [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
       [[ 0.401,  0.304,  0.694, -0.867,  0.377],
        [ 0.856,  0.758,  1.149, -0.412,  0.831],
        [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])fexecedÙ¹‚‡Ù§xCheck by solving one pair of Ù¢„acÙ „ööelocalacelocalõÙ§e and Ù¢„abÙ „ööelocalabelocalõÙ§n vectors (cf. Ù¡jx[1, 1, :]Ù§b):€Ù´ƒÙ±‚`Ù¢„osolve_circulantÙ „escipye1.8.0fmodulex#scipy.linalg._basic.solve_circulantfmoduleõÙ±‚`a(Ù±‚`Ù¢„acÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`a:Ù±‚`a]Ù±‚`a)x/array([ 0.856,  0.758,  1.149, -0.412,  0.831])fexecedöÙ¼ƒÙ»ƒicirculantx(scipy.linalg._special_matrices.circulantõÙ¹‚Ù§pcirculant matrix€öe1.8.0Ù«xOsolve_circulant(c, b, singular='raise', tol=None, caxis=-1, baxis=0, outaxis=0)öx#scipy.linalg._basic.solve_circulant€
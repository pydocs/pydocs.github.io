Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚‰Ù§xThis function returns a block diagonal matrix D consisting blocks of size at most 2x2 and also a possibly permuted unit lower triangular matrix Ù¡aLÙ§x such that the factorization Ù¡kA = L D L^HÙ§d or Ù¡kA = L D L^TÙ§k holds. If Ù¢„elowerÙ „ööelocalelowerelocalõÙ§xa is False then (again possibly permuted) upper triangular matrices are returned as outer factors.€Ù¹‚‰Ù§xdThe permutation array can be used to triangularize the outer factors simply by a row shuffle, i.e., Ù¡klu[perm, :]Ù§xj is an upper/lower triangular matrix. This is also equivalent to multiplication with a permutation matrix Ù¡iP.dot(lu)Ù§h, where Ù¡aPÙ§x& is a column-permuted identity matrix Ù¡jI[:, perm]Ù§a.€Ù¹‚ƒÙ§x&Depending on the value of the boolean Ù¢„elowerÙ „ööelocalelowerelocalõÙ§x©, only upper or lower triangular part of the input array is referenced. Hence, a triangular matrix on entry would give the same result as if the full matrix is supplied.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚…Ù§sThis function uses Ù¡f?SYTRFÙ§x% routines for symmetric matrices and Ù¡f?HETRFÙ§xM routines for Hermitian matrices from LAPACK. See  for the algorithm details.€Ù¹‚ƒÙ§qDepending on the Ù¢„elowerÙ „ööelocalelowerelocalõÙ§x² keyword value, only lower or upper triangular part of the input array is referenced. Moreover, this keyword also defines the structure of the outer factors of the factorization.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.1.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaAjarray_likeÙ¹‚Ù§rSquare input array€Ù°ƒelowernbool, optionalÙ¹‚ƒÙ§xkThis switches between the lower and upper triangular outer factors of the factorization. Lower triangular (Ù¡jlower=TrueÙ§q) is the default.€Ù°ƒihermitiannbool, optionalÙ¹‚…Ù§x0For complex-valued arrays, this defines whether Ù¡nA = A.conj().TÙ§d or Ù¡gA = A.TÙ§x? is assumed. For real-valued arrays, this switch has no effect.€Ù°ƒkoverwrite_anbool, optionalÙ¹‚ƒÙ§xAllow overwriting data in Ù¢„aAÙ „ööelocalaAelocalõÙ§x1 (may enhance performance). The default is False.€Ù°ƒlcheck_finitenbool, optionalÙ¹‚Ù§xÏWhether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.€öfRaisesÙ¯‚‚Ù°ƒ`jValueErrorÙ¹‚Ù§xIf input array is not square.€Ù°ƒ`nComplexWarningÙ¹‚Ù§xmIf a complex-valued array with nonzero imaginary parts on the diagonal is given and hermitian is set to True.€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒblugndarrayÙ¹‚Ù§xQThe (possibly) permuted upper/lower triangular outer factor of the factorization.€Ù°ƒadgndarrayÙ¹‚Ù§x3The block diagonal multiplier of the factorization.€Ù°ƒdpermgndarrayÙ¹‚Ù§xDThe row-permutation index array that brings lu into triangular form.€ögSummaryÙ¯‚Ù¹‚Ù§xRComputes the LDLt or Bunch-Kaufman factorization of a symmetric/ hermitian matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshExampleseNoteshSee AlsojReferencesx/scipy/linalg/_decomp_ldl.pyr<class 'function'>x'scipy.signal._lti_conversion.linalg.ldlÙ¯‚†Ù¹‚‡Ù§x Given an upper triangular array Ù¡aaÙ§xC that represents the full symmetric array with its entries, obtain Ù¡alÙ§x!, 'd' and the permutation vector Ù¢„dpermÙ „ööelocaldpermelocalõÙ§a:€Ù´ƒ˜UÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cldlÙ „escipye1.8.0fmodulexscipy.linalg._decomp_ldl.ldlfmoduleõÙ±‚`a
Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„bluÙ „escipye1.8.0fmodulexscipy.linalg._decomp_lu.lufmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dpermÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cldlÙ „escipye1.8.0fmodulexscipy.linalg._decomp_ldl.ldlfmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`elowerÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`a Ù±‚bc1t# Use the upper partÙ±‚`a
Ù±‚`Ù¢„bluÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxQarray([[ 0. ,  0. ,  1. ],
       [ 0. ,  1. , -0.5],
       [ 1. ,  1. ,  1.5]])fexecedÙ´ƒÙ±‚`Ù¢„adÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxQarray([[-5. ,  0. ,  0. ],
       [ 0. ,  1.5,  0. ],
       [ 0. ,  0. ,  2. ]])fexecedÙ´ƒÙ±‚`Ù¢„dpermÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõparray([2, 1, 0])fexecedÙ´ƒ‡Ù±‚`Ù¢„bluÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`Ù¢„dpermÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`a:Ù±‚`a]xQarray([[ 1. ,  1. ,  1.5],
       [ 0. ,  1. , -0.5],
       [ 0. ,  0. ,  1. ]])fexecedÙ´ƒÙ±‚`Ù¢„bluÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„adÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„bluÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)xHarray([[ 2., -1.,  3.],
       [-1.,  2.,  0.],
       [ 3.,  0.,  1.]])fexecedö‚Ù¼ƒÙ»ƒhcholeskyx&scipy.linalg._decomp_cholesky.choleskyõ€öÙ¼ƒÙ»ƒbluxscipy.linalg._decomp_lu.luõ€öe1.8.0Ù«xHldl(A, lower=True, hermitian=True, overwrite_a=False, check_finite=True)öxscipy.linalg._decomp_ldl.ldl€
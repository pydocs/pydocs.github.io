Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‹Ù§x.This primarily exists to be called during the Ù¡mmethod='auto'Ù§k option in Ù¢„hconvolveÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.convolvefmoduleõÙ§e and Ù¢„icorrelateÙ „escipye1.8.0fmodulex#scipy.signal._signaltools.correlatefmoduleõÙ§x0. It can also be used to determine the value of Ù¡fmethodÙ§x€ for many different convolutions of the same dtype/shape. In addition, it supports timing the convolution to adapt the value of Ù¡fmethodÙ§x/ to a particular set of inputs and/or hardware.€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚‡Ù§xŠGenerally, this method is 99% accurate for 2D signals and 85% accurate for 1D signals for randomly chosen input sizes. For precision, use Ù¡lmeasure=TrueÙ§x} to find the fastest method by timing the convolution. This can be used to avoid the minimal overhead of finding the fastest Ù¡fmethodÙ§x! later, or to adapt the value of Ù¡fmethodÙ§x to a particular set of inputs.€Ù¹‚…Ù§x›Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this function. These experiments measured the ratio between the time required when using Ù¡mmethod='auto'Ù§x5 and the time required for the fastest method (i.e., Ù¡x.ratio = time_auto / min(time_fft, time_direct)Ù§x"). In these experiments, we found:€ÙÈƒÙ¹‚Ù§x€There is a 95% chance of this ratio being less than 1.5 for 1D signals   and a 99% chance of being less than 2.5 for 2D signals.€Ù¹‚Ù§xDThe ratio was always less than 2.5/5 for 1D/2D signals respectively.€Ù¹‚…Ù§xdThis function is most inaccurate for 1D convolutions that take between 1   and 10 milliseconds with Ù¡omethod='direct'Ù§x;. A good proxy for this   (at least in our experiments) is Ù¡x!1e6 <= in1.size * in2.size <= 1e7Ù§a.€Ù¹‚Ù§x„The 2D results almost certainly generalize to 3D/4D/etc because the implementation is the same (the 1D implementation is different).€Ù¹‚Ù§ykAll the numbers above are specific to the EC2 machine. However, we did find that this function generalizes fairly decently across hardware. The speed tests were of similar quality (and even slightly better) than the same tests performed on the machine to tune this function's numbers (a mid-2014 15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).€Ù¹‚…Ù§uThere are cases when Ù¢„kfftconvolveÙ „escipye1.8.0fmodulex%scipy.signal._signaltools.fftconvolvefmoduleõÙ§x/ supports the inputs but this function returns Ù£ƒfdirectööÙ§x= (e.g., to protect against floating point integer precision).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.19 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒcin1jarray_likeÙ¹‚Ù§x8The first argument passed into the convolution function.€Ù°ƒcin2jarray_likeÙ¹‚Ù§x9The second argument passed into the convolution function.€Ù°ƒdmodex'str {'full', 'valid', 'same'}, optional‚Ù¹‚Ù§x+A string indicating the size of the output:€ÙÁƒÙÅ‚Ù¹‚Ù¡dfull€Ù¹‚Ù§xNThe output is the full discrete linear convolution    of the inputs. (Default)€ÙÅ‚Ù¹‚Ù¡evalid€Ù¹‚Ù§xSThe output consists only of those elements that do not    rely on the zero-padding.€ÙÅ‚Ù¹‚Ù¡dsame€Ù¹‚ƒÙ§xThe output is the same size as Ù¢„cin1Ù „ööelocalcin1elocalõÙ§x0, centered    with respect to the 'full' output.€Ù°ƒgmeasurenbool, optionalÙ¹‚…Ù§x)If True, run and time the convolution of Ù¢„cin1Ù „ööelocalcin1elocalõÙ§e and Ù¢„cin2Ù „escipye1.8.0fmodulex'scipy.signal._fir_filter_design.firwin2fmoduleõÙ§xs with both methods and return the fastest. If False (default), predict the fastest method using precomputed values.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒfmethodcstrÙ¹‚Ù§xQA string indicating which convolution method is fastest, either 'direct' or 'fft'€Ù°ƒetimesndict, optionalÙ¹‚ƒÙ§xfA dictionary containing the times (in seconds) needed for each method. This value is only returned if Ù¡lmeasure=TrueÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x0Find the fastest convolution/correlation method.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/signal/_signaltools.py„r<class 'function'>xscipy.signal.choose_conv_methodÙ¯‚…Ù¹‚Ù§x.Estimate the fastest method for a given input:€Ù´ƒ˜JÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`cimgÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmib32Ù±‚`a,Ù±‚`a Ù±‚bmib32Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚bnbffilterÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„rchoose_conv_methodÙ „escipye1.8.0fmodulex,scipy.signal._signaltools.choose_conv_methodfmoduleõÙ±‚`a(Ù±‚`cimgÙ±‚`a,Ù±‚`a Ù±‚bnbffilterÙ±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dsameÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõe'fft'fexecedÙ¹‚Ù§xEThis can then be applied to other arrays of the same dtype and shape:€Ù´ƒ˜SÙ±‚`dimg2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmib32Ù±‚`a,Ù±‚`a Ù±‚bmib32Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`gfilter2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ecorr2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „escipye1.8.0fmodulex#scipy.signal._signaltools.correlatefmoduleõÙ±‚`a(Ù±‚`dimg2Ù±‚`a,Ù±‚`a Ù±‚`gfilter2Ù±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dsameÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚aoa=Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`econv2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hconvolveÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.convolvefmoduleõÙ±‚`a(Ù±‚`dimg2Ù±‚`a,Ù±‚`a Ù±‚`gfilter2Ù±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dsameÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚aoa=Ù±‚`Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ±‚`a)`fexecedÙ¹‚‡Ù§xThe output of this function (Ù¡fmethodÙ§m) works with Ù¢„icorrelateÙ „escipye1.8.0fmodulex#scipy.signal._signaltools.correlatefmoduleõÙ§e and Ù¢„hconvolveÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.convolvefmoduleõÙ§a.€ö‚Ù¼ƒÙ»ƒhconvolvex"scipy.signal._signaltools.convolveõ€öÙ¼ƒÙ»ƒicorrelatex#scipy.signal._signaltools.correlateõ€öe1.8.0Ù«x8choose_conv_method(in1, in2, mode='full', measure=False)öx,scipy.signal._signaltools.choose_conv_method€
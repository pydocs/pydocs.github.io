Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚‹Ù§wThe Lambert W function Ù£ƒdW(z)ööÙ§x' is defined as the inverse function of Ù¡jw * exp(w)Ù§x. In other words, the value of Ù¡dW(z)Ù§n is such that Ù¡tz = W(z) * exp(W(z))Ù§x for any complex number Ù¡azÙ§a.€Ù¹‚…Ù§x†The Lambert W function is a multivalued function with infinitely many branches. Each branch gives a separate solution of the equation Ù¡lz = w exp(w)Ù§x0. Here, the branches are indexed by the integer Ù¢„akÙ „ööelocalakelocalõÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚ˆÙ¹‚ƒÙ§xAll branches are supported by Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ§a:€ÙÈ‚Ù¹‚‚Ù¡klambertw(z)Ù§x( gives the principal solution (branch 0)€Ù¹‚ƒÙ¡nlambertw(z, k)Ù§x gives the solution on branch Ù£ƒaköö€Ù¹‚Ù§xNThe Lambert W function has two partially real branches: the principal branch (Ù£ƒek = 0ööÙ§s) is real for real Ù¡hz > -1/eÙ§j, and the Ù¡fk = -1Ù§t branch is real for Ù¡l-1/e < z < 0Ù§v. All branches except Ù¡ek = 0Ù§x# have a logarithmic singularity at Ù¡ez = 0Ù§a.€Ù¹‚Ù©Ù§oPossible issues€Ù¹‚…Ù§xGThe evaluation can become inaccurate very close to the branch point at Ù¡d-1/eÙ§x. In some corner cases, Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ§xE might currently fail to converge, or can end up on the wrong branch.€Ù¹‚Ù©Ù§iAlgorithm€Ù¹‚…Ù§x%Halley's iteration is used to invert Ù¡jw * exp(w)Ù§x=, using a first-order asymptotic approximation (O(log(w)) or Ù£ƒdO(w)ööÙ§x) as the initial estimate.€Ù¹‚Ù§xCThe definition, implementation and choice of branches is based on .€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒazjarray_likeÙ¹‚Ù§oInput argument.€Ù°ƒakmint, optionalÙ¹‚Ù§mBranch index.€Ù°ƒctolofloat, optionalÙ¹‚Ù§uEvaluation tolerance.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒawearrayÙ¹‚„Ù¢„awÙ „ööelocalawelocalõÙ§x will have the same shape as Ù¢„azÙ „ööelocalazelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§sLambert W function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰iSignaturegSummarypExtended SummaryjParametersgReturnseNoteshSee AlsojReferenceshExamplesx/scipy/special/_lambertw.pyr<class 'function'>x"scipy.signal._signaltools.lambertwÙ¯‚‹Ù¹‚ƒÙ§x)The Lambert W function is the inverse of Ù¡hw exp(w)Ù§a:€Ù´ƒ”Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„gspecialÙ „escipye1.8.0fmodulemscipy.specialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ±‚`a
Ù±‚`awÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõx(0.56714329040978384+0j)fexecedÙ´ƒŠÙ±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõÙ±‚`a)h(1.0+0j)fexecedÙ¹‚Ù§x!Any branch gives a valid inverse:€Ù´ƒÙ±‚`awÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚bmia3Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõx)(-2.8535817554090377+17.113535539412148j)fexecedÙ´ƒˆÙ±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõÙ±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„awÙ „enumpyf1.22.3fmoduleunumpy.complexfloatingfmoduleõÙ±‚`a)x+(1.0000000000000002+1.609823385706477e-15j)fexecedÙ¹‚Ù©Ù§x Applications to equation-solving€Ù¹‚ƒÙ§x~The Lambert W function may be used to solve various kinds of equations, such as finding the value of the infinite power tower Ù¥rz^{z^{z^{\ldots}}}Ù§a:€Ù´ƒ˜+Ù±‚akcdefÙ±‚`a Ù±‚bnfetowerÙ±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akbifÙ±‚`a Ù±‚`anÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚bmia0Ù±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`azÙ±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`azÙ±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚`etowerÙ±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚aoa-Ù±‚bmia1Ù±‚`a)c...fexecedÙ´ƒ‡Ù±‚`etowerÙ±‚`a(Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a)q0.641185744504986fexecedÙ´ƒ”Ù±‚aoa-Ù±‚`Ù¢„hlambertwÙ „escipye1.8.0fmodulex scipy.special._lambertw.lambertwfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„clogÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmfc0.5Ù±‚`a)Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„clogÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmfc0.5Ù±‚`a)x(0.64118574450498589+0j)fexecedöÙ¼ƒÙ»ƒkwrightomegax(scipy.special.cython_special.wrightomegaõÙ¹‚Ù§xthe Wright Omega function€öe1.8.0Ù«xlambertw(z, k=0, tol=1e-8)öx scipy.special._lambertw.lambertw€
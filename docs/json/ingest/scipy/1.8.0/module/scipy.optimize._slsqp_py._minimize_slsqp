Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒdftolefloatÙ¹‚Ù§x<Precision goal for the value of f in the stopping criterion.€Ù°ƒcepsefloatÙ¹‚Ù§x;Step size used for numerical approximation of the Jacobian.€Ù°ƒddispdboolÙ¹‚ƒÙ§x5Set to True to print convergence messages. If False, Ù£ƒiverbosityööÙ§x is ignored and set to 0.€Ù°ƒgmaxitercintÙ¹‚Ù§xMaximum number of iterations.€Ù°ƒtfinite_diff_rel_stepxNone or array_like, optionalÙ¹‚‹Ù§cIf Ù£ƒx#jac in ['2-point', '3-point', 'cs']ööÙ§x> the relative step size to use for numerical approximation of Ù£ƒcjacööÙ§x(. The absolute step size is computed as Ù¡x)h = rel_step * sign(x0) * max(1, abs(x0))Ù§x0, possibly adjusted to fit into the bounds. For Ù¡pmethod='3-point'Ù§m the sign of Ù£ƒahööÙ§xC is ignored. If None (default) then step is selected automatically.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xgMinimize a scalar function of one or more variables using Sequential Least Squares Programming (SLSQP).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummaryjParametersx/scipy/optimize/_slsqp_py.pyÖr<class 'function'>x>scipy.signal._filter_design.optimize._minimize._minimize_slsqpÙ¯‚€ö€e1.8.0Ù«xÑ_minimize_slsqp(func, x0, args=(), jac=None, bounds=None, constraints=(), maxiter=100, ftol=1e-06, iprint=1, disp=False, eps=1.4901161193847656e-08, callback=None, finite_diff_rel_step=None, **unknown_options)öx(scipy.optimize._slsqp_py._minimize_slsqp€
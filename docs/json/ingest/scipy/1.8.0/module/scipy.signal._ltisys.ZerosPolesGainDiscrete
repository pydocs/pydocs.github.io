Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚“Ù§x=Represents the system as the discrete-time transfer function Ù¥x.H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])Ù§h, where Ù¥akÙ§h is the Ù£ƒdgainööÙ§b, Ù¥azÙ§i are the Ù¢„ezerosÙ „escipye1.8.0fmoduletscipy.optimize.zerosfmoduleõÙ§e and Ù¥apÙ§i are the Ù£ƒepolesööÙ§p. Discrete-time Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ§x3 systems inherit additional functionality from the Ù¢„ddltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.dltifmoduleõÙ§g class.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x:Changing the value of properties that are not part of the Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ§x$ system representation (such as the Ù£ƒaAööÙ§b, Ù£ƒaBööÙ§b, Ù£ƒaCööÙ§b, Ù£ƒaDööÙ§x« state-space matrices) is very inefficient and may lead to numerical inaccuracies.  It is better to convert to the specific system representation first. For example, call Ù¡qsys = sys.to_ss()Ù§x: before accessing/changing the A, B, C, D system matrices.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒg*systemiarguments‚Ù¹‚ƒÙ§dThe Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ§x} class can be instantiated with 1 or 3 arguments. The following gives the number of input arguments and their interpretation:€Ù·ƒx8* 1: `dlti` system: (`StateSpace`, `TransferFunction` ors  `ZerosPolesGain`)x%* 3: array_like: (zeros, poles, gain)Ù°ƒsdt: float, optional`Ù¹‚…Ù§x<Sampling time [s] of the discrete-time systems. Defaults to Ù¡dTrueÙ§xT (unspecified sampling time). Must be specified as a keyword argument, for example, Ù¡fdt=0.1Ù§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xFDiscrete-time Linear Time Invariant system in zeros, poles, gain form.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesx/scipy/signal/_ltisys.py~n<class 'type'>x+scipy.signal._ltisys.ZerosPolesGainDiscreteÙ¯‚…Ù¹‚ƒÙ§x Construct the transfer function Ù¥x-H(s) = \frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}Ù§a:€Ù´ƒ‡Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõ`fexecedÙ´ƒ–Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)xEZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)fexecedÙ¹‚ƒÙ§x Construct the transfer function Ù¥x-H(s) = \frac{5(z - 1)(z - 2)}{(z - 3)(z - 4)}Ù§x% with a sampling time of 0.1 seconds:€Ù´ƒ˜Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`bdtÙ±‚aoa=Ù±‚bmfc0.1Ù±‚`a)xBZerosPolesGainDiscrete(
array([1, 2]),
array([3, 4]),
5,
dt: 0.1
)fexecedö†Ù¼ƒÙ»ƒjStateSpacexscipy.signal._ltisys.StateSpaceõ€öÙ¼ƒÙ»ƒpTransferFunctionx%scipy.signal._ltisys.TransferFunctionõ€öÙ¼ƒÙ»ƒddltixscipy.signal._ltisys.dltiõ€öÙ¼ƒÙ»ƒgzpk2sosx#scipy.signal._filter_design.zpk2sosõ€öÙ¼ƒÙ»ƒfzpk2ssx#scipy.signal._lti_conversion.zpk2ssõ€öÙ¼ƒÙ»ƒfzpk2tfx"scipy.signal._filter_design.zpk2tfõ€öe1.8.0Ù«ööx+scipy.signal._ltisys.ZerosPolesGainDiscrete€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§xCan be used for smoothing data.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚…Ù§x4Currently, only the smoothing spline approximation (Ù¡kiopt[0] = 0Ù§e and Ù¡kiopt[0] = 1Ù§xl in the FITPACK routine) is supported.  The exact least-squares spline approximation is not implemented yet.€Ù¹‚…Ù§x:When actually performing the interpolation, the requested Ù¢„avÙ „ööelocalavelocalõÙ§xG values must lie within the same length 2pi interval that the original Ù¢„avÙ „ööelocalavelocalõÙ§x values were chosen from.€Ù¹‚ƒÙ§xFor more information, see the Ù£ƒhFITPACK_ööÙ§x site about this function.€Ù²‚x3.. _FITPACK: http://www.netlib.org/dierckx/spgrid.fftargetöpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaujarray_likeÙ¹‚ƒÙ§x‡1-D array of colatitude coordinates in strictly ascending order. Coordinates must be given in radians and lie within the open interval Ù¡g(0, pi)Ù§a.€Ù°ƒavjarray_likeÙ¹‚‰Ù§xu1-D array of longitude coordinates in strictly ascending order. Coordinates must be given in radians. First element (Ù¡dv[0]Ù§x) must lie within the interval Ù¡i[-pi, pi)Ù§p. Last element (Ù¡ev[-1]Ù§o) must satisfy Ù¡tv[-1] <= v[0] + 2*piÙ§a.€Ù°ƒarjarray_likeÙ¹‚ƒÙ§x2-D array of data with shape Ù¡p(u.size, v.size)Ù§a.€Ù°ƒasofloat, optionalÙ¹‚ƒÙ§x<Positive smoothing factor defined for estimation condition (Ù¡cs=0Ù§w is for interpolation).€Ù°ƒopole_continuityxbool or (bool, bool), optionalÙ¹‚‰Ù§x!Order of continuity at the poles Ù¡cu=0Ù§b (Ù¡rpole_continuity[0]Ù§f) and Ù¡du=piÙ§b (Ù¡rpole_continuity[1]Ù§xs).  The order of continuity at the pole will be 1 or 0 when this is True or False, respectively. Defaults to False.€Ù°ƒkpole_valuesx!float or (float, float), optionalÙ¹‚…Ù§xData values at the poles Ù¡cu=0Ù§e and Ù¡du=piÙ§xX.  Either the whole parameter or each individual element can be None.  Defaults to None.€Ù°ƒjpole_exactxbool or (bool, bool), optionalÙ¹‚…Ù§x"Data value exactness at the poles Ù¡cu=0Ù§e and Ù¡du=piÙ§xÑ.  If True, the value is considered to be the right function value, and it will be fitted exactly. If False, the value will be considered to be a data value just like the other data values.  Defaults to False.€Ù°ƒipole_flatxbool or (bool, bool), optionalÙ¹‚…Ù§qFor the poles at Ù¡cu=0Ù§e and Ù¡du=piÙ§xY, specify whether or not the approximation has vanishing derivatives.  Defaults to False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xCBivariate spline approximation over a rectangular mesh on a sphere.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesx/scipy/interpolate/_fitpack2.pyÿn<class 'type'>x:scipy.signal._ltisys.interpolate.RectSphereBivariateSplineÙ¯‚Ù¹‚Ù§x,Suppose we have global data on a coarse grid€Ù´ƒ˜vÙ±‚`dlatsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmic170Ù±‚`a,Ù±‚`a Ù±‚bmia9Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmfd180.Ù±‚`a
Ù±‚`dlonsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmic350Ù±‚`a,Ù±‚`a Ù±‚bmib18Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmfd180.Ù±‚`a
Ù±‚`Ù¢„ddataÙ „escipye1.8.0fmoduleqscipy.sparse.datafmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jatleast_2dÙ „enumpyf1.22.3fmodulepnumpy.atleast_2dfmoduleõÙ±‚`a(Ù±‚bmfc90.Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmfc80.Ù±‚`a,Ù±‚`a Ù±‚bmfc80.Ù±‚`a,Ù±‚`a Ù±‚bmib18Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`aTÙ±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jatleast_2dÙ „enumpyf1.22.3fmodulepnumpy.atleast_2dfmoduleõÙ±‚`a(Ù±‚bmfd180.Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cabsÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfd350.Ù±‚`a,Ù±‚`a Ù±‚bmia9Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`aT`fexecedÙ¹‚Ù§x5We want to interpolate it to a global one-degree grid€Ù´ƒ˜FÙ±‚`hnew_latsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmic180Ù±‚`a,Ù±‚`a Ù±‚bmic180Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmic180Ù±‚`a
Ù±‚`hnew_lonsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmic360Ù±‚`a,Ù±‚`a Ù±‚bmic360Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmic180Ù±‚`a
Ù±‚`hnew_latsÙ±‚`a,Ù±‚`a Ù±‚`hnew_lonsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ±‚`a(Ù±‚`hnew_latsÙ±‚`a,Ù±‚`a Ù±‚`hnew_lonsÙ±‚`a)`fexecedÙ¹‚Ù§x)We need to set up the interpolator object€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„kinterpolateÙ „escipye1.8.0fmoduleqscipy.interpolatefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„xRectSphereBivariateSplineÙ „escipye1.8.0fmodulex5scipy.interpolate._fitpack2.RectSphereBivariateSplinefmoduleõÙ±‚`a
Ù±‚`clutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„xRectSphereBivariateSplineÙ „escipye1.8.0fmodulex5scipy.interpolate._fitpack2.RectSphereBivariateSplinefmoduleõÙ±‚`a(Ù±‚`dlatsÙ±‚`a,Ù±‚`a Ù±‚`dlonsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ddataÙ „escipye1.8.0fmoduleqscipy.sparse.datafmoduleõÙ±‚`a)`fexecedÙ¹‚ƒÙ§x&Finally we interpolate the data.  The Ù¢„xRectSphereBivariateSplineÙ „escipye1.8.0fmodulex5scipy.interpolate._fitpack2.RectSphereBivariateSplinefmoduleõÙ§xO object only takes 1-D arrays as input, therefore we need to do some reshaping.€Ù´ƒ˜"Ù±‚`kdata_interpÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`clutÙ±‚aoa.Ù±‚`bevÙ±‚`a(Ù±‚`Ù¢„hnew_latsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eravelÙ±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`u                     Ù±‚`Ù¢„hnew_lonsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eravelÙ±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`greshapeÙ±‚`a(Ù±‚`a(Ù±‚bmic360Ù±‚`a,Ù±‚`a Ù±‚bmic180Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`aT`fexecedÙ¹‚Ù§x{Looking at the original and the interpolated data, one can see that the interpolant reproduces the original data very well:€Ù´ƒ˜KÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`cfigÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffigureÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.figurefmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`cax1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cfigÙ±‚aoa.Ù±‚`kadd_subplotÙ±‚`a(Ù±‚bmic211Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cax1Ù „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fimshowÙ „jmatplotlibe3.5.1fmodulex!matplotlib.axes._axes.Axes.imshowfmoduleõÙ±‚`a(Ù±‚`Ù¢„ddataÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`minterpolationÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gnearestÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`cax2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cfigÙ±‚aoa.Ù±‚`kadd_subplotÙ±‚`a(Ù±‚bmic212Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cax2Ù „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fimshowÙ „jmatplotlibe3.5.1fmodulex!matplotlib.axes._axes.Axes.imshowfmoduleõÙ±‚`a(Ù±‚`Ù¢„kdata_interpÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`minterpolationÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gnearestÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x?fig-scipy.interpolate._fitpack2.RectSphereBivariateSpline-0.pngÙ¹‚•Ù§xChoosing the optimal value of Ù¡asÙ§x0 can be a delicate task. Recommended values for Ù¡asÙ§x” depend on the accuracy of the data values.  If the user has an idea of the statistical errors on the data, she can also find a proper estimate for Ù¡asÙ§x/. By assuming that, if she specifies the right Ù¡asÙ§x%, the interpolator will use a spline Ù¡ff(u,v)Ù§xM which exactly reproduces the function underlying the data, she can evaluate Ù¡xsum((r(i,j)-s(u(i),v(j)))**2)Ù§x" to find a good estimate for this Ù¡asÙ§x?. For example, if she knows that the statistical errors on her Ù¡fr(i,j)Ù§x=-values are not greater than 0.1, she may expect that a good Ù¡asÙ§x% should have a value not larger than Ù¡xu.size * v.size * (0.1)**2Ù§a.€Ù¹‚Ù§x3If nothing is known about the statistical error in Ù¡fr(i,j)Ù§b, Ù¡asÙ§x^ must be determined by trial and error.  The best is then to start with a very large value of Ù¡asÙ§xN (to determine the least-squares polynomial and the corresponding upper bound Ù¡cfp0Ù§e for Ù¡asÙ§x2) and then to progressively decrease the value of Ù¡asÙ§x, (say by a factor 10 in the beginning, i.e. Ù¡xs = fp0 / 10, fp0 / 100, ...Ù§xS  and more carefully as the approximation shows more detail) to obtain closer fits.€Ù¹‚ƒÙ§x2The interpolation results for different values of Ù¡asÙ§x% give some insight into this process:€Ù´ƒ˜œÙ±‚`dfig2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ffigureÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.figurefmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmfc3e9Ù±‚`a,Ù±‚`a Ù±‚bmfc2e9Ù±‚`a,Ù±‚`a Ù±‚bmfc1e9Ù±‚`a,Ù±‚`a Ù±‚bmfc1e8Ù±‚`a]Ù±‚`a
Ù±‚akcforÙ±‚`a Ù±‚`Ù¢„cidxÙ „escipye1.8.0fmodulex5scipy.signal._filter_design._nearest_real_complex_idxfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dsvalÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnbienumerateÙ±‚`a(Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`clutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„xRectSphereBivariateSplineÙ „escipye1.8.0fmodulex5scipy.interpolate._fitpack2.RectSphereBivariateSplinefmoduleõÙ±‚`a(Ù±‚`dlatsÙ±‚`a,Ù±‚`a Ù±‚`dlonsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ddataÙ „escipye1.8.0fmoduleqscipy.sparse.datafmoduleõÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚aoa=Ù±‚`dsvalÙ±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`kdata_interpÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`clutÙ±‚aoa.Ù±‚`bevÙ±‚`a(Ù±‚`Ù¢„hnew_latsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eravelÙ±‚`a(Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`x                         Ù±‚`Ù¢„hnew_lonsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eravelÙ±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`greshapeÙ±‚`a(Ù±‚`a(Ù±‚bmic360Ù±‚`a,Ù±‚`a Ù±‚bmic180Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`aTÙ±‚`a
Ù±‚`d    Ù±‚`baxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`dfig2Ù±‚aoa.Ù±‚`kadd_subplotÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„cidxÙ „escipye1.8.0fmodulex5scipy.signal._filter_design._nearest_real_complex_idxfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`Ù¢„baxÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fimshowÙ „jmatplotlibe3.5.1fmodulex!matplotlib.axes._axes.Axes.imshowfmoduleõÙ±‚`a(Ù±‚`Ù¢„kdata_interpÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`minterpolationÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gnearestÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`Ù¢„baxÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„iset_titleÙ „jmatplotlibe3.5.1fmodulex$matplotlib.axes._axes.Axes.set_titlefmoduleõÙ±‚`a(Ù±‚bsaÙ¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚bs2a"Ù±‚bs2ds = Ù±‚bsia{Ù±‚`dsvalÙ±‚bsia:Ù±‚bs2agÙ±‚bsia}Ù±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x?fig-scipy.interpolate._fitpack2.RectSphereBivariateSpline-1.pngö‰Ù¼ƒÙ»ƒoBivariateSplinex+scipy.interpolate._fitpack2.BivariateSplineõÙ¹‚Ù§x#a base class for bivariate splines.€öÙ¼ƒÙ»ƒrLSQBivariateSplinex.scipy.interpolate._fitpack2.LSQBivariateSplineõÙ¹‚Ù§x7a bivariate spline using weighted least-squares fitting€öÙ¼ƒÙ»ƒxLSQSphereBivariateSplineööÙ¹‚Ù§xPa bivariate spline in spherical coordinates using weighted least-squares fitting€öÙ¼ƒÙ»ƒsRectBivariateSplinex/scipy.interpolate._fitpack2.RectBivariateSplineõÙ¹‚Ù§x+a bivariate spline over a rectangular mesh.€öÙ¼ƒÙ»ƒuSmoothBivariateSplinex1scipy.interpolate._fitpack2.SmoothBivariateSplineõÙ¹‚Ù§x5a smoothing bivariate spline through the given points€öÙ¼ƒÙ»ƒxSmoothSphereBivariateSplineööÙ¹‚Ù§x5a smoothing bivariate spline in spherical coordinates€öÙ¼ƒÙ»ƒpUnivariateSplinex,scipy.interpolate._fitpack2.UnivariateSplineõÙ¹‚Ù§x=a smooth univariate spline to fit a given set of data points.€öÙ¼ƒÙ»ƒgbisplevööÙ¹‚Ù§x?a function to evaluate a bivariate B-spline and its derivatives€öÙ¼ƒÙ»ƒhbisplrepx(scipy.interpolate._fitpack_impl.bisplrepõÙ¹‚Ù§xCa function to find a bivariate B-spline representation of a surface€öe1.8.0Ù«ööx5scipy.interpolate._fitpack2.RectSphereBivariateSpline€
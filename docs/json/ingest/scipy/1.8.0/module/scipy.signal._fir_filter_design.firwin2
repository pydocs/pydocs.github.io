Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚…Ù§xFrom the given frequencies Ù¢„dfreqÙ „ööelocaldfreqelocalõÙ§x and corresponding gains Ù¢„dgainÙ „ööelocaldgainelocalõÙ§xl, this function constructs an FIR filter with linear phase and (approximately) the given frequency response.€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚…Ù§xØFrom the given set of frequencies and gains, the desired response is constructed in the frequency domain. The inverse FFT is applied to the desired response to create the associated convolution kernel, and the first Ù¢„gnumtapsÙ „ööelocalgnumtapselocalõÙ§x( coefficients of this kernel, scaled by Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§o, are returned.€Ù¹‚ƒÙ§xfThe FIR filter will have linear phase. The type of filter is determined by the value of 'numtaps` and Ù¢„mantisymmetricÙ „ööelocalmantisymmetricelocalõÙ§x, flag. There are four possible combinations:€Ù·„xE- odd  `numtaps`, `antisymmetric` is False, type I filter is producedxF- even `numtaps`, `antisymmetric` is False, type II filter is producedxF- odd  `numtaps`, `antisymmetric` is True, type III filter is producedxE- even `numtaps`, `antisymmetric` is True, type IV filter is producedÙ¹‚Ù§xSMagnitude response of all but type I filters are subjects to following constraints:€Ù·ƒx+- type II  -- zero at the Nyquist frequencyx2- type III -- zero at zero and Nyquist frequenciesx$- type IV  -- zero at zero frequencyÙÆƒlversionaddeddTODOÙ¹‚Ù§f0.9.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒgnumtapscintÙ¹‚…Ù§x'The number of taps in the FIR filter.  Ù¢„gnumtapsÙ „ööelocalgnumtapselocalõÙ§s must be less than Ù¢„fnfreqsÙ „ööelocalfnfreqselocalõÙ§a.€Ù°ƒdfreqoarray_like, 1-DÙ¹‚‹Ù§xkThe frequency sampling points. Typically 0.0 to 1.0 with 1.0 being Nyquist.  The Nyquist frequency is half Ù¢„bfsÙ „ööelocalbfselocalõÙ§p. The values in Ù¢„dfreqÙ „ööelocaldfreqelocalõÙ§xf must be nondecreasing. A value can be repeated once to implement a discontinuity. The first value in Ù¢„dfreqÙ „ööelocaldfreqelocalõÙ§x' must be 0, and the last value must be Ù¡dfs/2Ù§o. Values 0 and Ù¡dfs/2Ù§v must not be repeated.€Ù°ƒdgainjarray_likeÙ¹‚Ù§x˜The filter gains at the frequency sampling points. Certain constraints to gain values, depending on the filter type, are applied, see Notes for details.€Ù°ƒfnfreqsmint, optionalÙ¹‚‡Ù§xâThe size of the interpolation mesh used to construct the filter. For most efficient behavior, this should be a power of 2 plus 1 (e.g, 129, 257, etc). The default is one more than the smallest power of 2 that is not less than Ù¢„gnumtapsÙ „ööelocalgnumtapselocalõÙ§b. Ù¢„fnfreqsÙ „ööelocalfnfreqselocalõÙ§v must be greater than Ù¢„gnumtapsÙ „ööelocalgnumtapselocalõÙ§a.€Ù°ƒfwindowx5string or (string, float) or float, or None, optionalÙ¹‚ƒÙ§x2Window function to use. Default is "hamming". See Ù¢„wscipy.signal.get_windowÙ „escipya*capix(scipy.signal.windows._windows.get_windowfmoduleõÙ§xR for the complete list of possible values. If None, no window function is applied.€Ù°ƒcnyqofloat, optionalÙ¹‚†Ù¨Ù§xDeprecated. Use `fs` instead.Ù§x2 This is the Nyquist frequency. Each frequency in Ù¢„dfreqÙ „ööelocaldfreqelocalõÙ§w must be between 0 and Ù¢„cnyqÙ „ööelocalcnyqelocalõÙ§p.  Default is 1.€Ù°ƒmantisymmetricnbool, optionalÙ¹‚Ù§xZWhether resulting impulse response is symmetric/antisymmetric. See Notes for more details.€Ù°ƒbfsofloat, optionalÙ¹‚…Ù§x8The sampling frequency of the signal. Each frequency in Ù£ƒfcutoffööÙ§w must be between 0 and Ù¡dfs/2Ù§o. Default is 2.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdtapsgndarrayÙ¹‚ƒÙ§xDThe filter coefficients of the FIR filter, as a 1-D array of length Ù¢„gnumtapsÙ „ööelocalgnumtapselocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x*FIR filter design using the window method.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx#/scipy/signal/_fir_filter_design.pyçr<class 'function'>tscipy.signal.firwin2Ù¯‚‚Ù¹‚Ù§xtA lowpass FIR filter with a response that is 1 on [0.0, 0.5], and that decreases linearly on [0.5, 1.0] from 1 to 0:€Ù´ƒ˜2Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚`dtapsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gfirwin2Ù „escipye1.8.0fmodulex'scipy.signal._fir_filter_design.firwin2fmoduleõÙ±‚`a(Ù±‚bmic150Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚bmfc1.0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`dtapsÙ±‚`a[Ù±‚bmib72Ù±‚`a:Ù±‚bmib78Ù±‚`a]Ù±‚`a)xI[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]fexecedö„Ù¼ƒÙ»ƒefirlsx%scipy.signal._fir_filter_design.firlsõ€öÙ¼ƒÙ»ƒffirwinx&scipy.signal._fir_filter_design.firwinõ€öÙ¼ƒÙ»ƒmminimum_phasex-scipy.signal._fir_filter_design.minimum_phaseõ€öÙ¼ƒÙ»ƒeremezx%scipy.signal._fir_filter_design.remezõ€öe1.8.0Ù«xcfirwin2(numtaps, freq, gain, nfreqs=None, window='hamming', nyq=None, antisymmetric=False, fs=None)öx'scipy.signal._fir_filter_design.firwin2€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§yAs currently implemented, Dijkstra's algorithm does not work for graphs with direction-dependent distances when directed == False. i.e., if csgraph[i,j] and csgraph[j,i] are not equal and both are nonzero, setting directed=False will not yield the correct result.€Ù¹‚Ù§xÜAlso, this routine does not work for graphs with negative distances.  Negative distances can lead to infinite cycles that must be handled by specialized algorithms such as Bellman-Ford's algorithm or Johnson's algorithm.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒgcsgraphx-array, matrix, or sparse matrix, 2 dimensionsÙ¹‚Ù§xGThe N x N array of non-negative distances representing the input graph.€Ù°ƒhdirectednbool, optionalÙ¹‚Ù§yRIf True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j] and from point j to i along paths csgraph[j, i]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j or j to i along either csgraph[i, j] or csgraph[j, i].€Ù°ƒgindicesxarray_like or int, optionalÙ¹‚Ù§xJif specified, only compute the paths from the points at the given indices.€Ù°ƒsreturn_predecessorsnbool, optionalÙ¹‚Ù§x1If True, return the size (N, N) predecesor matrix€Ù°ƒjunweightednbool, optionalÙ¹‚Ù§xÇIf True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized.€Ù°ƒelimitofloat, optional‚Ù¹‚Ù§yThe maximum distance to calculate, must be >= 0. Using a smaller limit will decrease computation time by aborting calculations between pairs that are separated by a distance > limit. For such pairs, the distance will be equal to np.inf (i.e., not connected).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.14.0 €Ù°ƒhmin_onlynbool, optional‚Ù¹‚Ù§xæIf False (default), for every node in the graph, find the shortest path from every node in indices. If True, for every node in the graph, find the shortest path from any of the nodes in indices (which can be substantially faster).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.3.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒkdist_matrixx&ndarray, shape ([n_indices, ]n_nodes,)Ù¹‚Ù§yWThe matrix of distances between graph nodes. If min_only=False, dist_matrix has shape (n_indices, n_nodes) and dist_matrix[i, j] gives the shortest distance from point i to point j along the graph. If min_only=True, dist_matrix has shape (n_nodes,) and contains for a given node the shortest path to that node from any of the nodes in indices.€Ù°ƒlpredecessorsx&ndarray, shape ([n_indices, ]n_nodes,)Ù¹‚Ù§yåIf min_only=False, this has shape (n_indices, n_nodes), otherwise it has shape (n_nodes,). Returned only if return_predecessors == True. The matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999€Ù°ƒgsourcesxndarray, shape (n_nodes,)Ù¹‚Ù§yCReturned only if min_only=True and return_predecessors=True. Contains the index of the source which had the shortest path to each target.  If no path exists within the limit, this will contain -9999.  The value at the indices passed will be equal to that index (i.e. the fastest way to reach node i, is to start on node i).€ögSummaryÙ¯‚Ù¹‚Ù§x(Dijkstra algorithm using Fibonacci Heaps€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡iSignaturegSummarypExtended SummaryjParametersgReturnseNoteshExamplesööx$<class 'builtin_function_or_method'>xSscipy.signal._filter_design.optimize._differentiable_functions.sps.csgraph.dijkstraÙ¯‚„Ù´ƒ•Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsr_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csr.csr_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„gcsgraphÙ „escipye1.8.0fmoduletscipy.sparse.csgraphfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hdijkstraÙ „escipye1.8.0fmodulex,scipy.sparse.csgraph._shortest_path.dijkstrafmoduleõ`fexecedÙ´ƒ˜LÙ±‚`egraphÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a
Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`a]Ù±‚`a
Ù±‚`egraphÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsr_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csr.csr_matrixfmoduleõÙ±‚`a(Ù±‚`egraphÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`egraphÙ±‚`a)x+  (0, 1)	1
  (0, 2)	2
  (1, 3)	1
  (2, 3)	3fexecedÙ´ƒ˜Ù±‚`Ù¢„kdist_matrixÙ „escipye1.8.0fmodulex1scipy.sparse.csgraph._tools.construct_dist_matrixfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`lpredecessorsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hdijkstraÙ „escipye1.8.0fmodulex,scipy.sparse.csgraph._shortest_path.dijkstrafmoduleõÙ±‚`a(Ù±‚`Ù¢„gcsgraphÙ „escipye1.8.0fmoduletscipy.sparse.csgraphfmoduleõÙ±‚aoa=Ù±‚`egraphÙ±‚`a,Ù±‚`a Ù±‚`hdirectedÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚`gindicesÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`sreturn_predecessorsÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„kdist_matrixÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõwarray([0., 1., 2., 2.])fexecedÙ´ƒÙ±‚`Ù¢„lpredecessorsÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx0array([-9999,     0,     0,     1], dtype=int32)fexecedö€e1.8.0Ù«xydijkstra(csgraph, directed=True, indices=None, return_predecessors=False, unweighted=False, limit=np.inf, min_only=False)öx,scipy.sparse.csgraph._shortest_path.dijkstra€
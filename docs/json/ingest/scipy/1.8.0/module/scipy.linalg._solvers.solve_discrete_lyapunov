Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚‡Ù§xsThis section describes the available solvers that can be selected by the 'method' parameter. The default method is Ù¨Ù§fdirectÙ§d if Ù¡aMÙ§u is less than 10 and Ù¡hbilinearÙ§k otherwise.€Ù¹‚…Ù§gMethod Ù¨Ù§fdirectÙ§x´ uses a direct analytical solution to the discrete Lyapunov equation. The algorithm is given in, for example, . However, it requires the linear solution of a system with dimension Ù¥cM^2Ù§xI so that performance degrades rapidly for even moderately sized matrices.€Ù¹‚‰Ù§gMethod Ù¨Ù§hbilinearÙ§xl uses a bilinear transformation to convert the discrete Lyapunov equation to a continuous Lyapunov equation Ù¥k(BX+XB'=-C)Ù§g where Ù¥qB=(A-I)(A+I)^{-1}Ù§e and Ù¥xC=2(A' + I)^{-1} Q (A + I)^{-1}Ù§x«. The continuous equation can be efficiently solved since it is a special case of a Sylvester equation. The transformation algorithm is from Popov (1964) as described in .€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒda, qq(M, M) array_likeÙ¹‚Ù§xfSquare matrices corresponding to A and Q in the equation above respectively. Must have the same shape.€Ù°ƒfmethodx {'direct', 'bilinear'}, optional‚Ù¹‚Ù§oType of solver.€Ù¹‚‡Ù§xIf not given, chosen to be Ù¡fdirectÙ§d if Ù¡aMÙ§u is less than 10 and Ù¡hbilinearÙ§k otherwise.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaxgndarrayÙ¹‚Ù§x*Solution to the discrete Lyapunov equation€ögSummaryÙ¯‚Ù¹‚ƒÙ§x&Solves the discrete Lyapunov equation Ù¥qAXA^H - X + Q = 0Ù§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/linalg/_solvers.pyêr<class 'function'>x;scipy.signal._lti_conversion.linalg.solve_discrete_lyapunovÙ¯‚ƒÙ¹‚‡Ù§fGiven Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„aqÙ „ööelocalaqelocalõÙ§k solve for Ù¢„axÙ „ööelocalaxelocalõÙ§a:€Ù´ƒ˜<Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmfc0.2Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a,Ù±‚`a[Ù±‚bmfc0.7Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfc0.9Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ceyeÙ „enumpyf1.22.3fmoduleinumpy.eyefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„wsolve_discrete_lyapunovÙ „escipye1.8.0fmodulex-scipy.linalg._solvers.solve_discrete_lyapunovfmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxFarray([[ 0.70872893,  1.43518822],
       [ 1.43518822, -2.4266315 ]])fexecedÙ´ƒ˜Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`aTÙ±‚`a)Ù±‚aoa-Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedöÙ¼ƒÙ»ƒxsolve_continuous_lyapunovx/scipy.linalg._solvers.solve_continuous_lyapunovõÙ¹‚Ù§x>computes the solution to the continuous-time Lyapunov equation€öe1.8.0Ù«x*solve_discrete_lyapunov(a, q, method=None)öx-scipy.linalg._solvers.solve_discrete_lyapunov€
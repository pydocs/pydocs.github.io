Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ˆÙ¹‚‰Ù§cIf Ù£ƒaMööÙ§x is the degree of numerator Ù¢„abÙ „ööelocalabelocalõÙ§e and Ù£ƒaNööÙ§x the degree of denominator Ù¢„aaÙ „ööelocalaaelocalõÙ§l            €ÙÀx–b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]
----- = ------------------------------------------
a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]Ù¹‚Ù§xEthen the partial-fraction expansion H(s) is defined as::             €ÙÀxpr[0]       r[1]             r[-1]
------ + -------- + ... + --------- + k(s)
-p[0])   (s-p[1])         (s-p[-1])Ù¹‚ƒÙ§x6If there are any repeated roots (closer together than Ù¢„ctolÙ „ööelocalctolelocalõÙ§x%), then H(s) has terms like::        €ÙÀxxr[i]      r[i+1]              r[i+n-1]
------ + ----------- + ... + -----------
-p[i])  (s-p[i])**2          (s-p[i])**nÙ¹‚ƒÙ§xËThis function is used for polynomials in positive powers of s or z, such as analog filters or digital filters in controls engineering.  For negative powers of z (typical for digital filters in DSP), use Ù¢„hresiduezÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.residuezfmoduleõÙ§a.€Ù¹‚Ù§x*See Notes for details about the algorithm.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§xXThe "deflation through subtraction" algorithm is used for computations --- method 6 in .€Ù¹‚‡Ù§xøThe form of partial fraction expansion depends on poles multiplicity in the exact mathematical sense. However there is no way to exactly determine multiplicity of roots of a polynomial in numerical computing. Thus you should think of the result of Ù¢„gresidueÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.residuefmoduleõÙ§l with given Ù¢„ctolÙ „ööelocalctolelocalõÙ§x“ as partial fraction expansion computed for the denominator composed of the computed poles with empirically determined multiplicity. The choice of Ù¢„ctolÙ „ööelocalctolelocalõÙ§x< can drastically change the result if there are close poles.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒabjarray_likeÙ¹‚Ù§x"Numerator polynomial coefficients.€Ù°ƒaajarray_likeÙ¹‚Ù§x$Denominator polynomial coefficients.€Ù°ƒctolofloat, optionalÙ¹‚ƒÙ§xoThe tolerance for two roots to be considered equal in terms of the distance between them. Default is 1e-3. See Ù¢„lunique_rootsÙ „escipye1.8.0fmodulex&scipy.signal._signaltools.unique_rootsfmoduleõÙ§u for further details.€Ù°ƒertypex{'avg', 'min', 'max'}, optionalÙ¹‚ƒÙ§x[Method for computing a root to represent a group of identical roots. Default is 'avg'. See Ù¢„lunique_rootsÙ „escipye1.8.0fmodulex&scipy.signal._signaltools.unique_rootsfmoduleõÙ§u for further details.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒargndarrayÙ¹‚Ù§x€Residues corresponding to the poles. For repeated poles, the residues are ordered to correspond to ascending by power fractions.€Ù°ƒapgndarrayÙ¹‚Ù§x.Poles ordered by magnitude in ascending order.€Ù°ƒakgndarrayÙ¹‚Ù§x+Coefficients of the direct polynomial term.€ögSummaryÙ¯‚Ù¹‚Ù§x2Compute partial-fraction expansion of b(s) / a(s).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferencesx/scipy/signal/_signaltools.py
0r<class 'function'>tscipy.signal.residueÙ¯‚€ö„Ù¼ƒÙ»ƒfinvresx scipy.signal._signaltools.invresõ€öÙ¼ƒÙ»ƒjnumpy.polyjnumpy.polyõ€öÙ¼ƒÙ»ƒhresiduezx"scipy.signal._signaltools.residuezõ€öÙ¼ƒÙ»ƒlunique_rootsx&scipy.signal._signaltools.unique_rootsõ€öe1.8.0Ù«x%residue(b, a, tol=0.001, rtype='avg')öx!scipy.signal._signaltools.residue€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xCArrays are used to determine the optimal prefix of LAPACK routines.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x´This routine automatically chooses between Fortran/C interfaces. Fortran code is used whenever possible for arrays with column major order. In all other cases, C code is preferred.€Ù¹‚ƒÙ§yIn LAPACK, the naming convention is that all functions start with a type prefix, which depends on the type of the principal matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy types {float32, float64, complex64, complex128} respectively, and are stored in attribute Ù¡htypecodeÙ§x of the returned functions.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒenamesvstr or sequence of strÙ¹‚Ù§x0Name(s) of LAPACK functions without type prefix.€Ù°ƒfarraysxsequence of ndarrays, optionalÙ¹‚Ù§x±Arrays can be given to determine optimal prefix of LAPACK routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used.€Ù°ƒedtypevstr or dtype, optionalÙ¹‚ƒÙ§x!Data-type specifier. Not used if Ù¢„farraysÙ „ööelocalfarrayselocalõÙ§n is non-empty.€Ù°ƒeilp64x${True, False, 'preferred'}, optionalÙ¹‚Ù§x’Whether to return ILP64 routine variant. Choosing 'preferred' returns ILP64 routine if available, and otherwise the 32-bit routine. Default: False€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒefuncsdlistÙ¹‚Ù§x&List containing the found function(s).€ögSummaryÙ¯‚Ù¹‚Ù§x4Return available LAPACK function objects from names.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnseNoteshExamplesw/scipy/linalg/lapack.py€r<class 'function'>x4scipy.signal._lti_conversion.linalg.get_lapack_funcsÙ¯‚…Ù¹‚Ù§x™Suppose we would like to use '?lange' routine which computes the selected norm of an array. We pass our array in order to get the correct 'lange' flavor.€Ù´ƒ˜;Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbLAÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`gx_langeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bLAÙ±‚aoa.Ù±‚`Ù¢„pget_lapack_funcsÙ „escipye1.8.0fmodulex$scipy.linalg.lapack.get_lapack_funcsfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1elangeÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`gx_langeÙ±‚aoa.Ù±‚`htypecodec'd'fexecedÙ´ƒ˜Ù±‚`gx_langeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bLAÙ±‚aoa.Ù±‚`Ù¢„pget_lapack_funcsÙ „escipye1.8.0fmodulex$scipy.linalg.lapack.get_lapack_funcsfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1elangeÙ±‚bs1a'Ù±‚`a,Ù±‚`a(Ù±‚`aaÙ±‚aoa*Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`gx_langeÙ±‚aoa.Ù±‚`htypecodec'z'fexecedÙ¹‚„Ù§y+Several LAPACK routines work best when its internal WORK array has the optimal size (big enough for fast computation and small enough to avoid waste of memory). This size is determined also by a dedicated query to the function which is often wrapped as a standalone function and commonly denoted as Ù¡i###_lworkÙ§x. Below is an example for Ù¡e?sysv€Ù´ƒ˜Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbLAÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmid1000Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia1Ù±‚`ajÙ±‚`a
Ù±‚bc1x1# We pick up zsysv and zsysv_lwork due to b arrayÙ±‚`a
Ù±‚`exsysvÙ±‚`a,Ù±‚`a Ù±‚`fxlworkÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bLAÙ±‚aoa.Ù±‚`Ù¢„pget_lapack_funcsÙ „escipye1.8.0fmodulex$scipy.linalg.lapack.get_lapack_funcsfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bs1a'Ù±‚bs1dsysvÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1jsysv_lworkÙ±‚bs1a'Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`iopt_lworkÙ±‚`a,Ù±‚`a Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`fxlworkÙ±‚`a(Ù±‚`aaÙ±‚aoa.Ù±‚`eshapeÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1x"# returns a complex for 'z' prefixÙ±‚`a
Ù±‚`dudutÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dipivÙ „escipye1.8.0fmodulex+scipy.linalg._decomp_ldl._ldl_sanitize_ipivfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dinfoÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`exsysvÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„elworkÙ „escipye1.8.0fmodulex"scipy.linalg.lapack._compute_lworkfmoduleõÙ±‚aoa=Ù±‚bnbcintÙ±‚`a(Ù±‚`iopt_lworkÙ±‚aoa.Ù±‚`drealÙ±‚`a)Ù±‚`a)`fexecedö€e1.8.0Ù«x;get_lapack_funcs(names, arrays=(), dtype=None, ilp64=False)öx$scipy.linalg.lapack.get_lapack_funcs€
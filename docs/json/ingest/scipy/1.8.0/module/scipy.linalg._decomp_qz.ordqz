Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚‰Ù§iOn exit, Ù¡x,(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,NÙ§x(, will be the generalized eigenvalues.  Ù¡wALPHAR(j) + ALPHAI(j)*iÙ§e and Ù¡qBETA(j),j=1,...,NÙ§y+ are the diagonals of the complex Schur form (S,T) that would result if the 2-by-2 diagonal blocks of the real generalized Schur form of (A,B) were further reduced to triangular form using complex unitary transformations. If ALPHAI(j) is zero, then the jth eigenvalue is real; if positive, then the Ù¡xRj``th and ``(j+1)``st eigenvalues are a
complex conjugate pair, with ``ALPHAI(j+1)Ù§j negative.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.17.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaAq(N, N) array_likeÙ¹‚Ù§v2-D array to decompose€Ù°ƒaBq(N, N) array_likeÙ¹‚Ù§v2-D array to decompose€Ù°ƒdsortx0{callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optionalƒÙ¹‚Ù§xoSpecifies whether the upper eigenvalues should be sorted. A callable may be passed that, given an ordered pair Ù¡m(alpha,
beta)Ù§x representing the eigenvalue Ù¡px = (alpha/beta)Ù§xw, returns a boolean denoting whether the eigenvalue should be sorted to the top-left (True). For the real matrix pairs Ù¡dbetaÙ§o is real while Ù¡ealphaÙ§x3 can be complex, and for complex matrix pairs both Ù¡ealphaÙ§e and Ù¡dbetaÙ§xq can be complex. The callable must be able to accept a NumPy array. Alternatively, string parameters may be used:€Ù·„x(- 'lhp'   Left-hand plane (x.real < 0.0)x)- 'rhp'   Right-hand plane (x.real > 0.0)x8- 'iuc'   Inside the unit circle (x*x.conjugate() < 1.0)x9- 'ouc'   Outside the unit circle (x*x.conjugate() > 1.0)Ù¹‚‰Ù§xEWith the predefined sorting functions, an infinite eigenvalue (i.e., Ù¡jalpha != 0Ù§e and Ù¡hbeta = 0Ù§x’) is considered to lie in neither the left-hand nor the right-hand plane, but it is considered to lie outside the unit circle. For the eigenvalue Ù¡v(alpha, beta) = (0, 0)Ù§x., the predefined sorting functions all return Ù¡eFalseÙ§a.€Ù°ƒfoutputx str {'real','complex'}, optionalÙ¹‚Ù§xTConstruct the real or complex QZ decomposition for real matrices. Default is 'real'.€Ù°ƒkoverwrite_anbool, optionalÙ¹‚Ù§x+If True, the contents of A are overwritten.€Ù°ƒkoverwrite_bnbool, optionalÙ¹‚Ù§x+If True, the contents of B are overwritten.€Ù°ƒlcheck_finitenbool, optionalÙ¹‚…Ù§xIf true checks the elements of Ù¢„aAÙ „ööelocalaAelocalõÙ§e and Ù¢„aBÙ „ööelocalaBelocalõÙ§xa are finite numbers. If false does no checking and passes matrix through to underlying algorithm.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚†Ù°ƒbAAn(N, N) ndarrayÙ¹‚Ù§xGeneralized Schur form of A.€Ù°ƒbBBn(N, N) ndarrayÙ¹‚Ù§xGeneralized Schur form of B.€Ù°ƒealphal(N,) ndarrayÙ¹‚Ù§x(alpha = alphar + alphai * 1j. See notes.€Ù°ƒdbetal(N,) ndarrayÙ¹‚Ù§jSee notes.€Ù°ƒaQn(N, N) ndarrayÙ¹‚Ù§wThe left Schur vectors.€Ù°ƒaZn(N, N) ndarrayÙ¹‚Ù§xThe right Schur vectors.€ögSummaryÙ¯‚Ù¹‚Ù§x8QZ decomposition for a pair of matrices with reordering.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNoteshSee AlsohExamplesx/scipy/linalg/_decomp_qz.pyr<class 'function'>x)scipy.signal._lti_conversion.linalg.ordqzÙ¯‚ƒÙ´ƒ˜¯Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„eordqzÙ „escipye1.8.0fmodulexscipy.linalg._decomp_qz.ordqzfmoduleõÙ±‚`a
Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aBÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bAAÙ±‚`a,Ù±‚`a Ù±‚`bBBÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dbetaÙ „escipye1.8.0fmodulex!scipy.special.cython_special.betafmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aQÙ±‚`a,Ù±‚`a Ù±‚`aZÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„eordqzÙ „escipye1.8.0fmodulexscipy.linalg._decomp_qz.ordqzfmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aBÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dsortÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„clhpÙ „escipye1.8.0fmodulexscipy.linalg._decomp_qz._lhpfmoduleõÙ±‚bs1a'Ù±‚`a)`fexecedÙ¹‚Ù§xJSince we have sorted for left half plane eigenvalues, negatives come first€Ù´ƒ‹Ù±‚`a(Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚aoa/Ù±‚`Ù¢„dbetaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`drealÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmia0x/array([ True,  True, False, False], dtype=bool)fexecedöÙ¼ƒÙ»ƒbqzxscipy.linalg._decomp_qz.qzõ€öe1.8.0Ù«x_ordqz(A, B, sort='lhp', output='real', overwrite_a=False, overwrite_b=False, check_finite=True)öxscipy.linalg._decomp_qz.ordqz€
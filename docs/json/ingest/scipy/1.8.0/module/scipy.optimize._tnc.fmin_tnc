Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚Ù§xThe underlying algorithm is truncated Newton, also called Newton Conjugate-Gradient. This method differs from scipy.optimize.fmin_ncg in that€ÙÇ‚Ù¹‚Ù§x,it wraps a C implementation of the algorithm€Ù¹‚Ù§x=it allows each variable to be given an upper and lower bound.€Ù¹‚Ù§yJThe algorithm incorporates the bound constraints by determining the descent direction as in an unconstrained truncated Newton, but never taking a step-size large enough to leave the space of feasible x's. The algorithm keeps track of a set of currently active constraints, and ignores them when computing the minimum allowable step size. (The x's associated with the active constraint are kept fixed.) If the maximum allowable step size is zero then a new constraint is added. At the end of each iteration one of the constraints may be deemed no longer active and removed. A constraint is considered no longer active is if it is currently active but the gradient for that variable points inward from the constraint. The specific constraint removed is the one associated with the variable of largest index whose constraint is no longer active.€Ù¹‚Ù§x+Return codes are defined as follows::      €ÙÀyY-1 : Infeasible (lower bound > upper bound)
 0 : Local minimum reached (|pg| ~= 0)
 1 : Converged (|f_n-f_(n-1)| ~= 0)
 2 : Converged (|x_n-x_(n-1)| ~= 0)
 3 : Max. number of function evaluations reached
 4 : Linear search failed
 5 : All lower bounds are equal to the upper bounds
 6 : Unable to progress
 7 : User requested end of minimizationöpOther ParametersÙ¯‚€öjParametersÙ¯‚–Ù°ƒdfuncxcallable ``func(x, *args)``…Ù¹‚Ù§x&Function to minimize.  Must do one of:€ÙÇÙ¹‚Ù§x^Return f and g, where f is the value of the function and g its    gradient (a list of floats).€ÙÇÙ¹‚ƒÙ§xHReturn the function value but supply gradient function    separately as Ù¢„ffprimeÙ „escipye1.8.0fmodulex-scipy.optimize._root_scalar.MemoizeDer.fprimefmoduleõÙ§a.€ÙÇÙ¹‚ƒÙ§x"Return the function value and set Ù¡papprox_grad=TrueÙ§a.€Ù¹‚Ù§x:If the function returns None, the minimization is aborted.€Ù°ƒbx0jarray_likeÙ¹‚Ù§xInitial estimate of minimum.€Ù°ƒffprimex'callable ``fprime(x, *args)``, optionalÙ¹‚‰Ù§lGradient of Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§w. If None, then either Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x2 must return the function value and the gradient (Ù¡tf,g = func(x, *args)Ù§e) or Ù¢„kapprox_gradÙ „ööelocalkapprox_gradelocalõÙ§n must be True.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§xArguments to pass to function.€Ù°ƒkapprox_gradnbool, optionalÙ¹‚Ù§x.If true, approximate the gradient numerically.€Ù°ƒfboundsnlist, optionalÙ¹‚Ù§x¢(min, max) pairs for each element in x0, defining the bounds on that parameter. Use None or +/-inf for one of min or max when there is no bound in that direction.€Ù°ƒgepsilonofloat, optionalÙ¹‚Ù§xZUsed if approx_grad is True. The stepsize in a finite difference approximation for fprime.€Ù°ƒescaletarray_like, optionalÙ¹‚Ù§x•Scaling factors to apply to each variable. If None, the factors are up-low for interval bounded variables and 1+|x| for the others. Defaults to None.€Ù°ƒfoffsettarray_like, optionalÙ¹‚Ù§x~Value to subtract from each variable. If None, the offsets are (up+low)/2 for interval bounded variables and x for the others.€Ù°ƒhmessagesmint, optionalÙ¹‚Ù§xrBit mask used to select messages display during minimization values defined in the MSGS dict. Defaults to MGS_ALL.€Ù°ƒddispmint, optionalÙ¹‚Ù§x?Integer interface to messages. 0 = no message, 5 = all messages€Ù°ƒgmaxCGitmint, optionalÙ¹‚Ù§x¹Maximum number of hessian*vector evaluations per main iteration. If maxCGit == 0, the direction chosen is -gradient if maxCGit < 0, maxCGit is set to max(1,min(50,n/2)). Defaults to -1.€Ù°ƒfmaxfunmint, optionalÙ¹‚Ù§xÔMaximum number of function evaluation. If None, maxfun is set to max(100, 10*len(x0)). Defaults to None. Note that this function may violate the limit because of evaluating gradients by numerical differentiation.€Ù°ƒcetaofloat, optionalÙ¹‚Ù§xHSeverity of the line search. If < 0 or > 1, set to 0.25. Defaults to -1.€Ù°ƒfstepmxofloat, optionalÙ¹‚Ù§xtMaximum step for the line search. May be increased during call. If too small, it will be set to 10.0. Defaults to 0.€Ù°ƒhaccuracyofloat, optionalÙ¹‚Ù§x~Relative precision for finite difference calculations. If <= machine_precision, set to sqrt(machine_precision). Defaults to 0.€Ù°ƒdfminofloat, optionalÙ¹‚Ù§x/Minimum function value estimate. Defaults to 0.€Ù°ƒdftolofloat, optionalÙ¹‚Ù§xnPrecision goal for the value of f in the stopping criterion. If ftol < 0.0, ftol is set to 0.0 defaults to -1.€Ù°ƒdxtolofloat, optionalÙ¹‚Ù§x¦Precision goal for the value of x in the stopping criterion (after applying x scaling factors). If xtol < 0.0, xtol is set to sqrt(machine_precision). Defaults to -1.€Ù°ƒepgtolofloat, optionalÙ¹‚Ù§xáPrecision goal for the value of the projected gradient in the stopping criterion (after applying x scaling factors). If pgtol < 0.0, pgtol is set to 1e-2 * sqrt(accuracy). Setting it to 0.0 is not recommended. Defaults to -1.€Ù°ƒgrescaleofloat, optionalÙ¹‚Ù§xScaling factor (in log10) used to trigger f value rescaling. If 0, rescale at each iteration. If a large value, never rescale. If < 0, rescale is set to 1.3.€Ù°ƒhcallbackrcallable, optionalÙ¹‚Ù§xWCalled after each iteration, as callback(xk), where xk is the current parameter vector.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒaxgndarrayÙ¹‚Ù§mThe solution.€Ù°ƒfnfevalcintÙ¹‚Ù§x#The number of function evaluations.€Ù°ƒbrccintÙ¹‚Ù§vReturn code, see below€ögSummaryÙ¯‚Ù¹‚Ù§x¨Minimize a function with variables subject to bounds, using gradient information in a truncated Newton algorithm. This method wraps a C implementation of the algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNotesjReferencesw/scipy/optimize/_tnc.pyWr<class 'function'>x-scipy.signal._filter_design.optimize.fmin_tncÙ¯‚€öÙ¼ƒÙ»ƒhminimizeööÙ¹‚ƒÙ§xOInterface to minimization algorithms for multivariate functions. See the 'TNC' Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§o in particular.€öe1.8.0Ù«xúfmin_tnc(func, x0, fprime=None, args=(), approx_grad=0, bounds=None, epsilon=1e-08, scale=None, offset=None, messages=15, maxCGit=-1, maxfun=None, eta=-1, stepmx=0, accuracy=0, fmin=0, ftol=-1, xtol=-1, pgtol=-1, rescale=-1, disp=None, callback=None)öxscipy.optimize._tnc.fmin_tnc€
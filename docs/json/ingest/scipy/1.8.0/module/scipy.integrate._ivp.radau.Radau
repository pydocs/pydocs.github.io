Ùª­jAttributesÙ¯‚‹Ù°ƒancintÙ¹‚Ù§tNumber of equations.€Ù°ƒfstatusfstringÙ¹‚Ù§x@Current status of the solver: 'running', 'finished' or 'failed'.€Ù°ƒgt_boundefloatÙ¹‚Ù§nBoundary time.€Ù°ƒidirectionefloatÙ¹‚Ù§x Integration direction: +1 or -1.€Ù°ƒatefloatÙ¹‚Ù§mCurrent time.€Ù°ƒaygndarrayÙ¹‚Ù§nCurrent state.€Ù°ƒet_oldefloatÙ¹‚Ù§x.Previous time. None if no steps were made yet.€Ù°ƒistep_sizeefloatÙ¹‚Ù§xASize of the last successful step. None if no steps were made yet.€Ù°ƒdnfevcintÙ¹‚Ù§x-Number of evaluations of the right-hand side.€Ù°ƒdnjevcintÙ¹‚Ù§x&Number of evaluations of the Jacobian.€Ù°ƒcnlucintÙ¹‚Ù§xNumber of LU decompositions.€öpExtended SummaryÙ¯‚Ù¹‚Ù§x¾The implementation follows . The error is controlled with a third-order accurate embedded formula. A cubic polynomial which satisfies the collocation conditions is used for the dense output.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŠÙ°ƒcfunhcallableÙ¹‚Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(t, y)Ù§g. Here Ù¡atÙ§x8 is a scalar, and there are two options for the ndarray Ù¡ayÙ§x&: It can either have shape (n,); then Ù¡cfunÙ§xV must return array_like with shape (n,). Alternatively it can have shape (n, k); then Ù¡cfunÙ§xb must return an array_like with shape (n, k), i.e., each column corresponds to a single column in Ù¡ayÙ§x6. The choice between the two options is determined by Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§x” argument (see below). The vectorized implementation allows a faster approximation of the Jacobian by finite differences (required for this solver).€Ù°ƒbt0efloatÙ¹‚Ù§mInitial time.€Ù°ƒby0varray_like, shape (n,)Ù¹‚Ù§nInitial state.€Ù°ƒgt_boundefloatÙ¹‚Ù§xnBoundary time - the integration won't continue beyond it. It also determines the direction of the integration.€Ù°ƒjfirst_stepwfloat or None, optionalÙ¹‚ƒÙ§xInitial step size. Default is Ù¡dNoneÙ§x. which means that the algorithm should choose.€Ù°ƒhmax_stepofloat, optionalÙ¹‚Ù§xuMaximum allowed step size. Default is np.inf, i.e., the step size is not bounded and determined solely by the solver.€Ù°ƒjrtol, atolxfloat and array_like, optionalÙ¹‚˜#Ù§xWRelative and absolute tolerances. The solver keeps the local error estimates less than Ù¡tatol + rtol * abs(y)Ù§h. HHere Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x@ controls a relative accuracy (number of correct digits), while Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xW controls absolute accuracy (number of correct decimal places). To achieve the desired Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§f, set Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x= to be lower than the lowest value that can be expected from Ù¡mrtol * abs(y)Ù§i so that Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x# dominates the allowable error. If Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§p is larger than Ù¡mrtol * abs(y)Ù§xT the number of correct digits is not guaranteed. Conversely, to achieve the desired Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e set Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§k such that Ù¡mrtol * abs(y)Ù§v is always lower than Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xT. If components of y have different scales, it might be beneficial to set different Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xK values for different components by passing array_like with shape (n,) for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x. Default values are 1e-3 for Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§n and 1e-6 for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§a.€Ù°ƒcjacx5{None, array_like, sparse_matrix, callable}, optionalƒÙ¹‚ƒÙ§x©Jacobian matrix of the right-hand side of the system with respect to y, required by this method. The Jacobian matrix has shape (n, n) and its element (i, j) is equal to Ù¡md f_i / d y_jÙ§x.. There are three ways to define the Jacobian:€Ù·ˆx<* If array_like or sparse_matrix, the Jacobian is assumed ton  be constant.x8* If callable, the Jacobian is assumed to depend on bothx;  t and y; it will be called as ``jac(t, y)`` as necessary.x@  For the 'Radau' and 'BDF' methods, the return value might be ap  sparse matrix.x9* If None (default), the Jacobian will be approximated byu  finite differences.Ù¹‚Ù§xmIt is generally recommended to provide the Jacobian rather than relying on a finite-difference approximation.€Ù°ƒljac_sparsityx+{None, array_like, sparse matrix}, optionalÙ¹‚‡Ù§x‘Defines a sparsity structure of the Jacobian matrix for a finite-difference approximation. Its shape must be (n, n). This argument is ignored if Ù¢„cjacÙ „ööelocalcjacelocalõÙ§h is not Ù¡dNoneÙ§x4. If the Jacobian has only few non-zero elements in Ù¨Ù§deachÙ§x× row, providing the sparsity structure will greatly speed up the computations . A zero entry means that a corresponding element in the Jacobian is always zero. If None (default), the Jacobian is assumed to be dense.€Ù°ƒjvectorizednbool, optionalÙ¹‚ƒÙ§hWhether Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x: is implemented in a vectorized fashion. Default is False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x;Implicit Runge-Kutta method of Radau IIA family of order 5.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersjAttributesjReferencesx/scipy/integrate/_ivp/radau.py³n<class 'type'>x$scipy.signal._ltisys.integrate.RadauÙ¯‚€ö€e1.8.0Ù«ööx scipy.integrate._ivp.radau.Radau€
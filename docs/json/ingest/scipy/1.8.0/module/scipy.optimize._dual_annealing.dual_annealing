Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‹Ù¹‚‚Ù§y[This function implements the Dual Annealing optimization. This stochastic approach derived from  combines the generalization of CSA (Classical Simulated Annealing) and FSA (Fast Simulated Annealing)   coupled to a strategy for applying a local search on accepted locations . An alternative implementation of this same algorithm is described in  and benchmarks are presented in . This approach introduces an advanced method to refine the solution found by the generalized annealing process. This algorithm uses a distorted Cauchy-Lorentz visiting distribution, with its shape controlled by the parameter Ù¥eq_{v}€Ù¤y6g_ { q_ { v}} ( \Delta x ( t)) \propto \frac { \ \left [ T_ { q_ { v}} ( t) \right]^ { - \frac { D} { 3 - q_ { v}}}} { \ \left [ { 1+ ( q_ { v} - 1)\frac { ( \Delta x ( t))^ { 2}} { \ \left [ T_ { q_ { v}} ( t)\right]^ { \frac { 2} { 3 - q_ { v}}}}}\right]^ { \ \frac { 1} { q_ { v} - 1}+\frac { D - 1} { 2}}} Ù¹‚‰Ù§fWhere Ù¥atÙ§x^ is the artificial time. This visiting distribution is used to generate a trial jump distance Ù¥k\Delta x(t)Ù§m of variable Ù¥dx(t)Ù§x under artificial temperature Ù¥lT_{q_{v}}(t)Ù§a.€Ù¹‚Ù§x}From the starting point, after calling the visiting distribution function, the acceptance probability is computed as follows:€Ù¤xrp_ { q_ { a}} = \min { \ { 1,\left [ 1 - ( 1 - q_ { a}) \beta \Delta E \right]^ { \ \frac { 1} { 1 - q_ { a}}}\}} Ù¹‚…Ù§fWhere Ù¥eq_{a}Ù§x  is a acceptance parameter. For Ù¥gq_{a}<1Ù§x<, zero acceptance probability is assigned to the cases where€Ù¤x)[ 1 - ( 1 - q_ { a}) \beta \Delta E] < 0 Ù¹‚ƒÙ§xThe artificial temperature Ù¥lT_{q_{v}}(t)Ù§x is decreased according to€Ù¤xuT_ { q_ { v}} ( t) = T_ { q_ { v}} ( 1) \frac { 2^ { q_ { v} - 1} - 1} { \left ( \ 1 + t\right)^ { q_ { v} - 1} - 1} Ù¹‚ƒÙ§fWhere Ù¥eq_{v}Ù§x is the visiting parameter.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.2.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒdfunchcallableÙ¹‚‡Ù§x<The objective function to be minimized. Must be in the form Ù¡kf(x, *args)Ù§h, where Ù¡axÙ§x0 is the argument in the form of a 1-D array and Ù¡dargsÙ§xZ is a  tuple of any additional fixed parameters needed to completely specify the function.€Ù°ƒfboundsvsequence, shape (n, 2)Ù¹‚…Ù§wBounds for variables.  Ù¡j(min, max)Ù§x pairs for each element in Ù¡axÙ§x7, defining bounds for the objective function parameter.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§xTAny additional fixed parameters needed to completely specify the objective function.€Ù°ƒgmaxitermint, optionalÙ¹‚Ù§xFThe maximum number of global search iterations. Default value is 1000.€Ù°ƒpminimizer_kwargsndict, optionalÙ¹‚‡Ù§x=Extra keyword arguments to be passed to the local minimizer (Ù£ƒhminimizeööÙ§x$). Some important options could be: Ù¡fmethodÙ§x% for the minimizer method to use and Ù¡dargsÙ§x- for objective function additional arguments.€Ù°ƒlinitial_tempofloat, optionalÙ¹‚Ù§xÕThe initial temperature, use higher values to facilitates a wider search of the energy landscape, allowing dual_annealing to escape local minima that it is trapped in. Default value is 5230. Range is (0.01, 5.e4].€Ù°ƒrrestart_temp_ratioofloat, optionalÙ¹‚ƒÙ§xIDuring the annealing process, temperature is decreasing, when it reaches Ù¡x!initial_temp * restart_temp_ratioÙ§x\, the reannealing process is triggered. Default value of the ratio is 2e-5. Range is (0, 1).€Ù°ƒevisitofloat, optionalÙ¹‚Ù§xËParameter for visiting distribution. Default value is 2.62. Higher values give the visiting distribution a heavier tail, this makes the algorithm jump to a more distant region. The value range is (1, 3].€Ù°ƒfacceptofloat, optionalÙ¹‚Ù§xÙParameter for acceptance distribution. It is used to control the probability of acceptance. The lower the acceptance parameter, the smaller the probability of acceptance. Default value is -5.0 with a range (-1e4, -5].€Ù°ƒfmaxfunmint, optionalÙ¹‚Ù§xÜSoft limit for the number of objective function calls. If the algorithm is in the middle of a local search, this number will be exceeded, the algorithm will stop just after the local search is done. Default value is 1e7.€Ù°ƒdseedx%{None, int, `numpy.random.Generator`,‚Ù·x%`numpy.random.RandomState`}, optionalÙ¹‚•Ù§cIf Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§m is None (or Ù£ƒinp.randomööÙ§g), the Ù¢„xnumpy.random.RandomStateÙ „enumpya*capixnumpy.random.mtrand.RandomStatefmoduleõÙ§w singleton is used. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§r is an int, a new Ù¡kRandomStateÙ§x instance is used, seeded with Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§e. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§n is already a Ù¡iGeneratorÙ§d or Ù¡kRandomStateÙ§x. instance then that instance is used. Specify Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§x™ for repeatable minimizations. The random numbers generated with this seed only affect the visiting distribution function and new coordinates generation.€Ù°ƒono_local_searchnbool, optionalÙ¹‚ƒÙ§cIf Ù¢„ono_local_searchÙ „ööelocalono_local_searchelocalõÙ§xw is set to True, a traditional Generalized Simulated Annealing will be performed with no local search strategy applied.€Ù°ƒhcallbackrcallable, optionalƒÙ¹‚‰Ù§x#A callback function with signature Ù¡wcallback(x, f, context)Ù§x-, which will be called for all minima found. Ù¡axÙ§e and Ù¡afÙ§xI are the coordinates and function value of the latest minimum found, and Ù¡gcontextÙ§x4 has value in [0, 1, 2], with the following meaning:€Ù·ƒx/- 0: minimum detected in the annealing process.x4- 1: detection occurred in the local search process.x2- 2: detection done in the dual annealing process.Ù¹‚Ù§xEIf the callback implementation returns True, the algorithm will stop.€Ù°ƒbx0xndarray, shape(n,), optionalÙ¹‚Ù§x+Coordinates of a single N-D starting point.€Ù°ƒtlocal_search_optionsndict, optionalÙ¹‚ƒÙ§xBackwards compatible flag for Ù¢„pminimizer_kwargsÙ „ööelocalpminimizer_kwargselocalõÙ§x', only one of these should be supplied.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcresnOptimizeResultÙ¹‚‹Ù§x)The optimization result represented as a Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x# object. Important attributes are: Ù¡axÙ§u the solution array, Ù¡cfunÙ§x0 the value of the function at the solution, and Ù¡gmessageÙ§x3 which describes the cause of the termination. See Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x' for a description of other attributes.€ögSummaryÙ¯‚Ù¹‚Ù§x;Find the global minimum of a function using Dual Annealing.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNotesjReferenceshExamplesx"/scipy/optimize/_dual_annealing.py´r<class 'function'>x3scipy.signal._filter_design.optimize.dual_annealingÙ¯‚ƒÙ¹‚Ù§xThe following example is a 10-D problem, with many local minima. The function involved is called Rastrigin (https://en.wikipedia.org/wiki/Rastrigin_function)€Ù´ƒ˜kÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ndual_annealingÙ „escipye1.8.0fmodulex-scipy.optimize._dual_annealing.dual_annealingfmoduleõÙ±‚`a
Ù±‚`dfuncÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csumÙ „enumpyf1.22.3fmoduleinumpy.sumfmoduleõÙ±‚`a(Ù±‚`axÙ±‚aoa*Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmib10Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚`axÙ±‚`a)Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmib10Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsizeÙ „enumpyf1.22.3fmodulejnumpy.sizefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„blwÙ „escipye1.8.0fmodulex"scipy.linalg.lapack._compute_lworkfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmfd5.12Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmib10Ù±‚`a
Ù±‚`bupÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmfd5.12Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmib10Ù±‚`a
Ù±‚`cretÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ndual_annealingÙ „escipye1.8.0fmodulex-scipy.optimize._dual_annealing.dual_annealingfmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚aoa=Ù±‚bnbdlistÙ±‚`a(Ù±‚bnbczipÙ±‚`a(Ù±‚`Ù¢„blwÙ „escipye1.8.0fmodulex"scipy.linalg.lapack._compute_lworkfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bupÙ±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`cretÙ±‚aoa.Ù±‚`axxÈarray([-4.26437714e-09, -3.91699361e-09, -1.86149218e-09, -3.97165720e-09,
       -6.29151648e-09, -6.53145322e-09, -3.93616815e-09, -6.55623025e-09,
       -6.05775280e-09, -5.00668935e-09]) # randomfexecedÙ´ƒƒÙ±‚`cretÙ±‚aoa.Ù±‚`cfunh0.000000fexecedö€e1.8.0Ù«xúdual_annealing(func, bounds, args=(), maxiter=1000, minimizer_kwargs=None, initial_temp=5230.0, restart_temp_ratio=2e-05, visit=2.62, accept=-5.0, maxfun=10000000.0, seed=None, no_local_search=False, callback=None, x0=None, local_search_options=None)öx-scipy.optimize._dual_annealing.dual_annealing€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§xùDifferential Evolution is stochastic in nature (does not use gradient methods) to find the minimum, and can search large areas of candidate space, but often requires larger numbers of function evaluations than conventional gradient-based techniques.€Ù¹‚Ù§x)The algorithm is due to Storn and Price .€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚ƒÙ§yFDifferential evolution is a stochastic population based method that is useful for global optimization problems. At each pass through the population the algorithm mutates each candidate solution by mixing with other candidate solutions to create a trial candidate. There are several strategies  for creating trial candidates, which suit some problems more than others. The 'best1bin' strategy is a good starting point for many systems. In this strategy two members of the population are randomly chosen. Their difference is used to mutate the best member (the 'best' in 'best1bin'), Ù¥cb_0Ù§i, so far:€Ù¤xDb ' = b_0 + mutation * ( population [ rand0] - population [ rand1]) Ù¹‚•Ù§x”A trial vector is then constructed. Starting with a randomly chosen ith parameter the trial is sequentially filled (in modulo) with parameters from Ù¡bb'Ù§x9 or the original candidate. The choice of whether to use Ù¡bb'Ù§x¤ or the original candidate is made with a binomial distribution (the 'bin' in 'best1bin') - a random number in [0, 1) is generated. If this number is less than the Ù¢„mrecombinationÙ „ööelocalmrecombinationelocalõÙ§x, constant then the parameter is loaded from Ù¡bb'Ù§x`, otherwise it is loaded from the original candidate. The final parameter is always loaded from Ù¡bb'Ù§y. Once the trial candidate is built its fitness is assessed. If the trial is better than the original candidate then it takes its place. If it is also better than the best overall candidate it also replaces that. To improve your chances of finding a global minimum use higher Ù¢„gpopsizeÙ „ööelocalgpopsizeelocalõÙ§u values, with higher Ù¢„hmutationÙ „ööelocalhmutationelocalõÙ§x and (dithering), but lower Ù¢„mrecombinationÙ „ööelocalmrecombinationelocalõÙ§x¬ values. This has the effect of widening the search radius, but slowing convergence. By default the best solution vector is updated continuously within a single iteration (Ù¡tupdating='immediate'Ù§y). This is a modification  of the original differential evolution algorithm which can lead to faster convergence as trial vectors can immediately benefit from improved solutions. To use the original Storn and Price behaviour, updating the best solution once per iteration, set Ù¡supdating='deferred'Ù§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.15.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚“Ù°ƒdfunchcallableÙ¹‚‡Ù§x<The objective function to be minimized. Must be in the form Ù¡kf(x, *args)Ù§h, where Ù¡axÙ§x0 is the argument in the form of a 1-D array and Ù¡dargsÙ§xZ is a  tuple of any additional fixed parameters needed to completely specify the function.€Ù°ƒfboundstsequence or `Bounds`Ù¹‚Ù§xOBounds for variables. There are two ways to specify the bounds: 1. Instance of Ù¢„fBoundsÙ „escipye1.8.0fmodulex"scipy.optimize._constraints.BoundsfmoduleõÙ§k class. 2. Ù¡j(min, max)Ù§x pairs for each element in Ù¡axÙ§xL, defining the finite lower and upper bounds for the optimizing argument of Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x. It is required to have Ù¡ulen(bounds) == len(x)Ù§b. Ù¡klen(bounds)Ù§x2 is used to determine the number of parameters in Ù¡axÙ§a.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§xTAny additional fixed parameters needed to completely specify the objective function.€Ù°ƒhstrategymstr, optionalƒÙ¹‚Ù§x=The differential evolution strategy to use. Should be one of:€Ù·Œl- 'best1bin'l- 'best1exp'l- 'rand1exp'r- 'randtobest1exp'u- 'currenttobest1exp'l- 'best2exp'l- 'rand2exp'r- 'randtobest1bin'u- 'currenttobest1bin'l- 'best2bin'l- 'rand2bin'l- 'rand1bin'Ù¹‚Ù§xThe default is 'best1bin'.€Ù°ƒgmaxitermint, optionalÙ¹‚‚Ù§x’The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: Ù¡x (maxiter + 1) * popsize * len(x)€Ù°ƒgpopsizemint, optionalÙ¹‚‰Ù§xGA multiplier for setting the total population size. The population has Ù¡ppopsize * len(x)Ù§xV individuals. This keyword is overridden if an initial population is supplied via the Ù¢„dinitÙ „ööelocaldinitelocalõÙ§u keyword. When using Ù¡linit='sobol'Ù§x@ the population size is calculated as the next power of 2 after Ù¡ppopsize * len(x)Ù§a.€Ù°ƒctolofloat, optionalÙ¹‚‡Ù§x;Relative tolerance for convergence, the solving stops when Ù¡x@np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))Ù§l, where and Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e and Ù¢„ctolÙ „ööelocalctolelocalõÙ§x6 are the absolute and relative tolerance respectively.€Ù°ƒhmutationx&float or tuple(float, float), optionalÙ¹‚…Ù§xºThe mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple Ù¡j(min, max)Ù§x¦ dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from Ù¡kU[min, max)Ù§x“. Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence.€Ù°ƒmrecombinationofloat, optionalÙ¹‚Ù§yThe recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability.€Ù°ƒdseedx%{None, int, `numpy.random.Generator`,‚Ù·x%`numpy.random.RandomState`}, optionalÙ¹‚•Ù§cIf Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§m is None (or Ù£ƒinp.randomööÙ§g), the Ù¢„xnumpy.random.RandomStateÙ „enumpya*capixnumpy.random.mtrand.RandomStatefmoduleõÙ§w singleton is used. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§r is an int, a new Ù¡kRandomStateÙ§x instance is used, seeded with Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§e. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§n is already a Ù¡iGeneratorÙ§d or Ù¡kRandomStateÙ§x. instance then that instance is used. Specify Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§x for repeatable minimizations.€Ù°ƒddispnbool, optionalÙ¹‚ƒÙ§uPrints the evaluated Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§t at every iteration.€Ù°ƒhcallbackx3callable, `callback(xk, convergence=val)`, optionalÙ¹‚‰Ù§x7A function to follow the progress of the minimization. Ù¡bxkÙ§x$ is the best solution found so far. Ù¡cvalÙ§xF represents the fractional value of the population convergence.  When Ù¡cvalÙ§x= is greater than one the function halts. If callback returns Ù¡dTrueÙ§xG, then the minimization is halted (any polishing is still carried out).€Ù°ƒfpolishnbool, optionalÙ¹‚‡Ù§xIf True (default), then Ù¢„wscipy.optimize.minimizeÙ „escipya*capix!scipy.optimize._minimize.minimizefmoduleõÙ§j with the Ù£ƒhL-BFGS-BööÙ§x¡ method is used to polish the best population member at the end, which can improve the minimization slightly. If a constrained problem is being studied then the Ù£ƒltrust-conströöÙ§x method is used instead.€Ù°ƒdinitxstr or array-like, optional…Ù¹‚Ù§xOSpecify which type of population initialization is performed. Should be one of:€Ù·ˆr- 'latinhypercube'i- 'sobol'j- 'halton'j- 'random'x@- array specifying the initial population. The array should havexA  shape ``(M, len(x))``, where M is the total population size andx%  len(x) is the number of parameters.x+  `init` is clipped to `bounds` before use.Ù¹‚Ù§xvThe default is 'latinhypercube'. Latin Hypercube sampling tries to maximize coverage of the available parameter space.€Ù¹‚…Ù§x¼'sobol' and 'halton' are superior alternatives and maximize even more the parameter space. 'sobol' will enforce an initial population size which is calculated as the next power of 2 after Ù¡ppopsize * len(x)Ù§x@. 'halton' has no requirements but is a bit less efficient. See Ù¢„oscipy.stats.qmcÙ „escipya*capioscipy.stats.qmcfmoduleõÙ§r for more details.€Ù¹‚Ù§ya'random' initializes the population randomly - this has the drawback that clustering can occur, preventing the whole of parameter space being covered. Use of an array to specify a population could be used, for example, to create a tight bunch of initial guesses in an location where the solution is known to exist, thereby reducing time for convergence.€Ù°ƒdatolofloat, optionalÙ¹‚‡Ù§x;Absolute tolerance for convergence, the solving stops when Ù¡x@np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))Ù§l, where and Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e and Ù¢„ctolÙ „ööelocalctolelocalõÙ§x6 are the absolute and relative tolerance respectively.€Ù°ƒhupdatingx#{'immediate', 'deferred'}, optional‚Ù¹‚‰Ù§cIf Ù¡k'immediate'Ù§xÎ, the best solution vector is continuously updated within a single generation . This can lead to faster convergence as trial vectors can take advantage of continuous improvements in the best solution. With Ù¡j'deferred'Ù§x@, the best solution vector is updated once per generation. Only Ù¡j'deferred'Ù§x- is compatible with parallelization, and the Ù¢„gworkersÙ „ööelocalgworkerselocalõÙ§x# keyword can over-ride this option.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.2.0 €Ù°ƒgworkersx"int or map-like callable, optional‚Ù¹‚“Ù§cIf Ù¢„gworkersÙ „ööelocalgworkerselocalõÙ§x- is an int the population is subdivided into Ù¢„gworkersÙ „ööelocalgworkerselocalõÙ§x* sections and evaluated in parallel (uses Ù£ƒx&multiprocessing.Pool <multiprocessing>ööÙ§x_). Supply -1 to use all available CPU cores. Alternatively supply a map-like callable, such as Ù£ƒxmultiprocessing.Pool.mapööÙ§xN for evaluating the population in parallel. This evaluation is carried out as Ù¡wworkers(func, iterable)Ù§x . This option will override the Ù¢„hupdatingÙ „ööelocalhupdatingelocalõÙ§l keyword to Ù¡supdating='deferred'Ù§d if Ù¡lworkers != 1Ù§p. Requires that Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§o be pickleable.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.2.0 €Ù°ƒkconstraintsx/{NonLinearConstraint, LinearConstraint, Bounds}‚Ù¹‚ƒÙ§x?Constraints on the solver, over and above those applied by the Ù¢„fboundsÙ „ööelocalfboundselocalõÙ§x% kwd. Uses the approach by Lampinen .€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.4.0 €Ù°ƒbx0xNone or array-like, optional‚Ù¹‚ƒÙ§x§Provides an initial guess to the minimization. Once the population has been initialized this vector replaces the first (best) member. This replacement is done even if Ù¢„dinitÙ „ööelocaldinitelocalõÙ§x  is given an initial population.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcresnOptimizeResultÙ¹‚“Ù§x)The optimization result represented as a Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x# object. Important attributes are: Ù¡axÙ§u the solution array, Ù¡gsuccessÙ§xD a Boolean flag indicating if the optimizer exited successfully and Ù¡gmessageÙ§x3 which describes the cause of the termination. See Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x+ for a description of other attributes. If Ù¢„fpolishÙ „ööelocalfpolishelocalõÙ§xh was employed, and a lower minimum was obtained by the polishing, then OptimizeResult also contains the Ù¡cjacÙ§xN attribute. If the eventual solution does not satisfy the applied constraints Ù¡gsuccessÙ§i will be Ù¡eFalseÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x4Finds the global minimum of a multivariate function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshExamplesjReferencesx)/scipy/optimize/_differentialevolution.pyr<class 'function'>x;scipy.signal._filter_design.optimize.differential_evolutionÙ¯‚‰Ù¹‚…Ù§xcLet us consider the problem of minimizing the Rosenbrock function. This function is implemented in Ù¢„erosenÙ „escipye1.8.0fmodulexscipy.optimize._optimize.rosenfmoduleõÙ§d in Ù¢„nscipy.optimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ§a.€Ù´ƒ˜MÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„erosenÙ „escipye1.8.0fmodulexscipy.optimize._optimize.rosenfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a
Ù±‚`fboundsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`fresultÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a(Ù±‚`Ù¢„erosenÙ „escipye1.8.0fmodulexscipy.optimize._optimize.rosenfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚`a)Ù±‚`a
Ù±‚`fresultÙ±‚aoa.Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fresultÙ±‚aoa.Ù±‚`cfunx5(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)fexecedÙ¹‚Ù§x%Now repeat, but with parallelization.€Ù´ƒ˜MÙ±‚`fboundsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`fresultÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a(Ù±‚`Ù¢„erosenÙ „escipye1.8.0fmodulexscipy.optimize._optimize.rosenfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚`a,Ù±‚`a Ù±‚`hupdatingÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1hdeferredÙ±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`x                                 Ù±‚`gworkersÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`fresultÙ±‚aoa.Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fresultÙ±‚aoa.Ù±‚`cfunx5(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)fexecedÙ¹‚Ù§x+Let's try and do a constrained minimization€Ù´ƒ˜(Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„sNonlinearConstraintÙ „escipye1.8.0fmodulex/scipy.optimize._constraints.NonlinearConstraintfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fBoundsÙ „escipye1.8.0fmodulex"scipy.optimize._constraints.BoundsfmoduleõÙ±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfhconstr_fÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)c>>>fexecedÙ´ƒ˜MÙ±‚bc1x0# the sum of x[0] and x[1] must be less than 1.9Ù±‚`a
Ù±‚`cnlcÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„sNonlinearConstraintÙ „escipye1.8.0fmodulex/scipy.optimize._constraints.NonlinearConstraintfmoduleõÙ±‚`a(Ù±‚`hconstr_fÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cinfÙ±‚`a,Ù±‚`a Ù±‚bmfc1.9Ù±‚`a)Ù±‚`a
Ù±‚bc1x)# specify limits using a `Bounds` object.Ù±‚`a
Ù±‚`fboundsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fBoundsÙ „escipye1.8.0fmodulex"scipy.optimize._constraints.BoundsfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb2.Ù±‚`a,Ù±‚`a Ù±‚bmfb2.Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`fresultÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a(Ù±‚`Ù¢„erosenÙ „escipye1.8.0fmodulexscipy.optimize._optimize.rosenfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚`a,Ù±‚`a Ù±‚`kconstraintsÙ±‚aoa=Ù±‚`a(Ù±‚`cnlcÙ±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`x                                 Ù±‚`Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`fresultÙ±‚aoa.Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fresultÙ±‚aoa.Ù±‚`cfunx8(array([0.96633867, 0.93363577]), 0.0011361355854792312)fexecedÙ¹‚Ù§xmNext find the minimum of the Ackley function (https://en.wikipedia.org/wiki/Test_functions_for_optimization).€Ù´ƒ˜ÇÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnffackleyÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`darg1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmfc0.2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`darg2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmfb2.Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmfb2.Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚aoa-Ù±‚bmfc20.Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`darg1Ù±‚`a)Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`darg2Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfc20.Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`aeÙ±‚`a
Ù±‚`fboundsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚aoa-Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`fresultÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„vdifferential_evolutionÙ „escipye1.8.0fmodulex<scipy.optimize._differentialevolution.differential_evolutionfmoduleõÙ±‚`a(Ù±‚`fackleyÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚`a)Ù±‚`a
Ù±‚`fresultÙ±‚aoa.Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`fresultÙ±‚aoa.Ù±‚`cfunx+(array([ 0.,  0.]), 4.4408920985006262e-16)fexecedö€e1.8.0Ù«ydifferential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=(), x0=None)öx<scipy.optimize._differentialevolution.differential_evolution€
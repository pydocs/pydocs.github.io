Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ÙÀx.x = arg min(sum(func(y)**2,axis=0))
         yögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚Ù§xC"leastsq" is a wrapper around MINPACK's lmdif and lmder algorithms.€Ù¹‚ƒÙ§ycov_x is a Jacobian approximation to the Hessian of the least squares objective function. This approximation assumes that the objective function is based on the difference between some observed target data (ydata) and a (non-linear) function of the parameters Ù£ƒpf(xdata, params)ööÙ§l ::         €ÙÀx'func(params) = ydata - f(xdata, params)Ù¹‚Ù§x-so that the objective function is ::         €ÙÀx5min   sum((ydata - f(xdata, params))**2, axis=0)
ramsÙ¹‚‡Ù§nThe solution, Ù¢„axÙ „ööelocalaxelocalõÙ§x4, is always a 1-D array, regardless of the shape of Ù¢„bx0Ù „ööelocalbx0elocalõÙ§m, or whether Ù¢„bx0Ù „ööelocalbx0elocalõÙ§m is a scalar.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒdfunchcallableÙ¹‚‰Ù§x*Should take at least one (possibly length Ù¡aNÙ§x vector) argument and returns Ù¡aMÙ§xH floating point numbers. It must not return NaNs or fitting might fail. Ù¡aMÙ§x" must be greater than or equal to Ù¡aNÙ§a.€Ù°ƒbx0gndarrayÙ¹‚Ù§x+The starting estimate for the minimization.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§x5Any extra arguments to func are placed in this tuple.€Ù°ƒdDfunrcallable, optionalÙ¹‚Ù§x‡A function or method to compute the Jacobian of func with derivatives across the rows. If this is None, the Jacobian will be estimated.€Ù°ƒkfull_outputnbool, optionalÙ¹‚Ù§x(non-zero to return all optional outputs.€Ù°ƒicol_derivnbool, optionalÙ¹‚Ù§x‡non-zero to specify that the Jacobian function computes derivatives down the columns (faster, because there is no transpose operation).€Ù°ƒdftolofloat, optionalÙ¹‚Ù§x-Relative error desired in the sum of squares.€Ù°ƒdxtolofloat, optionalÙ¹‚Ù§x3Relative error desired in the approximate solution.€Ù°ƒdgtolofloat, optionalÙ¹‚Ù§xROrthogonality desired between the function vector and the columns of the Jacobian.€Ù°ƒfmaxfevmint, optionalÙ¹‚‡Ù§x0The maximum number of calls to the function. If Ù¢„dDfunÙ „ööelocaldDfunelocalõÙ§x is provided, then the default Ù¢„fmaxfevÙ „ööelocalfmaxfevelocalõÙ§xM is 100*(N+1) where N is the number of elements in x0, otherwise the default Ù¢„fmaxfevÙ „ööelocalfmaxfevelocalõÙ§n is 200*(N+1).€Ù°ƒfepsfcnofloat, optionalÙ¹‚Ù§y7A variable used in determining a suitable step length for the forward- difference approximation of the Jacobian (for Dfun=None). Normally the actual step length will be sqrt(epsfcn)*x If epsfcn is less than the machine precision, it is assumed that the relative errors are of the order of the machine precision.€Ù°ƒffactorofloat, optionalÙ¹‚…Ù§x0A parameter determining the initial step bound (Ù¡vfactor * || diag * x||Ù§x). Should be in interval Ù¡j(0.1, 100)Ù§a.€Ù°ƒddiagrsequence, optionalÙ¹‚Ù§xCN positive entries that serve as a scale factors for the variables.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚…Ù°ƒaxgndarrayÙ¹‚Ù§xLThe solution (or the result of the last iteration for an unsuccessful call).€Ù°ƒecov_xgndarrayÙ¹‚‹Ù§xThe inverse of the Hessian. Ù£ƒdfjacööÙ§e and Ù£ƒdipvtööÙ§xˆ are used to construct an estimate of the Hessian. A value of None indicates a singular matrix, which means the curvature in parameters Ù¢„axÙ „ööelocalaxelocalõÙ§xH is numerically flat. To obtain the covariance matrix of the parameters Ù¢„axÙ „ööelocalaxelocalõÙ§b, Ù¢„ecov_xÙ „ööelocalecov_xelocalõÙ§xF must be multiplied by the variance of the residuals -- see curve_fit.€Ù°ƒhinfodictddict‚Ù¹‚Ù§x/a dictionary of optional outputs with the keys:€ÙÁ…ÙÅ‚Ù¹‚Ù¡dnfev€Ù¹‚Ù§xThe number of function calls€ÙÅ‚Ù¹‚Ù¡dfvec€Ù¹‚Ù§x$The function evaluated at the output€ÙÅ‚Ù¹‚Ù¡dfjac€Ù¹‚Ù§xÉA permutation of the R matrix of a QR     factorization of the final approximate     Jacobian matrix, stored column wise.     Together with ipvt, the covariance of the     estimate can be approximated.€ÙÅ‚Ù¹‚Ù¡dipvt€Ù¹‚Ù§xöAn integer array of length N which defines     a permutation matrix, p, such that     fjac*p = q*r, where r is upper triangular     with diagonal elements of nonincreasing     magnitude. Column j of p is column ipvt(j)     of the identity matrix.€ÙÅ‚Ù¹‚Ù¡cqtf€Ù¹‚Ù§x!The vector (transpose(q) * fvec).€Ù°ƒdmesgcstrÙ¹‚Ù§x?A string message giving information about the cause of failure.€Ù°ƒciercintÙ¹‚Ù§x»An integer flag. If it is equal to 1, 2, 3 or 4, the solution was found. Otherwise, the solution was not found. In either case, the optional output variable 'mesg' gives more information.€ögSummaryÙ¯‚Ù¹‚Ù§x2Minimize the sum of squares of a set of equations.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/optimize/_minpack_py.pyr<class 'function'>x,scipy.signal._filter_design.optimize.leastsqÙ¯‚Ù´ƒ˜)Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„gleastsqÙ „escipye1.8.0fmodulex"scipy.optimize._minpack_py.leastsqfmoduleõÙ±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfdfuncÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚bmia2Ù±‚aoa*Ù±‚`a(Ù±‚`axÙ±‚aoa-Ù±‚bmia3Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚aoa+Ù±‚bmia1Ù±‚`a
Ù±‚`Ù¢„gleastsqÙ „escipye1.8.0fmodulex"scipy.optimize._minpack_py.leastsqfmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)x(array([2.99999999]), 1)fexecedöÙ¼ƒÙ»ƒmleast_squaresx0scipy.optimize._lsq.least_squares.prepare_boundsõÙ¹‚ƒÙ§x\Newer interface to solve nonlinear least-squares problems with bounds on the variables. See Ù¡lmethod=='lm'Ù§o in particular.€öe1.8.0Ù«xleastsq(func, x0, args=(), Dfun=None, full_output=0, col_deriv=0, ftol=1.49012e-08, xtol=1.49012e-08, gtol=0.0, maxfev=0, epsfcn=None, factor=100, diag=None)öx"scipy.optimize._minpack_py.leastsq€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚“Ù§x/Represents the system as the transfer function Ù¥x6H(s)=\sum_{i=0}^N b[N-i] s^i / \sum_{j=0}^M a[M-j] s^jÙ§h, where Ù¥abÙ§x are elements of the numerator Ù£ƒcnumööÙ§b, Ù¥aaÙ§x! are elements of the denominator Ù£ƒcdenööÙ§f, and Ù¡oN == len(b) - 1Ù§b, Ù¡oM == len(a) - 1Ù§r. Continuous-time Ù¢„pTransferFunctionÙ „escipye1.8.0fmodulex%scipy.signal._ltisys.TransferFunctionfmoduleõÙ§x3 systems inherit additional functionality from the Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ§g class.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x:Changing the value of properties that are not part of the Ù¢„pTransferFunctionÙ „escipye1.8.0fmodulex%scipy.signal._ltisys.TransferFunctionfmoduleõÙ§x$ system representation (such as the Ù£ƒaAööÙ§b, Ù£ƒaBööÙ§b, Ù£ƒaCööÙ§b, Ù£ƒaDööÙ§x« state-space matrices) is very inefficient and may lead to numerical inaccuracies.  It is better to convert to the specific system representation first. For example, call Ù¡qsys = sys.to_ss()Ù§x: before accessing/changing the A, B, C, D system matrices.€Ù¹‚‡Ù§x-If (numerator, denominator) is passed in for Ù¡g*systemÙ§xm, coefficients for both the numerator and denominator should be specified in descending exponent order (e.g. Ù¡ls^2 + 3s + 5Ù§x would be represented as Ù¡i[1, 3, 5]Ù§a)€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒr*system: arguments`‚Ù¹‚ƒÙ§dThe Ù¢„pTransferFunctionÙ „escipye1.8.0fmodulex%scipy.signal._ltisys.TransferFunctionfmoduleõÙ§x} class can be instantiated with 1 or 2 arguments. The following gives the number of input arguments and their interpretation:€Ù·ƒx7* 1: `lti` system: (`StateSpace`, `TransferFunction` ors  `ZerosPolesGain`)x)* 2: array_like: (numerator, denominator)öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xGContinuous-time Linear Time Invariant system in transfer function form.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesx/scipy/signal/_ltisys.pyân<class 'type'>x/scipy.signal._ltisys.TransferFunctionContinuousÙ¯‚„Ù¹‚ƒÙ§x Construct the transfer function Ù¥x(H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}Ù§a:€Ù´ƒ‡Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõ`fexecedÙ´ƒ˜Ù±‚`cnumÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a
Ù±‚`cdenÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]`fexecedÙ´ƒ‰Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pTransferFunctionÙ „escipye1.8.0fmodulex%scipy.signal._ltisys.TransferFunctionfmoduleõÙ±‚`a(Ù±‚`cnumÙ±‚`a,Ù±‚`a Ù±‚`cdenÙ±‚`a)xVTransferFunctionContinuous(
array([ 1.,  3.,  3.]),
array([ 1.,  2.,  1.]),
dt: None
)fexecedö†Ù¼ƒÙ»ƒjStateSpacexscipy.signal._ltisys.StateSpaceõ€öÙ¼ƒÙ»ƒnZerosPolesGainx#scipy.signal._ltisys.ZerosPolesGainõ€öÙ¼ƒÙ»ƒcltixscipy.signal._ltisys.ltiõ€öÙ¼ƒÙ»ƒftf2sosx"scipy.signal._filter_design.tf2sosõ€öÙ¼ƒÙ»ƒetf2ssx"scipy.signal._lti_conversion.tf2ssõ€öÙ¼ƒÙ»ƒftf2zpkx"scipy.signal._filter_design.tf2zpkõ€öe1.8.0Ù«ööx/scipy.signal._ltisys.TransferFunctionContinuous€
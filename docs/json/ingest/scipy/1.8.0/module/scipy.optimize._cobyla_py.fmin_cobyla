Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§x‚This algorithm is based on linear approximations to the objective function and each constraint. We briefly describe the algorithm.€Ù¹‚Ù§yşSuppose the function is being minimized over k variables. At the jth iteration the algorithm has k+1 points v_1, ..., v_(k+1), an approximate solution x_j, and a radius RHO_j. (i.e., linear plus a constant) approximations to the objective function and constraint functions such that their function values agree with the linear approximation on the k+1 points v_1,.., v_(k+1). This gives a linear program to solve (where the linear approximations of the constraint functions are constrained to be non-negative).€Ù¹‚Ù§yŒHowever, the linear approximations are likely only good approximations near the current simplex, so the linear program is given the further requirement that the solution, which will become x_(j+1), must be within RHO_j from x_j. RHO_j only decreases, never increases. The initial RHO_j is rhobeg and the final RHO_j is rhoend. In this way COBYLA's iterations behave like a trust region algorithm.€Ù¹‚Ù§xóAdditionally, the linear program may be inconsistent, or the approximation may give poor improvement. For details about how these issues are resolved, as well as how the points v_i are updated, refer to the source code or the references below.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒdfunchcallableÙ¹‚Ù§x2Function to minimize. In the form func(x, \*args).€Ù°ƒbx0gndarrayÙ¹‚Ù§nInitial guess.€Ù°ƒdconshsequenceÙ¹‚…Ù§x"Constraint functions; must all be Ù¡c>=0Ù§xN (a single function if only 1 constraint). Each function takes the parameters Ù¢„axÙ „ööelocalaxelocalõÙ§x` as its first argument, and it can return either a single number or an array or list of numbers.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§x$Extra arguments to pass to function.€Ù°ƒhconsargsotuple, optionalÙ¹‚ƒÙ§x~Extra arguments to pass to constraint functions (default of None means use same extra arguments as those passed to func). Use Ù¡b()Ù§x for no extra arguments.€Ù°ƒfrhobegofloat, optionalÙ¹‚Ù§x,Reasonable initial changes to the variables.€Ù°ƒfrhoendofloat, optionalÙ¹‚Ù§xuFinal accuracy in the optimization (not precisely guaranteed). This is a lower bound on the size of the trust region.€Ù°ƒddispv{0, 1, 2, 3}, optionalÙ¹‚Ù§x6Controls the frequency of output; 0 implies no output.€Ù°ƒfmaxfunmint, optionalÙ¹‚Ù§x'Maximum number of function evaluations.€Ù°ƒecatolofloat, optionalÙ¹‚Ù§x-Absolute tolerance for constraint violations.€Ù°ƒhcallbackrcallable, optionalÙ¹‚…Ù§x Called after each iteration, as Ù¡kcallback(x)Ù§h, where Ù¡axÙ§x! is the current parameter vector.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaxgndarrayÙ¹‚ƒÙ§xThe argument that minimises Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§xœMinimize a function using the Constrained Optimization By Linear Approximation (COBYLA) method. This method wraps a FORTRAN implementation of the algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/optimize/_cobyla_py.py%r<class 'function'>x0scipy.signal._filter_design.optimize.fmin_cobylaÙ¯‚‚Ù·Œu>>> def objective(x):x...     return x[0]*x[1]c...s>>> def constr1(x):x&...     return 1 - (x[0]**2 + x[1]**2)c...s>>> def constr2(x):s...     return x[1]c...x*>>> from scipy.optimize import fmin_cobylaxG>>> fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)x!array([-0.70710685,  0.70710671])Ù¹‚Ù§x.The exact solution is (-sqrt(2)/2, sqrt(2)/2).€öÙ¼ƒÙ»ƒhminimizeööÙ¹‚ƒÙ§xRInterface to minimization algorithms for multivariate functions. See the 'COBYLA' Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§o in particular.€öe1.8.0Ù«x†fmin_cobyla(func, x0, cons, args=(), consargs=None, rhobeg=1.0, rhoend=0.0001, maxfun=1000, disp=None, catol=0.0002, *, callback=None)öx%scipy.optimize._cobyla_py.fmin_cobyla€
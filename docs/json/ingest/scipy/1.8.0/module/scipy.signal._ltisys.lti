Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚ŠÙ¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ§x+ instances do not exist directly. Instead, Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ§x/ creates an instance of one of its subclasses: Ù¢„jStateSpaceÙ „escipye1.8.0fmodulexscipy.signal._ltisys.StateSpacefmoduleõÙ§b, Ù¢„pTransferFunctionÙ „escipye1.8.0fmodulex%scipy.signal._ltisys.TransferFunctionfmoduleõÙ§d or Ù¢„nZerosPolesGainÙ „escipye1.8.0fmodulex#scipy.signal._ltisys.ZerosPolesGainfmoduleõÙ§a.€Ù¹‚‡Ù§x-If (numerator, denominator) is passed in for Ù¡g*systemÙ§xn, coefficients for both the numerator and denominator should be specified in descending exponent order (e.g., Ù¡ls^2 + 3s + 5Ù§x would be represented as Ù¡i[1, 3,
5]Ù§b).€Ù¹‚‡Ù§xnChanging the value of properties that are not directly part of the current system representation (such as the Ù¢„ezerosÙ „escipye1.8.0fmoduletscipy.optimize.zerosfmoduleõÙ§f of a Ù¢„jStateSpaceÙ „escipye1.8.0fmodulexscipy.signal._ltisys.StateSpacefmoduleõÙ§xœ system) is very inefficient and may lead to numerical inaccuracies. It is better to convert to the specific system representation first. For example, call Ù¡rsys = sys.to_zpk()Ù§x4 before accessing/changing the zeros, poles or gain.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒg*systemiargumentsƒÙ¹‚ƒÙ§dThe Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ§x§ class can be instantiated with either 2, 3 or 4 arguments. The following gives the number of arguments and the corresponding continuous-time subclass that is created:€Ù·ƒx2* 2: `TransferFunction`:  (numerator, denominator)x+* 3: `ZerosPolesGain`: (zeros, poles, gain)x * 4: `StateSpace`:  (A, B, C, D)Ù¹‚Ù§x,Each argument can be an array or a sequence.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x8Continuous-time linear time invariant system base class.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametershSee AlsoeNoteshExamplesx/scipy/signal/_ltisys.py…n<class 'type'>pscipy.signal.ltiÙ¯‚†Ù´ƒ‡Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõ`fexecedÙ´ƒÙ±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)xXStateSpaceContinuous(
array([[1]]),
array([[2]]),
array([[3]]),
array([[4]]),
dt: None
)fexecedÙ¹‚ƒÙ§x Construct the transfer function Ù¥x-H(s) = \frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}Ù§a:€Ù´ƒ–Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)xEZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)fexecedÙ¹‚ƒÙ§x Construct the transfer function Ù¥xH(s) = \frac{3s + 4}{1s + 2}Ù§a:€Ù´ƒ“Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)xHTransferFunctionContinuous(
array([3., 4.]),
array([1., 2.]),
dt: None
)fexecedö„Ù¼ƒÙ»ƒjStateSpacexscipy.signal._ltisys.StateSpaceõ€öÙ¼ƒÙ»ƒpTransferFunctionx%scipy.signal._ltisys.TransferFunctionõ€öÙ¼ƒÙ»ƒnZerosPolesGainx#scipy.signal._ltisys.ZerosPolesGainõ€öÙ¼ƒÙ»ƒddltixscipy.signal._ltisys.dltiõ€öe1.8.0Ù«ööxscipy.signal._ltisys.lti€
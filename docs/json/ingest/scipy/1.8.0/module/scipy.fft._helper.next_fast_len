Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‹Ù§yGSciPy's FFT algorithms gain their speed by a recursive divide and conquer strategy. This relies on efficient functions for small prime factors of the input length. Thus, the transforms are fastest when using composites of the prime factors handled by the fft implementation. If there are efficient functions for all radices <= Ù£ƒanööÙ§x#, then the result will be a number Ù£ƒaxööÙ§d >= Ù¡ftargetÙ§x with only prime factors < Ù£ƒanööÙ§q. (Also known as Ù£ƒanööÙ§p-smooth numbers)€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§xƒThe result of this function may change in future as performance considerations change, for example, if new prime factors are added.€Ù¹‚‡Ù§hCalling Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ§d or Ù¢„difftÙ „escipye1.8.0fmoduleuscipy.fft._basic.ifftfmoduleõÙ§x" with real input data performs an Ù¡e'R2C'Ù§v transform internally.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒftargetcintÙ¹‚Ù§x;Length to start searching from. Must be a positive integer.€Ù°ƒdrealnbool, optionalÙ¹‚‡Ù§x5True if the FFT involves real input or output (e.g., Ù¢„drfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.rfftfmoduleõÙ§d or Ù¢„dhfftÙ „escipye1.8.0fmoduleuscipy.fft._basic.hfftfmoduleõÙ§i but not Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ§u). Defaults to False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutcintÙ¹‚ƒÙ§x2The smallest fast length greater than or equal to Ù¡ftargetÙ§a.€ögSummaryÙ¯‚Ù¹‚ƒÙ§x)Find the next fast size of input data to Ù¡cfftÙ§x, for zero-padding, etc.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnseNoteshExamplesööx&<class 'functools._lru_cache_wrapper'>xscipy.signal._czt.next_fast_lenÙ¯‚‡Ù¹‚Ù§x>On a particular machine, an FFT of prime length takes 11.4 ms:€Ù´ƒ˜1Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`gmin_lenÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmie93059Ù±‚`b  Ù±‚bc1x&# prime length is worst case for speedÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`gmin_lenÙ±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)`fexecedÙ¹‚Ù§xcZero-padding to the next regular length reduces computation time to 1.6 ms, a speedup of 7.3 times:€Ù´ƒ‹Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„mnext_fast_lenÙ „escipye1.8.0fmodulexscipy.fft._helper.next_fast_lenfmoduleõÙ±‚`a(Ù±‚`gmin_lenÙ±‚`a,Ù±‚`a Ù±‚`drealÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)e93312fexecedÙ´ƒÙ±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmie93312Ù±‚`a)`fexecedÙ¹‚ƒÙ§xuRounding up to the next power of 2 is not optimal, taking 3.0 ms to compute; 1.9 times longer than the size given by Ù¡mnext_fast_lenÙ§a:€Ù´ƒÙ±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmif131072Ù±‚`a)`fexecedö€e1.8.0Ù«ööxscipy.fft._helper.next_fast_len€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‰Ù§rAn ID of a matrix Ù¢„aAÙ „ööelocalaAelocalõÙ§x& is a factorization defined by a rank Ù¢„akÙ „ööelocalakelocalõÙ§w, a column index array Ù¢„cidxÙ „escipye1.8.0fmodulex5scipy.signal._filter_design._nearest_real_complex_idxfmoduleõÙ§x!, and interpolation coefficients Ù¢„dprojÙ „ööelocaldprojelocalõÙ§r such that::      €ÙÀx,numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]]Ù¹‚Ù§x8The original matrix can then be reconstructed as::      €ÙÀx†numpy.hstack([A[:,idx[:k]],
                            numpy.dot(A[:,idx[:k]], proj)]
                        )[:,numpy.argsort(idx)]Ù¹‚ƒÙ§sor via the routine Ù¢„xreconstruct_matrix_from_idÙ „escipye1.8.0fmodulex5scipy.linalg.interpolative.reconstruct_matrix_from_idfmoduleõÙ§x-. This can equivalently be written as::      €ÙÀxunumpy.dot(A[:,idx[:k]],
                    numpy.hstack([numpy.eye(k), proj])
                  )[:,np.argsort(idx)]Ù¹‚Ù§x;in terms of the skeleton and interpolation matrices::      €ÙÀpB = A[:,idx[:k]]Ù¹‚Ù§kand::      €ÙÀx9P = numpy.hstack([numpy.eye(k), proj])[:,np.argsort(idx)]Ù¹‚…Ù§wrespectively. See also Ù¢„xreconstruct_interp_matrixÙ „escipye1.8.0fmodulex4scipy.linalg.interpolative.reconstruct_interp_matrixfmoduleõÙ§e and Ù¢„wreconstruct_skel_matrixÙ „escipye1.8.0fmodulex2scipy.linalg.interpolative.reconstruct_skel_matrixfmoduleõÙ§a.€Ù¹‚…Ù§xTThe ID can be computed to any relative precision or rank (depending on the value of Ù¢„heps_or_kÙ „ööelocalheps_or_kelocalõÙ§x ). If a precision is specified (Ù£ƒleps_or_k < 1ööÙ§x6), then this function has the output signature::      €ÙÀx)k, idx, proj = interp_decomp(A, eps_or_k)Ù¹‚ƒÙ§x#Otherwise, if a rank is specified (Ù£ƒmeps_or_k >= 1ööÙ§x'), then the output signature is::      €ÙÀx&idx, proj = interp_decomp(A, eps_or_k)Ù¾yå..  This function automatically detects the form of the input parameters
    and passes them to the appropriate backend. For details, see
    :func:`_backend.iddp_id`, :func:`_backend.iddp_aid`,
    :func:`_backend.iddp_rid`, :func:`_backend.iddr_id`,
    :func:`_backend.iddr_aid`, :func:`_backend.iddr_rid`,
    :func:`_backend.idzp_id`, :func:`_backend.idzp_aid`,
    :func:`_backend.idzp_rid`, :func:`_backend.idzr_id`,
    :func:`_backend.idzr_aid`, and :func:`_backend.idzr_rid`.ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaAxT:class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` with `rmatvec`Ù¹‚Ù§uMatrix to be factored€Ù°ƒheps_or_klfloat or intÙ¹‚…Ù§sRelative error (if Ù£ƒleps_or_k < 1ööÙ§n) or rank (if Ù£ƒmeps_or_k >= 1ööÙ§s) of approximation.€Ù°ƒdrandnbool, optionalÙ¹‚‰Ù§x"Whether to use random sampling if Ù¢„aAÙ „ööelocalaAelocalõÙ§l is of type Ù¢„mnumpy.ndarrayÙ „enumpya*capimnumpy.ndarrayfmoduleõÙ§x+ (randomized algorithms are always used if Ù¢„aAÙ „ööelocalaAelocalõÙ§l is of type Ù¢„x"scipy.sparse.linalg.LinearOperatorÙ „escipya*capix-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ§b).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒakcintÙ¹‚ƒÙ§x9Rank required to achieve specified relative precision if Ù£ƒleps_or_k < 1ööÙ§a.€Ù°ƒcidxv:class:`numpy.ndarray`Ù¹‚Ù§sColumn index array.€Ù°ƒdprojv:class:`numpy.ndarray`Ù¹‚Ù§xInterpolation coefficients.€ögSummaryÙ¯‚Ù¹‚Ù§wCompute ID of a matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersgReturnsx/scipy/linalg/interpolative.pyâr<class 'function'>xEscipy.signal._filter_design.optimize._remove_redundancy.interp_decompÙ¯‚€ö€e1.8.0Ù«x%interp_decomp(A, eps_or_k, rand=True)öx(scipy.linalg.interpolative.interp_decomp€
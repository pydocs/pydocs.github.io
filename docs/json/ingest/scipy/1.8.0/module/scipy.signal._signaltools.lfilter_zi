Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚…Ù§xCompute an initial state Ù¢„bziÙ „ööelocalbzielocalõÙ§i for the Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ§xD function that corresponds to the steady state of the step response.€Ù¹‚Ù§x§A typical use of this function is to set the initial state so that the output of the filter starts at the same value as the first element of the signal to be filtered.€ögMethodsÙ¯‚€öeNotesÙ¯‚ˆÙ¹‚Ù§xŒA linear filter with order m has a state space representation (A, B, C, D), for which the output y of the filter can be expressed as::      €ÙÀx1z(n+1) = A*z(n) + B*x(n)
y(n)   = C*z(n) + D*x(n)Ù¹‚Ù§x­where z(n) is a vector of length m, A has shape (m, m), B has shape (m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is a scalar).  lfilter_zi solves::      €ÙÀmzi = A*zi + BÙ¹‚Ù§xlIn other words, it finds the initial condition for which the response to an input of all ones is a constant.€Ù¹‚…Ù§xGiven the filter coefficients Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„abÙ „ööelocalabelocalõÙ§x§, the state space matrices for the transposed direct form II implementation of the linear filter, which is the implementation used by scipy.signal.lfilter, are::      €ÙÀx6A = scipy.linalg.companion(a).T
B = b[1:] - a[1:]*b[0]Ù¹‚‰Ù§iassuming Ù£ƒda[0]ööÙ§l is 1.0; if Ù£ƒda[0]ööÙ§k is not 1, Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„abÙ „ööelocalabelocalõÙ§x are first divided by a[0].€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒdb, aparray_like (1-D)Ù¹‚ƒÙ§x!The IIR filter coefficients. See Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ§v for more information.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒbzik1-D ndarrayÙ¹‚Ù§x!The initial state for the filter.€ögSummaryÙ¯‚Ù¹‚Ù§xHConstruct initial conditions for lfilter for step response steady-state.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/signal/_signaltools.py¨r<class 'function'>wscipy.signal.lfilter_ziÙ¯‚…Ù¹‚…Ù§xÁThe following code creates a lowpass Butterworth filter. Then it applies that filter to an array whose values are all 1.0; the output is also all 1.0, as expected for a lowpass filter.  If the Ù¢„bziÙ „ööelocalbzielocalõÙ§m argument of Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ§xF had not been given, the output would have shown the transient signal.€Ù´ƒ˜QÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`donesÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„jlfilter_ziÙ „escipye1.8.0fmodulex$scipy.signal._signaltools.lfilter_zifmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fbutterÙ „escipye1.8.0fmodulex"scipy.signal._filter_design.butterfmoduleõÙ±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fbutterÙ „escipye1.8.0fmodulex"scipy.signal._filter_design.butterfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmfd0.25Ù±‚`a)Ù±‚`a
Ù±‚`bziÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jlfilter_ziÙ „escipye1.8.0fmodulex$scipy.signal._signaltools.lfilter_zifmoduleõÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`bzoÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`donesÙ±‚`a(Ù±‚bmib10Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bziÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa=Ù±‚`Ù¢„bziÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx8array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])fexecedÙ¹‚Ù§pAnother example:€Ù´ƒ˜:Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`bzfÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bziÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa=Ù±‚`Ù¢„bziÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa*Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxearray([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
    0.44399389,  0.35505241])fexecedÙ¹‚‹Ù§nNote that the Ù¢„bziÙ „ööelocalbzielocalõÙ§m argument to Ù¢„glfilterÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.lfilterfmoduleõÙ§t was computed using Ù¢„jlfilter_ziÙ „escipye1.8.0fmodulex$scipy.signal._signaltools.lfilter_zifmoduleõÙ§o and scaled by Ù£ƒdx[0]ööÙ§s.  Then the output Ù£ƒayööÙ§x8 has no transient until the input drops from 0.5 to 0.0.€öƒÙ¼ƒÙ»ƒhfiltfiltx"scipy.signal._signaltools.filtfiltõ€öÙ¼ƒÙ»ƒglfilterx!scipy.signal._signaltools.lfilterõ€öÙ¼ƒÙ»ƒglfilticx!scipy.signal._signaltools.lfilticõ€öe1.8.0Ù«plfilter_zi(b, a)öx$scipy.signal._signaltools.lfilter_zi€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x¢Uses the "brute force" method, i.e., computes the function's value at each point of a multidimensional grid of points, to find the global minimum of the function.€Ù¹‚‡Ù§xzThe function is evaluated everywhere in the range with the datatype of the first call to the function, as enforced by the Ù¡ivectorizeÙ§xM NumPy function. The value and type of the function evaluation returned when Ù¡pfull_output=TrueÙ§x! are affected in addition by the Ù¡ffinishÙ§v argument (see Notes).€Ù¹‚ƒÙ§xThe brute force approach is inefficient because the number of grid points increases exponentially - the number of grid points to evaluate is Ù¡lNs ** len(x)Ù§x. Consequently, even with coarse grid spacing, even moderately sized problems can take a long time to run, and/or run into memory limitations.€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚„Ù¨Ù§fNote 1Ù§xa: The program finds the gridpoint at which the lowest value of the objective function occurs. If Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§x× is None, that is the point returned. When the global minimum occurs within (or not very far outside) the grid's boundaries, and the grid is fine enough, that point will be in the neighborhood of the global minimum.€Ù¹‚‘Ù§xHowever, users often employ some other optimization program to "polish" the gridpoint values, i.e., to seek a more precise (local) minimum near Ù£ƒgbrute'sööÙ§u best gridpoint. The Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§l function's Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§xS option provides a convenient way to do that. Any polishing program used must take Ù£ƒgbrute'sööÙ§x@ output as its initial guess as a positional argument, and take Ù£ƒgbrute'sööÙ§r input values for Ù¢„dargsÙ „ööelocaldargselocalõÙ§xS as keyword arguments, otherwise an error will be raised. It may additionally take Ù¢„kfull_outputÙ „ööelocalkfull_outputelocalõÙ§h and/or Ù¢„ddispÙ „ööelocalddispelocalõÙ§v as keyword arguments.€Ù¹‚’Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§r assumes that the Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§x function returns either an Ù¢„nOptimizeResultÙ „escipye1.8.0fmodulex'scipy.optimize._optimize.OptimizeResultfmoduleõÙ§x  object or a tuple in the form: Ù¡x(xmin, Jmin, ... , statuscode)Ù§h, where Ù¡dxminÙ§x* is the minimizing value of the argument, Ù¡dJminÙ§xp is the minimum value of the objective function, "..." may be some other returned values (which are not used by Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§g), and Ù¡jstatuscodeÙ§x is the status code of the Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§i program.€Ù¹‚Ù§oNote that when Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§x3 is not None, the values returned are those of the Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§j program, Ù¨Ù§cnotÙ§x) the gridpoint ones. Consequently, while Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§x3 confines its search to the input grid points, the Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§xÉ program's results usually will not coincide with any gridpoint, and may fall outside the grid's boundary. Thus, if a minimum only needs to be found over the provided grid points, make sure to pass in Ù£ƒkfinish=NoneööÙ§a.€Ù¹‚’Ù¨Ù§fNote 2Ù§x: The grid of points is a Ù£ƒknumpy.mgridööÙ§m object. For Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§e the Ù¢„frangesÙ „ööelocalfrangeselocalõÙ§e and Ù¢„bNsÙ „ööelocalbNselocalõÙ§x9 inputs have the following effect. Each component of the Ù¢„frangesÙ „ööelocalfrangeselocalõÙ§x tuple can be either a slice object or a two-tuple giving a range of values, such as (0, 5). If the component is a slice object, Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§x: uses it directly. If the component is a two-tuple range, Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§x< internally converts it to a slice object that interpolates Ù¢„bNsÙ „ööelocalbNselocalõÙ§x8 points from its low-value to its high-value, inclusive.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒdfunchcallableÙ¹‚‡Ù§x<The objective function to be minimized. Must be in the form Ù¡kf(x, *args)Ù§h, where Ù¡axÙ§x0 is the argument in the form of a 1-D array and Ù¡dargsÙ§xY is a tuple of any additional fixed parameters needed to completely specify the function.€Ù°ƒfrangesetupleÙ¹‚‡Ù§vEach component of the Ù¢„frangesÙ „ööelocalfrangeselocalõÙ§xD tuple must be either a "slice object" or a range tuple of the form Ù¡k(low, high)Ù§xl. The program uses these to create the grid of points on which the objective function will be computed. See Ù£ƒfNote 2ööÙ§q for more detail.€Ù°ƒdargsotuple, optionalÙ¹‚Ù§xJAny additional fixed parameters needed to completely specify the function.€Ù°ƒbNsmint, optionalÙ¹‚ƒÙ§xFNumber of grid points along the axes, if not otherwise specified. See Ù£ƒeNote2ööÙ§a.€Ù°ƒkfull_outputnbool, optionalÙ¹‚Ù§xNIf True, return the evaluation grid and the objective function's values on it.€Ù°ƒffinishrcallable, optionalÙ¹‚‹Ù§xfAn optimization function that is called with the result of brute force minimization as initial guess. Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§m should take Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x9 and the initial guess as positional arguments, and take Ù¢„dargsÙ „ööelocaldargselocalõÙ§x0 as keyword arguments. It may additionally take Ù¢„kfull_outputÙ „ööelocalkfull_outputelocalõÙ§h and/or Ù¢„ddispÙ „ööelocalddispelocalõÙ§xe as keyword arguments. Use None if no "polishing" function is to be used. See Notes for more details.€Ù°ƒddispnbool, optionalÙ¹‚ƒÙ§x3Set to True to print convergence messages from the Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§j callable.€Ù°ƒgworkersx"int or map-like callable, optional‚Ù¹‚Ù§cIf Ù¢„gworkersÙ „ööelocalgworkerselocalõÙ§x' is an int the grid is subdivided into Ù¢„gworkersÙ „ööelocalgworkerselocalõÙ§x* sections and evaluated in parallel (uses Ù£ƒx&multiprocessing.Pool <multiprocessing>ööÙ§j). Supply Ù£ƒb-1ööÙ§x^ to use all cores available to the Process. Alternatively supply a map-like callable, such as Ù£ƒxmultiprocessing.Pool.mapööÙ§xH for evaluating the grid in parallel. This evaluation is carried out as Ù¡wworkers(func, iterable)Ù§p. Requires that Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§o be pickleable.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.3.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚„Ù°ƒbx0gndarrayÙ¹‚ƒÙ§xnA 1-D array containing the coordinates of a point at which the objective function had its minimum value. (See Ù£ƒfNote 1ööÙ§x for which point is returned.)€Ù°ƒdfvalefloatÙ¹‚…Ù§xFunction value at the point Ù¢„bx0Ù „ööelocalbx0elocalõÙ§q. (Returned when Ù¢„kfull_outputÙ „ööelocalkfull_outputelocalõÙ§j is True.)€Ù°ƒdgridetupleÙ¹‚…Ù§xARepresentation of the evaluation grid. It has the same length as Ù¢„bx0Ù „ööelocalbx0elocalõÙ§q. (Returned when Ù¢„kfull_outputÙ „ööelocalkfull_outputelocalõÙ§j is True.)€Ù°ƒdJoutgndarrayÙ¹‚…Ù§x<Function values at each point of the evaluation grid, i.e., Ù¡rJout = func(*grid)Ù§q. (Returned when Ù¢„kfull_outputÙ „ööelocalkfull_outputelocalõÙ§j is True.)€ögSummaryÙ¯‚Ù¹‚Ù§x6Minimize a function over a given range by brute force.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/optimize/_optimize.pyär<class 'function'>x*scipy.signal._filter_design.optimize.bruteÙ¯‚‰Ù¹‚Ù§xWe illustrate the use of Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ§xÉ to seek the global minimum of a function of two variables that is given as the sum of a positive-definite quadratic and two deep "Gaussian-shaped" craters. Specifically, define the objective function Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ§x& as the sum of three other functions, Ù¡pf = f1 + f2 + f3Ù§x+. We suppose each of these has a signature Ù¡l(z, *params)Ù§h, where Ù¡jz = (x, y)Ù§g,  and Ù¡fparamsÙ§x( and the functions are as defined below.€Ù´ƒ˜£Ù±‚`fparamsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib44Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmib26Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a)Ù±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfbf1Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`azÙ±‚`a
Ù±‚`d    Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`agÙ±‚`a,Ù±‚`a Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚`akÙ±‚`a,Ù±‚`a Ù±‚`alÙ±‚`a,Ù±‚`a Ù±‚`escaleÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`fparamsÙ±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a(Ù±‚`aaÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`abÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`acÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`ayÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚aoa*Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`aeÙ±‚aoa*Ù±‚`ayÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a)`fexecedÙ´ƒ˜hÙ±‚akcdefÙ±‚`a Ù±‚bnfbf2Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`azÙ±‚`a
Ù±‚`d    Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`agÙ±‚`a,Ù±‚`a Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚`akÙ±‚`a,Ù±‚`a Ù±‚`alÙ±‚`a,Ù±‚`a Ù±‚`escaleÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`fparamsÙ±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚`agÙ±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`a(Ù±‚`a(Ù±‚`axÙ±‚aoa-Ù±‚`ahÙ±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`a(Ù±‚`ayÙ±‚aoa-Ù±‚`aiÙ±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚`escaleÙ±‚`a)Ù±‚`a)`fexecedÙ´ƒ˜hÙ±‚akcdefÙ±‚`a Ù±‚bnfbf3Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`azÙ±‚`a
Ù±‚`d    Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`agÙ±‚`a,Ù±‚`a Ù±‚`ahÙ±‚`a,Ù±‚`a Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚`akÙ±‚`a,Ù±‚`a Ù±‚`alÙ±‚`a,Ù±‚`a Ù±‚`escaleÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`fparamsÙ±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚`ajÙ±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`a(Ù±‚`a(Ù±‚`axÙ±‚aoa-Ù±‚`akÙ±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`a(Ù±‚`ayÙ±‚aoa-Ù±‚`alÙ±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚`escaleÙ±‚`a)Ù±‚`a)`fexecedÙ´ƒ˜-Ù±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`bf1Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`bf2Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`bf3Ù±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`fparamsÙ±‚`a)`fexecedÙ¹‚ƒÙ§xƒThus, the objective function may have local minima near the minimum of each of the three functions of which it is composed. To use Ù¢„dfminÙ „escipye1.8.0fmodulexscipy.optimize._optimize.fminfmoduleõÙ§xA to polish its gridpoint result, we may then continue as follows:€Ù´ƒ˜MÙ±‚`grrangesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bnbesliceÙ±‚`a(Ù±‚aoa-Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfd0.25Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbesliceÙ±‚`a(Ù±‚aoa-Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfd0.25Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a
Ù±‚`hresbruteÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚aoa.Ù±‚`Ù¢„ebruteÙ „escipye1.8.0fmodulexscipy.optimize._optimize.brutefmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`grrangesÙ±‚`a,Ù±‚`a Ù±‚`dargsÙ±‚aoa=Ù±‚`fparamsÙ±‚`a,Ù±‚`a Ù±‚`kfull_outputÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a
Ù±‚`x                          Ù±‚`Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ±‚aoa=Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚aoa.Ù±‚`Ù¢„dfminÙ „escipye1.8.0fmodulexscipy.optimize._optimize.fminfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`hresbruteÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`b  Ù±‚bc1p# global minimumx!array([-1.05665192,  1.80834843])fexecedÙ´ƒ†Ù±‚`hresbruteÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`b  Ù±‚bc1x"# function value at global minimumm-3.4085818767fexecedÙ¹‚ƒÙ§mNote that if Ù¢„ffinishÙ „escipye1.8.0fmodulex4scipy.interpolate._polyint._Interpolator1D._finish_yfmoduleõÙ§xq had been set to None, we would have gotten the gridpoint [-1.0 1.75] where the rounded function value is -2.892.€ö‚Ù¼ƒÙ»ƒlbasinhoppingx)scipy.optimize._basinhopping.basinhoppingõ€öÙ¼ƒÙ»ƒvdifferential_evolutionx<scipy.optimize._differentialevolution.differential_evolutionõ€öe1.8.0Ù«xnbrute(func, ranges, args=(), Ns=20, full_output=0, finish=<function fmin at 0x0000000>, disp=False, workers=1)öxscipy.optimize._optimize.brute€
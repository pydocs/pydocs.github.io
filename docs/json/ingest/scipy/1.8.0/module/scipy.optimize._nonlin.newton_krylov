Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x9This method is suitable for solving large-scale problems.€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚Ù§y
This function implements a Newton-Krylov solver. The basic idea is to compute the inverse of the Jacobian with an iterative Krylov method. These methods require only evaluating the Jacobian-vector products, which are conveniently approximated by a finite difference:€Ù¤x9J v \approx ( f ( x + \omega*v / |v|) - f ( x)) / \omega Ù¹‚Ù§xbDue to the use of iterative matrix inverses, these methods can deal with large nonlinear problems.€Ù¹‚…Ù§hSciPy's Ù¢„sscipy.sparse.linalgÙ „escipye1.8.0fmodulesscipy.sparse.linalgfmoduleõÙ§xQ module offers a selection of Krylov solvers to choose from. The default here is Ù¢„flgmresÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§x¤, which is a variant of restarted GMRES iteration that reuses some of the information obtained in the previous Newton steps to invert Jacobians in subsequent steps.€Ù¹‚Ù§xhFor a review on Newton-Krylov methods, see for example , and for the LGMRES sparse inverse method, see .€öpOther ParametersÙ¯‚€öjParametersÙ¯‚’Ù°ƒaFpfunction(x) -> fÙ¹‚Ù§xIFunction whose root to find; should take and return an array-like object.€Ù°ƒcxinjarray_likeÙ¹‚Ù§xInitial guess for the solution€Ù°ƒerdiffofloat, optionalÙ¹‚Ù§x7Relative step size to use in numerical differentiation.€Ù°ƒfmethodx<{'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function‚Ù¹‚ƒÙ§xKrylov method to use to approximate the Jacobian. Can be a string, or a function implementing the same interface as the iterative solvers in Ù¢„sscipy.sparse.linalgÙ „escipye1.8.0fmodulesscipy.sparse.linalgfmoduleõÙ§a.€Ù¹‚ƒÙ§oThe default is Ù¢„xscipy.sparse.linalg.lgmresÙ „escipya*capix)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§a.€Ù°ƒminner_maxitermint, optionalÙ¹‚Ù§x¬Parameter to pass to the "inner" Krylov solver: maximum number of iterations. Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.€Ù°ƒginner_Mx!LinearOperator or InverseJacobianƒÙ¹‚Ù§x‡Preconditioner for the inner Krylov iteration. Note that you can use also inverse Jacobians as (adaptive) preconditioners. For example,€ÙÀxÉ>>> from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
>>> from scipy.optimize.nonlin import InverseJacobian
>>> jac = BroydenFirst()
>>> kjac = KrylovJacobian(inner_M=InverseJacobian(jac))Ù¹‚‡Ù§xHIf the preconditioner has a method named 'update', it will be called as Ù¡lupdate(x, f)Ù§x! after each nonlinear step, with Ù¡axÙ§x giving the current point, and Ù¡afÙ§x the current function value.€Ù°ƒgouter_kmint, optionalÙ¹‚ƒÙ§xBSize of the subspace kept across LGMRES nonlinear iterations. See Ù¢„xscipy.sparse.linalg.lgmresÙ „escipya*capix)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§m for details.€Ù°ƒlinner_kwargsfkwargsÙ¹‚‡Ù§x?Keyword parameters for the "inner" Krylov solver (defined with Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§x'). Parameter names must start with the Ù£ƒfinner_ööÙ§xN prefix which will be stripped before passing on the inner method. See, e.g., Ù¢„xscipy.sparse.linalg.gmresÙ „escipya*capix+scipy.sparse.linalg._isolve.iterative.gmresfmoduleõÙ§m for details.€Ù°ƒditermint, optionalÙ¹‚Ù§x`Number of iterations to make. If omitted (default), make as many as required to meet tolerances.€Ù°ƒgverbosenbool, optionalÙ¹‚Ù§x*Print status to stdout on every iteration.€Ù°ƒgmaxitermint, optionalÙ¹‚ƒÙ§xNMaximum number of iterations to make. If more are needed to meet convergence, Ù¢„mNoConvergenceÙ „escipye1.8.0fmodulex$scipy.optimize._nonlin.NoConvergencefmoduleõÙ§k is raised.€Ù°ƒef_tolofloat, optionalÙ¹‚Ù§xOAbsolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6.€Ù°ƒff_rtolofloat, optionalÙ¹‚Ù§x:Relative tolerance for the residual. If omitted, not used.€Ù°ƒex_tolofloat, optionalÙ¹‚Ù§x±Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used.€Ù°ƒfx_rtolofloat, optionalÙ¹‚Ù§x1Relative minimum step size. If omitted, not used.€Ù°ƒhtol_normx$function(vector) -> scalar, optionalÙ¹‚Ù§x>Norm to use in convergence check. Default is the maximum norm.€Ù°ƒkline_searchx-{None, 'armijo' (default), 'wolfe'}, optionalÙ¹‚Ù§x‰Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to 'armijo'.€Ù°ƒhcallbackrfunction, optionalÙ¹‚‡Ù§x?Optional callback function. It is called on every iteration as Ù¡ncallback(x, f)Ù§g where Ù£ƒaxööÙ§x is the current solution and Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ§x the corresponding residual.€öfRaisesÙ¯‚Ù°ƒ`mNoConvergenceÙ¹‚Ù§xWhen a solution was not found.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcsolgndarrayÙ¹‚ƒÙ§x#An array (of similar array type as Ù£ƒbx0ööÙ§x ) containing the final solution.€ögSummaryÙ¯‚Ù¹‚Ù§xKFind a root of a function, using Krylov approximation for inverse Jacobian.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotesjReferenceshExamplest/dev/papyri/<string>ör<class 'function'>x2scipy.signal._filter_design.optimize.newton_krylovÙ¯‚„Ù¹‚Ù§x>The following functions define a system of nonlinear equations€Ù´ƒ˜9Ù±‚akcdefÙ±‚`a Ù±‚bnfcfunÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a
Ù±‚`l            Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚bmia2Ù±‚`a]`fexecedÙ¹‚Ù§x&A solution can be obtained as follows.€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚aoa.Ù±‚`Ù¢„mnewton_krylovÙ „escipye1.8.0fmodulex$scipy.optimize._nonlin.newton_krylovfmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„csolÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxarray([0.66731771, 0.66536458])fexecedöƒÙ¼ƒÙ»ƒdrootööÙ¹‚ƒÙ§xEInterface to root finding algorithms for multivariate functions. See Ù¡pmethod=='krylov'Ù§o in particular.€öÙ¼ƒÙ»ƒxscipy.sparse.linalg.gmresöö€öÙ¼ƒÙ»ƒxscipy.sparse.linalg.lgmresöö€öe1.8.0Ù«xònewton_krylov(F, xin, iter=None, rdiff=None, method='lgmres', inner_maxiter=20, inner_M=None, outer_k=10, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)öx$scipy.optimize._nonlin.newton_krylov€
Ùª­jAttributesÙ¯‚‰Ù°ƒancintÙ¹‚Ù§tNumber of equations.€Ù°ƒfstatusfstringÙ¹‚Ù§x@Current status of the solver: 'running', 'finished' or 'failed'.€Ù°ƒgt_boundefloatÙ¹‚Ù§nBoundary time.€Ù°ƒidirectionefloatÙ¹‚Ù§x Integration direction: +1 or -1.€Ù°ƒatefloatÙ¹‚Ù§mCurrent time.€Ù°ƒaygndarrayÙ¹‚Ù§nCurrent state.€Ù°ƒet_oldefloatÙ¹‚Ù§x.Previous time. None if no steps were made yet.€Ù°ƒdnfevcintÙ¹‚Ù§x-Number of evaluations of the right-hand side.€Ù°ƒdnjevcintÙ¹‚Ù§x&Number of evaluations of the Jacobian.€öpExtended SummaryÙ¯‚Ù¹‚Ù§x´This is a wrapper to the Fortran solver from ODEPACK . It switches automatically between the nonstiff Adams method and the stiff BDF method. The method was originally detailed in .€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒcfunhcallableÙ¹‚Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(t, y)Ù§g. Here Ù¡atÙ§x8 is a scalar, and there are two options for the ndarray Ù¡ayÙ§x&: It can either have shape (n,); then Ù¡cfunÙ§xV must return array_like with shape (n,). Alternatively it can have shape (n, k); then Ù¡cfunÙ§xa must return an array_like with shape (n, k), i.e. each column corresponds to a single column in Ù¡ayÙ§x6. The choice between the two options is determined by Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§x” argument (see below). The vectorized implementation allows a faster approximation of the Jacobian by finite differences (required for this solver).€Ù°ƒbt0efloatÙ¹‚Ù§mInitial time.€Ù°ƒby0varray_like, shape (n,)Ù¹‚Ù§nInitial state.€Ù°ƒgt_boundefloatÙ¹‚Ù§xnBoundary time - the integration won't continue beyond it. It also determines the direction of the integration.€Ù°ƒjfirst_stepwfloat or None, optionalÙ¹‚ƒÙ§xInitial step size. Default is Ù¡dNoneÙ§x. which means that the algorithm should choose.€Ù°ƒhmin_stepofloat, optionalÙ¹‚Ù§xrMinimum allowed step size. Default is 0.0, i.e., the step size is not bounded and determined solely by the solver.€Ù°ƒhmax_stepofloat, optionalÙ¹‚Ù§xuMaximum allowed step size. Default is np.inf, i.e., the step size is not bounded and determined solely by the solver.€Ù°ƒjrtol, atolxfloat and array_like, optionalÙ¹‚˜#Ù§xWRelative and absolute tolerances. The solver keeps the local error estimates less than Ù¡tatol + rtol * abs(y)Ù§g. Here Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x@ controls a relative accuracy (number of correct digits), while Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xW controls absolute accuracy (number of correct decimal places). To achieve the desired Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§f, set Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x= to be lower than the lowest value that can be expected from Ù¡mrtol * abs(y)Ù§i so that Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x# dominates the allowable error. If Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§p is larger than Ù¡mrtol * abs(y)Ù§xT the number of correct digits is not guaranteed. Conversely, to achieve the desired Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e set Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§k such that Ù¡mrtol * abs(y)Ù§v is always lower than Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xT. If components of y have different scales, it might be beneficial to set different Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xK values for different components by passing array_like with shape (n,) for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x. Default values are 1e-3 for Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§n and 1e-6 for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§a.€Ù°ƒcjacxNone or callable, optionalÙ¹‚‡Ù§xEJacobian matrix of the right-hand side of the system with respect to Ù¡ayÙ§xJ. The Jacobian matrix has shape (n, n) and its element (i, j) is equal to Ù¡md f_i / d y_jÙ§x!. The function will be called as Ù¡ijac(t, y)Ù§x». If None (default), the Jacobian will be approximated by finite differences. It is generally recommended to provide the Jacobian rather than relying on a finite-difference approximation.€Ù°ƒllband, ubandkint or NoneÙ¹‚Ù§x9Parameters defining the bandwidth of the Jacobian, i.e., Ù¡x3jac[i, j] != 0 only for i - lband <= j <= i + ubandÙ§xt. Setting these requires your jac routine to return the Jacobian in the packed format: the returned array must have Ù¡anÙ§m columns and Ù¡quband + lband + 1Ù§x< rows in which Jacobian diagonals are written. Specifically Ù¡x)jac_packed[uband + i - j , j] = jac[i, j]Ù§x. The same format is used in Ù¢„xscipy.linalg.solve_bandedÙ „escipya*capix scipy.linalg._basic.solve_bandedfmoduleõÙ§xE (check for an illustration). These parameters can be also used with Ù¡hjac=NoneÙ§xK to reduce the number of Jacobian elements estimated by finite differences.€Ù°ƒjvectorizednbool, optionalÙ¹‚ƒÙ§hWhether Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x| is implemented in a vectorized fashion. A vectorized implementation offers no advantages for this solver. Default is False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xBAdams/BDF method with automatic stiffness detection and switching.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersjAttributesjReferencesx/scipy/integrate/_ivp/lsoda.pyn<class 'type'>x$scipy.signal._ltisys.integrate.LSODAÙ¯‚€ö€e1.8.0Ù«ööx scipy.integrate._ivp.lsoda.LSODA€
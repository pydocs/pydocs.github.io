Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xwSTFTs can be used as a way of quantifying the change of a nonstationary signal's frequency and phase content over time.€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚‡Ù§x@In order to enable inversion of an STFT via the inverse STFT in Ù¢„eistftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.istftfmoduleõÙ§x’, the signal windowing must obey the constraint of "Nonzero OverLap Add" (NOLA), and the input signal must have complete windowing coverage (i.e. Ù¡x3(x.shape[axis] - nperseg) %
(nperseg-noverlap) == 0Ù§g). The Ù¢„fpaddedÙ „ööelocalfpaddedelocalõÙ§x) argument may be used to accomplish this.€Ù¹‚‹Ù§xGiven a time-domain signal Ù¥dx[n]Ù§k, a window Ù¥dw[n]Ù§q, and a hop size Ù¥aHÙ§c = Ù£ƒrnperseg - noverlapööÙ§x#, the windowed frame at time index Ù¥atÙ§l is given by€Ù¤xx_ { t} [ n]=x [ n]w [ n - tH] Ù¹‚Ù§x9The overlap-add (OLA) reconstruction equation is given by€Ù¤xQx [ n]=\frac { \sum_ { t}x_ { t} [ n]w [ n - tH]} { \sum_ { t}w^ { 2} [ n - tH]} Ù¹‚‰Ù§xThe NOLA constraint ensures that every normalization term that appears in the denomimator of the OLA reconstruction equation is nonzero. Whether a choice of Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§b, Ù¢„gnpersegÙ „ööelocalgnpersegelocalõÙ§f, and Ù¢„hnoverlapÙ „ööelocalhnoverlapelocalõÙ§x, satisfy this constraint can be tested with Ù¢„jcheck_NOLAÙ „escipye1.8.0fmodulex$scipy.signal._spectral_py.check_NOLAfmoduleõÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.19.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒaxjarray_likeÙ¹‚Ù§x!Time series of measurement values€Ù°ƒbfsofloat, optionalÙ¹‚ƒÙ§xSampling frequency of the Ù¢„axÙ „ööelocalaxelocalõÙ§x time series. Defaults to 1.0.€Ù°ƒfwindowx$str or tuple or array_like, optionalÙ¹‚‰Ù§xDesired window to use. If Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§x' is a string or tuple, it is passed to Ù¢„jget_windowÙ „escipye1.8.0fmodulex(scipy.signal.windows._windows.get_windowfmoduleõÙ§xC to generate the window values, which are DFT-even by default. See Ù¢„jget_windowÙ „escipye1.8.0fmodulex(scipy.signal.windows._windows.get_windowfmoduleõÙ§x3 for a list of windows and required parameters. If Ù¢„fwindowÙ „ööelocalfwindowelocalõÙ§xp is array_like it will be used directly as the window and its length must be nperseg. Defaults to a Hann window.€Ù°ƒgnpersegmint, optionalÙ¹‚Ù§x(Length of each segment. Defaults to 256.€Ù°ƒhnoverlapmint, optionalÙ¹‚‡Ù§x1Number of points to overlap between segments. If Ù¡dNoneÙ§b, Ù¡wnoverlap = nperseg // 2Ù§n. Defaults to Ù¡dNoneÙ§xD. When specified, the COLA constraint must be met (see Notes below).€Ù°ƒdnfftmint, optionalÙ¹‚‡Ù§x<Length of the FFT used, if a zero padded FFT is desired. If Ù¡dNoneÙ§t, the FFT length is Ù¢„gnpersegÙ „ööelocalgnpersegelocalõÙ§n. Defaults to Ù¡dNoneÙ§a.€Ù°ƒgdetrendx$str or function or `False`, optionalÙ¹‚Ù§x*Specifies how to detrend each segment. If Ù¢„gdetrendÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.detrendfmoduleõÙ§x" is a string, it is passed as the Ù£ƒdtypeööÙ§q argument to the Ù¢„gdetrendÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.detrendfmoduleõÙ§xW function. If it is a function, it takes a segment and returns a detrended segment. If Ù¢„gdetrendÙ „escipye1.8.0fmodulex!scipy.signal._signaltools.detrendfmoduleõÙ§d is Ù¡eFalseÙ§x%, no detrending is done. Defaults to Ù¡eFalseÙ§a.€Ù°ƒoreturn_onesidednbool, optionalÙ¹‚‡Ù§cIf Ù¡dTrueÙ§x0, return a one-sided spectrum for real data. If Ù¡eFalseÙ§x* return a two-sided spectrum. Defaults to Ù¡dTrueÙ§x@, but for complex data, a two-sided spectrum is always returned.€Ù°ƒhboundaryustr or None, optionalÙ¹‚‰Ù§y6Specifies whether the input signal is extended at both ends, and how to generate the new values, in order to center the first windowed segment on the first input point. This has the benefit of enabling reconstruction of the first input point when the employed window function starts at zero. Valid options are Ù¡x*['even', 'odd', 'constant', 'zeros', None]Ù§x8. Defaults to 'zeros', for zero padding extension. I.e. Ù¡l[1, 2, 3, 4]Ù§p is extended to Ù¡r[0, 1, 2, 3, 4, 0]Ù§e for Ù¡inperseg=3Ù§a.€Ù°ƒfpaddednbool, optionalÙ¹‚‹Ù§xÈSpecifies whether the input signal is zero-padded at the end to make the signal fit exactly into an integer number of window segments, so that all of the signal is included in the output. Defaults to Ù¡dTrueÙ§x.. Padding occurs after boundary extension, if Ù¢„hboundaryÙ „escipye1.8.0fmodulex+scipy.signal._signaltools._bvalfromboundaryfmoduleõÙ§h is not Ù¡dNoneÙ§f, and Ù¢„fpaddedÙ „ööelocalfpaddedelocalõÙ§d is Ù¡dTrueÙ§t, as is the default.€Ù°ƒdaxismint, optionalÙ¹‚ƒÙ§xOAxis along which the STFT is computed; the default is over the last axis (i.e. Ù¡gaxis=-1Ù§b).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒafgndarrayÙ¹‚Ù§xArray of sample frequencies.€Ù°ƒatgndarrayÙ¹‚Ù§wArray of segment times.€Ù°ƒcZxxgndarrayÙ¹‚…Ù§hSTFT of Ù¢„axÙ „ööelocalaxelocalõÙ§x. By default, the last axis of Ù¢„cZxxÙ „ööelocalcZxxelocalõÙ§x" corresponds to the segment times.€ögSummaryÙ¯‚Ù¹‚Ù§x0Compute the Short Time Fourier Transform (STFT).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/signal/_spectral_py.pyr<class 'function'>qscipy.signal.stftÙ¯‚†Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¹‚Ù§x­Generate a test signal, a 2 Vrms sine wave whose frequency is slowly modulated around 3kHz, corrupted by white noise of exponentially decreasing magnitude sampled at 10 kHz.€Ù´ƒ˜Ù±‚`bfsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfd10e3Ù±‚`a
Ù±‚`aNÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfc1e5Ù±‚`a
Ù±‚`campÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`knoise_powerÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfd0.01Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`bfsÙ±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmia2Ù±‚`a
Ù±‚`dtimeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚`aNÙ±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bnbefloatÙ±‚`a(Ù±‚`bfsÙ±‚`a)Ù±‚`a
Ù±‚`cmodÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmic500Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmfd0.25Ù±‚aoa*Ù±‚`dtimeÙ±‚`a)Ù±‚`a
Ù±‚`gcarrierÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`campÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmfc3e3Ù±‚aoa*Ù±‚`dtimeÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`cmodÙ±‚`a)Ù±‚`a
Ù±‚`enoiseÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`fnormalÙ±‚`a(Ù±‚`escaleÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dsqrtÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`knoise_powerÙ±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚`dsizeÙ±‚aoa=Ù±‚`dtimeÙ±‚aoa.Ù±‚`eshapeÙ±‚`a)Ù±‚`a
Ù±‚`enoiseÙ±‚`a Ù±‚aoa*Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`dtimeÙ±‚aoa/Ù±‚bmia5Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`gcarrierÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`enoise`fexecedÙ¹‚Ù§x&Compute and plot the STFT's magnitude.€Ù´ƒ˜\Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`cZxxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dstftÙ „escipye1.8.0fmodulexscipy.signal._spectral_py.stftfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`bfsÙ±‚`a,Ù±‚`a Ù±‚`gnpersegÙ±‚aoa=Ù±‚bmid1000Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jpcolormeshÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.pcolormeshfmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„afÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„cZxxÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`dvminÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`dvmaxÙ±‚aoa=Ù±‚`campÙ±‚`a,Ù±‚`a Ù±‚`gshadingÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1ggouraudÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„etitleÙ „jmatplotlibe3.5.1fmodulewmatplotlib.pyplot.titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1nSTFT MagnitudeÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1nFrequency [Hz]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1jTime [sec]Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x(fig-scipy.signal._spectral_py.stft-0.pngö‡Ù¼ƒÙ»ƒjcheck_COLAx$scipy.signal._spectral_py.check_COLAõÙ¹‚Ù§x?Check whether the Constant OverLap Add (COLA) constraint is met€öÙ¼ƒÙ»ƒjcheck_NOLAx$scipy.signal._spectral_py.check_NOLAõÙ¹‚Ù§x>Check whether the Nonzero Overlap Add (NOLA) constraint is met€öÙ¼ƒÙ»ƒccsdxscipy.signal._spectral_py.csdõÙ¹‚Ù§x)Cross spectral density by Welch's method.€öÙ¼ƒÙ»ƒeistftxscipy.signal._spectral_py.istftõÙ¹‚Ù§x$Inverse Short Time Fourier Transform€öÙ¼ƒÙ»ƒklombscarglex%scipy.signal._spectral_py.lombscargleõÙ¹‚Ù§x2Lomb-Scargle periodogram for unevenly sampled data€öÙ¼ƒÙ»ƒkspectrogramx%scipy.signal._spectral_py.spectrogramõÙ¹‚Ù§xSpectrogram by Welch's method.€öÙ¼ƒÙ»ƒewelchxscipy.signal._spectral_py.welchõÙ¹‚Ù§x)Power spectral density by Welch's method.€öe1.8.0Ù«x’stft(x, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, detrend=False, return_onesided=True, boundary='zeros', padded=True, axis=-1)öxscipy.signal._spectral_py.stft€
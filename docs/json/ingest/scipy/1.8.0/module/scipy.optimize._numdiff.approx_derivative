Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x©If a function maps from R^n to R^m, its derivatives form m-by-n matrix called the Jacobian, where an element (i, j) is a partial derivative of f[i] with respect to x[j].€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚‘Ù§cIf Ù¢„hrel_stepÙ „ööelocalhrel_stepelocalõÙ§x! is not provided, it assigned as Ù¡jEPS**(1/s)Ù§xD, where EPS is determined from the smallest floating point dtype of Ù¢„bx0Ù „ööelocalbx0elocalõÙ§d or Ù£ƒgfun(x0)ööÙ§b, Ù¡vnp.finfo(x0.dtype).epsÙ§xŞ, s=2 for '2-point' method and s=3 for '3-point' method. Such relative step approximately minimizes a sum of truncation and round-off errors, see . Relative steps are used by default. However, absolute steps are used when Ù¡tabs_step is not NoneÙ§xf. If any of the absolute or relative steps produces an indistinguishable difference from the original Ù¢„bx0Ù „ööelocalbx0elocalõÙ§b, Ù¡s(x0 + dx) - x0 == 0Ù§xF, then a automatic step size is substituted for that particular entry.€Ù¹‚Ù§yA finite difference scheme for '3-point' method is selected automatically. The well-known central difference scheme is used for points sufficiently far from the boundary, and 3-point forward or backward scheme is used for points near the boundary. Both schemes have the second-order accuracy in terms of Taylor expansion. Refer to  for the formulas of 3-point forward and backward difference schemes.€Ù¹‚Ù§yƒFor dense differencing when m=1 Jacobian is returned with a shape (n,), on the other hand when n=1 Jacobian is returned with a shape (m, 1). Our motivation is the following: a) It handles a case of gradient computation (m=1) in a conventional way. b) It clearly separates these two different cases. b) In all cases np.atleast_2d can be called to get 2-D Jacobian with correct dimensions.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŠÙ°ƒcfunhcallableÙ¹‚Ù§xÅFunction of which to estimate the derivatives. The argument x passed to this function is ndarray of shape (n,) (never a scalar even if n=1). It must return 1-D array_like of shape (m,) or a scalar.€Ù°ƒbx0x!array_like of shape (n,) or floatÙ¹‚Ù§xSPoint at which to estimate the derivatives. Float will be converted to a 1-D array.€Ù°ƒfmethodx&{'3-point', '2-point', 'cs'}, optionalÙÁÙÅ‚Ù¹‚Ù§x Finite difference method to use:€ÙÈƒÙÁÙÅ‚Ù¹‚Ù§x<'2-point' - use the first order accuracy forward or backward€Ù¹‚Ù§kdifference.€ÙÁÙÅ‚Ù¹‚Ù§x='3-point' - use central difference in interior points and the€Ù¹‚Ù§xYsecond order accuracy forward or backward difference                   near the boundary.€ÙÁÙÅ‚Ù¹‚Ù§x@'cs' - use a complex-step finite difference scheme. This assumes€Ù¹‚Ù§xšthat the user function is real-valued and can be              analytically continued to the complex plane. Otherwise,              produces bogus results.€Ù°ƒhrel_stepxNone or array_like, optionalÙ¹‚‹Ù§xSRelative step size to use. If None (default) the absolute step size is computed as Ù¡x)h = rel_step * sign(x0) * max(1, abs(x0))Ù§g, with Ù¢„hrel_stepÙ „ööelocalhrel_stepelocalõÙ§x4 being selected automatically, see Notes. Otherwise Ù¡x!h = rel_step * sign(x0) * abs(x0)Ù§f. For Ù¡pmethod='3-point'Ù§m the sign of Ù£ƒahööÙ§xR is ignored. The calculated step size is possibly adjusted to fit into the bounds.€Ù°ƒhabs_steptarray_like, optionalÙ¹‚‡Ù§xIAbsolute step size to use, possibly adjusted to fit into the bounds. For Ù¡pmethod='3-point'Ù§m the sign of Ù¢„habs_stepÙ „ööelocalhabs_stepelocalõÙ§x9 is ignored. By default relative steps are used, only if Ù¡tabs_step is not NoneÙ§x are absolute steps used.€Ù°ƒbf0xNone or array_like, optionalÙ¹‚…Ù§x)If not None it is assumed to be equal to Ù¡gfun(x0)Ù§s, in this case the Ù¡gfun(x0)Ù§x  is not called. Default is None.€Ù°ƒfboundsxtuple of array_like, optionalÙ¹‚…Ù§xjLower and upper bounds on independent variables. Defaults to no bounds. Each bound must match the size of Ù¢„bx0Ù „ööelocalbx0elocalõÙ§x¬ or be a scalar, in the latter case the bound will be the same for all variables. Use it to limit the range of function evaluation. Bounds checking is not implemented when Ù¢„ras_linear_operatorÙ „ööelocalras_linear_operatorelocalõÙ§i is True.€Ù°ƒhsparsityx4{None, array_like, sparse matrix, 2-tuple}, optionalÙ¹‚Ù§yDefines a sparsity structure of the Jacobian matrix. If the Jacobian matrix is known to have only few non-zero elements in each row, then it's possible to estimate its several columns by a single function evaluation . To perform such economic computations two ingredients are required:€Ù°ƒras_linear_operatornbool, optionalÙ¹‚‹Ù§x"When True the function returns an Ù¢„x"scipy.sparse.linalg.LinearOperatorÙ „escipya*capix-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ§xE. Otherwise it returns a dense array or a sparse matrix depending on Ù¢„hsparsityÙ „ööelocalhsparsityelocalõÙ§x=. The linear operator provides an efficient way of computing Ù¡hJ.dot(p)Ù§p for any vector Ù¡apÙ§xb of shape (n,), but does not allow direct access to individual elements of the matrix. By default Ù¢„ras_linear_operatorÙ „ööelocalras_linear_operatorelocalõÙ§j is False.€Ù°ƒlargs, kwargsxtuple and dict, optionalÙ¹‚…Ù§xAdditional arguments passed to Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x2. Both empty by default. The calling signature is Ù¡wfun(x, *args, **kwargs)Ù§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaJx({ndarray, sparse matrix, LinearOperator}Ù¹‚‰Ù§x;Finite difference approximation of the Jacobian matrix. If Ù¢„ras_linear_operatorÙ „ööelocalras_linear_operatorelocalõÙ§xz is True returns a LinearOperator with shape (m, n). Otherwise it returns a dense array or sparse matrix depending on how Ù¢„hsparsityÙ „ööelocalhsparsityelocalõÙ§p is defined. If Ù¢„hsparsityÙ „ööelocalhsparsityelocalõÙ§x: is None then a ndarray with shape (m, n) is returned. If Ù¢„hsparsityÙ „ööelocalhsparsityelocalõÙ§xÔ is not None returns a csr_matrix with shape (m, n). For sparse matrices and linear operators it is always returned as a 2-D structure, for ndarrays, if m=1 it is returned as a 1-D gradient array with shape (n,).€ögSummaryÙ¯‚Ù¹‚Ù§xWCompute finite difference approximation of the derivatives of a vector-valued function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/optimize/_numdiff.pyr<class 'function'>xPscipy.signal._filter_design.optimize._differentiable_functions.approx_derivativeÙ¯‚‡Ù´ƒ‘Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„qapprox_derivativeÙ „escipye1.8.0fmodulex)scipy.optimize._numdiff.approx_derivativefmoduleõc>>>qexception_in_execÙ´ƒ˜CÙ±‚akcdefÙ±‚`a Ù±‚bnfÙ¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bc1Ù „escipye1.8.0fmodulex(scipy.signal._filter_design._arc_jac_sc1fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bc2Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„bc1Ù „escipye1.8.0fmodulex(scipy.signal._filter_design._arc_jac_sc1fmoduleõÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`u                     Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`bc2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a]Ù±‚`a)c...fexecedÙ´ƒ˜'Ù±‚`Ù¢„bx0Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„qapprox_derivativeÙ „escipye1.8.0fmodulex)scipy.optimize._numdiff.approx_derivativefmoduleõÙ±‚`a(Ù±‚`Ù¢„afÙ „escipye1.8.0fmodulex8scipy.optimize._bglu_dense._consider_refactor.<locals>.ffmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bx0Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dargsÙ±‚aoa=Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)x&array([[ 1.,  0.],
       [-1.,  0.]])fexecedÙ¹‚Ù§x†Bounds can be used to limit the region of function evaluation. In the example below we compute left and right derivative at point 1.0.€Ù´ƒ˜Ù±‚akcdefÙ±‚`a Ù±‚bnfagÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`axÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚akbifÙ±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`a Ù±‚akdelseÙ±‚`a Ù±‚`axc...fexecedÙ´ƒ˜Ù±‚`bx0Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfc1.0Ù±‚`a
Ù±‚`Ù¢„qapprox_derivativeÙ „escipye1.8.0fmodulex)scipy.optimize._numdiff.approx_derivativefmoduleõÙ±‚`a(Ù±‚`agÙ±‚`a,Ù±‚`a Ù±‚`bx0Ù±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚aoa=Ù±‚`a(Ù±‚aoa-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cinfÙ±‚`a,Ù±‚`a Ù±‚bmfc1.0Ù±‚`a)Ù±‚`a)larray([ 1.])fexecedÙ´ƒ“Ù±‚`Ù¢„qapprox_derivativeÙ „escipye1.8.0fmodulex)scipy.optimize._numdiff.approx_derivativefmoduleõÙ±‚`a(Ù±‚`agÙ±‚`a,Ù±‚`a Ù±‚`bx0Ù±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚aoa=Ù±‚`a(Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cinfÙ±‚`a)Ù±‚`a)larray([ 2.])fexecedöÙ¼ƒÙ»ƒpcheck_derivativex(scipy.optimize._numdiff.check_derivativeõÙ¹‚Ù§x6Check correctness of a function computing derivatives.€öe1.8.0Ù«x¤approx_derivative(fun, x0, method='3-point', rel_step=None, abs_step=None, f0=None, bounds=(-inf, inf), sparsity=None, as_linear_operator=False, args=(), kwargs={})öx)scipy.optimize._numdiff.approx_derivative€
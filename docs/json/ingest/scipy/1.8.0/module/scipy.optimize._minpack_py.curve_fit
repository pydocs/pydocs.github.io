Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§hAssumes Ù¡xydata = f(xdata, *params) + epsÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚…Ù§eWith Ù¡kmethod='lm'Ù§x?, the algorithm uses the Levenberg-Marquardt algorithm through Ù¢„gleastsqÙ „escipye1.8.0fmodulex"scipy.optimize._minpack_py.leastsqfmoduleõÙ§xE. Note that this algorithm can only deal with unconstrained problems.€Ù¹‚ƒÙ§xXBox constraints can be handled by methods 'trf' and 'dogbox'. Refer to the docstring of Ù¢„mleast_squaresÙ „escipye1.8.0fmodulex/scipy.optimize._lsq.least_squares.least_squaresfmoduleõÙ§v for more information.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒafhcallableÙ¹‚Ù§x•The model function, f(x, ...). It must take the independent variable as the first argument and the parameters to fit as separate remaining arguments.€Ù°ƒexdatatarray_like or objectÙ¹‚Ù§xµThe independent variable where the data is measured. Should usually be an M-length sequence or an (k,M)-shaped array for functions with k predictors, but can actually be any object.€Ù°ƒeydatajarray_likeÙ¹‚ƒÙ§x1The dependent data, a length M array - nominally Ù¡mf(xdata, ...)Ù§a.€Ù°ƒbp0tarray_like, optionalÙ¹‚Ù§xÓInitial guess for the parameters (length N). If None, then the initial values will all be 1 (if the number of parameters for the function can be determined using introspection, otherwise a ValueError is raised).€Ù°ƒesigmax0None or M-length sequence or MxM array, optionalƒÙ¹‚‡Ù§xDetermines the uncertainty in Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ§x. If we define residuals as Ù¡xr = ydata - f(xdata, *popt)Ù§x, then the interpretation of Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§x% depends on its number of dimensions:€Ù·‰x?- A 1-D `sigma` should contain values of standard deviations ofx<  errors in `ydata`. In this case, the optimized function isx$  ``chisq = sum((r / sigma) ** 2)``.`x7- A 2-D `sigma` should contain the covariance matrix ofx<  errors in `ydata`. In this case, the optimized function isx#  ``chisq = r.T @ inv(sigma) @ r``.`x  .. versionadded:: 0.19Ù¹‚ƒÙ§x$None (default) is equivalent of 1-D Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§r filled with ones.€Ù°ƒnabsolute_sigmanbool, optional‚Ù¹‚…Ù§iIf True, Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§xE is used in an absolute sense and the estimated parameter covariance Ù¢„dpcovÙ „ööelocaldpcovelocalõÙ§x  reflects these absolute values.€Ù¹‚’Ù§x8If False (default), only the relative magnitudes of the Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§x9 values matter. The returned parameter covariance matrix Ù¢„dpcovÙ „ööelocaldpcovelocalõÙ§u is based on scaling Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§xJ by a constant factor. This constant is set by demanding that the reduced Ù£ƒechisqööÙ§x for the optimal parameters Ù¢„dpoptÙ „ööelocaldpoptelocalõÙ§p when using the Ù¨Ù§fscaledÙ§a Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§x equals unity. In other words, Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§xj is scaled to match the sample variance of the residuals after the fit. Default is False. Mathematically, Ù¡xJpcov(absolute_sigma=False) = pcov(absolute_sigma=True) * chisq(popt)/(M-N)€Ù°ƒlcheck_finitenbool, optionalÙ¹‚Ù§xãIf True, check that the input arrays do not contain nans of infs, and raise a ValueError if they do. Setting this parameter to False may silently produce nonsensical results if the input arrays do contain nans. Default is True.€Ù°ƒfboundsx2-tuple of array_like, optional‚Ù¹‚ƒÙ§xøLower and upper bounds on parameters. Defaults to no bounds. Each element of the tuple must be either an array with the length equal to the number of parameters, or a scalar (in which case the bound is taken to be the same for all parameters). Use Ù¡fnp.infÙ§xF with an appropriate sign to disable bounds on all or some parameters.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.17 €Ù°ƒfmethodx!{'lm', 'trf', 'dogbox'}, optional‚Ù¹‚…Ù§x$Method to use for optimization. See Ù¢„mleast_squaresÙ „escipye1.8.0fmodulex/scipy.optimize._lsq.least_squares.least_squaresfmoduleõÙ§xK for more details. Default is 'lm' for unconstrained problems and 'trf' if Ù¢„fboundsÙ „ööelocalfboundselocalõÙ§x“ are provided. The method 'lm' won't work when the number of observations is less than the number of variables, use 'trf' or 'dogbox' in this case.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.17 €Ù°ƒcjacx"callable, string or None, optional‚Ù¹‚‡Ù§xFunction with signature Ù¡kjac(x, ...)Ù§x which computes the Jacobian matrix of the model function with respect to parameters as a dense array_like structure. It will be scaled according to provided Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§x¦. If None (default), the Jacobian will be estimated numerically. String keywords for 'trf' and 'dogbox' methods can be used to select a finite difference scheme, see Ù¢„mleast_squaresÙ „escipye1.8.0fmodulex/scipy.optimize._lsq.least_squares.least_squaresfmoduleõÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.18 €Ù°ƒfkwargs`Ù¹‚‡Ù§xKeyword arguments passed to Ù¢„gleastsqÙ „escipye1.8.0fmodulex"scipy.optimize._minpack_py.leastsqfmoduleõÙ§e for Ù¡kmethod='lm'Ù§d or Ù¢„mleast_squaresÙ „escipye1.8.0fmodulex/scipy.optimize._lsq.least_squares.least_squaresfmoduleõÙ§k otherwise.€öfRaisesÙ¯‚ƒÙ°ƒ`jValueErrorÙ¹‚…Ù§jif either Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ§d or Ù¢„exdataÙ „ööelocalexdataelocalõÙ§x3 contain NaNs, or if incompatible options are used.€Ù°ƒ`lRuntimeErrorÙ¹‚Ù§x(if the least-squares minimization fails.€Ù°ƒ`oOptimizeWarningÙ¹‚Ù§x5if covariance of the parameters can not be estimated.€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒdpoptearrayÙ¹‚ƒÙ§xNOptimal values for the parameters so that the sum of the squared residuals of Ù¡wf(xdata, *popt) - ydataÙ§n is minimized.€Ù°ƒdpcovi2-D arrayƒÙ¹‚ƒÙ§xŸThe estimated covariance of popt. The diagonals provide the variance of the parameter estimate. To compute one standard deviation errors on the parameters use Ù¡xperr = np.sqrt(np.diag(pcov))Ù§a.€Ù¹‚…Ù§hHow the Ù¢„esigmaÙ „ööelocalesigmaelocalõÙ§x7 parameter affects the estimated covariance depends on Ù¢„nabsolute_sigmaÙ „ööelocalnabsolute_sigmaelocalõÙ§x argument, as described above.€Ù¹‚ƒÙ§xoIf the Jacobian matrix at the solution doesn't have a full rank, then 'lm' method returns a matrix filled with Ù¡fnp.infÙ§xq, on the other hand 'trf'  and 'dogbox' methods use Moore-Penrose pseudoinverse to compute the covariance matrix.€ögSummaryÙ¯‚Ù¹‚Ù§x;Use non-linear least squares to fit a function, f, to data.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/scipy/optimize/_minpack_py.pyr<class 'function'>x.scipy.signal._filter_design.optimize.curve_fitÙ¯‚ŒÙ´ƒ“Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„icurve_fitÙ „escipye1.8.0fmodulex$scipy.optimize._minpack_py.curve_fitfmoduleõ`fexecedÙ´ƒ˜'Ù±‚akcdefÙ±‚`a Ù±‚bnfdfuncÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`acÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`abÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`ac`fexecedÙ¹‚Ù§x*Define the data to be fit with some noise:€Ù´ƒ˜aÙ±‚`exdataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmib50Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`dfuncÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmfc1.3Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`gy_noiseÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfc0.2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`fnormalÙ±‚`a(Ù±‚`dsizeÙ±‚aoa=Ù±‚`exdataÙ±‚aoa.Ù±‚`dsizeÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`gy_noiseÙ±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1bb-Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„ddataÙ „escipye1.8.0fmoduleqscipy.sparse.datafmoduleõÙ±‚bs1a'Ù±‚`a)`fexecedÙ¹‚ƒÙ§x/Fit for the parameters a, b, c of the function Ù£ƒdfuncööÙ§a:€Ù´ƒ“Ù±‚`dpoptÙ±‚`a,Ù±‚`a Ù±‚`dpcovÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„icurve_fitÙ „escipye1.8.0fmodulex$scipy.optimize._minpack_py.curve_fitfmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„exdataÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx+array([2.56274217, 1.37268521, 0.47427475])fexecedÙ´ƒ˜)Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚`dfuncÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1br-Ù±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`i         Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gfit: a=Ù±‚bsie%5.3fÙ±‚bs1d, b=Ù±‚bsie%5.3fÙ±‚bs1d, c=Ù±‚bsie%5.3fÙ±‚bs1a'Ù±‚`a Ù±‚aoa%Ù±‚`a Ù±‚bnbÙ¢„etupleÙ „escipye1.8.0fmodulex$scipy.integrate._quadrature.tuplesetfmoduleõÙ±‚`a(Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)`fexecedÙ¹‚‡Ù§x,Constrain the optimization to the region of Ù¡k0 <= a <= 3Ù§b, Ù¡k0 <= b <= 1Ù§e and Ù¡m0 <= c <= 0.5Ù§a:€Ù´ƒ˜%Ù±‚`dpoptÙ±‚`a,Ù±‚`a Ù±‚`dpcovÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„icurve_fitÙ „escipye1.8.0fmodulex$scipy.optimize._minpack_py.curve_fitfmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„exdataÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„eydataÙ „escipye1.8.0fmodulex(scipy.sparse._sputils.is_pydata_spmatrixfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fboundsÙ±‚aoa=Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfb3.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx+array([2.43736712, 1.        , 0.34463856])fexecedÙ´ƒ˜)Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚`dfuncÙ±‚`a(Ù±‚`exdataÙ±‚`a,Ù±‚`a Ù±‚aoa*Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1cg--Ù±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`i         Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1gfit: a=Ù±‚bsie%5.3fÙ±‚bs1d, b=Ù±‚bsie%5.3fÙ±‚bs1d, c=Ù±‚bsie%5.3fÙ±‚bs1a'Ù±‚`a Ù±‚aoa%Ù±‚`a Ù±‚bnbÙ¢„etupleÙ „escipye1.8.0fmodulex$scipy.integrate._quadrature.tuplesetfmoduleõÙ±‚`a(Ù±‚`Ù¢„dpoptÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)`fexecedÙ´ƒ˜Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1ayÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x.fig-scipy.optimize._minpack_py.curve_fit-0.pngö‚Ù¼ƒÙ»ƒmleast_squaresx0scipy.optimize._lsq.least_squares.prepare_boundsõÙ¹‚Ù§x3Minimize the sum of squares of nonlinear functions.€öÙ¼ƒÙ»ƒvscipy.stats.linregressööÙ¹‚Ù§xICalculate a linear least squares regression for two sets of measurements.€öe1.8.0Ù«xcurve_fit(f, xdata, ydata, p0=None, sigma=None, absolute_sigma=False, check_finite=True, bounds=(-inf, inf), method=None, jac=None, **kwargs)öx$scipy.optimize._minpack_py.curve_fit€
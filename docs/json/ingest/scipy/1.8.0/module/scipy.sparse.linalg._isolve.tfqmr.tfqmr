Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚ƒÙ§ymThe Transpose-Free QMR algorithm is derived from the CGS algorithm. However, unlike CGS, the convergence curves for the TFQMR method is smoothed by computing a quasi minimization of the residual norm. The implementation supports left preconditioner, and the "residual norm" to compute in convergence criterion is actually an upper bound on the actual residual norm Ù¡k||b - Axk||Ù§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaAx({sparse matrix, ndarray, LinearOperator}Ù¹‚‡Ù§xGThe real or complex N-by-N matrix of the linear system. Alternatively, Ù¢„aAÙ „ööelocalaAelocalõÙ§x, can be a linear operator which can produce Ù¡bAxÙ§n using, e.g., Ù¢„x"scipy.sparse.linalg.LinearOperatorÙ „escipya*capix-scipy.sparse.linalg._interface.LinearOperatorfmoduleõÙ§a.€Ù°ƒabi{ndarray}Ù¹‚Ù§x>Right hand side of the linear system. Has shape (N,) or (N,1).€Ù°ƒbx0i{ndarray}Ù¹‚Ù§x Starting guess for the solution.€Ù°ƒitol, atolofloat, optional‚Ù¹‚‰Ù§xTolerances for convergence, Ù¡x,norm(residual) <= max(tol*norm(b-Ax0), atol)Ù§r. The default for Ù¢„ctolÙ „ööelocalctolelocalõÙ§x is 1.0e-5. The default for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§d is Ù¡qtol * norm(b-Ax0)Ù§a.€ÙÆƒgwarning`Ù¹‚Ù§xwThe default value for `atol` will be changed in a future release. For future compatibility, specify `atol` explicitly. €Ù°ƒgmaxitermint, optionalÙ¹‚…Ù§x‰Maximum number of iterations.  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved. Default is Ù¡vmin(10000, ndofs * 10)Ù§h, where Ù¡rndofs = A.shape[0]Ù§a.€Ù°ƒaMx({sparse matrix, ndarray, LinearOperator}Ù¹‚Ù§y3Inverse of the preconditioner of A.  M should approximate the inverse of A and be easy to solve for (see Notes).  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance.  By default, no preconditioner is used.€Ù°ƒhcallbackrfunction, optionalÙ¹‚…Ù§xFUser-supplied function to call after each iteration.  It is called as Ù£ƒlcallback(xk)ööÙ§h, where Ù£ƒbxkööÙ§x  is the current solution vector.€Ù°ƒdshownbool, optionalÙ¹‚‡Ù§hSpecify Ù¡kshow = TrueÙ§x to show the convergence, Ù¡lshow = FalseÙ§x7 is to close the output of the convergence. Default is Ù¡eFalseÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaxgndarrayÙ¹‚Ù§wThe converged solution.€Ù°ƒdinfocintÙ¹‚Ù§x!Provides convergence information:€ögSummaryÙ¯‚Ù¹‚ƒÙ§x=Use Transpose-Free Quasi-Minimal Residual iteration to solve Ù¡fAx = bÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNotesjReferenceshExamplesx%/scipy/sparse/linalg/_isolve/tfqmr.pyr<class 'function'>xOscipy.signal._filter_design.optimize._differentiable_functions.sps.linalg.tfqmrÙ¯‚‚Ù´ƒ˜sÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsparseÙ „escipye1.8.0fmodulelscipy.sparsefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„etfqmrÙ „escipye1.8.0fmodulex'scipy.sparse.linalg._isolve.tfqmr.tfqmrfmoduleõÙ±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jcsc_matrixÙ „escipye1.8.0fmodulexscipy.sparse._csc.csc_matrixfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`edtypeÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`hexitCodeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„etfqmrÙ „escipye1.8.0fmodulex'scipy.sparse.linalg._isolve.tfqmr.tfqmrfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`hexitCodeÙ±‚`a)Ù±‚`l            Ù±‚bc1x$# 0 indicates successful convergencea0fexecedÙ´ƒÙ±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aAÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedö€e1.8.0Ù«x[tfqmr(A, b, x0=None, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False)öx'scipy.sparse.linalg._isolve.tfqmr.tfqmr€
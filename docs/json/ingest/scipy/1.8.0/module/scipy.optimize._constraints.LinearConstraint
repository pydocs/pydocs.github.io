Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x6The constraint has the general inequality form::      €ÙÀtlb <= A.dot(x) <= ubÙ¹‚Ù§xpHere the vector of independent variables x is passed as ndarray of shape (n,) and the matrix A has shape (m, n).€Ù¹‚Ù§x~It is possible to use equal bounds to represent an equality constraint or infinite bounds to represent a one-sided constraint.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaAx){array_like, sparse matrix}, shape (m, n)Ù¹‚Ù§xMatrix defining the constraint.€Ù°ƒflb, ubjarray_likeÙ¹‚‹Ù§x´Lower and upper bounds on the constraint. Each array must have the shape (m,) or be a scalar, in the latter case a bound will be the same for all components of the constraint. Use Ù¡fnp.infÙ§xO with an appropriate sign to specify a one-sided constraint. Set components of Ù¢„blbÙ „ööelocalblbelocalõÙ§e and Ù¢„bubÙ „ööelocalbubelocalõÙ§x¦ equal to represent an equality constraint. Note that you can mix constraints of different types: interval, one-sided or equality, by setting different components of Ù¢„blbÙ „ööelocalblbelocalõÙ§e and Ù¢„bubÙ „ööelocalbubelocalõÙ§o as  necessary.€Ù°ƒmkeep_feasiblexarray_like of bool, optionalÙ¹‚Ù§x¸Whether to keep the constraint components feasible throughout iterations. A single value set this property for all components. Default is False. Has no effect for equality constraints.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x#Linear constraint on the variables.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryjParametersx/scipy/optimize/_constraints.pywn<class 'type'>x5scipy.signal._filter_design.optimize.LinearConstraintÙ¯‚€ö€e1.8.0Ù«ööx,scipy.optimize._constraints.LinearConstraint€
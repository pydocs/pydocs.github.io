Ùª­jAttributesÙ¯‚‹Ù°ƒancintÙ¹‚Ù§tNumber of equations.€Ù°ƒfstatusfstringÙ¹‚Ù§x@Current status of the solver: 'running', 'finished' or 'failed'.€Ù°ƒgt_boundefloatÙ¹‚Ù§nBoundary time.€Ù°ƒidirectionefloatÙ¹‚Ù§x Integration direction: +1 or -1.€Ù°ƒatefloatÙ¹‚Ù§mCurrent time.€Ù°ƒaygndarrayÙ¹‚Ù§nCurrent state.€Ù°ƒet_oldefloatÙ¹‚Ù§x.Previous time. None if no steps were made yet.€Ù°ƒistep_sizeefloatÙ¹‚Ù§xASize of the last successful step. None if no steps were made yet.€Ù°ƒdnfevcintÙ¹‚Ù§x'Number of the system's rhs evaluations.€Ù°ƒdnjevcintÙ¹‚Ù§x#Number of the Jacobian evaluations.€Ù°ƒcnlucintÙ¹‚Ù§xNumber of LU decompositions.€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§xEIn order to implement a new solver you need to follow the guidelines:€Ù·˜!xC1. A constructor must accept parameters presented in the base classxG   (listed below) along with any other parameters specific to a solver.x;2. A constructor must accept arbitrary extraneous argumentsxA   ``**extraneous``, but warn that these arguments are irrelevantx=   using `common.warn_extraneous` function. Do not pass thesex   arguments to the base class.xD3. A solver must implement a private method `_step_impl(self)` whichx=   propagates a solver one step further. It must return tuplexD   ``(success, message)``, where ``success`` is a boolean indicatingx=   whether a step was successful, and ``message`` is a stringx?   containing description of a failure if a step failed or Nonem   otherwise.xG4. A solver must implement a private method `_dense_output_impl(self)`,xD   which returns a `DenseOutput` object covering the last successfulh   step.xD5. A solver must have attributes listed below in Attributes section.xC   Note that ``t_old`` and ``step_size`` are updated automatically.xC6. Use `fun(self, t, y)` method for the system rhs evaluation, thisxB   way the number of function evaluations (`nfev`) will be trackedq   automatically.xF7. For convenience, a base class provides `fun_single(self, t, y)` andx9   `fun_vectorized(self, t, y)` for evaluating the rhs inxE   non-vectorized and vectorized fashions respectively (regardless ofxD   how `fun` from the constructor is implemented). These calls don'tt   increment `nfev`.xF8. If a solver uses a Jacobian matrix and LU decompositions, it shouldxF   track the number of Jacobian evaluations (`njev`) and the number ofx   LU decompositions (`nlu`).xC9. By convention, the function evaluations used to compute a finitexD   difference approximation of the Jacobian should not be counted inx/   `nfev`, thus use `fun_single(self, t, y)` orxB   `fun_vectorized(self, t, y)` when computing a finite differencex!   approximation of the Jacobian.ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒcfunhcallableÙ¹‚Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(t, y)Ù§g. Here Ù¡atÙ§x3 is a scalar and there are two options for ndarray Ù¡ayÙ§x&. It can either have shape (n,), then Ù¡cfunÙ§xb must return array_like with shape (n,). Or, alternatively, it can have shape (n, n_points), then Ù¡cfunÙ§x` must return array_like with shape (n, n_points) (each column corresponds to a single column in Ù¡ayÙ§x7). The choice between the two options is determined by Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§v argument (see below).€Ù°ƒbt0efloatÙ¹‚Ù§mInitial time.€Ù°ƒby0varray_like, shape (n,)Ù¹‚Ù§nInitial state.€Ù°ƒgt_boundefloatÙ¹‚Ù§xpBoundary time --- the integration won't continue beyond it. It also determines the direction of the integration.€Ù°ƒjvectorizeddboolÙ¹‚ƒÙ§hWhether Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x( is implemented in a vectorized fashion.€Ù°ƒosupport_complexnbool, optionalÙ¹‚Ù§x‹Whether integration in a complex domain should be supported. Generally determined by a derived solver class capabilities. Default is False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xBase class for ODE solvers.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersjAttributesx/scipy/integrate/_ivp/base.pyn<class 'type'>x(scipy.signal._ltisys.integrate.OdeSolverÙ¯‚€ö€e1.8.0Ù«ööx#scipy.integrate._ivp.base.OdeSolver€
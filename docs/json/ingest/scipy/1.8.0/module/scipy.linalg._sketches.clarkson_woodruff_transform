Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚‡Ù§vGiven an input_matrix Ù¡aAÙ§i of size Ù¡f(n, d)Ù§s, compute a matrix Ù¡bA'Ù§x! of size (sketch_size, d) so that€Ù¤x\|Ax\| \approx \|A ' x\| Ù¹‚Ù§xewith high probability via the Clarkson-Woodruff Transform, otherwise known as the CountSketch matrix.€ögMethodsÙ¯‚€öeNotesÙ¯‚ŠÙ¹‚Ù§uTo make the statement€Ù¤x\|Ax\| \approx \|A ' x\| Ù¹‚ƒÙ§xŠprecise, observe the following result which is adapted from the proof of Theorem 14 of  via Markov's Inequality. If we have a sketch size Ù¡msketch_size=kÙ§r which is at least€Ù¤x&k \geq \frac { 2} { \epsilon^2\delta} Ù¹‚ƒÙ§xThen for any fixed vector Ù¡axÙ§a,€Ù¤x"\|Ax\| = ( 1\pm\epsilon)\|A ' x\| Ù¹‚Ù§x*with probability at least one minus delta.€Ù¹‚‡Ù§x_This implementation takes advantage of sparsity: computing a sketch takes time proportional to Ù¡eA.nnzÙ§g. Data Ù¡aAÙ§m which is in Ù¡wscipy.sparse.csc_matrixÙ§x= format gives the quickest computation time for sparse input.€ÙÀyÀ>>> from scipy import linalg
>>> from scipy import sparse
>>> rng = np.random.default_rng()
>>> n_rows, n_columns, density, sketch_n_rows = 15000, 100, 0.01, 200
>>> A = sparse.rand(n_rows, n_columns, density=density, format='csc')
>>> B = sparse.rand(n_rows, n_columns, density=density, format='csr')
>>> C = sparse.rand(n_rows, n_columns, density=density, format='coo')
>>> D = rng.standard_normal((n_rows, n_columns))
>>> SA = linalg.clarkson_woodruff_transform(A, sketch_n_rows) # fastest
>>> SB = linalg.clarkson_woodruff_transform(B, sketch_n_rows) # fast
>>> SC = linalg.clarkson_woodruff_transform(C, sketch_n_rows) # slower
>>> SD = linalg.clarkson_woodruff_transform(D, sketch_n_rows) # slowestÙ¹‚Ù§xZThat said, this method does perform well on dense inputs, just slower on a relative scale.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒxinput_matrix: array_like`Ù¹‚ƒÙ§wInput matrix, of shape Ù¡f(n, d)Ù§a.€Ù°ƒpsketch_size: int`Ù¹‚Ù§xNumber of rows for the sketch.€Ù°ƒdseedx%{None, int, `numpy.random.Generator`,‚Ù·x%`numpy.random.RandomState`}, optionalÙ¹‚“Ù§cIf Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§m is None (or Ù£ƒinp.randomööÙ§g), the Ù¢„xnumpy.random.RandomStateÙ „enumpya*capixnumpy.random.mtrand.RandomStatefmoduleõÙ§w singleton is used. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§r is an int, a new Ù¡kRandomStateÙ§x instance is used, seeded with Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§e. If Ù¢„dseedÙ „escipye1.8.0fmodulexscipy.linalg.interpolative.seedfmoduleõÙ§n is already a Ù¡iGeneratorÙ§d or Ù¡kRandomStateÙ§x% instance then that instance is used.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒbA'jarray_likeÙ¹‚…Ù§xSketch of the input matrix Ù¡aAÙ§j, of size Ù¡p(sketch_size, d)Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§xAApplies a Clarkson-Woodruff Transform/sketch to the input matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshExamplesjReferencesx/scipy/linalg/_sketches.py:r<class 'function'>x?scipy.signal._lti_conversion.linalg.clarkson_woodruff_transformÙ¯‚‡Ù¹‚ƒÙ§xGiven a big dense matrix Ù¡aAÙ§a:€Ù´ƒ˜GÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚`fn_rowsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„in_columnsÙ „escipye1.8.0fmodulex4scipy.optimize._linprog_rs._select_singleton_columnsfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`msketch_n_rowsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmie15000Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a,Ù±‚`a Ù±‚bmic200Ù±‚`a
Ù±‚`Ù¢„crngÙ „escipye1.8.0fmodulexscipy._lib._util.rng_integersfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚aoa.Ù±‚`kdefault_rngÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „escipye1.8.0fmodulexscipy._lib._util.rng_integersfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`a(Ù±‚`fn_rowsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„in_columnsÙ „escipye1.8.0fmodulex4scipy.optimize._linprog_rs._select_singleton_columnsfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`fsketchÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„xclarkson_woodruff_transformÙ „escipye1.8.0fmodulex2scipy.linalg._sketches.clarkson_woodruff_transformfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`msketch_n_rowsÙ±‚`a)Ù±‚`a
Ù±‚`fsketchÙ±‚aoa.Ù±‚`eshapej(200, 100)fexecedÙ´ƒ˜Ù±‚`fnorm_AÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`dnormÙ±‚`a(Ù±‚`aAÙ±‚`a)Ù±‚`a
Ù±‚`knorm_sketchÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`dnormÙ±‚`a(Ù±‚`fsketchÙ±‚`a)`fexecedÙ¹‚…Ù§x)Now with high probability, the true norm Ù¡fnorm_AÙ§x is close to the sketched norm Ù¡knorm_sketchÙ§s in absolute value.€Ù¹‚ƒÙ§xPSimilarly, applying our sketch preserves the solution to a linear regression of Ù¥o\min \|Ax - b\|Ù§a.€Ù´ƒ˜©Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚`fn_rowsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„in_columnsÙ „escipye1.8.0fmodulex4scipy.optimize._linprog_rs._select_singleton_columnsfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`msketch_n_rowsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmie15000Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a,Ù±‚`a Ù±‚bmic200Ù±‚`a
Ù±‚`Ù¢„crngÙ „escipye1.8.0fmodulexscipy._lib._util.rng_integersfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚aoa.Ù±‚`kdefault_rngÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aAÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „escipye1.8.0fmodulexscipy._lib._util.rng_integersfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`a(Ù±‚`fn_rowsÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„in_columnsÙ „escipye1.8.0fmodulex4scipy.optimize._linprog_rs._select_singleton_columnsfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „escipye1.8.0fmodulexscipy._lib._util.rng_integersfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`fn_rowsÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚`ercondÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„bAbÙ „escipye1.8.0fmodulex%scipy.optimize._linprog_util._get_AbcfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fhstackÙ „escipye1.8.0fmodulexscipy.sparse._construct.hstackfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`aAÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚aoa.Ù±‚`greshapeÙ±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`cSAbÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„xclarkson_woodruff_transformÙ „escipye1.8.0fmodulex2scipy.linalg._sketches.clarkson_woodruff_transformfmoduleõÙ±‚`a(Ù±‚`Ù¢„bAbÙ „escipye1.8.0fmodulex%scipy.optimize._linprog_util._get_AbcfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`msketch_n_rowsÙ±‚`a)Ù±‚`a
Ù±‚`bSAÙ±‚`a,Ù±‚`a Ù±‚`bSbÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cSAbÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a:Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`cSAbÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a
Ù±‚`jx_sketchedÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚`a(Ù±‚`bSAÙ±‚`a,Ù±‚`a Ù±‚`bSbÙ±‚`a,Ù±‚`a Ù±‚`ercondÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)`fexecedÙ¹‚…Ù§x!As with the matrix norm example, Ù¡xnp.linalg.norm(A @ x - b)Ù§m is close to Ù¡x"np.linalg.norm(A @ x_sketched - b)Ù§w with high probability.€ö€e1.8.0Ù«xAclarkson_woodruff_transform(input_matrix, sketch_size, seed=None)öx2scipy.linalg._sketches.clarkson_woodruff_transform€
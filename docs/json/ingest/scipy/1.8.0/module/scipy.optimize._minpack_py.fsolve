Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§x:Return the roots of the (non-linear) equations defined by Ù¡kfunc(x) = 0Ù§x given a starting estimate.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚‚Ù¡ffsolveÙ§x: is a wrapper around MINPACK's hybrd and hybrj algorithms.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŒÙ°ƒdfuncxcallable ``f(x, *args)``Ù¹‚Ù§xfA function that takes at least one (possibly vector) argument, and returns a value of the same length.€Ù°ƒbx0gndarrayÙ¹‚ƒÙ§x'The starting estimate for the roots of Ù¡kfunc(x) = 0Ù§a.€Ù°ƒdargsotuple, optionalÙ¹‚ƒÙ§wAny extra arguments to Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§a.€Ù°ƒffprimex"callable ``f(x, *args)``, optionalÙ¹‚ƒÙ§x&A function to compute the Jacobian of Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§xN with derivatives across the rows. By default, the Jacobian will be estimated.€Ù°ƒkfull_outputnbool, optionalÙ¹‚Ù§x!If True, return optional outputs.€Ù°ƒicol_derivnbool, optionalÙ¹‚Ù§x~Specify whether the Jacobian function computes derivatives down the columns (faster, because there is no transpose operation).€Ù°ƒdxtolofloat, optionalÙ¹‚ƒÙ§xaThe calculation will terminate if the relative error between two consecutive iterates is at most Ù¢„dxtolÙ „ööelocaldxtolelocalõÙ§a.€Ù°ƒfmaxfevmint, optionalÙ¹‚…Ù§x;The maximum number of calls to the function. If zero, then Ù¡i100*(N+1)Ù§x5 is the maximum where N is the number of elements in Ù¢„bx0Ù „ööelocalbx0elocalõÙ§a.€Ù°ƒdbandotuple, optionalÙ¹‚ƒÙ§x¢If set to a two-sequence containing the number of sub- and super-diagonals within the band of the Jacobi matrix, the Jacobi matrix is considered banded (only for Ù¡kfprime=NoneÙ§b).€Ù°ƒfepsfcnofloat, optionalÙ¹‚…Ù§xUA suitable step length for the forward-difference approximation of the Jacobian (for Ù¡kfprime=NoneÙ§f). If Ù¢„fepsfcnÙ „ööelocalfepsfcnelocalõÙ§x‡ is less than the machine precision, it is assumed that the relative errors in the functions are of the order of the machine precision.€Ù°ƒffactorofloat, optionalÙ¹‚…Ù§x0A parameter determining the initial step bound (Ù¡vfactor * || diag * x||Ù§x). Should be in the interval Ù¡j(0.1, 100)Ù§a.€Ù°ƒddiagrsequence, optionalÙ¹‚Ù§xCN positive entries that serve as a scale factors for the variables.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚„Ù°ƒaxgndarrayÙ¹‚Ù§xLThe solution (or the result of the last iteration for an unsuccessful call).€Ù°ƒhinfodictddict‚Ù¹‚Ù§x/A dictionary of optional outputs with the keys:€ÙÁ†ÙÅ‚Ù¹‚Ù¡dnfev€Ù¹‚Ù§xnumber of function calls€ÙÅ‚Ù¹‚Ù¡dnjev€Ù¹‚Ù§xnumber of Jacobian calls€ÙÅ‚Ù¹‚Ù¡dfvec€Ù¹‚Ù§x function evaluated at the output€ÙÅ‚Ù¹‚Ù¡dfjac€Ù¹‚Ù§xthe orthogonal matrix, q, produced by the QR     factorization of the final approximate Jacobian     matrix, stored column wise€ÙÅ‚Ù¹‚Ù¡ar€Ù¹‚Ù§xKupper triangular matrix produced by QR factorization     of the same matrix€ÙÅ‚Ù¹‚Ù¡cqtf€Ù¹‚‚Ù§kthe vector Ù¡u(transpose(q) * fvec)€Ù°ƒciercintÙ¹‚ƒÙ§xGAn integer flag.  Set to 1 if a solution was found, otherwise refer to Ù¢„dmesgÙ „ööelocaldmesgelocalõÙ§v for more information.€Ù°ƒdmesgcstrÙ¹‚ƒÙ§xIf no solution is found, Ù¢„dmesgÙ „ööelocaldmesgelocalõÙ§x details the cause of failure.€ögSummaryÙ¯‚Ù¹‚Ù§xFind the roots of a function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/optimize/_minpack_py.py.r<class 'function'>x+scipy.signal._filter_design.optimize.fsolveÙ¯‚ƒÙ¹‚ƒÙ§x,Find a solution to the system of equations: Ù¡xx0*cos(x1) = 4,  x1*x0 - x1 = 5Ù§a.€Ù´ƒ˜WÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ffsolveÙ „escipye1.8.0fmodulex!scipy.optimize._minpack_py.fsolvefmoduleõÙ±‚`a
Ù±‚akcdefÙ±‚`a Ù±‚bnfdfuncÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a
Ù±‚`l            Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a
Ù±‚`drootÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ffsolveÙ „escipye1.8.0fmodulex!scipy.optimize._minpack_py.fsolvefmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`drootxarray([6.50409711, 0.90841421])fexecedÙ´ƒ“Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„giscloseÙ „enumpyf1.22.3fmodulemnumpy.isclosefmoduleõÙ±‚`a(Ù±‚`dfuncÙ±‚`a(Ù±‚`drootÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.0Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1x"# func(root) should be almost 0.0.uarray([ True,  True])fexecedöÙ¼ƒÙ»ƒdrootööÙ¹‚ƒÙ§xIInterface to root finding algorithms for multivariate functions. See the Ù¡nmethod=='hybr'Ù§o in particular.€öe1.8.0Ù«xfsolve(func, x0, args=(), fprime=None, full_output=0, col_deriv=0, xtol=1.49012e-08, maxfev=0, band=None, epsfcn=None, factor=100, diag=None)öx!scipy.optimize._minpack_py.fsolve€
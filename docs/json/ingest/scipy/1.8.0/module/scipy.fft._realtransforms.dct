Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚—Ù¹‚‡Ù§xFor a single dimension array Ù¡axÙ§b, Ù¡tdct(x, norm='ortho')Ù§t is equal to MATLAB Ù¡fdct(x)Ù§a.€ÙÆƒgwarningx=For ``type in {1, 2, 3}``, ``norm="ortho"`` breaks the directÙ¹‚Ù§xjcorrespondence with the direct Fourier transform. To recover it you must specify ``orthogonalize=False``. €Ù¹‚‡Ù§dFor Ù¡lnorm="ortho"Ù§j both the Ù¢„cdctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dctfmoduleõÙ§e and Ù¢„didctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.idctfmoduleõÙ§xæ are scaled by the same overall factor in both directions. By default, the transform is also orthogonalized which for types 1, 2 and 3 means the transform definition is modified to give orthogonality of the DCT matrix (see below).€Ù¹‚“Ù§dFor Ù¡onorm="backward"Ù§x, there is no scaling on Ù¢„cdctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dctfmoduleõÙ§i and the Ù¢„didctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.idctfmoduleõÙ§n is scaled by Ù¡c1/NÙ§g where Ù¡aNÙ§x' is the "logical" size of the DCT. For Ù¡nnorm="forward"Ù§e the Ù¡c1/NÙ§x) normalization is applied to the forward Ù¢„cdctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dctfmoduleõÙ§q instead and the Ù¢„didctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.idctfmoduleõÙ§q is unnormalized.€Ù¹‚Ù§x½There are, theoretically, 8 types of the DCT, only the first 4 types are implemented in SciPy.'The' DCT generally refers to DCT type 2, and 'the' Inverse DCT generally refers to DCT type 3.€Ù¹‚Ù©Ù§fType I€Ù¹‚ƒÙ§xFThere are several definitions of the DCT-I; we use the following (for Ù¡onorm="backward"Ù§a)€Ù¤xny_k = x_0 + ( - 1)^k x_ { N - 1} + 2 \sum_ { n=1}^ { N - 2} x_n \cos\left ( \frac { \pi k n} { N - 1} \right) Ù¹‚“Ù§cIf Ù¡rorthogonalize=TrueÙ§b, Ù¡dx[0]Ù§e and Ù¡fx[N-1]Ù§x' are multiplied by a scaling factor of Ù¥h\sqrt{2}Ù§f, and Ù¡dy[0]Ù§e and Ù¡fy[N-1]Ù§p are divided by Ù¥h\sqrt{2}Ù§u. When combined with Ù¡lnorm="ortho"Ù§xC, this makes the corresponding matrix of coefficients orthonormal (Ù¡sO @ O.T = np.eye(N)Ù§b).€ÙÆƒdnote`Ù¹‚Ù§x2The DCT - I is only supported for input size > 1. €Ù¹‚Ù©Ù§gType II€Ù¹‚ƒÙ§xGThere are several definitions of the DCT-II; we use the following (for Ù¡onorm="backward"Ù§a)€Ù¤xTy_k = 2 \sum_ { n=0}^ { N - 1} x_n \cos\left ( \frac { \pi k ( 2n+1)} { 2N} \right) Ù¹‚‹Ù§cIf Ù¡rorthogonalize=TrueÙ§b, Ù¡dy[0]Ù§o is divided by Ù¥h\sqrt{2}Ù§x which, when combined with Ù¡lnorm="ortho"Ù§x>, makes the corresponding matrix of coefficients orthonormal (Ù¡sO @ O.T = np.eye(N)Ù§b).€Ù¹‚Ù©Ù§hType III€Ù¹‚ƒÙ§x9There are several definitions, we use the following (for Ù¡onorm="backward"Ù§a)€Ù¤xXy_k = x_0 + 2 \sum_ { n=1}^ { N - 1} x_n \cos\left ( \frac { \pi ( 2k+1)n} { 2N}\right) Ù¹‚‹Ù§cIf Ù¡rorthogonalize=TrueÙ§b, Ù¡dx[0]Ù§x terms are multiplied by Ù¥h\sqrt{2}Ù§x which, when combined with Ù¡lnorm="ortho"Ù§x>, makes the corresponding matrix of coefficients orthonormal (Ù¡sO @ O.T = np.eye(N)Ù§b).€Ù¹‚ƒÙ§xWThe (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up to a factor Ù£ƒb2NööÙ§xS. The orthonormalized DCT-III is exactly the inverse of the orthonormalized DCT-II.€Ù¹‚Ù©Ù§gType IV€Ù¹‚ƒÙ§xGThere are several definitions of the DCT-IV; we use the following (for Ù¡onorm="backward"Ù§a)€Ù¤xZy_k = 2 \sum_ { n=0}^ { N - 1} x_n \cos\left ( \frac { \pi ( 2k+1) ( 2n+1)} { 4N} \right) Ù¹‚„Ù¡morthogonalizeÙ§xX has no effect here, as the DCT-IV matrix is already orthogonal up to a scale factor of Ù¡b2NÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaxjarray_likeÙ¹‚Ù§pThe input array.€Ù°ƒdtypev{1, 2, 3, 4}, optionalÙ¹‚Ù§x/Type of the DCT (see Notes). Default type is 2.€Ù°ƒanmint, optionalÙ¹‚‹Ù§xLength of the transform.  If Ù¡qn < x.shape[axis]Ù§b, Ù¢„axÙ „ööelocalaxelocalõÙ§s is truncated.  If Ù¡qn > x.shape[axis]Ù§b, Ù¢„axÙ „ööelocalaxelocalõÙ§x( is zero-padded. The default results in Ù¡qn = x.shape[axis]Ù§a.€Ù°ƒdaxismint, optionalÙ¹‚ƒÙ§xOAxis along which the dct is computed; the default is over the last axis (i.e., Ù¡gaxis=-1Ù§b).€Ù°ƒdnormx*{"backward", "ortho", "forward"}, optionalÙ¹‚Ù§x6Normalization mode (see Notes). Default is "backward".€Ù°ƒkoverwrite_xnbool, optionalÙ¹‚ƒÙ§xIf True, the contents of Ù¢„axÙ „ööelocalaxelocalõÙ§x( can be destroyed; the default is False.€Ù°ƒgworkersmint, optionalÙ¹‚…Ù§xdMaximum number of workers to use for parallel computation. If negative, the value wraps around from Ù¡nos.cpu_count()Ù§f. See Ù¢„cfftÙ „escipya*capitscipy.fft._basic.fftfmoduleõÙ§r for more details.€Ù°ƒmorthogonalizenbool, optional‚Ù¹‚‡Ù§xGWhether to use the orthogonalized DCT variant (see Notes). Defaults to Ù¡dTrueÙ§f when Ù¡mnorm=="ortho"Ù§e and Ù¡eFalseÙ§k otherwise.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.8.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒayondarray of realÙ¹‚Ù§xThe transformed input array.€ögSummaryÙ¯‚Ù¹‚Ù§xBReturn the Discrete Cosine Transform of arbitrary type sequence x.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx/scipy/fft/_realtransforms.pyx<class 'uarray._Function'>x&scipy.signal._filter_design.sp_fft.dctÙ¯‚ƒÙ¹‚Ù§xÊThe Type 1 DCT is equivalent to the FFT (though faster) for real, even-symmetrical inputs. The output is also real and even-symmetrical. Half of the FFT input is used to generate half of the FFT output:€Ù´ƒ˜)Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„cdctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dctfmoduleõÙ±‚`a
Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb4.Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚`a,Ù±‚`a Ù±‚bmfb5.Ù±‚`a,Ù±‚`a Ù±‚bmfc10.Ù±‚`a,Ù±‚`a Ù±‚bmfb5.Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`drealx+array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])fexecedÙ´ƒ—Ù±‚`Ù¢„cdctÙ „escipye1.8.0fmodulexscipy.fft._realtransforms.dctfmoduleõÙ±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb4.Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚`a,Ù±‚`a Ù±‚bmfb5.Ù±‚`a,Ù±‚`a Ù±‚bmfc10.Ù±‚`a]Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)xarray([ 30.,  -8.,   6.,  -2.])fexecedöÙ¼ƒÙ»ƒdidctxscipy.fft._realtransforms.idctõÙ¹‚Ù§kInverse DCT€öe1.8.0Ù«ööxscipy.fft._realtransforms.dct€
Ùª­jAttributesÙ¯‚ŠÙ°ƒaNcintÙ¹‚Ù§x>The number of data points (as determined by the input arrays).€Ù°ƒbdigndarrayÙ¹‚ƒÙ§x=The 1-D array of data values at each of the data coordinates Ù¢„bxiÙ „ööelocalbxielocalõÙ§a.€Ù°ƒbxigndarrayÙ¹‚Ù§x"The 2-D array of data coordinates.€Ù°ƒhfunctionostr or callableÙ¹‚Ù§x<The radial basis function. See description under Parameters.€Ù°ƒgepsilonefloatÙ¹‚Ù§xFParameter used by gaussian or multiquadrics functions. See Parameters.€Ù°ƒfsmoothefloatÙ¹‚Ù§x6Smoothing parameter. See description under Parameters.€Ù°ƒdnormostr or callableÙ¹‚Ù§x8The distance function. See description under Parameters.€Ù°ƒdmodecstrÙ¹‚Ù§x<Mode of the interpolation. See description under Parameters.€Ù°ƒenodesgndarrayÙ¹‚Ù§x1A 1-D array of node values for the interpolation.€Ù°ƒaAxinternal property, do not use€öpExtended SummaryÙ¯‚ÙÆƒdnote`Ù¹‚Ù§xJ`Rbf` is legacy code, for new usage please use `RBFInterpolator` instead. €ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒe*argsfarraysÙ¹‚Ù§xnx, y, z, ..., d, where x, y, z, ... are the coordinates of the nodes and d is the array of values at the nodes€Ù°ƒhfunctionxstr or callable, optionalƒÙ¹‚Ù§x‹The radial basis function, based on the radius, r, given by the norm (default is Euclidean distance); the default is 'multiquadric'::      €ÙÀxÆ'multiquadric': sqrt((r/self.epsilon)**2 + 1)
'inverse': 1.0/sqrt((r/self.epsilon)**2 + 1)
'gaussian': exp(-(r/self.epsilon)**2)
'linear': r
'cubic': r**3
'quintic': r**5
'thin_plate': r**2 * log(r)Ù¹‚Ù§x«If callable, then it must take 2 arguments (self, r). The epsilon parameter will be available as self.epsilon. Other keyword arguments passed in will be available as well.€Ù°ƒgepsilonofloat, optionalÙ¹‚Ù§xAdjustable constant for gaussian or multiquadrics functions - defaults to approximate average distance between nodes (which is a good start).€Ù°ƒfsmoothofloat, optionalÙ¹‚Ù§x«Values greater than zero increase the smoothness of the approximation. 0 is for interpolation (default), the function will always go through the nodal points in this case.€Ù°ƒdnormwstr, callable, optionalÙ¹‚‡Ù§xúA function that returns the 'distance' between two points, with inputs as arrays of positions (x, y, z, ...), and an output as an array of distance. E.g., the default: 'euclidean', such that the result is a matrix of the distances from each point in Ù¡bx1Ù§r to each point in Ù¡bx2Ù§x). For more options, see documentation of Ù£ƒxscipy.spatial.distances.cdistööÙ§a.€Ù°ƒdmodemstr, optionalÙ¹‚…Ù§xVMode of the interpolation, can be '1-D' (default) or 'N-D'. When it is '1-D' the data Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ§xO will be considered as 1-D and flattened internally. When it is 'N-D' the data Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ§xb is assumed to be an array of shape (n_samples, m), where m is the dimension of the target domain.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xfA class for radial basis function interpolation of functions from N-D scattered data to an M-D domain.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡iSignaturegSummarypExtended SummaryjParametersjAttributeshSee AlsohExamplesx/scipy/interpolate/_rbf.py7n<class 'type'>x$scipy.signal._ltisys.interpolate.RbfÙ¯‚Ù´ƒ˜pÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„kinterpolateÙ „escipye1.8.0fmoduleqscipy.interpolatefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cRbfÙ „escipye1.8.0fmodulexscipy.interpolate._rbf.RbffmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „escipye1.8.0fmodulex9scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.dfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmib50Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`drbfiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cRbfÙ „escipye1.8.0fmodulexscipy.interpolate._rbf.RbffmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„azÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„adÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`b  Ù±‚bc1x-# radial basis function interpolator instanceÙ±‚`a
Ù±‚`bxiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`byiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bziÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib20Ù±‚`a)Ù±‚`a
Ù±‚`bdiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`drbfiÙ±‚`a(Ù±‚`bxiÙ±‚`a,Ù±‚`a Ù±‚`byiÙ±‚`a,Ù±‚`a Ù±‚`bziÙ±‚`a)Ù±‚`c   Ù±‚bc1u# interpolated valuesÙ±‚`a
Ù±‚`Ù¢„bdiÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapee(20,)fexecedöÙ¼ƒÙ»ƒoRBFInterpolatorx,scipy.interpolate._rbfinterp.RBFInterpolatorõ€öe1.8.0Ù«tRbf(*args, **kwargs)öxscipy.interpolate._rbf.Rbf€
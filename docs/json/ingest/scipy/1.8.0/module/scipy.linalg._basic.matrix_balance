Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§xÀThe balancing tries to equalize the row and column 1-norms by applying a similarity transformation such that the magnitude variation of the matrix entries is reflected to the scaling matrices.€Ù¹‚Ù§xÄMoreover, if enabled, the matrix is first permuted to isolate the upper triangular parts of the matrix and, again if scaling is also enabled, only the remaining subblocks are subjected to scaling.€Ù¹‚Ù§x4The balanced matrix satisfies the following equality€Ù¤rB = T^ { - 1} A T Ù¹‚Ù§x^The scaling coefficients are approximated to the nearest power of 2 to avoid round-off errors.€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§x‘This algorithm is particularly useful for eigenvalue and matrix decompositions and in many cases it is already called by various LAPACK routines.€Ù¹‚Ù§y%The algorithm is based on the well-known technique of  and has been modified to account for special cases. See  for details which have been implemented since LAPACK v3.5.0. Before this version there are corner cases where balancing can actually worsen the conditioning. See  for such examples.€Ù¹‚Ù§xQThe code is a wrapper around LAPACK's xGEBAL routine family for matrix balancing.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.19.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaAq(n, n) array_likeÙ¹‚Ù§x%Square data matrix for the balancing.€Ù°ƒgpermutenbool, optionalÙ¹‚Ù§xSThe selector to define whether permutation of A is also performed prior to scaling.€Ù°ƒescalenbool, optionalÙ¹‚Ù§xUThe selector to turn on and off the scaling. If False, the matrix will not be scaled.€Ù°ƒhseparatenbool, optionalÙ¹‚Ù§xThis switches from returning a full matrix of the transformation to a tuple of two separate 1-D permutation and scaling arrays.€Ù°ƒkoverwrite_anbool, optionalÙ¹‚Ù§x³This is passed to xGEBAL directly. Essentially, overwrites the result to the data. It might increase the space efficiency. See LAPACK manual for details. This is False by default.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒaBn(n, n) ndarrayÙ¹‚Ù§oBalanced matrix€Ù°ƒaTn(n, n) ndarrayÙ¹‚Ù§xwA possibly permuted diagonal matrix whose nonzero entries are integer powers of 2 to avoid numerical truncation errors.€Ù°ƒkscale, perml(n,) ndarrayÙ¹‚‡Ù§cIf Ù¡hseparateÙ§x2 keyword is set to True then instead of the array Ù¡aTÙ§xr above, the scaling and the permutation vectors are given separately as a tuple without allocating the full array Ù¡aTÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§xFCompute a diagonal similarity transformation for row/column balancing.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshExamplesjReferencesw/scipy/linalg/_basic.pyèr<class 'function'>x2scipy.signal._lti_conversion.linalg.matrix_balanceÙ¯‚„Ù´ƒ˜0Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia9Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmfd0.01Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmib10Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚`a]Ù±‚`a]Ù±‚`a)`fexecedÙ´ƒ˜+Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`ipermscaleÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„nmatrix_balanceÙ „escipye1.8.0fmodulex"scipy.linalg._basic.matrix_balancefmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)x.array([ 3.66666667,  0.4995005 ,  0.91312162])fexecedÙ´ƒ˜Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cabsÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`csumÙ±‚`a(Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)x:array([ 1.2       ,  1.27041742,  0.92658316])  # may varyfexecedÙ´ƒƒÙ±‚`ipermscaleÙ±‚`b  Ù±‚bc1x"# only powers of 2 (0.5 == 2^(-1))xcarray([[  0.5,   0. ,  0. ],  # may vary
       [  0. ,   1. ,  0. ],
       [  0. ,   0. ,  1. ]])fexecedö€e1.8.0Ù«xNmatrix_balance(A, permute=True, scale=True, separate=False, overwrite_a=False)öx"scipy.linalg._basic.matrix_balance€
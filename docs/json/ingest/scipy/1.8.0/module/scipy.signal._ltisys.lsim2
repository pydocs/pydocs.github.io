Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚‰Ù§sThis function uses Ù¢„vscipy.integrate.odeintÙ „escipya*capix"scipy.integrate._odepack_py.odeintfmoduleõÙ§xV to solve the system's differential equations.  Additional keyword arguments given to Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ§r are passed on to Ù¢„fodeintÙ „escipye1.8.0fmodulexscipy.integrate._odepack.odeintfmoduleõÙ§x.  See the documentation for Ù¢„vscipy.integrate.odeintÙ „escipya*capix"scipy.integrate._odepack_py.odeintfmoduleõÙ§x  for the full list of arguments.€Ù¹‚‡Ù§xIf (num, den) is passed in for Ù¡fsystemÙ§xm, coefficients for both the numerator and denominator should be specified in descending exponent order (e.g. Ù¡ls^2 + 3s + 5Ù§x would be represented as Ù¡i[1, 3, 5]Ù§b).€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒfsystemx@an instance of the `lti` class or a tuple describing the system.‚Ù¹‚Ù§xOThe following gives the number of elements in the tuple and the interpretation:€ÙÈ„Ù¹‚ƒÙ§p1: (instance of Ù£ƒcltiööÙ§a)€Ù¹‚Ù§m2: (num, den)€Ù¹‚Ù§w3: (zeros, poles, gain)€Ù¹‚Ù§o4: (A, B, C, D)€Ù°ƒaUxarray_like (1D or 2D), optionalÙ¹‚Ù§xôAn input array describing the input at each time T.  Linear interpolation is used between given times.  If there are multiple inputs, then each column of the rank-2 array represents an input.  If U is not given, the input is assumed to be zero.€Ù°ƒaTxarray_like (1D or 2D), optionalÙ¹‚Ù§x“The time steps at which the input is defined and at which the output is desired.  The default is 101 evenly spaced points on the interval [0,10.0].€Ù°ƒbX0xarray_like (1D), optionalÙ¹‚ƒÙ§x/The initial condition of the state vector.  If Ù¢„bX0Ù „ööelocalbX0elocalõÙ§x: is not given, the initial conditions are assumed to be 0.€Ù°ƒfkwargsddictÙ¹‚ƒÙ§x;Additional keyword arguments are passed on to the function Ù¢„fodeintÙ „escipye1.8.0fmodulexscipy.integrate._odepack.odeintfmoduleõÙ§x(.  See the notes below for more details.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒaTj1D ndarrayÙ¹‚Ù§xThe time values for the output.€Ù°ƒdyoutgndarrayÙ¹‚Ù§xThe response of the system.€Ù°ƒdxoutgndarrayÙ¹‚Ù§x'The time-evolution of the state-vector.€ögSummaryÙ¯‚Ù¹‚ƒÙ§xLSimulate output of a continuous-time linear system, by using the ODE solver Ù¢„vscipy.integrate.odeintÙ „escipya*capix"scipy.integrate._odepack_py.odeintfmoduleõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNoteshSee AlsohExamplesx/scipy/signal/_ltisys.pyär<class 'function'>rscipy.signal.lsim2Ù¯‚”Ù¹‚ƒÙ§jWe'll use Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ§x9 to simulate an analog Bessel filter applied to a signal.€Ù´ƒ–Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fbesselÙ „escipye1.8.0fmodulex"scipy.signal._filter_design.besselfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõ`fexecedÙ¹‚Ù§x7Create a low-pass Bessel filter with a cutoff of 12 Hz.€Ù´ƒ˜$Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fbesselÙ „escipye1.8.0fmodulex"scipy.signal._filter_design.besselfmoduleõÙ±‚`a(Ù±‚`aNÙ±‚aoa=Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`bWnÙ±‚aoa=Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmib12Ù±‚`a,Ù±‚`a Ù±‚`ebtypeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1glowpassÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`fanalogÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)`fexecedÙ¹‚Ù§x-Generate data to which the filter is applied.€Ù´ƒ•Ù±‚`atÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmfd1.25Ù±‚`a,Ù±‚`a Ù±‚bmic500Ù±‚`a,Ù±‚`a Ù±‚`hendpointÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)`fexecedÙ¹‚Ù§xÂThe input signal is the sum of three sinusoidal curves, with frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.€Ù´ƒ˜;Ù±‚`auÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmia4Ù±‚aoa*Ù±‚`atÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfc0.6Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmib40Ù±‚aoa*Ù±‚`atÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a
Ù±‚`e     Ù±‚bmfc0.5Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ccosÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚aoa*Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`bpiÙ±‚aoa*Ù±‚bmib80Ù±‚aoa*Ù±‚`atÙ±‚`a)Ù±‚`a)`fexecedÙ¹‚ƒÙ§xSimulate the filter with Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ§a.€Ù´ƒ˜Ù±‚`dtoutÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dyoutÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dxoutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`aUÙ±‚aoa=Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`aTÙ±‚aoa=Ù±‚`atÙ±‚`a)`fexecedÙ¹‚Ù§pPlot the result.€Ù´ƒ˜gÙ±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1arÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚aoa=Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`ilinewidthÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1einputÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`Ù¢„dtoutÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„dyoutÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1akÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`ilinewidthÙ±‚aoa=Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1foutputÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`clocÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dbestÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`fshadowÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚`jframealphaÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dgridÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.gridfmoduleõÙ±‚`a(Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚aoa=Ù±‚bmfc0.3Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1atÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x$fig-scipy.signal._ltisys.lsim2-0.pngÙ¹‚…Ù§x5In a second example, we simulate a double integrator Ù¡gy'' = uÙ§x, with a constant input Ù¡eu = 1Ù§x>.  We'll use the state space representation of the integrator.€Ù´ƒ˜aÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ±‚`a
Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aBÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aCÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`aDÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia0Ù±‚`a
Ù±‚`fsystemÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cltiÙ „escipye1.8.0fmodulexscipy.signal._ltisys.ltifmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aBÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aCÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aDÙ±‚`a)`fexecedÙ¹‚„Ù£ƒatööÙ§e and Ù£ƒauööÙ§xA define the time and input signal for the system to be simulated.€Ù´ƒ˜Ù±‚`atÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`cnumÙ±‚aoa=Ù±‚bmib50Ù±‚`a)Ù±‚`a
Ù±‚`auÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„iones_likeÙ „enumpyf1.22.3fmoduleonumpy.ones_likefmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a)`fexecedÙ¹‚…Ù§x&Compute the simulation, and then plot Ù£ƒayööÙ§x).  As expected, the plot shows the curve Ù¡ly = 0.5*t**2Ù§a.€Ù´ƒ˜6Ù±‚`dtoutÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„elsim2Ù „escipye1.8.0fmodulexscipy.signal._ltisys.lsim2fmoduleõÙ±‚`a(Ù±‚`fsystemÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`atÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`atÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dgridÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.gridfmoduleõÙ±‚`a(Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚aoa=Ù±‚bmfc0.3Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1atÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x$fig-scipy.signal._ltisys.lsim2-1.pngöÙ¼ƒÙ»ƒdlsimxscipy.signal._ltisys.lsimõ€öe1.8.0Ù«x0lsim2(system, U=None, T=None, X0=None, **kwargs)öxscipy.signal._ltisys.lsim2€
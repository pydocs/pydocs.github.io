Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x8It represents the set of constraints of the form::      €ÙÀxf_eq(x) = 0
f_ineq(x) <= 0Ù¹‚…Ù§fwhere Ù¡df_eqÙ§e and Ù¡ff_ineqÙ§x/ are evaluated by a single function, see below.€Ù¹‚Ù§xnThe class is supposed to be instantiated by factory methods, which should prepare the parameters listed below.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒln_eq, n_ineqcintÙ¹‚Ù§x;Number of equality and inequality constraints respectively.€Ù°ƒcfunhcallableÙ¹‚‹Ù§x4Function defining the constraints. The signature is Ù¡vfun(x) -> c_eq, c_ineqÙ§h, where Ù¡dc_eqÙ§q is ndarray with Ù¢„dn_eqÙ „ööelocaldn_eqelocalõÙ§p components and Ù¡fc_ineqÙ§q is ndarray with Ù¢„fn_ineqÙ „ööelocalfn_ineqelocalõÙ§l components.€Ù°ƒcjachcallableÙ¹‚‡Ù§xFFunction to evaluate the Jacobian of the constraint. The signature is Ù¡vjac(x) -> J_eq, J_ineqÙ§h, where Ù¡dJ_eqÙ§e and Ù¡fJ_ineqÙ§xT are either ndarray of csr_matrix of shapes (n_eq, n) and (n_ineq, n), respectively.€Ù°ƒdhesshcallableÙ¹‚‰Ù§x`Function to evaluate the Hessian of the constraints multiplied by Lagrange multipliers, that is Ù¡x%dot(f_eq, v_eq) + dot(f_ineq, v_ineq)Ù§s. The signature is Ù¡xhess(x, v_eq, v_ineq) -> HÙ§h, where Ù¡aHÙ§xK has an implied shape (n, n) and provide a matrix-vector product operation Ù¡hH.dot(p)Ù§a.€Ù°ƒmkeep_feasiblexndarray, shape (n_ineq,)Ù¹‚Ù§xEMask indicating which inequality constraints should be kept feasible.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x8Canonical constraint to use with trust-constr algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryjParametersx;/scipy/optimize/_trustregion_constr/canonical_constraint.pyn<class 'type'>xascipy.signal._filter_design.optimize._trustregion_constr.canonical_constraint.CanonicalConstraintÙ¯‚€ö€e1.8.0Ù«ööxKscipy.optimize._trustregion_constr.canonical_constraint.CanonicalConstraint€
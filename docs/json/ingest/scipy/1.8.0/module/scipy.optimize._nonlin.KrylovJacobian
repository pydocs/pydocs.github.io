Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x9This method is suitable for solving large-scale problems.€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚Ù§y
This function implements a Newton-Krylov solver. The basic idea is to compute the inverse of the Jacobian with an iterative Krylov method. These methods require only evaluating the Jacobian-vector products, which are conveniently approximated by a finite difference:€Ù¤x9J v \approx ( f ( x + \omega*v / |v|) - f ( x)) / \omega Ù¹‚Ù§xbDue to the use of iterative matrix inverses, these methods can deal with large nonlinear problems.€Ù¹‚…Ù§hSciPy's Ù¢„sscipy.sparse.linalgÙ „escipye1.8.0fmodulesscipy.sparse.linalgfmoduleõÙ§xQ module offers a selection of Krylov solvers to choose from. The default here is Ù¢„flgmresÙ „escipye1.8.0fmodulex)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§x¤, which is a variant of restarted GMRES iteration that reuses some of the information obtained in the previous Newton steps to invert Jacobians in subsequent steps.€Ù¹‚Ù§xhFor a review on Newton-Krylov methods, see for example , and for the LGMRES sparse inverse method, see .€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒp%(params_basic)s`€Ù°ƒerdiffofloat, optionalÙ¹‚Ù§x7Relative step size to use in numerical differentiation.€Ù°ƒfmethodx<{'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function‚Ù¹‚ƒÙ§xKrylov method to use to approximate the Jacobian. Can be a string, or a function implementing the same interface as the iterative solvers in Ù¢„sscipy.sparse.linalgÙ „escipye1.8.0fmodulesscipy.sparse.linalgfmoduleõÙ§a.€Ù¹‚ƒÙ§oThe default is Ù¢„xscipy.sparse.linalg.lgmresÙ „escipya*capix)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§a.€Ù°ƒminner_maxitermint, optionalÙ¹‚Ù§x¬Parameter to pass to the "inner" Krylov solver: maximum number of iterations. Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.€Ù°ƒginner_Mx!LinearOperator or InverseJacobianƒÙ¹‚Ù§x‡Preconditioner for the inner Krylov iteration. Note that you can use also inverse Jacobians as (adaptive) preconditioners. For example,€ÙÀxÉ>>> from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
>>> from scipy.optimize.nonlin import InverseJacobian
>>> jac = BroydenFirst()
>>> kjac = KrylovJacobian(inner_M=InverseJacobian(jac))Ù¹‚‡Ù§xHIf the preconditioner has a method named 'update', it will be called as Ù¡lupdate(x, f)Ù§x! after each nonlinear step, with Ù¡axÙ§x giving the current point, and Ù¡afÙ§x the current function value.€Ù°ƒgouter_kmint, optionalÙ¹‚ƒÙ§xBSize of the subspace kept across LGMRES nonlinear iterations. See Ù¢„xscipy.sparse.linalg.lgmresÙ „escipya*capix)scipy.sparse.linalg._isolve.lgmres.lgmresfmoduleõÙ§m for details.€Ù°ƒlinner_kwargsfkwargsÙ¹‚‡Ù§x?Keyword parameters for the "inner" Krylov solver (defined with Ù¢„fmethodÙ „escipye1.8.0fmodulex1scipy.sparse._data._create_method.<locals>.methodfmoduleõÙ§x'). Parameter names must start with the Ù£ƒfinner_ööÙ§xN prefix which will be stripped before passing on the inner method. See, e.g., Ù¢„xscipy.sparse.linalg.gmresÙ „escipya*capix+scipy.sparse.linalg._isolve.iterative.gmresfmoduleõÙ§m for details.€Ù°ƒp%(params_extra)s`€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xKFind a root of a function, using Krylov approximation for inverse Jacobian.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametershSee AlsoeNotesjReferenceshExamplesx/scipy/optimize/_nonlin.py n<class 'type'>x;scipy.signal._filter_design.optimize._nonlin.KrylovJacobianÙ¯‚„Ù¹‚Ù§x>The following functions define a system of nonlinear equations€Ù´ƒ˜9Ù±‚akcdefÙ±‚`a Ù±‚bnfcfunÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a
Ù±‚`l            Ù±‚bmfc0.5Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚bmia2Ù±‚`a]`fexecedÙ¹‚Ù§x&A solution can be obtained as follows.€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a
Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚aoa.Ù±‚`Ù¢„mnewton_krylovÙ „escipye1.8.0fmodulex$scipy.optimize._nonlin.newton_krylovfmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„csolÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõxarray([0.66731771, 0.66536458])fexecedöƒÙ¼ƒÙ»ƒdrootööÙ¹‚ƒÙ§xEInterface to root finding algorithms for multivariate functions. See Ù¡pmethod=='krylov'Ù§o in particular.€öÙ¼ƒÙ»ƒxscipy.sparse.linalg.gmresöö€öÙ¼ƒÙ»ƒxscipy.sparse.linalg.lgmresöö€öe1.8.0Ù«ööx%scipy.optimize._nonlin.KrylovJacobian€
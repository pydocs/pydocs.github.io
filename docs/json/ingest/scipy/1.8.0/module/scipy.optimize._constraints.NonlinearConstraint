Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x6The constraint has the general inequality form::      €ÙÀrlb <= fun(x) <= ubÙ¹‚ƒÙ§xRHere the vector of independent variables x is passed as ndarray of shape (n,) and Ù¡cfunÙ§x$ returns a vector with m components.€Ù¹‚Ù§x~It is possible to use equal bounds to represent an equality constraint or infinite bounds to represent a one-sided constraint.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§ySFinite difference schemes {'2-point', '3-point', 'cs'} may be used for approximating either the Jacobian or the Hessian. We, however, do not allow its use for approximating both simultaneously. Hence whenever the Jacobian is estimated via finite-differences, we require the Hessian to be estimated using one of the quasi-Newton strategies.€Ù¹‚Ù§yThe scheme 'cs' is potentially the most accurate, but requires the function to correctly handles complex inputs and be analytically continuable to the complex plane. The scheme '3-point' is more accurate than '2-point' but requires twice as many operations.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒcfunhcallableÙ¹‚ƒÙ§x7The function defining the constraint. The signature is Ù¡x fun(x) -> array_like, shape (m,)Ù§a.€Ù°ƒflb, ubjarray_likeÙ¹‚‹Ù§x´Lower and upper bounds on the constraint. Each array must have the shape (m,) or be a scalar, in the latter case a bound will be the same for all components of the constraint. Use Ù¡fnp.infÙ§xO with an appropriate sign to specify a one-sided constraint. Set components of Ù¢„blbÙ „ööelocalblbelocalõÙ§e and Ù¢„bubÙ „ööelocalbubelocalõÙ§x¦ equal to represent an equality constraint. Note that you can mix constraints of different types: interval, one-sided or equality, by setting different components of Ù¢„blbÙ „ööelocalblbelocalõÙ§e and Ù¢„bubÙ „ööelocalbubelocalõÙ§o as  necessary.€Ù°ƒcjacx1{callable,  '2-point', '3-point', 'cs'}, optionalÙ¹‚ƒÙ§y"Method of computing the Jacobian matrix (an m-by-n matrix, where element (i, j) is the partial derivative of f[i] with respect to x[j]).  The keywords {'2-point', '3-point', 'cs'} select a finite difference scheme for the numerical estimation. A callable must have the following signature: Ù¡x0jac(x) -> {ndarray, sparse matrix}, shape (m, n)Ù§w. Default is '2-point'.€Ù°ƒdhessxM{callable, '2-point', '3-point', 'cs', HessianUpdateStrategy, None}, optionalƒÙ¹‚ƒÙ§xµMethod for computing the Hessian matrix. The keywords {'2-point', '3-point', 'cs'} select a finite difference scheme for numerical  estimation.  Alternatively, objects implementing Ù¢„uHessianUpdateStrategyÙ „escipye1.8.0fmodulex=scipy.optimize._hessian_update_strategy.HessianUpdateStrategyfmoduleõÙ§x[ interface can be used to approximate the Hessian. Currently available implementations are:€Ù·‚x- `BFGS` (default option)g- `SR1`Ù¹‚‡Ù§x-A callable must return the Hessian matrix of Ù¡kdot(fun, v)Ù§x( and must have the following signature: Ù¡xGhess(x, v) -> {LinearOperator, sparse matrix, array_like}, shape (n, n)Ù§g. Here Ù¡avÙ§x< is ndarray with shape (m,) containing Lagrange multipliers.€Ù°ƒmkeep_feasiblexarray_like of bool, optionalÙ¹‚Ù§x¸Whether to keep the constraint components feasible throughout iterations. A single value set this property for all components. Default is False. Has no effect for equality constraints.€Ù°ƒx2finite_diff_rel_step: None or array_like, optional`Ù¹‚Ù§x¨Relative step size for the finite difference approximation. Default is None, which will select a reasonable value automatically depending on a finite difference scheme.€Ù°ƒxEfinite_diff_jac_sparsity: {None, array_like, sparse matrix}, optional`Ù¹‚ƒÙ§x¤Defines the sparsity structure of the Jacobian matrix for finite difference estimation, its shape must be (m, n). If the Jacobian has only few non-zero elements in Ù¨Ù§deachÙ§y row, providing the sparsity structure will greatly speed up the computations. A zero entry means that a corresponding element in the Jacobian is identically zero. If provided, forces the use of 'lsmr' trust-region solver. If None (default) then dense differencing will be used.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x&Nonlinear constraint on the variables.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParameterseNoteshExamplesx/scipy/optimize/_constraints.pyn<class 'type'>x8scipy.signal._filter_design.optimize.NonlinearConstraintÙ¯‚‚Ù¹‚‚Ù§jConstrain Ù¡vx[0] < sin(x[1]) + 1.9€Ù´ƒ˜5Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hoptimizeÙ „escipye1.8.0fmodulenscipy.optimizefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„sNonlinearConstraintÙ „escipye1.8.0fmodulex/scipy.optimize._constraints.NonlinearConstraintfmoduleõÙ±‚`a
Ù±‚`cconÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csinÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`cnlcÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„sNonlinearConstraintÙ „escipye1.8.0fmodulex/scipy.optimize._constraints.NonlinearConstraintfmoduleõÙ±‚`a(Ù±‚`cconÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cinfÙ±‚`a,Ù±‚`a Ù±‚bmfc1.9Ù±‚`a)`fexecedö€e1.8.0Ù«ööx/scipy.optimize._constraints.NonlinearConstraint€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xAArrays are used to determine the optimal prefix of BLAS routines.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x´This routine automatically chooses between Fortran/C interfaces. Fortran code is used whenever possible for arrays with column major order. In all other cases, C code is preferred.€Ù¹‚…Ù§y'In BLAS, the naming convention is that all functions start with a type prefix, which depends on the type of the principal matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy types {float32, float64, complex64, complex128} respectively. The code and the dtype are stored in attributes Ù£ƒhtypecodeööÙ§e and Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§x of the returned functions.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒenamesvstr or sequence of strÙ¹‚Ù§x.Name(s) of BLAS functions without type prefix.€Ù°ƒfarraysxsequence of ndarrays, optionalÙ¹‚Ù§x¯Arrays can be given to determine optimal prefix of BLAS routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used.€Ù°ƒedtypevstr or dtype, optionalÙ¹‚ƒÙ§x!Data-type specifier. Not used if Ù¢„farraysÙ „ööelocalfarrayselocalõÙ§n is non-empty.€Ù°ƒeilp64x${True, False, 'preferred'}, optionalÙ¹‚Ù§x’Whether to return ILP64 routine variant. Choosing 'preferred' returns ILP64 routine if available, and otherwise the 32-bit routine. Default: False€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒefuncsdlistÙ¹‚Ù§x&List containing the found function(s).€ögSummaryÙ¯‚Ù¹‚Ù§x2Return available BLAS function objects from names.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnseNoteshExamplesu/scipy/linalg/blas.pyšr<class 'function'>x2scipy.signal._lti_conversion.linalg.get_blas_funcsÙ¯‚‚Ù´ƒ˜;Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnbLAÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „escipye1.8.0fmodulexscipy.sparse._construct.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`fx_gemvÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bLAÙ±‚aoa.Ù±‚`Ù¢„nget_blas_funcsÙ „escipye1.8.0fmodulex scipy.linalg.blas.get_blas_funcsfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1dgemvÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`fx_gemvÙ±‚aoa.Ù±‚`htypecodec'd'fexecedÙ´ƒ˜Ù±‚`fx_gemvÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bLAÙ±‚aoa.Ù±‚`Ù¢„nget_blas_funcsÙ „escipye1.8.0fmodulex scipy.linalg.blas.get_blas_funcsfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1dgemvÙ±‚bs1a'Ù±‚`a,Ù±‚`a(Ù±‚`aaÙ±‚aoa*Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`fx_gemvÙ±‚aoa.Ù±‚`htypecodec'z'fexecedö€e1.8.0Ù«x9get_blas_funcs(names, arrays=(), dtype=None, ilp64=False)öx scipy.linalg.blas.get_blas_funcs€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§x(Compute a vector x such that the 2-norm Ù¡i|b - A x|Ù§n is minimized.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚‰Ù§eWhen Ù¡g'gelsy'Ù§v is used as a driver, Ù¢„hresiduesÙ „escipye1.8.0fmodulex+scipy.signal._signaltools._compute_residuesfmoduleõÙ§x# is set to a (0,)-shaped array and Ù¢„asÙ „ööelocalaselocalõÙ§k is always Ù¡dNoneÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaaq(M, N) array_likeÙ¹‚Ù§tLeft-hand side array€Ù°ƒabx(M,) or (M, K) array_likeÙ¹‚Ù§uRight hand side array€Ù°ƒdcondofloat, optionalÙ¹‚ƒÙ§xhCutoff for 'small' singular values; used to determine effective rank of a. Singular values smaller than Ù¡xcond * largest_singular_valueÙ§u are considered zero.€Ù°ƒkoverwrite_anbool, optionalÙ¹‚ƒÙ§pDiscard data in Ù¢„aaÙ „ööelocalaaelocalõÙ§x- (may enhance performance). Default is False.€Ù°ƒkoverwrite_bnbool, optionalÙ¹‚ƒÙ§pDiscard data in Ù¢„abÙ „ööelocalabelocalõÙ§x- (may enhance performance). Default is False.€Ù°ƒlcheck_finitenbool, optionalÙ¹‚Ù§xÏWhether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.€Ù°ƒmlapack_drivermstr, optional‚Ù¹‚Ù§xLWhich LAPACK driver is used to solve the least-squares problem. Options are Ù¡g'gelsd'Ù§b, Ù¡g'gelsy'Ù§b, Ù¡g'gelss'Ù§k. Default (Ù¡g'gelsd'Ù§x) is a good choice.  However, Ù¡g'gelsy'Ù§x+ can be slightly faster on many problems.  Ù¡g'gelss'Ù§xC was used historically.  It is generally slow but uses less memory.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.17.0 €öfRaisesÙ¯‚‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§x!If computation does not converge.€Ù°ƒ`jValueErrorÙ¹‚Ù§x#When parameters are not compatible.€öhReceivesÙ¯‚€ögReturnsÙ¯‚„Ù°ƒaxv(N,) or (N, K) ndarrayÙ¹‚Ù§wLeast-squares solution.€Ù°ƒhresiduesu(K,) ndarray or floatÙ¹‚‰Ù§x(Square of the 2-norm for each column in Ù¡gb - a xÙ§e, if Ù¡eM > NÙ§e and Ù¡lndim(A) == nÙ§v (returns a scalar if Ù¡abÙ§x4 is 1-D). Otherwise a (0,)-shaped array is returned.€Ù°ƒdrankcintÙ¹‚ƒÙ§rEffective rank of Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€Ù°ƒasx(min(M, N),) ndarray or NoneÙ¹‚‡Ù§sSingular values of Ù¢„aaÙ „ööelocalaaelocalõÙ§x. The condition number of Ù¡aaÙ§d is Ù¡ls[0] / s[-1]Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§x2Compute least-squares solution to equation Ax = b.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesw/scipy/linalg/_basic.pyr<class 'function'>x%scipy.signal._fir_filter_design.lstsqÙ¯‚ŠÙ´ƒ“Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõ`fexecedÙ¹‚Ù§x#Suppose we have the following data:€Ù´ƒ˜=Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmfc3.5Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmfc8.5Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc0.3Ù±‚`a,Ù±‚`a Ù±‚bmfc1.1Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmfc2.0Ù±‚`a,Ù±‚`a Ù±‚bmfc3.2Ù±‚`a,Ù±‚`a Ù±‚bmfc6.6Ù±‚`a,Ù±‚`a Ù±‚bmfc8.6Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚…Ù§x2We want to fit a quadratic polynomial of the form Ù¡ny = a + b*x**2Ù§xj to this data.  We first form the "design matrix" M, with a constant column of 1s and a column containing Ù¡dx**2Ù§a:€Ù´ƒ—Ù±‚`aMÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`gnewaxisÙ±‚`a]Ù±‚aoa*Ù±‚aoa*Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a
Ù±‚`aMx¯array([[  1.  ,   1.  ],
       [  1.  ,   6.25],
       [  1.  ,  12.25],
       [  1.  ,  16.  ],
       [  1.  ,  25.  ],
       [  1.  ,  49.  ],
       [  1.  ,  72.25]])fexecedÙ¹‚‰Ù§x.We want to find the least-squares solution to Ù¡lM.dot(p) = yÙ§h, where Ù¡apÙ§x5 is a vector with length 2 that holds the parameters Ù¡aaÙ§e and Ù¡abÙ§a.€Ù´ƒ–Ù±‚`apÙ±‚`a,Ù±‚`a Ù±‚`cresÙ±‚`a,Ù±‚`a Ù±‚`crnkÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„elstsqÙ „escipye1.8.0fmodulexscipy.linalg._basic.lstsqfmoduleõÙ±‚`a(Ù±‚`aMÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„apÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõx!array([ 0.20925829,  0.12013861])fexecedÙ¹‚Ù§x#Plot the data and the fitted curve.€Ù´ƒ˜{Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aoÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„ddataÙ „escipye1.8.0fmoduleqscipy.sparse.datafmoduleõÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„bxxÙ „escipye1.8.0fmodulexscipy.special._ufuncs_cxxfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmic101Ù±‚`a)Ù±‚`a
Ù±‚`byyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„apÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„apÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚aoa*Ù±‚`Ù¢„bxxÙ „escipye1.8.0fmodulexscipy.special._ufuncs_cxxfmoduleõÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`Ù¢„bxxÙ „escipye1.8.0fmodulexscipy.special._ufuncs_cxxfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`byyÙ±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1x!least squares fit, $y = a + bx^2$Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1ayÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`jframealphaÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`fshadowÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dgridÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.gridfmoduleõÙ±‚`a(Ù±‚`Ù¢„ealphaÙ „escipye1.8.0fmodulex=scipy.sparse.linalg._expm_multiply.LazyOperatorNormInfo.alphafmoduleõÙ±‚aoa=Ù±‚bmfd0.25Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x#fig-scipy.linalg._basic.lstsq-0.pngöÙ¼ƒÙ»ƒsscipy.optimize.nnlsööÙ¹‚Ù§x3linear least squares with non-negativity constraint€öe1.8.0Ù«xclstsq(a, b, cond=None, overwrite_a=False, overwrite_b=False, check_finite=True, lapack_driver=None)öxscipy.linalg._basic.lstsq€
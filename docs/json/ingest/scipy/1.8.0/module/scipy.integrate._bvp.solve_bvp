Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§xnThis function numerically solves a first order system of ODEs subject to two-point boundary conditions::      €ÙÀxIdy / dx = f(x, y, p) + S * y / (x - a), a <= x <= b
bc(y(a), y(b), p) = 0Ù¹‚Ù§yHere x is a 1-D independent variable, y(x) is an N-D vector-valued function and p is a k-D vector of unknown parameters which is to be found along with y(x). For the problem to be determined, there must be n + k boundary conditions, i.e., bc must be an (n + k)-D function.€Ù¹‚Ù§yNThe last singular term on the right-hand side of the system is optional. It is defined by an n-by-n matrix S, such that the solution must satisfy S y(a) = 0. This condition will be forced during iterations, so it must not contradict boundary conditions. See  for the explanation how this term is handled when solving BVPs numerically.€Ù¹‚Ù§yÆProblems in a complex domain can be solved as well. In this case, y and p are considered to be complex, and f and bc are assumed to be complex-valued functions, but x stays real. Note that f and bc must be complex differentiable (satisfy Cauchy-Riemann equations ), otherwise you should rewrite your problem for real and imaginary parts separately. To solve a problem in a complex domain, pass an initial guess for y with a complex data type (see below).€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§xÜThis function implements a 4th order collocation algorithm with the control of residuals similar to . A collocation system is solved by a damped Newton method with an affine-invariant criterion function as described in .€Ù¹‚Ù§xÍNote that in   integral residuals are defined without normalization by interval lengths. So, their definition is different by a multiplier of h**0.5 (h is an interval length) from the definition used here.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.18.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ŒÙ°ƒcfunhcallableÙ¹‚‘Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(x, y)Ù§e, or Ù¡lfun(x, y, p)Ù§x7 if parameters are present. All arguments are ndarray: Ù¡axÙ§r with shape (m,), Ù¡ayÙ§x! with shape (n, m), meaning that Ù¡gy[:, i]Ù§p corresponds to Ù¡dx[i]Ù§f, and Ù¡apÙ§xb with shape (k,). The return value must be an array with shape (n, m) and with the same layout as Ù¡ayÙ§a.€Ù°ƒbbchcallableÙ¹‚‹Ù§xSFunction evaluating residuals of the boundary conditions. The calling signature is Ù¡jbc(ya, yb)Ù§e, or Ù¡mbc(ya, yb, p)Ù§x7 if parameters are present. All arguments are ndarray: Ù¡byaÙ§e and Ù¡bybÙ§v with shape (n,), and Ù¡apÙ§xH with shape (k,). The return value must be an array with shape (n + k,).€Ù°ƒaxvarray_like, shape (m,)Ù¹‚…Ù§xJInitial mesh. Must be a strictly increasing sequence of real numbers with Ù¡fx[0]=aÙ§e and Ù¡gx[-1]=bÙ§a.€Ù°ƒayxarray_like, shape (n, m)Ù¹‚…Ù§xSInitial guess for the function values at the mesh nodes, ith column corresponds to Ù¡dx[i]Ù§x(. For problems in a complex domain pass Ù¢„ayÙ „ööelocalayelocalõÙ§xE with a complex data type (even if the initial guess is purely real).€Ù°ƒapx,array_like with shape (k,) or None, optionalÙ¹‚Ù§x}Initial guess for the unknown parameters. If None (default), it is assumed that the problem doesn't depend on any parameters.€Ù°ƒaSx$array_like with shape (n, n) or NoneÙ¹‚Ù§xfMatrix defining the singular term. If None (default), the problem is solved without the singular term.€Ù°ƒgfun_jacxcallable or None, optionalÙ¹‚…Ù§xVFunction computing derivatives of f with respect to y and p. The calling signature is Ù¡mfun_jac(x, y)Ù§e, or Ù¡pfun_jac(x, y, p)Ù§x[ if parameters are present. The return must contain 1 or 2 elements in the following order:€Ù°ƒfbc_jacxcallable or None, optionalÙ¹‚…Ù§x]Function computing derivatives of bc with respect to ya, yb, and p. The calling signature is Ù¡nbc_jac(ya, yb)Ù§e, or Ù¡qbc_jac(ya, yb, p)Ù§x[ if parameters are present. The return must contain 2 or 3 elements in the following order:€Ù°ƒctolofloat, optionalÙ¹‚‡Ù§x0Desired tolerance of the solution. If we define Ù¡pr = y' - f(x, y)Ù§xX, where y is the found solution, then the solver tries to achieve on each mesh interval Ù¡xnorm(r / (1 + abs(f)) < tolÙ§h, where Ù¡dnormÙ§xc is estimated in a root mean squared sense (using a numerical quadrature formula). Default is 1e-3.€Ù°ƒimax_nodesmint, optionalÙ¹‚Ù§xaMaximum allowed number of the mesh nodes. If exceeded, the algorithm terminates. Default is 1000.€Ù°ƒgverboses{0, 1, 2}, optionalÙ¹‚Ù§xLevel of algorithm's verbosity:€Ù°ƒfbc_tolofloat, optionalÙ¹‚‡Ù§xADesired absolute tolerance for the boundary condition residuals: Ù¢„bbcÙ „ööelocalbbcelocalõÙ§v value should satisfy Ù¡pabs(bc) < bc_tolÙ§x component-wise. Equals to Ù¢„ctolÙ „ööelocalctolelocalõÙ§xG by default. Up to 10 iterations are allowed to achieve this tolerance.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‹Ù°ƒ`x/Bunch object with the following fields defined:€Ù°ƒcsolePPolyÙ¹‚ƒÙ§xFound solution for y as Ù¢„wscipy.interpolate.PPolyÙ „escipya*capix$scipy.interpolate._interpolate.PPolyfmoduleõÙ§x( instance, a C1 continuous cubic spline.€Ù°ƒapxndarray or None, shape (k,)Ù¹‚Ù§xJFound parameters. None, if the parameters were not present in the problem.€Ù°ƒaxsndarray, shape (m,)Ù¹‚Ù§xNodes of the final mesh.€Ù°ƒayundarray, shape (n, m)Ù¹‚Ù§x"Solution values at the mesh nodes.€Ù°ƒbypundarray, shape (n, m)Ù¹‚Ù§x'Solution derivatives at the mesh nodes.€Ù°ƒmrms_residualswndarray, shape (m - 1,)Ù¹‚ƒÙ§xURMS values of the relative residuals over each mesh interval (see the description of Ù¢„ctolÙ „ööelocalctolelocalõÙ§l parameter).€Ù°ƒenitercintÙ¹‚Ù§xNumber of completed iterations.€Ù°ƒfstatuscint‚Ù¹‚Ù§x!Reason for algorithm termination:€Ù·„x5* 0: The algorithm converged to the desired accuracy.x2* 1: The maximum number of mesh nodes is exceeded.xA* 2: A singular Jacobian encountered when solving the collocationi  system.Ù°ƒgmessagefstringÙ¹‚Ù§x-Verbal description of the termination reason.€Ù°ƒgsuccessdboolÙ¹‚ƒÙ§x9True if the algorithm converged to the desired accuracy (Ù¡hstatus=0Ù§b).€ögSummaryÙ¯‚Ù¹‚Ù§x4Solve a boundary value problem for a system of ODEs.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshExamplesx/scipy/integrate/_bvp.pyÆr<class 'function'>x(scipy.signal._ltisys.integrate.solve_bvpÙ¯‚˜ Ù·‚ty'' + k * exp(y) = 0oy(0) = y(1) = 0Ù¹‚Ù§jfor k = 1.€Ù·‚hy1' = y2ny2' = -exp(y1)Ù´ƒ˜%Ù±‚akcdefÙ±‚`a Ù±‚bnfcfunÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fvstackÙ „enumpyf1.22.3fmodulelnumpy.vstackfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`ayÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cexpÙ „enumpyf1.22.3fmoduleknumpy.ufuncfmoduleõÙ±‚`a(Ù±‚`ayÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a)`fexecedÙ¹‚Ù§x9Implement evaluation of the boundary condition residuals:€Ù´ƒ˜Ù±‚akcdefÙ±‚`a Ù±‚bnfbbcÙ±‚`a(Ù±‚`byaÙ±‚`a,Ù±‚`a Ù±‚`bybÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`byaÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`bybÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚Ù§x%Define the initial mesh with 5 nodes:€Ù´ƒÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)`fexecedÙ¹‚Ù§x–This problem is known to have two solutions. To obtain both of them, we use two different initial guesses for y. We denote them by subscripts a and b.€Ù´ƒ˜,Ù±‚`Ù¢„cy_aÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dsizeÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cy_bÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dsizeÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cy_bÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia3`fexecedÙ¹‚Ù§x#Now we are ready to run the solver.€Ù´ƒ˜-Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„iintegrateÙ „escipye1.8.0fmoduleoscipy.integratefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„isolve_bvpÙ „escipye1.8.0fmodulexscipy.integrate._bvp.solve_bvpfmoduleõÙ±‚`a
Ù±‚`eres_aÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_bvpÙ „escipye1.8.0fmodulexscipy.integrate._bvp.solve_bvpfmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`bbcÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„cy_aÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`eres_bÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_bvpÙ „escipye1.8.0fmodulexscipy.integrate._bvp.solve_bvpfmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`bbcÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„cy_bÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)`fexecedÙ¹‚Ù§xzLet's plot the two found solutions. We take an advantage of having the solution in a spline form to produce a smooth plot.€Ù´ƒ˜vÙ±‚`fx_plotÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a)Ù±‚`a
Ù±‚`hy_plot_aÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`eres_aÙ±‚aoa.Ù±‚`csolÙ±‚`a(Ù±‚`fx_plotÙ±‚`a)Ù±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`hy_plot_bÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`eres_bÙ±‚aoa.Ù±‚`csolÙ±‚`a(Ù±‚`fx_plotÙ±‚`a)Ù±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`fx_plotÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„hy_plot_aÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1cy_aÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`fx_plotÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„hy_plot_bÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`elabelÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1cy_bÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„flegendÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.legendfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x(fig-scipy.integrate._bvp.solve_bvp-0.pngÙ¹‚Ù§xTWe see that the two solutions have similar shape, but differ in scale significantly.€Ù·‚ry'' + k**2 * y = 0oy(0) = y(1) = 0Ù·iy'(0) = kÙ·‚hy1' = y2py2' = -k**2 * y1Ù´ƒ˜4Ù±‚akcdefÙ±‚`a Ù±‚bnfcfunÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`apÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`akÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`apÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fvstackÙ „enumpyf1.22.3fmodulelnumpy.vstackfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`ayÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`akÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`ayÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)Ù±‚`a)`fexecedÙ¹‚Ù§xMNote that parameters p are passed as a vector (with one element in our case).€Ù¹‚Ù§x"Implement the boundary conditions:€Ù´ƒ˜6Ù±‚akcdefÙ±‚`a Ù±‚bnfbbcÙ±‚`a(Ù±‚`byaÙ±‚`a,Ù±‚`a Ù±‚`bybÙ±‚`a,Ù±‚`a Ù±‚`apÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`akÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`apÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „escipye1.8.0fmodulex(scipy.integrate._ode.ode.get_return_codefmoduleõÙ±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`byaÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`bybÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`byaÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`akÙ±‚`a]Ù±‚`a)`fexecedÙ¹‚Ù§x Set up the initial mesh and guess for y. We aim to find the solution for k = 2 * pi, to achieve that we set values of y to approximately follow sin(2 * pi * x):€Ù´ƒ˜;Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dsizeÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`a
Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia1`fexecedÙ¹‚Ù§x0Run the solver with 6 as an initial guess for k.€Ù´ƒ˜Ù±‚`csolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„isolve_bvpÙ „escipye1.8.0fmodulexscipy.integrate._bvp.solve_bvpfmoduleõÙ±‚`a(Ù±‚`cfunÙ±‚`a,Ù±‚`a Ù±‚`bbcÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`apÙ±‚aoa=Ù±‚`a[Ù±‚bmia6Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚Ù§x1We see that the found k is approximately correct:€Ù´ƒ†Ù±‚`csolÙ±‚aoa.Ù±‚`apÙ±‚`a[Ù±‚bmia0Ù±‚`a]m6.28329460046fexecedÙ¹‚Ù§x@And, finally, plot the solution to see the anticipated sinusoid:€Ù´ƒ˜@Ù±‚`fx_plotÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fy_plotÙ „escipye1.8.0fmodulex)scipy.spatial._plotutils.delaunay_plot_2dfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`csolÙ±‚aoa.Ù±‚`csolÙ±‚`a(Ù±‚`fx_plotÙ±‚`a)Ù±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.plotfmoduleõÙ±‚`a(Ù±‚`fx_plotÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fy_plotÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fxlabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.xlabelfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„fylabelÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.ylabelfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸x(fig-scipy.integrate._bvp.solve_bvp-1.pngö€e1.8.0Ù«xvsolve_bvp(fun, bc, x, y, p=None, S=None, fun_jac=None, bc_jac=None, tol=0.001, max_nodes=1000, verbose=0, bc_tol=None)öxscipy.integrate._bvp.solve_bvp€
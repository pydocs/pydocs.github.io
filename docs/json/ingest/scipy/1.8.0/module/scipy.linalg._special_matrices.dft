Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x±Create the matrix that computes the discrete Fourier transform of a sequence . The nth primitive root of unity used to generate the matrix is exp(-2*pi*i/n), where i = sqrt(-1).€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚‡Ù§eWhen Ù¢„escaleÙ „ööelocalescaleelocalõÙ§x9 is None, multiplying a vector by the matrix returned by Ù¢„cdftÙ „escipye1.8.0fmodulex"scipy.linalg._special_matrices.dftfmoduleõÙ§x] is mathematically equivalent to (but much less efficient than) the calculation performed by Ù¢„mscipy.fft.fftÙ „escipya*capitscipy.fft._basic.fftfmoduleõÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.14.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒancintÙ¹‚Ù§xSize the matrix to create.€Ù°ƒescalemstr, optionalÙ¹‚‹Ù§x"Must be None, 'sqrtn', or 'n'. If Ù¢„escaleÙ „ööelocalescaleelocalõÙ§x& is 'sqrtn', the matrix is divided by Ù£ƒgsqrt(n)ööÙ§e. If Ù¢„escaleÙ „ööelocalescaleelocalõÙ§x" is 'n', the matrix is divided by Ù¢„anÙ „ööelocalanelocalõÙ§e. If Ù¢„escaleÙ „ööelocalescaleelocalõÙ§x‚ is None (the default), the matrix is not normalized, and the return value is simply the Vandermonde matrix of the roots of unity.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒamn(n, n) ndarrayÙ¹‚Ù§oThe DFT matrix.€ögSummaryÙ¯‚Ù¹‚Ù§x"Discrete Fourier transform matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshExamplesx"/scipy/linalg/_special_matrices.pyÌr<class 'function'>x'scipy.signal._lti_conversion.linalg.dftÙ¯‚„Ù´ƒ˜$Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cdftÙ „escipye1.8.0fmodulex"scipy.linalg._special_matrices.dftfmoduleõÙ±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pset_printoptionsÙ „enumpyf1.22.3fmodulevnumpy.set_printoptionsfmoduleõÙ±‚`a(Ù±‚`Ù¢„iprecisionÙ „escipye1.8.0fmodulex*scipy.optimize._shgo.SHGO.finite_precisionfmoduleõÙ±‚aoa=Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`hsuppressÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1t# for compact outputÙ±‚`a
Ù±‚`amÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cdftÙ „escipye1.8.0fmodulex"scipy.linalg._special_matrices.dftfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a)Ù±‚`a
Ù±‚`amyrarray([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ],
       [ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j],
       [ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j],
       [ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j],
       [ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]])fexecedÙ´ƒ˜ Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`amÙ±‚`a Ù±‚aoa@Ù±‚`a Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`b  Ù±‚bc1v# Compute the DFT of xxHarray([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])fexecedÙ¹‚…Ù§lVerify that Ù¡em @ xÙ§p is the same as Ù¡ffft(x)Ù§a.€Ù´ƒÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a
Ù±‚`Ù¢„cfftÙ „escipye1.8.0fmoduleiscipy.fftfmoduleõÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`e     Ù±‚bc1v# Same result as m @ xxHarray([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])fexecedö€e1.8.0Ù«rdft(n, scale=None)öx"scipy.linalg._special_matrices.dft€
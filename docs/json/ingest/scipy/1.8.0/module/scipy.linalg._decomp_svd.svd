Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§vFactorizes the matrix Ù¢„aaÙ „ööelocalaaelocalõÙ§x into two unitary matrices Ù¡aUÙ§e and Ù¡bVhÙ§r, and a 1-D array Ù¡asÙ§x3 of singular values (real, non-negative) such that Ù¡oa == U @ S @ VhÙ§h, where Ù¡aSÙ§x9 is a suitably shaped matrix of zeros with main diagonal Ù¡asÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒaaq(M, N) array_likeÙ¹‚Ù§tMatrix to decompose.€Ù°ƒmfull_matricesnbool, optionalÙ¹‚Ù§sIf True (default), Ù¢„aUÙ „ööelocalaUelocalõÙ§e and Ù¢„bVhÙ „ööelocalbVhelocalõÙ§n are of shape Ù¡f(M, M)Ù§b, Ù¡f(N, N)Ù§x. If False, the shapes are Ù¡f(M, K)Ù§e and Ù¡f(K, N)Ù§h, where Ù¡mK = min(M, N)Ù§a.€Ù°ƒjcompute_uvnbool, optionalÙ¹‚‡Ù§xWhether to compute also Ù¡aUÙ§e and Ù¡bVhÙ§p in addition to Ù¡asÙ§r. Default is True.€Ù°ƒkoverwrite_anbool, optionalÙ¹‚ƒÙ§uWhether to overwrite Ù¢„aaÙ „ööelocalaaelocalõÙ§x,; may improve performance. Default is False.€Ù°ƒlcheck_finitenbool, optionalÙ¹‚Ù§xÎWhether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.€Ù°ƒmlapack_driverx{'gesdd', 'gesvd'}, optional‚Ù¹‚‰Ù§x?Whether to use the more efficient divide-and-conquer approach (Ù¡g'gesdd'Ù§x#) or general rectangular approach (Ù¡g'gesvd'Ù§x0) to compute the SVD. MATLAB and Octave use the Ù¡g'gesvd'Ù§v approach. Default is Ù¡g'gesdd'Ù§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e0.18 €öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§x%If SVD computation does not converge.€öhReceivesÙ¯‚€ögReturnsÙ¯‚„Ù°ƒaUgndarrayÙ¹‚‡Ù§xAUnitary matrix having left singular vectors as columns. Of shape Ù¡f(M, M)Ù§d or Ù¡f(M, K)Ù§o, depending on Ù¢„mfull_matricesÙ „ööelocalmfull_matriceselocalõÙ§a.€Ù°ƒasgndarrayÙ¹‚ƒÙ§xIThe singular values, sorted in non-increasing order. Of shape (K,), with Ù¡mK = min(M, N)Ù§a.€Ù°ƒbVhgndarrayÙ¹‚‡Ù§x?Unitary matrix having right singular vectors as rows. Of shape Ù¡f(N, N)Ù§d or Ù¡f(K, N)Ù§n depending on Ù¢„mfull_matricesÙ „ööelocalmfull_matriceselocalõÙ§a.€Ù°ƒ`x1For ``compute_uv=False``, only ``s`` is returned.€ögSummaryÙ¯‚Ù¹‚Ù§xSingular Value Decomposition.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsohExamplesx/scipy/linalg/_decomp_svd.pyr<class 'function'>x'scipy.signal._lti_conversion.linalg.svdÙ¯‚‡Ù´ƒ˜eÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a
Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„kdefault_rngÙ „enumpyf1.22.3fmodulex#numpy.random._generator.default_rngfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`amÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`a(Ù±‚`amÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfb1.Ù±‚`ajÙ±‚aoa*Ù±‚`Ù¢„crngÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`a(Ù±‚`amÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aUÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚`bVhÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csvdÙ „escipye1.8.0fmodulexscipy.linalg._decomp_svd.svdfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„aUÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapeÙ±‚`a,Ù±‚`b  Ù±‚`Ù¢„asÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bVhÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapev((9, 9), (6,), (6, 6))fexecedÙ¹‚Ù§x7Reconstruct the original matrix from the decomposition:€Ù´ƒ˜QÙ±‚`Ù¢„esigmaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`amÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚akcforÙ±‚`a Ù±‚`aiÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚bnbÙ¢„cminÙ „escipye1.8.0fmodulex$scipy.sparse._data._minmax_mixin.minfmoduleõÙ±‚`a(Ù±‚`amÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`Ù¢„esigmaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚`aiÙ±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„asÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a[Ù±‚`aiÙ±‚`a]Ù±‚`a
Ù±‚`ba1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aUÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„esigmaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bVhÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ba1Ù „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedÙ¹‚‰Ù§sAlternatively, use Ù¡sfull_matrices=FalseÙ§x (notice that the shape of Ù¡aUÙ§i is then Ù¡f(m, n)Ù§l instead of Ù¡f(m, m)Ù§b):€Ù´ƒ˜#Ù±‚`aUÙ±‚`a,Ù±‚`a Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚`bVhÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csvdÙ „escipye1.8.0fmodulexscipy.linalg._decomp_svd.svdfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`mfull_matricesÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„aUÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„asÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapeÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bVhÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`eshapev((9, 6), (6,), (6, 6))fexecedÙ´ƒ˜$Ù±‚`aSÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ddiagÙ „enumpyf1.22.3fmodulejnumpy.diagfmoduleõÙ±‚`a(Ù±‚`Ù¢„asÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`Ù¢„aUÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`Ù¢„aSÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„bVhÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a)dTruefexecedÙ´ƒ˜Ù±‚`bs2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„csvdÙ „escipye1.8.0fmodulexscipy.linalg._decomp_svd.svdfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`jcompute_uvÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`Ù¢„asÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bs2Ù±‚`a)dTruefexecedö‚Ù¼ƒÙ»ƒgdiagsvdx scipy.linalg._decomp_svd.diagsvdõÙ¹‚Ù§x/Construct the Sigma matrix, given the vector s.€öÙ¼ƒÙ»ƒgsvdvalsx scipy.linalg._decomp_svd.svdvalsõÙ¹‚Ù§x$Compute singular values of a matrix.€öe1.8.0Ù«xhsvd(a, full_matrices=True, compute_uv=True, overwrite_a=False, check_finite=True, lapack_driver='gesdd')öxscipy.linalg._decomp_svd.svd€
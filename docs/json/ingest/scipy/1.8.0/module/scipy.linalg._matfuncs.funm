Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‰Ù§x,Returns the value of matrix-valued function Ù¡afÙ§d at Ù¢„aAÙ „ööelocalaAelocalõÙ§o. The function Ù¡afÙ§x/ is an extension of the scalar-valued function Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§m to matrices.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§xcThis function implements the general algorithm based on Schur decomposition (Algorithm 9.1.1. in ).€Ù¹‚Ù§x¦If the input matrix is known to be diagonalizable, then relying on the eigendecomposition is likely to be faster. For example, if your matrix is Hermitian, you can do€ÙÀym>>> from scipy.linalg import eigh
>>> def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaAq(N, N) array_likeÙ¹‚Ù§x(Matrix at which to evaluate the function€Ù°ƒdfunchcallableÙ¹‚Ù§x]Callable object that evaluates a scalar function f. Must be vectorized (eg. using vectorize).€Ù°ƒddispnbool, optionalÙ¹‚Ù§xmPrint warning if error in the result is estimated large instead of returning estimated error. (Default: True)€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒdfunmn(N, N) ndarrayÙ¹‚‚Ù§x<Value of the matrix function specified by func evaluated at Ù¢„aAÙ „ööelocalaAelocalõ€Ù°ƒferrestefloat‚Ù¹‚Ù§r(if disp == False)€Ù¹‚Ù§x21-norm of the estimated error, ||err||_1 / ||A||_1€ögSummaryÙ¯‚Ù¹‚Ù§x3Evaluate a matrix function specified by a callable.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshExampleseNotesjReferencesx/scipy/linalg/_matfuncs.pyèr<class 'function'>x(scipy.signal._lti_conversion.linalg.funmÙ¯‚‚Ù´ƒ˜2Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„dfunmÙ „escipye1.8.0fmodulexscipy.linalg._matfuncs.funmfmoduleõÙ±‚`a
Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc3.0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc4.0Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„dfunmÙ „escipye1.8.0fmodulexscipy.linalg._matfuncs.funmfmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚aoa*Ù±‚`axÙ±‚`a)x*array([[  4.,  15.],
       [  5.,  19.]])fexecedÙ´ƒ†Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)x*array([[  4.,  15.],
       [  5.,  19.]])fexecedö€e1.8.0Ù«xfunm(A, func, disp=True)öxscipy.linalg._matfuncs.funm€
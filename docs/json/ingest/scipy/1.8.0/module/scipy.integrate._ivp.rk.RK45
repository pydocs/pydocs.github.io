Ùª­jAttributesÙ¯‚‹Ù°ƒancintÙ¹‚Ù§tNumber of equations.€Ù°ƒfstatusfstringÙ¹‚Ù§x@Current status of the solver: 'running', 'finished' or 'failed'.€Ù°ƒgt_boundefloatÙ¹‚Ù§nBoundary time.€Ù°ƒidirectionefloatÙ¹‚Ù§x Integration direction: +1 or -1.€Ù°ƒatefloatÙ¹‚Ù§mCurrent time.€Ù°ƒaygndarrayÙ¹‚Ù§nCurrent state.€Ù°ƒet_oldefloatÙ¹‚Ù§x.Previous time. None if no steps were made yet.€Ù°ƒistep_sizeefloatÙ¹‚Ù§xASize of the last successful step. None if no steps were made yet.€Ù°ƒdnfevcintÙ¹‚Ù§x3Number evaluations of the system's right-hand side.€Ù°ƒdnjevcintÙ¹‚Ù§xcNumber of evaluations of the Jacobian. Is always 0 for this solver as it does not use the Jacobian.€Ù°ƒcnlucintÙ¹‚Ù§x9Number of LU decompositions. Is always 0 for this solver.€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§yThis uses the Dormand-Prince pair of formulas . The error is controlled assuming accuracy of the fourth-order method accuracy, but steps are taken using the fifth-order accurate formula (local extrapolation is done). A quartic interpolation polynomial is used for the dense output .€Ù¹‚Ù§x%Can be applied in the complex domain.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒcfunhcallableÙ¹‚Ù§x8Right-hand side of the system. The calling signature is Ù¡ifun(t, y)Ù§g. Here Ù¡atÙ§x8 is a scalar, and there are two options for the ndarray Ù¡ayÙ§x&: It can either have shape (n,); then Ù¡cfunÙ§xV must return array_like with shape (n,). Alternatively it can have shape (n, k); then Ù¡cfunÙ§xb must return an array_like with shape (n, k), i.e., each column corresponds to a single column in Ù¡ayÙ§x6. The choice between the two options is determined by Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§v argument (see below).€Ù°ƒbt0efloatÙ¹‚Ù§mInitial time.€Ù°ƒby0varray_like, shape (n,)Ù¹‚Ù§nInitial state.€Ù°ƒgt_boundefloatÙ¹‚Ù§xnBoundary time - the integration won't continue beyond it. It also determines the direction of the integration.€Ù°ƒjfirst_stepwfloat or None, optionalÙ¹‚ƒÙ§xInitial step size. Default is Ù¡dNoneÙ§x. which means that the algorithm should choose.€Ù°ƒhmax_stepofloat, optionalÙ¹‚Ù§xuMaximum allowed step size. Default is np.inf, i.e., the step size is not bounded and determined solely by the solver.€Ù°ƒjrtol, atolxfloat and array_like, optionalÙ¹‚˜#Ù§xWRelative and absolute tolerances. The solver keeps the local error estimates less than Ù¡tatol + rtol * abs(y)Ù§g. Here Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x@ controls a relative accuracy (number of correct digits), while Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xW controls absolute accuracy (number of correct decimal places). To achieve the desired Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§f, set Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x= to be lower than the lowest value that can be expected from Ù¡mrtol * abs(y)Ù§i so that Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§x# dominates the allowable error. If Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§p is larger than Ù¡mrtol * abs(y)Ù§xT the number of correct digits is not guaranteed. Conversely, to achieve the desired Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§e set Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§k such that Ù¡mrtol * abs(y)Ù§v is always lower than Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xT. If components of y have different scales, it might be beneficial to set different Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§xK values for different components by passing array_like with shape (n,) for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§x. Default values are 1e-3 for Ù¢„drtolÙ „ööelocaldrtolelocalõÙ§n and 1e-6 for Ù¢„datolÙ „escipye1.8.0fmodulex/scipy.sparse.linalg._isolve.iterative._get_atolfmoduleõÙ§a.€Ù°ƒjvectorizednbool, optionalÙ¹‚ƒÙ§hWhether Ù¢„cfunÙ „ööelocalcfunelocalõÙ§x: is implemented in a vectorized fashion. Default is False.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x*Explicit Runge-Kutta method of order 5(4).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersjAttributesjReferencesx/scipy/integrate/_ivp/rk.pyn<class 'type'>x#scipy.signal._ltisys.integrate.RK45Ù¯‚€ö€e1.8.0Ù«ööxscipy.integrate._ivp.rk.RK45€
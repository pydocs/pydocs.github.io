Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‡Ù§iConvolve Ù¢„cin1Ù „ööelocalcin1elocalõÙ§e and Ù¢„cin2Ù „escipye1.8.0fmodulex'scipy.signal._fir_filter_design.firwin2fmoduleõÙ§x), with the output size determined by the Ù¢„dmodeÙ „ööelocaldmodeelocalõÙ§j argument.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚‘Ù§lBy default, Ù¢„hconvolveÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.convolvefmoduleõÙ§e and Ù¢„icorrelateÙ „escipye1.8.0fmodulex#scipy.signal._signaltools.correlatefmoduleõÙ§e use Ù¡mmethod='auto'Ù§n, which calls Ù¢„rchoose_conv_methodÙ „escipye1.8.0fmodulex,scipy.signal._signaltools.choose_conv_methodfmoduleõÙ§x9 to choose the fastest method using pre-computed values (Ù¢„rchoose_conv_methodÙ „escipye1.8.0fmodulex,scipy.signal._signaltools.choose_conv_methodfmoduleõÙ§xF can also measure real-world timing with a keyword argument). Because Ù¢„kfftconvolveÙ „escipye1.8.0fmodulex%scipy.signal._signaltools.fftconvolvefmoduleõÙ§xP relies on floating point numbers, there are certain constraints that may force Ù£ƒmmethod=directööÙ§q (more detail in Ù¢„rchoose_conv_methodÙ „escipye1.8.0fmodulex,scipy.signal._signaltools.choose_conv_methodfmoduleõÙ§l docstring).€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒcin1jarray_likeÙ¹‚Ù§lFirst input.€Ù°ƒcin2jarray_likeÙ¹‚ƒÙ§x;Second input. Should have the same number of dimensions as Ù¢„cin1Ù „ööelocalcin1elocalõÙ§a.€Ù°ƒdmodex'str {'full', 'valid', 'same'}, optional‚Ù¹‚Ù§x+A string indicating the size of the output:€ÙÁƒÙÅ‚Ù¹‚Ù¡dfull€Ù¹‚Ù§xNThe output is the full discrete linear convolution    of the inputs. (Default)€ÙÅ‚Ù¹‚Ù¡evalid€Ù¹‚…Ù§xlThe output consists only of those elements that do not    rely on the zero-padding. In 'valid' mode, either Ù¢„cin1Ù „ööelocalcin1elocalõÙ§d or Ù¢„cin2Ù „escipye1.8.0fmodulex'scipy.signal._fir_filter_design.firwin2fmoduleõÙ§x>    must be at least as large as the other in every dimension.€ÙÅ‚Ù¹‚Ù¡dsame€Ù¹‚ƒÙ§xThe output is the same size as Ù¢„cin1Ù „ööelocalcin1elocalõÙ§x0, centered    with respect to the 'full' output.€Ù°ƒfmethodx'str {'auto', 'direct', 'fft'}, optional‚Ù¹‚Ù§xEA string indicating which method to use to calculate the convolution.€ÙÁƒÙÅ‚Ù¹‚Ù¡fdirect€Ù¹‚Ù§xSThe convolution is determined directly from sums, the definition of    convolution.€ÙÅ‚Ù¹‚Ù¡cfft€Ù¹‚ƒÙ§xGThe Fourier Transform is used to perform the convolution by calling    Ù¢„kfftconvolveÙ „escipye1.8.0fmodulex%scipy.signal._signaltools.fftconvolvefmoduleõÙ§a.€ÙÅ‚Ù¹‚Ù¡dauto€‚Ù¹‚Ù§x€Automatically chooses direct or Fourier method based on an estimate    of which is faster (default).  See Notes for more detail.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.19.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒhconvolveearrayÙ¹‚…Ù§xQAn N-dimensional array containing a subset of the discrete linear convolution of Ù¢„cin1Ù „ööelocalcin1elocalõÙ§f with Ù¢„cin2Ù „escipye1.8.0fmodulex'scipy.signal._fir_filter_design.firwin2fmoduleõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x"Convolve two N-dimensional arrays.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/scipy/signal/_signaltools.pyr<class 'function'>uscipy.signal.convolveÙ¯‚ƒÙ¹‚Ù§x*Smooth a square pulse using a Hann window:€Ù´ƒ˜FÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚`a
Ù±‚`csigÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frepeatÙ „enumpyf1.22.3fmodulelnumpy.repeatfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfb0.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a)Ù±‚`a
Ù±‚`cwinÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gwindowsÙ „escipye1.8.0fmoduletscipy.signal.windowsfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dhannÙ „escipye1.8.0fmoduleqscipy.signal.hannfmoduleõÙ±‚`a(Ù±‚bmib50Ù±‚`a)Ù±‚`a
Ù±‚`hfilteredÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fsignalÙ „escipye1.8.0fmodulelscipy.signalfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hconvolveÙ „escipye1.8.0fmodulex"scipy.signal._signaltools.convolvefmoduleõÙ±‚`a(Ù±‚`Ù¢„csigÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`cwinÙ±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dsameÙ±‚bs1a'Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bnbcsumÙ±‚`a(Ù±‚`cwinÙ±‚`a)`fexecedÙ´ƒ˜Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`cfigÙ±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`gax_origÙ±‚`a,Ù±‚`a Ù±‚`fax_winÙ±‚`a,Ù±‚`a Ù±‚`gax_filtÙ±‚`a)Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hsubplotsÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.subplotsfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`fsharexÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_origÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulexmatplotlib.axes._axes.Axes.plotfmoduleõÙ±‚`a(Ù±‚`Ù¢„csigÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_origÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„iset_titleÙ „jmatplotlibe3.5.1fmodulex$matplotlib.axes._axes.Axes.set_titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1nOriginal pulseÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_origÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gmarginsÙ „jmatplotlibe3.5.1fmodulex'matplotlib.axes._base._AxesBase.marginsfmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.1Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fax_winÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulexmatplotlib.axes._axes.Axes.plotfmoduleõÙ±‚`a(Ù±‚`cwinÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„fax_winÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„iset_titleÙ „jmatplotlibe3.5.1fmodulex$matplotlib.axes._axes.Axes.set_titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1wFilter impulse responseÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„fax_winÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gmarginsÙ „jmatplotlibe3.5.1fmodulex'matplotlib.axes._base._AxesBase.marginsfmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.1Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_filtÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dplotÙ „jmatplotlibe3.5.1fmodulexmatplotlib.axes._axes.Axes.plotfmoduleõÙ±‚`a(Ù±‚`hfilteredÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_filtÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„iset_titleÙ „jmatplotlibe3.5.1fmodulex$matplotlib.axes._axes.Axes.set_titlefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1oFiltered signalÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„gax_filtÙ „jmatplotlibe3.5.1fmodulex%matplotlib.axes._subplots.AxesSubplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gmarginsÙ „jmatplotlibe3.5.1fmodulex'matplotlib.axes._base._AxesBase.marginsfmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmfc0.1Ù±‚`a)Ù±‚`a
Ù±‚`cfigÙ±‚aoa.Ù±‚`ltight_layoutÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`cfigÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „escipye1.8.0fmodulex%scipy.optimize._optimize.show_optionsfmoduleõÙ±‚`a(Ù±‚`a)`fexecedö„Ù¼ƒÙ»ƒrchoose_conv_methodx,scipy.signal._signaltools.choose_conv_methodõÙ¹‚Ù§x2chooses the fastest appropriate convolution method€öÙ¼ƒÙ»ƒkfftconvolvex%scipy.signal._signaltools.fftconvolveõÙ¹‚Ù§xAlways uses the FFT method.€öÙ¼ƒÙ»ƒmnumpy.polymulmnumpy.polymulõÙ¹‚Ù§xTperforms polynomial multiplication (same operation, but also accepts poly1d objects)€öÙ¼ƒÙ»ƒjoaconvolvex$scipy.signal._signaltools.oaconvolveõÙ¹‚Ù§xUses the overlap-add method to do convolution, which is generally faster when the input arrays are large and significantly different in size.€öe1.8.0Ù«x.convolve(in1, in2, mode='full', method='auto')öx"scipy.signal._signaltools.convolve€
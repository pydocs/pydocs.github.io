Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§vThe DARE is defined as€Ù¤x;A^HXA - X - ( A^HXB) ( R + B^HXB)^ { - 1} ( B^HXA) + Q = 0 Ù¹‚Ù§x-The limitations for a solution to exist are :€Ù·…x?* All eigenvalues of :math:`A` outside the unit disc, should beo  controllable.`x;* The associated symplectic pencil (See Notes), should havex5  eigenvalues sufficiently away from the unit circle.Ù¹‚‡Ù§mMoreover, if Ù¡aeÙ§e and Ù¡asÙ§x are not both precisely Ù¡dNoneÙ§x&, then the generalized version of DARE€Ù¤xCA^HXA - E^HXE - ( A^HXB+S) ( R+B^HXB)^ { - 1} ( B^HXA+S^H) + Q = 0 Ù¹‚…Ù§xis solved. When omitted, Ù¡aeÙ§x# is assumed to be the identity and Ù¡asÙ§x" is assumed to be the zero matrix.€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚ƒÙ§x[The equation is solved by forming the extended symplectic matrix pencil, as described in , Ù¥mH - \lambda JÙ§x( given by the block matrices ::         €ÙÀxz[  A   0   B ]             [ E   0   B ]
[ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ]
[ S^H  0   R ]             [ 0 -B^H  0 ]Ù¹‚Ù§x$and using a QZ decomposition method.€Ù¹‚‡Ù§xQIn this algorithm, the fail conditions are linked to the symmetry of the product Ù¥lU_2 U_1^{-1}Ù§x and condition number of Ù¥cU_1Ù§h. Here, Ù¥aUÙ§x¢ is the 2m-by-m matrix that holds the eigenvectors spanning the stable subspace with 2-m rows and partitioned into two m-row matrices. See  and  for more details.€Ù¹‚…Ù§x€In order to improve the QZ decomposition accuracy, the pencil goes through a balancing step where the sum of absolute values of Ù¥aHÙ§e and Ù¥aJÙ§xÆ rows/cols (after removing the diagonal entries) is balanced following the recipe given in . If the data has small numerical noise, balancing may amplify their effects and some clean up is required.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaaq(M, M) array_likeÙ¹‚Ù§mSquare matrix€Ù°ƒabq(M, N) array_likeÙ¹‚Ù§eInput€Ù°ƒaqq(M, M) array_likeÙ¹‚Ù§eInput€Ù°ƒarq(N, N) array_likeÙ¹‚Ù§mSquare matrix€Ù°ƒaex(M, M) array_like, optionalÙ¹‚Ù§xNonsingular square matrix€Ù°ƒasx(M, N) array_like, optionalÙ¹‚Ù§eInput€Ù°ƒhbalanceddboolÙ¹‚Ù§xiThe boolean that indicates whether a balancing step is performed on the data. The default is set to True.€öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§xzFor cases where the stable subspace of the pencil could not be isolated. See Notes section and the references for details.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaxn(M, M) ndarrayÙ¹‚Ù§x4Solution to the discrete algebraic Riccati equation.€ögSummaryÙ¯‚Ù¹‚Ù§x;Solves the discrete-time algebraic Riccati equation (DARE).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotesjReferenceshExamplesx/scipy/linalg/_solvers.pyr<class 'function'>x6scipy.signal._lti_conversion.linalg.solve_discrete_areÙ¯‚ƒÙ¹‚‹Ù§fGiven Ù¢„aaÙ „ööelocalaaelocalõÙ§b, Ù¢„abÙ „ööelocalabelocalõÙ§b, Ù¢„aqÙ „ööelocalaqelocalõÙ§f, and Ù¢„arÙ „ööelocalarelocalõÙ§k solve for Ù¢„axÙ „ööelocalaxelocalõÙ§a:€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚`blaÙ±‚`a
Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚aoa-Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„arÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`blaÙ±‚aoa.Ù±‚`Ù¢„rsolve_discrete_areÙ „escipye1.8.0fmodulex(scipy.linalg._solvers.solve_discrete_arefmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„arÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`axx&array([[-4., -4.],
       [-4.,  7.]])fexecedÙ´ƒ˜YÙ±‚`aRÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`blaÙ±‚aoa.Ù±‚`esolveÙ±‚`a(Ù±‚`Ù¢„arÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`aTÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`aTÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„axÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aRÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedöÙ¼ƒÙ»ƒtsolve_continuous_arex*scipy.linalg._solvers.solve_continuous_areõÙ¹‚Ù§x0Solves the continuous algebraic Riccati equation€öe1.8.0Ù«x=solve_discrete_are(a, b, q, r, e=None, s=None, balanced=True)öx(scipy.linalg._solvers.solve_discrete_are€
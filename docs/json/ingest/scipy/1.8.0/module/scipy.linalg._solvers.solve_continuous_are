Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§vThe CARE is defined as€Ù¤x*X A + A^H X - X B R^ { - 1} B^H X + Q = 0 Ù¹‚Ù§x-The limitations for a solution to exist are :€Ù·…xA* All eigenvalues of :math:`A` on the right half plane, should beo  controllable.`x<* The associated hamiltonian pencil (See Notes), should havex8  eigenvalues sufficiently away from the imaginary axis.Ù¹‚‡Ù§mMoreover, if Ù¡aeÙ§d or Ù¡asÙ§r is not precisely Ù¡dNoneÙ§x&, then the generalized version of CARE€Ù¤x>E^HXA + A^HXE - ( E^HXB + S) R^ { - 1} ( B^HXE + S^H) + Q = 0 Ù¹‚‰Ù§xis solved. When omitted, Ù¡aeÙ§x# is assumed to be the identity and Ù¡asÙ§x= is assumed to be the zero matrix with sizes compatible with Ù¡aaÙ§e and Ù¡abÙ§o, respectively.€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚ƒÙ§x\The equation is solved by forming the extended hamiltonian matrix pencil, as described in , Ù¥mH - \lambda JÙ§x% given by the block matrices ::      €ÙÀx€[ A    0    B ]             [ E   0    0 ]
[-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ]
[ S^H B^H   R ]             [ 0   0    0 ]Ù¹‚Ù§x$and using a QZ decomposition method.€Ù¹‚‡Ù§xQIn this algorithm, the fail conditions are linked to the symmetry of the product Ù¥lU_2 U_1^{-1}Ù§x and condition number of Ù¥cU_1Ù§h. Here, Ù¥aUÙ§x¢ is the 2m-by-m matrix that holds the eigenvectors spanning the stable subspace with 2-m rows and partitioned into two m-row matrices. See  and  for more details.€Ù¹‚…Ù§x€In order to improve the QZ decomposition accuracy, the pencil goes through a balancing step where the sum of absolute values of Ù¥aHÙ§e and Ù¥aJÙ§xe entries (after removing the diagonal entries of the sum) is balanced following the recipe given in .€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g0.11.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaaq(M, M) array_likeÙ¹‚Ù§mSquare matrix€Ù°ƒabq(M, N) array_likeÙ¹‚Ù§eInput€Ù°ƒaqq(M, M) array_likeÙ¹‚Ù§eInput€Ù°ƒarq(N, N) array_likeÙ¹‚Ù§xNonsingular square matrix€Ù°ƒaex(M, M) array_like, optionalÙ¹‚Ù§xNonsingular square matrix€Ù°ƒasx(M, N) array_like, optionalÙ¹‚Ù§eInput€Ù°ƒhbalancednbool, optionalÙ¹‚Ù§xiThe boolean that indicates whether a balancing step is performed on the data. The default is set to True.€öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§xzFor cases where the stable subspace of the pencil could not be isolated. See Notes section and the references for details.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaxn(M, M) ndarrayÙ¹‚Ù§x;Solution to the continuous-time algebraic Riccati equation.€ögSummaryÙ¯‚Ù¹‚Ù§x=Solves the continuous-time algebraic Riccati equation (CARE).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotesjReferenceshExamplesx/scipy/linalg/_solvers.pyEr<class 'function'>x8scipy.signal._lti_conversion.linalg.solve_continuous_areÙ¯‚ƒÙ¹‚‹Ù§fGiven Ù¢„aaÙ „ööelocalaaelocalõÙ§b, Ù¢„abÙ „ööelocalabelocalõÙ§b, Ù¢„aqÙ „ööelocalaqelocalõÙ§f, and Ù¢„arÙ „ööelocalarelocalõÙ§k solve for Ù¢„axÙ „ööelocalaxelocalõÙ§a:€Ù´ƒ˜nÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚`a
Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmfc4.5Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmfc3.5Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmfb4.Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`arÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„flinalgÙ „escipye1.8.0fmodulelscipy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„tsolve_continuous_areÙ „escipye1.8.0fmodulex*scipy.linalg._solvers.solve_continuous_arefmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a)Ù±‚`a
Ù±‚`axxJarray([[ 21.72792206,  14.48528137],
       [ 14.48528137,   9.65685425]])fexecedÙ´ƒ˜-Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`aTÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„aaÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa-Ù±‚`axÙ±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`Ù¢„abÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)Ù±‚aoa.Ù±‚`cdotÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚`Ù¢„aqÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ±‚`a)dTruefexecedöÙ¼ƒÙ»ƒrsolve_discrete_arex(scipy.linalg._solvers.solve_discrete_areõÙ¹‚Ù§x3Solves the discrete-time algebraic Riccati equation€öe1.8.0Ù«x?solve_continuous_are(a, b, q, r, e=None, s=None, balanced=True)öx*scipy.linalg._solvers.solve_continuous_are€
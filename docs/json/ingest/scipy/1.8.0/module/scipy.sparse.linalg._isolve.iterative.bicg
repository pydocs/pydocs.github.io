Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚…Ù°ƒbx0gndarrayÙ¹‚Ù§x Starting guess for the solution.€Ù°ƒitol, atolofloat, optional‚Ù¹‚‡Ù§xTolerances for convergence, Ù¡x(norm(residual) <= max(tol*norm(b), atol)Ù§r. The default for Ù¡datolÙ§d is Ù¡h'legacy'Ù§x-, which emulates a different legacy behavior.€ÙÆƒgwarning`Ù¹‚Ù§xwThe default value for `atol` will be changed in a future release. For future compatibility, specify `atol` explicitly. €Ù°ƒgmaxitergintegerÙ¹‚Ù§x}Maximum number of iterations.  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.€Ù°ƒaMx({sparse matrix, ndarray, LinearOperator}Ù¹‚Ù§xéPreconditioner for A.  The preconditioner should approximate the inverse of A.  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance.€Ù°ƒhcallbackhfunctionÙ¹‚Ù§x|User-supplied function to call after each iteration.  It is called as callback(xk), where xk is the current solution vector.€öjParametersÙ¯‚‚Ù°ƒaAx({sparse matrix, ndarray, LinearOperator}Ù¹‚‰Ù§xGThe real or complex N-by-N matrix of the linear system. Alternatively, Ù¡aAÙ§x, can be a linear operator which can produce Ù¡bAxÙ§e and Ù¡eA^T xÙ§n using, e.g., Ù¡x"scipy.sparse.linalg.LinearOperatorÙ§a.€Ù°ƒabgndarrayÙ¹‚Ù§x>Right hand side of the linear system. Has shape (N,) or (N,1).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaxgndarrayÙ¹‚Ù§wThe converged solution.€Ù°ƒdinfoginteger€ögSummaryÙ¯‚Ù¹‚ƒÙ§x,Use BIConjugate Gradient iteration to solve Ù¡fAx = bÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametersgReturnspOther ParametershExamplesx)/scipy/sparse/linalg/_isolve/iterative.py€r<class 'function'>xNscipy.signal._filter_design.optimize._differentiable_functions.sps.linalg.bicgÙ¯‚Ù·‰x'>>> from scipy.sparse import csc_matrixx(>>> from scipy.sparse.linalg import bicgxC>>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)x)>>> b = np.array([2, 4, -1], dtype=float)x>>> x, exitCode = bicg(A, b)xC>>> print(exitCode)            # 0 indicates successful convergencea0x>>> np.allclose(A.dot(x), b)dTrueö€e1.8.0Ù«xNbicg(A, b, x0=None, tol=1e-05, maxiter=None, M=None, callback=None, atol=None)öx*scipy.sparse.linalg._isolve.iterative.bicg€
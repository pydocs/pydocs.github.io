{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "func",
            "type_": "callable",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The objective function to be minimized.  Must be in the form "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "f(x, *args)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the argument in the form of a 1-D array and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "args"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a  tuple of any additional fixed parameters needed to completely specify the function."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "bounds",
            "type_": "sequence or `Bounds`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Bounds for variables.  There are two ways to specify the bounds: 1. Instance of "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "Bounds",
                        "reference": {
                          "module": "scipy",
                          "version": "1.7.1",
                          "kind": "module",
                          "path": "scipy.optimize._constraints.Bounds"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " class. 2. "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(min, max)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " pairs for each element in "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", defining the finite lower and upper bounds for the optimizing argument of "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "func",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "func"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". It is required to have "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "len(bounds) == len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "len(bounds)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is used to determine the number of parameters in "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "args",
            "type_": "tuple, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Any additional fixed parameters needed to completely specify the objective function."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "strategy",
            "type_": "str, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The differential evolution strategy to use. Should be one of:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "- 'best1bin'",
                    "- 'best1exp'",
                    "- 'rand1exp'",
                    "- 'randtobest1exp'",
                    "- 'currenttobest1exp'",
                    "- 'best2exp'",
                    "- 'rand2exp'",
                    "- 'randtobest1bin'",
                    "- 'currenttobest1bin'",
                    "- 'best2bin'",
                    "- 'rand2bin'",
                    "- 'rand1bin'"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The default is 'best1bin'"
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "maxiter",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(maxiter + 1) * popsize * len(x)"
                        ]
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "popsize",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A multiplier for setting the total population size. The population has "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "popsize * len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " individuals. This keyword is overridden if an initial population is supplied via the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "init",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "init"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword. When using "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "init='sobol'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the population size is calculated as the next power of 2 after "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "popsize * len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "tol",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Relative tolerance for convergence, the solving stops when "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "atol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "atol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "tol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "tol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " are the absolute and relative tolerance respectively."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "mutation",
            "type_": "float or tuple(float, float), optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(min, max)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from U[min, max). Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "recombination",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "seed",
            "type_": "{None, int, `numpy.random.Generator`,",
            "desc": [
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "`numpy.random.RandomState`}, optional"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "seed",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "seed"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is None (or "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "np.random"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "), the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "numpy.random.RandomState",
                        "reference": {
                          "module": "numpy",
                          "version": "1.21.3",
                          "kind": "module",
                          "path": "numpy.random.mtrand.RandomState"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " singleton is used. If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "seed",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "seed"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an int, a new "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "RandomState"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " instance is used, seeded with "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "seed",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "seed"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "seed",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "seed"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is already a "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "Generator"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " or "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "RandomState"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " instance then that instance is used. Specify "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "seed",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "seed"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for repeatable minimizations."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "disp",
            "type_": "bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Prints the evaluated "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "func",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "func"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " at every iteration."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "callback",
            "type_": "callable, `callback(xk, convergence=val)`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A function to follow the progress of the minimization. "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "xk"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the current value of "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x0"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "val"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " represents the fractional value of the population convergence. When "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "val"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is greater than one the function halts. If callback returns "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "True"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", then the minimization is halted (any polishing is still carried out)."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "polish",
            "type_": "bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If True (default), then "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.optimize.minimize"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " with the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "L-BFGS-B"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " method is used to polish the best population member at the end, which can improve the minimization slightly. If a constrained problem is being studied then the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "trust-constr"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " method is used instead."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "maxfun",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Set the maximum number of function evaluations. However, it probably makes more sense to set "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "maxiter",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "maxiter"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " instead."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "init",
            "type_": "str or array-like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Specify which type of population initialization is performed. Should be one of:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "- 'latinhypercube'",
                    "- 'sobol'",
                    "- 'halton'",
                    "- 'random'",
                    "- array specifying the initial population. The array should have",
                    "  shape ``(M, len(x))``, where M is the total population size and",
                    "  len(x) is the number of parameters.",
                    "  `init` is clipped to `bounds` before use."
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The default is 'latinhypercube'. Latin Hypercube sampling tries to maximize coverage of the available parameter space."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "'sobol' and 'halton' are superior alternatives and maximize even more the parameter space. 'sobol' will enforce an initial population size which is calculated as the next power of 2 after "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "popsize * len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". 'halton' has no requirements but is a bit less efficient. See "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.stats.qmc"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for more details."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "'random' initializes the population randomly - this has the drawback that clustering can occur, preventing the whole of parameter space being covered. Use of an array to specify a population could be used, for example, to create a tight bunch of initial guesses in an location where the solution is known to exist, thereby reducing time for convergence."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "atol",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Absolute tolerance for convergence, the solving stops when "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "atol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "atol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "tol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "tol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " are the absolute and relative tolerance respectively."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "updating",
            "type_": "{'immediate', 'deferred'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "immediate"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the best solution vector is continuously updated within a single generation. This can lead to faster convergence as trial vectors can take advantage of continuous improvements in the best solution. With "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "deferred"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the best solution vector is updated once per generation. Only "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "deferred"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is compatible with parallelization, and the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "workers",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "workers"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword can over-ride this option."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "workers",
            "type_": "int or map-like callable, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "workers",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "workers"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an int the population is subdivided into "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "workers",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "workers"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " sections and evaluated in parallel (uses "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "multiprocessing.Pool <multiprocessing>"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "). Supply "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "-1"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " to use all cores available to the Process. Alternatively supply a map-like callable, such as "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "multiprocessing.Pool.map"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for evaluating the population in parallel. This evaluation is carried out as "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "workers(func, iterable)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". This option will override the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "updating",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "updating"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword to "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "updating='deferred'"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " if "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "workers != 1"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Requires that "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "func",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "func"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " be pickleable."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "constraints",
            "type_": "{NonLinearConstraint, LinearConstraint, Bounds}",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Constraints on the solver, over and above those applied by the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "bounds",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "bounds"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " kwd. Uses the approach by Lampinen."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "x0",
            "type_": "None or array-like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Provides an initial guess to the minimization. Once the population has been initialized this vector replaces the first (best) member. This replacement is done even if "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "init",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "init"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is given an initial population."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This class implements the differential evolution solver"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize._constraints.Bounds"
    },
    {
      "module": "numpy",
      "version": "1.21.3",
      "kind": "module",
      "path": "numpy.random.mtrand.RandomState"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Parameters"
  ],
  "item_file": "/scipy/optimize/_differentialevolution.py",
  "item_line": 334,
  "item_type": "<class 'type'>",
  "aliases": [
    "scipy.signal.filter_design.optimize._differentialevolution.DifferentialEvolutionSolver"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": "DifferentialEvolutionSolver(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, maxfun=inf, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=(), x0=None)",
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.optimize._differentialevolution.DifferentialEvolutionSolver",
  "arbitrary": []
}
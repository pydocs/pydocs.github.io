{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.linalg.interpolative"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "numpy",
      "version": "1.22.1",
      "kind": "module",
      "path": "numpy.empty"
    },
    {
      "module": "numpy",
      "version": "1.22.1",
      "kind": "module",
      "path": "numpy.ndarray"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/scipy/linalg/interpolative.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "scipy.signal.lti_conversion.linalg.interpolative"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.linalg.interpolative",
  "arbitrary": [
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "moduleauthor",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "Kenneth L. Ho < klho@stanford.edu> "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Admonition",
          "data": {
            "kind": "versionadded",
            "title": "TODO",
            "children": [
              {
                "inline": [
                  {
                    "type": "Words",
                    "data": {
                      "value": "0.13 "
                    }
                  }
                ],
                "inner": []
              }
            ]
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "currentmodule",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "scipy.linalg.interpolative "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "An interpolative decomposition (ID) of a matrix "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A \\in\n\\mathbb{C}^{m \\times n}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " of rank "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "k \\leq \\min \\{ m, n \\}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is a factorization"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockMath",
          "data": {
            "value": "A \\Pi = \\begin { bmatrix} A \\Pi_ { 1} & A \\Pi_ { 2} \\end { bmatrix} = A \\Pi_ { 1} \\begin { bmatrix} I & T \\end { bmatrix}, "
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "where "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "\\Pi = [\\Pi_{1}, \\Pi_{2}]"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is a permutation matrix with "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "\\Pi_{1} \\in \\{ 0, 1 \\}^{n \\times k}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", i.e., "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A \\Pi_{2} =\nA \\Pi_{1} T"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". This can equivalently be written as "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A = BP"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", where "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "B = A \\Pi_{1}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "P = [I, T] \\Pi^{\\mathsf{T}}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " are the "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "skeleton"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "interpolation matrices"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", respectively."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "If "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " does not have exact rank "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "k"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", then there exists an approximation in the form of an ID such that "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A = BP + E"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", where "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "\\| E \\| \\sim \\sigma_{k + 1}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is on the order of the "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "(k +\n1)"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "-th largest singular value of "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". Note that "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "\\sigma_{k\n+ 1}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is the best possible error for a rank-"
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "k"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " approximation and, in fact, is achieved by the singular value decomposition (SVD) "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "A \\approx U S V^{*}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", where "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "U \\in \\mathbb{C}^{m \\times\nk}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "V \\in \\mathbb{C}^{n \\times k}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " have orthonormal columns and "
                }
              },
              {
                "type": "Math",
                "data": {
                  "value": [
                    "S = \\mathop{\\mathrm{diag}} (\\sigma_{i}) \\in \\mathbb{C}^{k\n\\times k}"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is diagonal with nonnegative entries. The principal advantages of using an ID over an SVD are that:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "it is cheaper to construct;"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "it preserves the structure of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": "A",
                        "domain": null,
                        "role": "math"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "; and"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "it is more efficient to compute with in light of the identity submatrix of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": "P",
                        "domain": null,
                        "role": "math"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": "Interpolative matrix decomposition (:mod:`scipy.linalg.interpolative`)"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Main functionality:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "interp_decomp reconstruct_matrix_from_id reconstruct_interp_matrix reconstruct_skel_matrix id_to_svd svd estimate_spectral_norm estimate_spectral_norm_diff estimate_rank "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Support functions:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "seed rand "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Routines"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This module uses the ID software package  by Martinsson, Rokhlin, Shkolnisky, and Tygert, which is a Fortran library for computing IDs using various algorithms, including the rank-revealing QR approach of  and the more recent randomized methods described in , , and . This module exposes its functionality in a way convenient for Python users. Note that this module does not add any functionality beyond that of organizing a simpler and more consistent interface."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We advise the user to consult also the "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "documentation for the ID package\n<http://tygert.com/id_doc.4.pdf>",
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "References"
    },
    {
      "children": [],
      "title": "Tutorial"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The first step is to import "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "scipy.linalg.interpolative",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.linalg.interpolative"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " by issuing the command:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> import scipy.linalg.interpolative as sli"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Now let's build a matrix. For this, we consider a Hilbert matrix, which is well know to have low rank:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> from scipy.linalg import hilbert\n>>> n = 1000\n>>> A = hilbert(n)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We can also do this explicitly via:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> import numpy as np\n>>> n = 1000\n>>> A = np.empty((n, n), order='F')\n>>> for j in range(n):\n>>>     for i in range(m):\n>>>         A[i,j] = 1. / (i + j + 1)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Note the use of the flag "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "order='F'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " in "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "numpy.empty",
                  "reference": {
                    "module": "numpy",
                    "version": "1.22.1",
                    "kind": "module",
                    "path": "numpy.empty"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". This instantiates the matrix in Fortran-contiguous order and is important for avoiding data copying when passing to the backend."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We then define multiplication routines for the matrix by regarding it as a "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "scipy.sparse.linalg.LinearOperator",
                  "domain": null,
                  "role": "class"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ":"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> from scipy.sparse.linalg import aslinearoperator\n>>> L = aslinearoperator(A)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This automatically sets up methods describing the action of the matrix and its adjoint on a vector."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Initializing"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We have several choices of algorithm to compute an ID. These fall largely according to two dichotomies:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "EnumeratedList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "how the matrix is represented, i.e., via its entries or via its action on a    vector; and"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "whether to approximate it to a fixed relative precision or to a fixed rank."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We step through each choice in turn below."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In all cases, the ID is represented by three parameters:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "EnumeratedList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "a rank "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "k"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ";"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "an index array "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "idx"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "; and"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "interpolation coefficients "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "proj"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The ID is specified by the relation "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "np.dot(A[:,idx[:k]], proj) == A[:,idx[k:]]"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Computing an ID"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We first consider a matrix given in terms of its entries."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an ID to a fixed precision, type:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(A, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "where "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "eps < 1"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is the desired precision."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an ID to a fixed rank, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(A, k)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "where "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "k >= 1"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is the desired rank."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Both algorithms use random sampling and are usually faster than the corresponding older, deterministic algorithms, which can be accessed via the commands:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(A, eps, rand=False)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "and:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(A, k, rand=False)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "respectively."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "From matrix entries"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Now consider a matrix given in terms of its action on a vector as a "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "scipy.sparse.linalg.LinearOperator",
                  "domain": null,
                  "role": "class"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an ID to a fixed precision, type:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(L, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an ID to a fixed rank, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(L, k)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "These algorithms are randomized."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "From matrix action"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The ID routines above do not output the skeleton and interpolation matrices explicitly but instead return the relevant information in a more compact (and sometimes more useful) form. To build these matrices, write:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> B = sli.reconstruct_skel_matrix(A, k, idx)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "for the skeleton matrix and:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> P = sli.reconstruct_interp_matrix(idx, proj)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "for the interpolation matrix. The ID approximation can then be computed as:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> C = np.dot(B, P)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This can also be constructed directly using:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> C = sli.reconstruct_matrix_from_id(B, idx, proj)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "without having to first compute "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "P"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Alternatively, this can be done explicitly as well using:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> B = A[:,idx[:k]]\n>>> P = np.hstack([np.eye(k), proj])[:,np.argsort(idx)]\n>>> C = np.dot(B, P)"
          }
        }
      ],
      "title": "Reconstructing an ID"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "An ID can be converted to an SVD via the command:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> U, S, V = sli.id_to_svd(B, idx, proj)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The SVD approximation is then:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> C = np.dot(U, np.dot(np.diag(S), np.dot(V.conj().T)))"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The SVD can also be computed \"fresh\" by combining both the ID and conversion steps into one command. Following the various ID algorithms above, there are correspondingly various SVD algorithms that one can employ."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Computing an SVD"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We consider first SVD algorithms for a matrix given in terms of its entries."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an SVD to a fixed precision, type:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> U, S, V = sli.svd(A, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an SVD to a fixed rank, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> U, S, V = sli.svd(A, k)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Both algorithms use random sampling; for the determinstic versions, issue the keyword "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "rand=False"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " as above."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "From matrix entries"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Now consider a matrix given in terms of its action on a vector."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an SVD to a fixed precision, type:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> U, S, V = sli.svd(L, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To compute an SVD to a fixed rank, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> U, S, V = sli.svd(L, k)"
          }
        }
      ],
      "title": "From matrix action"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Several utility routines are also available."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To estimate the spectral norm of a matrix, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> snorm = sli.estimate_spectral_norm(A)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This algorithm is based on the randomized power method and thus requires only matrix-vector products. The number of iterations to take can be set using the keyword "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "its"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " (default: "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "its=20"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "). The matrix is interpreted as a "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "scipy.sparse.linalg.LinearOperator",
                  "domain": null,
                  "role": "class"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", but it is also valid to supply it as a "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "numpy.ndarray",
                  "reference": {
                    "module": "numpy",
                    "version": "1.22.1",
                    "kind": "module",
                    "path": "numpy.ndarray"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", in which case it is trivially converted using "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "scipy.sparse.linalg.aslinearoperator",
                  "domain": null,
                  "role": "func"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The same algorithm can also estimate the spectral norm of the difference of two matrices "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "A1"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "A2"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " as follows:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> diff = sli.estimate_spectral_norm_diff(A1, A2)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This is often useful for checking the accuracy of a matrix approximation."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Some routines in "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "scipy.linalg.interpolative",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.linalg.interpolative"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " require estimating the rank of a matrix as well. This can be done with either:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> k = sli.estimate_rank(A, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "or:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> k = sli.estimate_rank(L, eps)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "depending on the representation. The parameter "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "eps"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " controls the definition of the numerical rank."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Finally, the random number generation required for all randomized routines can be controlled via "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "scipy.linalg.interpolative.seed",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.linalg.interpolative.seed"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". To reset the seed values to their original values, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> sli.seed('default')"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To specify the seed values, use:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> sli.seed(s)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "where "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "s"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " must be an integer or array of 55 floats. If an integer, the array of floats is obtained by using "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "numpy.random.rand"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " with the given integer seed."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To simply generate some random numbers, type:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> sli.rand(n)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "where "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "n"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is the number of random numbers to generate."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Utility routines"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The above functions all automatically detect the appropriate interface and work with both real and complex data types, passing input arguments to the proper backend routine."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Remarks"
    }
  ]
}
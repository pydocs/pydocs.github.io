{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.sparse"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/scipy/sparse/__init__.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "scipy.signal.filter_design.optimize._differentiable_functions.sps"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.sparse",
  "arbitrary": [
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "currentmodule",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "scipy.sparse "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "SciPy 2-D sparse matrix package for numeric data."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Sparse matrices (:mod:`scipy.sparse`)"
    },
    {
      "children": [],
      "title": "Contents"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "bsr_matrix - Block Sparse Row matrix coo_matrix - A sparse matrix in COOrdinate format csc_matrix - Compressed Sparse Column matrix csr_matrix - Compressed Sparse Row matrix dia_matrix - Sparse matrix with DIAgonal storage dok_matrix - Dictionary Of Keys based sparse matrix lil_matrix - Row - based list of lists sparse matrix spmatrix - Sparse matrix base class "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Sparse matrix classes"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Building sparse matrices:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "eye - Sparse MxN matrix whose k - th diagonal is all ones identity - Identity matrix in sparse format kron - kronecker product of two sparse matrices kronsum - kronecker sum of sparse matrices diags - Return a sparse matrix from diagonals spdiags - Return a sparse matrix from diagonals block_diag - Build a block diagonal sparse matrix tril - Lower triangular portion of a matrix in sparse format triu - Upper triangular portion of a matrix in sparse format bmat - Build a sparse matrix from sparse sub - blocks hstack - Stack sparse matrices horizontally ( column wise) vstack - Stack sparse matrices vertically ( row wise) rand - Random values in a given shape random - Random values in a given shape "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Save and load sparse matrices:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "save_npz - Save a sparse matrix to a file using ``.npz`` format. load_npz - Load a sparse matrix from a file using ``.npz`` format. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Sparse matrix tools:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "find "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Identifying sparse matrices:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "issparse isspmatrix isspmatrix_csc isspmatrix_csr isspmatrix_bsr isspmatrix_lil isspmatrix_dok isspmatrix_coo isspmatrix_dia "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Functions"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "csgraph - Compressed sparse graph routines linalg - sparse linear algebra routines "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Submodules"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "SparseEfficiencyWarning SparseWarning "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Exceptions"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "There are seven available sparse matrix types:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockQuote",
          "data": {
            "value": [
              "1. csc_matrix: Compressed Sparse Column format",
              "2. csr_matrix: Compressed Sparse Row format",
              "3. bsr_matrix: Block Sparse Row format",
              "4. lil_matrix: List of Lists format",
              "5. dok_matrix: Dictionary of Keys format",
              "6. coo_matrix: COOrdinate format (aka IJV, triplet format)",
              "7. dia_matrix: DIAgonal format"
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To construct a matrix efficiently, use either dok_matrix or lil_matrix. The lil_matrix class supports basic slicing and fancy indexing with a similar syntax to NumPy arrays. As illustrated below, the COO format may also be used to efficiently construct matrices. Despite their similarity to NumPy arrays, it is "
                }
              },
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "strongly discouraged"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " to use NumPy functions directly on these matrices because NumPy may not properly convert them for computations, leading to unexpected (and incorrect) results. If you do want to apply a NumPy function to these matrices, first check if SciPy has its own implementation for the given sparse matrix class, or "
                }
              },
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "convert the\nsparse matrix to a NumPy array"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " (e.g., using the "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "toarray()",
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " method of the class) first before applying the method."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To perform manipulations such as multiplication or inversion, first convert the matrix to either CSC or CSR format. The lil_matrix format is row-based, so conversion to CSR is efficient, whereas conversion to CSC is less so."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "All conversions among the CSR, CSC, and COO formats are efficient, linear-time operations."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Usage information"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To do a vector product between a sparse matrix and a vector simply use the matrix "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "dot",
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " method, as described in its docstring:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)"
          }
        },
        {
          "type": "Admonition",
          "data": {
            "kind": "warning",
            "title": "As of NumPy 1.7, `np.dot` is not aware of sparse matrices,",
            "children": [
              {
                "inline": [
                  {
                    "type": "Words",
                    "data": {
                      "value": "therefore using it will result on unexpected results or errors. The corresponding dense array should be obtained first instead : >>> np.dot ( A.toarray ( ), v) array ( [ 1, - 3, - 1], dtype=int64) but then all the performance advantages would be lost. "
                    }
                  }
                ],
                "inner": []
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The CSR format is specially suitable for fast matrix vector products."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Matrix vector product"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Construct a 1000x1000 lil_matrix and add some values to it:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> from scipy.sparse import lil_matrix\n>>> from scipy.sparse.linalg import spsolve\n>>> from numpy.linalg import solve, norm\n>>> from numpy.random import rand"
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> A = lil_matrix((1000, 1000))\n>>> A[0, :100] = rand(100)\n>>> A[1, 100:200] = A[0, :100]\n>>> A.setdiag(rand(1000))"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Now convert it to CSR format and solve A x = b for x:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> A = A.tocsr()\n>>> b = rand(1000)\n>>> x = spsolve(A, b)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Convert it to a dense matrix and solve, and check that the result is the same:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> x_ = solve(A.toarray(), b)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Now we can compute norm of the error with:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> err = norm(x-x_)\n>>> err < 1e-10\nTrue"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "It should be small :)"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Example 1"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Construct a matrix in COO format:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> from scipy import sparse\n>>> from numpy import array\n>>> I = array([0,3,1,0])\n>>> J = array([0,3,1,2])\n>>> V = array([4,5,7,9])\n>>> A = sparse.coo_matrix((V,(I,J)),shape=(4,4))"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Notice that the indices do not need to be sorted."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Duplicate (i,j) entries are summed when converting to CSR or CSC."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> I = array([0,0,1,3,1,0,0])\n>>> J = array([0,2,1,3,1,0,0])\n>>> V = array([1,1,1,1,1,1,1])\n>>> B = sparse.coo_matrix((V,(I,J)),shape=(4,4)).tocsr()"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This is useful for constructing finite-element stiffness and mass matrices."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Example 2"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "CSR column indices are not necessarily sorted. Likewise for CSC row indices. Use the .sorted_indices() and .sort_indices() methods when sorted indices are required (e.g., when passing data to other libraries)."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Further details"
    }
  ]
}
{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This section describes the available solvers that can be selected by the 'method' parameter. The default method is "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "BFGS"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "Unconstrained minimization"
                  }
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "CG <optimize.minimize-cg>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses a nonlinear conjugate gradient algorithm by Polak and Ribiere, a variant of the Fletcher-Reeves method described in  pp.120-122. Only the first derivatives are used."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "BFGS <optimize.minimize-bfgs>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS)  pp. 136. It uses the first derivatives only. BFGS has proven good performance even for non-smooth optimizations. This method also returns an approximation of the Hessian inverse, stored as "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "hess_inv"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " in the OptimizeResult object."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "Newton-CG <optimize.minimize-newtoncg>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses a Newton-CG algorithm  pp. 168 (also known as the truncated Newton method). It uses a CG method to the compute the search direction. See also "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "TNC"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " method for a box-constrained minimization with a similar algorithm. Suitable for large-scale problems."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "dogleg <optimize.minimize-dogleg>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the dog-leg trust-region algorithm  for unconstrained minimization. This algorithm requires the gradient and Hessian; furthermore the Hessian is required to be positive definite."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-ncg <optimize.minimize-trustncg>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the Newton conjugate gradient trust-region algorithm  for unconstrained minimization. This algorithm requires the gradient and either the Hessian or a function that computes the product of the Hessian with a given vector. Suitable for large-scale problems."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-krylov <optimize.minimize-trustkrylov>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the Newton GLTR trust-region algorithm ,  for unconstrained minimization. This algorithm requires the gradient and either the Hessian or a function that computes the product of the Hessian with a given vector. Suitable for large-scale problems. On indefinite problems it requires usually less iterations than the "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-ncg"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " method and is recommended for medium and large-scale problems."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-exact <optimize.minimize-trustexact>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is a trust-region method for unconstrained minimization in which quadratic subproblems are solved almost exactly . This algorithm requires the gradient and the Hessian (which is "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "not"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " required to be positive definite). It is, in many situations, the Newton method to converge in fewer iteraction and the most recommended for small and medium-size problems."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "Bound-Constrained minimization"
                  }
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "Nelder-Mead <optimize.minimize-neldermead>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the Simplex algorithm , . This algorithm is robust in many applications. However, if numerical computation of derivative can be trusted, other algorithms using the first and/or second derivatives information might be preferred for their better performance in general."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "L-BFGS-B <optimize.minimize-lbfgsb>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the L-BFGS-B algorithm ,  for bound constrained minimization."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "Powell <optimize.minimize-powell>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is a modification of Powell's method ,  which is a conjugate direction method. It performs sequential one-dimensional minimizations along each vector of the directions set ("
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "direc"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " field in "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "options",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "options"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "info"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "), which is updated at each iteration of the main minimization loop. The function need not be differentiable, and no derivatives are taken. If bounds are not provided, then an unbounded line search will be used. If bounds are provided and the initial guess is within the bounds, then every function evaluation throughout the minimization procedure will be within the bounds. If bounds are provided, the initial guess is outside the bounds, and "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "direc"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is full rank (default has full rank), then some function evaluations during the first iteration may be outside the bounds, but every function evaluation after the first iteration will be within the bounds. If "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "direc"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is not full rank, then some parameters may not be optimized and the solution is not guaranteed to be within the bounds."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "TNC <optimize.minimize-tnc>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses a truncated Newton algorithm ,  to minimize a function with variables subject to bounds. This algorithm uses gradient information; it is also called Newton Conjugate-Gradient. It differs from the "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "Newton-CG"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " method described above as it wraps a C implementation and allows each variable to be given upper and lower bounds."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "Constrained Minimization"
                  }
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "COBYLA <optimize.minimize-cobyla>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses the Constrained Optimization BY Linear Approximation (COBYLA) method , , . The algorithm is based on linear approximations to the objective function and each constraint. The method wraps a FORTRAN implementation of the algorithm. The constraints functions 'fun' may return either a single number or an array or list of numbers."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "SLSQP <optimize.minimize-slsqp>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " uses Sequential Least SQuares Programming to minimize a function of several variables with any combination of bounds, equality and inequality constraints. The method wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft . Note that the wrapper handles infinite values in bounds by converting them into large floating values."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-constr <optimize.minimize-trustconstr>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is a trust-region algorithm for constrained optimization. It swiches between two implementations depending on the problem definition. It is the most versatile constrained minimization algorithm implemented in SciPy and the most appropriate for large-scale problems. For equality constrained problems it is an implementation of Byrd-Omojokun Trust-Region SQP method described in  and in , p. 549. When inequality constraints  are imposed as well, it swiches to the trust-region interior point  method described in . This interior point algorithm, in turn, solves inequality constraints by introducing slack variables and solving a sequence of equality-constrained barrier problems for progressively smaller values of the barrier parameter. The previously described equality constrained SQP method is used to solve the subproblems with increasing levels of accuracy as the iterate gets closer to a solution."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "Finite-Difference Options"
                  }
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "For Method "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "trust-constr <optimize.minimize-trustconstr>"
                  ],
                  "domain": null,
                  "role": "ref"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " the gradient and the Hessian may be approximated using three finite-difference schemes: {'2-point', '3-point', 'cs'}. The scheme 'cs' is, potentially, the most accurate but it requires the function to correctly handles complex inputs and to be differentiable in the complex plane. The scheme '3-point' is more accurate than '2-point' but requires twice as many operations."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Strong",
                "data": {
                  "content": {
                    "value": "Custom minimizers"
                  }
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "It may be useful to pass a custom minimization method, for example when using a frontend to this method such as "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "scipy.optimize.basinhopping"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or a different library.  You can simply pass a callable as the "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "method"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " parameter."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The callable is called as "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "method(fun, x0, args, **kwargs, **options)"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " where "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "kwargs"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " corresponds to any other parameters passed to "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " (such as "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "callback",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "callback"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "hess",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "hess"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", etc.), except the "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "options",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "options"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " dict, which has its contents also passed as "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "method",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "method"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " parameters pair by pair.  Also, if "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "jac",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "jac"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " has been passed as a bool type, "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "jac",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "jac"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "fun",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "fun"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " are mangled so that "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "fun",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "fun"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " returns just the function values and "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "jac",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "jac"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is converted to a function returning the Jacobian.  The method shall return an "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "OptimizeResult",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.OptimizeResult"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " object."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The provided "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "method",
                  "reference": {
                    "module": null,
                    "version": null,
                    "kind": "local",
                    "path": "method"
                  },
                  "kind": "local",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " callable must be able to accept (and possibly ignore) arbitrary parameters; the set of parameters accepted by "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " may expand in future versions and then these parameters will be passed to the method.  You can find an example in the scipy.optimize tutorial."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Admonition",
          "data": {
            "kind": "versionadded",
            "title": "TODO",
            "children": [
              {
                "inline": [
                  {
                    "type": "Words",
                    "data": {
                      "value": "0.11.0 "
                    }
                  }
                ],
                "inner": []
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "fun",
            "type_": "callable",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The objective function to be minimized."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``fun(x, *args) -> float``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an 1-D array with shape (n,) and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "args"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a tuple of the fixed parameters needed to completely specify the function."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "x0",
            "type_": "ndarray, shape (n,)",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Initial guess. Array of real elements of size (n,), where 'n' is the number of independent variables."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "args",
            "type_": "tuple, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Extra arguments passed to the objective function and its derivatives ("
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "fun",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "fun"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "jac",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "jac"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hess",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hess"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " functions)."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "method",
            "type_": "str or callable, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Type of solver.  Should be one of"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "- 'Nelder-Mead' :ref:`(see here) <optimize.minimize-neldermead>`",
                    "- 'Powell'      :ref:`(see here) <optimize.minimize-powell>`",
                    "- 'CG'          :ref:`(see here) <optimize.minimize-cg>`",
                    "- 'BFGS'        :ref:`(see here) <optimize.minimize-bfgs>`",
                    "- 'Newton-CG'   :ref:`(see here) <optimize.minimize-newtoncg>`",
                    "- 'L-BFGS-B'    :ref:`(see here) <optimize.minimize-lbfgsb>`",
                    "- 'TNC'         :ref:`(see here) <optimize.minimize-tnc>`",
                    "- 'COBYLA'      :ref:`(see here) <optimize.minimize-cobyla>`",
                    "- 'SLSQP'       :ref:`(see here) <optimize.minimize-slsqp>`",
                    "- 'trust-constr':ref:`(see here) <optimize.minimize-trustconstr>`",
                    "- 'dogleg'      :ref:`(see here) <optimize.minimize-dogleg>`",
                    "- 'trust-ncg'   :ref:`(see here) <optimize.minimize-trustncg>`",
                    "- 'trust-exact' :ref:`(see here) <optimize.minimize-trustexact>`",
                    "- 'trust-krylov' :ref:`(see here) <optimize.minimize-trustkrylov>`",
                    "- custom - a callable object (added in version 0.14.0),",
                    "  see below for description."
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If not given, chosen to be one of "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "BFGS"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "L-BFGS-B"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "SLSQP"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", depending if the problem has constraints or bounds."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "jac",
            "type_": "{callable,  '2-point', '3-point', 'cs', bool}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Method for computing the gradient vector. Only for CG, BFGS, Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If it is a callable, it should be a function that returns the gradient vector:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``jac(x, *args) -> array_like, shape (n,)``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an array with shape (n,) and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "args"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a tuple with the fixed parameters. If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "jac",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "jac"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a Boolean and is True, "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "fun",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "fun"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is assumed to return a tuple "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(f, g)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " containing the objective function and the gradient. Methods 'Newton-CG', 'trust-ncg', 'dogleg', 'trust-exact', and 'trust-krylov' require that either a callable be supplied, or that "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "fun",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "fun"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " return the objective and gradient. If None or False, the gradient will be estimated using 2-point finite difference estimation with an absolute step size. Alternatively, the keywords  {'2-point', '3-point', 'cs'} can be used to select a finite difference scheme for numerical estimation of the gradient with a relative step size. These finite difference schemes obey any specified "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "bounds",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "bounds"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "hess",
            "type_": "{callable, '2-point', '3-point', 'cs', HessianUpdateStrategy}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Method for computing the Hessian matrix. Only for Newton-CG, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If it is callable, it should return the Hessian matrix:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where x is a (n,) ndarray and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "args",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "args"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a tuple with the fixed parameters. LinearOperator and sparse matrix returns are only allowed for 'trust-constr' method. Alternatively, the keywords {'2-point', '3-point', 'cs'} select a finite difference scheme for numerical estimation. Or, objects implementing the "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "HessianUpdateStrategy",
                        "reference": {
                          "module": "scipy",
                          "version": "1.7.1",
                          "kind": "module",
                          "path": "scipy.optimize._hessian_update_strategy.HessianUpdateStrategy"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " interface can be used to approximate the Hessian. Available quasi-Newton methods implementing this interface are:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "- `BFGS`;",
                    "- `SR1`."
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Whenever the gradient is estimated via finite-differences, the Hessian cannot be estimated with options {'2-point', '3-point', 'cs'} and needs to be estimated using one of the quasi-Newton strategies. 'trust-exact' cannot use a finite-difference scheme, and must be used with a callable returning an (n, n) array."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "hessp",
            "type_": "callable, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Hessian of objective function times an arbitrary vector p. Only for Newton-CG, trust-ncg, trust-krylov, trust-constr. Only one of "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hessp",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hessp"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " or "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hess",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hess"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " needs to be given.  If "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hess",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hess"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is provided, then "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hessp",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hessp"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " will be ignored.  "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "hessp",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "hessp"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " must compute the Hessian times an arbitrary vector:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``hessp(x, p, *args) ->  ndarray shape (n,)``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where x is a (n,) ndarray, p is an arbitrary vector with dimension (n,) and "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "args",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "args"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a tuple with the fixed parameters."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "bounds",
            "type_": "sequence or `Bounds`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, and trust-constr methods. There are two ways to specify the bounds:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "1. Instance of `Bounds` class.",
                    "2. Sequence of ``(min, max)`` pairs for each element in `x`. None",
                    "   is used to specify no bound."
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "constraints",
            "type_": "{Constraint, dict} or List of {Constraint, dict}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Constraints definition (only for COBYLA, SLSQP and trust-constr)."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Constraints for 'trust-constr' are defined as a single object or a list of objects specifying constraints to the optimization problem. Available constraints are:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "- `LinearConstraint`",
                    "- `NonlinearConstraint`"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Constraints for COBYLA, SLSQP are defined as a list of dictionaries. Each dictionary with fields:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "type : str",
                    "    Constraint type: 'eq' for equality, 'ineq' for inequality.",
                    "fun : callable",
                    "    The function defining the constraint.",
                    "jac : callable, optional",
                    "    The Jacobian of `fun` (only for SLSQP).",
                    "args : sequence, optional",
                    "    Extra arguments to be passed to the function and Jacobian."
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Equality constraint means that the constraint function result is to be zero whereas inequality means that it is to be non-negative. Note that COBYLA only supports inequality constraints."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "tol",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Tolerance for termination. When "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "tol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "tol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is specified, the selected minimization algorithm sets some relevant solver-specific tolerance(s) equal to "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "tol",
                        "reference": {
                          "module": null,
                          "version": null,
                          "kind": "local",
                          "path": "tol"
                        },
                        "kind": "local",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". For detailed control, use solver-specific options."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "options",
            "type_": "dict, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A dictionary of solver options. All methods accept the following generic options:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "maxiter : int",
                    "    Maximum number of iterations to perform. Depending on the",
                    "    method each iteration may use several function evaluations.",
                    "disp : bool",
                    "    Set to True to print convergence messages."
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "For method-specific options, see "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "show_options()"
                        ],
                        "domain": null,
                        "role": "func"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "callback",
            "type_": "callable, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Called after each iteration. For 'trust-constr' it is a callable with the signature:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``callback(xk, OptimizeResult state) -> bool``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "xk"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the current parameter vector. and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "state"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "OptimizeResult",
                        "reference": {
                          "module": "scipy",
                          "version": "1.7.1",
                          "kind": "module",
                          "path": "scipy.optimize.optimize.OptimizeResult"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " object, with the same fields as the ones from the return. If callback returns True the algorithm execution is terminated. For all the other methods, the signature is:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockQuote",
                "data": {
                  "value": [
                    "``callback(xk)``"
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "xk"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the current parameter vector."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "res",
            "type_": "OptimizeResult",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The optimization result represented as a "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "OptimizeResult"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " object. Important attributes are: "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the solution array, "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "success"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " a Boolean flag indicating if the optimizer exited successfully and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "message"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " which describes the cause of the termination. See "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "OptimizeResult",
                        "reference": {
                          "module": "scipy",
                          "version": "1.7.1",
                          "kind": "module",
                          "path": "scipy.optimize.optimize.OptimizeResult"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for a description of other attributes."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Minimization of scalar function of one or more variables."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize.optimize.OptimizeResult"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.sparse.data._create_method.<locals>.method"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize.optimize.rosen_der"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize._minimize.minimize"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize.optimize.rosen"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize._hessian_update_strategy.BFGS"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize._hessian_update_strategy.HessianUpdateStrategy"
    },
    {
      "module": "scipy",
      "version": "1.7.1",
      "kind": "module",
      "path": "scipy.optimize._linprog_ip._get_message"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Parameters",
    "Returns",
    "See Also",
    "Notes",
    "References",
    "Examples"
  ],
  "item_file": "/scipy/optimize/_minimize.py",
  "item_line": 45,
  "item_type": "<class 'function'>",
  "aliases": [
    "scipy.signal.filter_design.optimize.minimize"
  ],
  "example_section_data": {
    "children": [
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Let us consider the problem of minimizing the Rosenbrock function. This function (and its respective derivatives) is implemented in "
              }
            },
            {
              "type": "Link",
              "data": {
                "value": "rosen",
                "reference": {
                  "module": "scipy",
                  "version": "1.7.1",
                  "kind": "module",
                  "path": "scipy.optimize.optimize.rosen"
                },
                "kind": "module",
                "exists": true
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " (resp. "
              }
            },
            {
              "type": "Link",
              "data": {
                "value": "rosen_der",
                "reference": {
                  "module": "scipy",
                  "version": "1.7.1",
                  "kind": "module",
                  "path": "scipy.optimize.optimize.rosen_der"
                },
                "kind": "module",
                "exists": true
              }
            },
            {
              "type": "Words",
              "data": {
                "value": ", "
              }
            },
            {
              "type": "Link",
              "data": {
                "value": "rosen_hess",
                "reference": {
                  "module": "scipy",
                  "version": "1.7.1",
                  "kind": "module",
                  "path": "scipy.optimize.optimize.rosen_hess"
                },
                "kind": "module",
                "exists": true
              }
            },
            {
              "type": "Words",
              "data": {
                "value": ") in the "
              }
            },
            {
              "type": "Link",
              "data": {
                "value": "scipy.optimize",
                "reference": {
                  "module": "scipy",
                  "version": "1.7.1",
                  "kind": "module",
                  "path": "scipy.optimize"
                },
                "kind": "module",
                "exists": true
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "."
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "kn",
              "link": {
                "type": "str",
                "data": "from"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "nn",
              "link": {
                "type": "Link",
                "data": {
                  "value": "scipy",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "nn",
              "link": {
                "type": "str",
                "data": "."
              }
            },
            {
              "type": "nn",
              "link": {
                "type": "Link",
                "data": {
                  "value": "optimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "kn",
              "link": {
                "type": "str",
                "data": "import"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "rosen",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.rosen"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "rosen_der",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.rosen_der"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            }
          ],
          "out": "",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "A simple application of the "
              }
            },
            {
              "type": "Emph",
              "data": {
                "value": {
                  "value": "Nelder-Mead"
                }
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " method is:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "1.3"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "0.7"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "0.8"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "1.9"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "1.2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "rosen",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.rosen"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "method",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.sparse.data._create_method.<locals>.method"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "Nelder-Mead"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "tol"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "1e-6"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "."
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            }
          ],
          "out": "array([ 1.,  1.,  1.,  1.,  1.])",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Now using the "
              }
            },
            {
              "type": "Emph",
              "data": {
                "value": {
                  "value": "BFGS"
                }
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " algorithm, using the first derivative and a few options:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "rosen",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.rosen"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "method",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.sparse.data._create_method.<locals>.method"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "Link",
                "data": {
                  "value": "BFGS",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._hessian_update_strategy.BFGS"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "jac"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "rosen_der",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.optimize.rosen_der"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "               "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "options"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "{"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "gtol"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "1e-6"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "disp"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "kc",
              "link": {
                "type": "str",
                "data": "True"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "}"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            }
          ],
          "out": "Optimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 26\n         Function evaluations: 31\n         Gradient evaluations: 31",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "."
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            }
          ],
          "out": "array([ 1.,  1.,  1.,  1.,  1.])",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "nb",
              "link": {
                "type": "str",
                "data": "print"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "."
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "message",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._linprog_ip._get_message"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            }
          ],
          "out": "Optimization terminated successfully.",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "."
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "hess_inv"
              }
            }
          ],
          "out": "array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary\n       [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],\n       [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],\n       [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],\n       [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Next, consider a minimization problem with several constraints (namely Example 16.4 from ). The objective function is:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "fun"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "k",
              "link": {
                "type": "str",
                "data": "lambda"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "1"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "+"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "1"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mf",
              "link": {
                "type": "str",
                "data": "2.5"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            }
          ],
          "out": "",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "There are three constraints defined as:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "cons"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "{"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "type"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "ineq"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "fun"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "k",
              "link": {
                "type": "str",
                "data": "lambda"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "  "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "1"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "+"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "}"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "        "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "{"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "type"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "ineq"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "fun"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "k",
              "link": {
                "type": "str",
                "data": "lambda"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "1"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "+"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "6"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "}"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "        "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "{"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "type"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "ineq"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "fun"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "k",
              "link": {
                "type": "str",
                "data": "lambda"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ":"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "-"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "+"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "*"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "x"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "["
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "1"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "]"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "+"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "}"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            }
          ],
          "out": "",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "And variables must be positive, hence the following bounds:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "bnds"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "kc",
              "link": {
                "type": "str",
                "data": "None"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "kc",
              "link": {
                "type": "str",
                "data": "None"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            }
          ],
          "out": "",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "The optimization problem is solved using the SLSQP method as:"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code2",
        "data": {
          "entries": [
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "res"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "minimize",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "fun"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "("
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "2"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "mi",
              "link": {
                "type": "str",
                "data": "0"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "Link",
                "data": {
                  "value": "method",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.sparse.data._create_method.<locals>.method"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "SLSQP"
              }
            },
            {
              "type": "s1",
              "link": {
                "type": "str",
                "data": "'"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": " "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "bounds"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "bnds"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ","
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "\n"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "               "
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "constraints"
              }
            },
            {
              "type": "o",
              "link": {
                "type": "str",
                "data": "="
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": "cons"
              }
            },
            {
              "type": "",
              "link": {
                "type": "str",
                "data": ")"
              }
            }
          ],
          "out": "",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "It should converge to the theoretical solution (1.4 ,1.7)."
              }
            }
          ],
          "inner": []
        }
      }
    ],
    "title": null
  },
  "see_also": [
    {
      "name": {
        "name": "minimize_scalar",
        "ref": "scipy.optimize._minimize.minimize_scalar",
        "exists": true
      },
      "descriptions": [
        {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Interface to minimization algorithms for scalar univariate functions"
              }
            }
          ],
          "inner": []
        }
      ],
      "type": null
    },
    {
      "name": {
        "name": "show_options",
        "ref": "scipy.optimize.optimize.show_options",
        "exists": true
      },
      "descriptions": [
        {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Additional options accepted by the solvers"
              }
            }
          ],
          "inner": []
        }
      ],
      "type": null
    }
  ],
  "version": "1.7.1",
  "signature": "minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)",
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.optimize._minimize.minimize",
  "arbitrary": []
}
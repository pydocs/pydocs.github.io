{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.optimize"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/scipy/optimize/__init__.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "scipy.signal.filter_design.optimize"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.optimize",
  "arbitrary": [
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "currentmodule",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "scipy.optimize "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "SciPy "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "optimize"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " provides functions for minimizing (or maximizing) objective functions, possibly subject to constraints. It includes solvers for nonlinear problems (with support for both local and global optimization algorithms), linear programing, constrained and nonlinear least-squares, root finding, and curve fitting."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Common functions and objects, shared across different solvers, are:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "show_options - Show specific options optimization solvers. OptimizeResult - The optimization result returned by some optimizers. OptimizeWarning - The optimization encountered problems. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Optimization and root finding (:mod:`scipy.optimize`)"
    },
    {
      "children": [],
      "title": "Optimization"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "minimize_scalar - Interface for minimizers of univariate functions "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "minimize_scalar",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._minimize.minimize_scalar"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.minimize_scalar - brent optimize.minimize_scalar - bounded optimize.minimize_scalar - golden "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Scalar functions optimization"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "minimize - Interface for minimizers of multivariate functions. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "minimize"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.minimize - neldermead optimize.minimize - powell optimize.minimize - cg optimize.minimize - bfgs optimize.minimize - newtoncg optimize.minimize - lbfgsb optimize.minimize - tnc optimize.minimize - cobyla optimize.minimize - slsqp optimize.minimize - trustconstr optimize.minimize - dogleg optimize.minimize - trustncg optimize.minimize - trustkrylov optimize.minimize - trustexact "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Constraints are passed to "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "minimize"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function as a single object or as a list of objects from the following classes:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "NonlinearConstraint - Class defining general nonlinear constraints. LinearConstraint - Class defining general linear constraints. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Simple bound constraints are handled separately and there is a special class for them:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "Bounds - Bound constraints. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Quasi-Newton strategies implementing "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "HessianUpdateStrategy",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._hessian_update_strategy.HessianUpdateStrategy"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " interface can be used to approximate the Hessian in "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "minimize"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function (available only for the 'trust-constr' method). Available quasi-Newton methods implementing this interface are:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "BFGS - Broyden - Fletcher - Goldfarb - Shanno ( BFGS) Hessian update strategy. SR1 - Symmetric - rank - 1 Hessian update strategy. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Local (multivariate) optimization"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "basinhopping - Basinhopping stochastic optimizer. brute - Brute force searching optimizer. differential_evolution - stochastic minimization using differential evolution. shgo - simplicial homology global optimisation dual_annealing - Dual annealing stochastic optimizer. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Global optimization"
    },
    {
      "children": [],
      "title": "Least-squares and curve fitting"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "least_squares - Solve a nonlinear least - squares problem with bounds on the variables. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Nonlinear least-squares"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "nnls - Linear least - squares problem with non - negativity constraint. lsq_linear - Linear least - squares problem with bound constraints. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Linear least-squares"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "curve_fit - - Fit curve to a set of points. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Curve fitting"
    },
    {
      "children": [],
      "title": "Root finding"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "root_scalar - Unified interface for nonlinear solvers of scalar functions. brentq - quadratic interpolation Brent method. brenth - Brent method, modified by Harris with hyperbolic extrapolation. ridder - Ridder ' s method. bisect - Bisection method. newton - Newton ' s method ( also Secant and Halley ' s methods). toms748 - Alefeld, Potra & Shi Algorithm 748. RootResults - The root finding result returned by some root finders. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "root_scalar",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._root_scalar.root_scalar"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.root_scalar - brentq optimize.root_scalar - brenth optimize.root_scalar - bisect optimize.root_scalar - ridder optimize.root_scalar - newton optimize.root_scalar - toms748 optimize.root_scalar - secant optimize.root_scalar - halley "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The table below lists situations and appropriate methods, along with "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "asymptotic"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " convergence rates per iteration (and per function evaluation) for successful convergence to a simple root(*). Bisection is the slowest of them all, adding one bit of accuracy for each function evaluation, but is guaranteed to converge. The other bracketing methods all (eventually) increase the number of accurate bits by about 50% for every function evaluation. The derivative-based methods, all built on "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "newton",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.zeros.newton"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", can converge quite quickly if the initial value is close to the root.  They can also be applied to functions defined on (a subset of) the complex plane."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "+-------------+----------+----------+-----------+-------------+-------------+----------------+ | Domain of f | Bracket? |    Derivatives?      | Solvers     |        Convergence           | +             +          +----------+-----------+             +-------------+----------------+ |             |          | "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "fprime",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._root_scalar.MemoizeDer.fprime"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " | "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "fprime2",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._root_scalar.MemoizeDer.fprime2"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " |             | Guaranteed? |  Rate(s)(*)    | +=============+==========+==========+===========+=============+=============+================+ | "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "R"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "         | Yes      | N/A      | N/A       | - bisection | - Yes       | - 1 \"Linear\"   | |             |          |          |           | - brentq    | - Yes       | - >=1, <= 1.62 | |             |          |          |           | - brenth    | - Yes       | - >=1, <= 1.62 | |             |          |          |           | - ridder    | - Yes       | - 2.0 (1.41)   | |             |          |          |           | - toms748   | - Yes       | - 2.7 (1.65)   | +-------------+----------+----------+-----------+-------------+-------------+----------------+ | "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "R"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "C"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "  | No       | No       | No        | secant      | No          | 1.62 (1.62)    | +-------------+----------+----------+-----------+-------------+-------------+----------------+ | "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "R"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "C"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "  | No       | Yes      | No        | newton      | No          | 2.00 (1.41)    | +-------------+----------+----------+-----------+-------------+-------------+----------------+ | "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "R"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "C"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "  | No       | Yes      | Yes       | halley      | No          | 3.00 (1.44)    | +-------------+----------+----------+-----------+-------------+-------------+----------------+"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "seealso",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "`scipy.optimize.cython_optimize` - - Typed Cython versions of zeros functions "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Fixed point finding:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "fixed_point - Single - variable fixed - point solver. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Scalar functions"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "root - Unified interface for nonlinear solvers of multivariate functions. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "root",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._root.root"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.root - hybr optimize.root - lm optimize.root - broyden1 optimize.root - broyden2 optimize.root - anderson optimize.root - linearmixing optimize.root - diagbroyden optimize.root - excitingmixing optimize.root - krylov optimize.root - dfsane "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Multidimensional"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "linprog - - Unified interface for minimizers of linear programming problems. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "linprog"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.linprog - simplex optimize.linprog - interior - point optimize.linprog - revised_simplex optimize.linprog - highs - ipm optimize.linprog - highs - ds optimize.linprog - highs "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The simplex, interior-point, and revised simplex methods support callback functions, such as:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "linprog_verbose_callback - - Sample callback function for linprog ( simplex). "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Linear programming"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "linear_sum_assignment - - Solves the linear - sum assignment problem. quadratic_assignment - - Solves the quadratic assignment problem. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "quadratic_assignment",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize._qap.quadratic_assignment"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " function supports the following methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "toctree",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "optimize.qap - faq optimize.qap - 2opt "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Assignment problems"
    },
    {
      "children": [],
      "title": "Utilities"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "approx_fprime - Approximate the gradient of a scalar function. check_grad - Check the supplied derivative using finite differences. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Finite-difference approximation"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "bracket - Bracket a minimum, given two starting points. line_search - Return a step that satisfies the strong Wolfe conditions. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Line search"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "LbfgsInvHessProduct - Linear operator for L - BFGS approximate inverse Hessian. HessianUpdateStrategy - Interface for implementing Hessian update strategies "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Hessian approximation"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "rosen - The Rosenbrock function. rosen_der - The derivative of the Rosenbrock function. rosen_hess - The Hessian matrix of the Rosenbrock function. rosen_hess_prod - Product of the Rosenbrock Hessian with a vector. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Benchmark problems"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The functions below are not recommended for use in new scripts; all of these methods are accessible via a newer, more consistent interfaces, provided by the interfaces above."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Legacy functions"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "General-purpose multivariate methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "fmin - Nelder - Mead Simplex algorithm. fmin_powell - Powell ' s ( modified) level set method. fmin_cg - Non - linear ( Polak - Ribiere) conjugate gradient algorithm. fmin_bfgs - Quasi - Newton method ( Broydon - Fletcher - Goldfarb - Shanno). fmin_ncg - Line - search Newton Conjugate Gradient. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Constrained multivariate methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "fmin_l_bfgs_b - Zhu, Byrd, and Nocedal ' s constrained optimizer. fmin_tnc - Truncated Newton code. fmin_cobyla - Constrained optimization by linear approximation. fmin_slsqp - Minimization using sequential least - squares programming. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Univariate (scalar) minimization methods:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "fminbound - Bounded minimization of a scalar function. brent - 1 - D function minimization using Brent method. golden - 1 - D function minimization using Golden Section method. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Optimization"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "leastsq - Minimize the sum of squares of M equations in N unknowns. "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Least-squares"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "General nonlinear solvers:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "fsolve - Non - linear multivariable equation solver. broyden1 - Broyden ' s first method. broyden2 - Broyden ' s second method. "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Large-scale nonlinear solvers:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "newton_krylov anderson "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Simple iteration solvers:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "excitingmixing linearmixing diagbroyden "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Link",
                "data": {
                  "value": "Additional information on the nonlinear solvers",
                  "reference": {
                    "module": "scipy",
                    "version": "1.7.1",
                    "kind": "module",
                    "path": "scipy.optimize.nonlin"
                  },
                  "kind": "module",
                  "exists": true
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Root finding"
    }
  ]
}
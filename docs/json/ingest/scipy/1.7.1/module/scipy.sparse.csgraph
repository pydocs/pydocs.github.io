{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.sparse.csgraph"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/scipy/sparse/csgraph/__init__.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "scipy.signal.filter_design.optimize._differentiable_functions.sps.csgraph"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.sparse.csgraph",
  "arbitrary": [
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "currentmodule",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "scipy.sparse.csgraph "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Fast graph algorithms based on sparse matrix representations."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Compressed sparse graph routines (:mod:`scipy.sparse.csgraph`)"
    },
    {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "connected_components - - determine connected components of a graph laplacian - - compute the laplacian of a graph shortest_path - - compute the shortest path between points on a positive graph dijkstra - - use Dijkstra ' s algorithm for shortest path floyd_warshall - - use the Floyd - Warshall algorithm for shortest path bellman_ford - - use the Bellman - Ford algorithm for shortest path johnson - - use Johnson ' s algorithm for shortest path breadth_first_order - - compute a breadth - first order of nodes depth_first_order - - compute a depth - first order of nodes breadth_first_tree - - construct the breadth - first tree from a given node depth_first_tree - - construct a depth - first tree from a given node minimum_spanning_tree - - construct the minimum spanning tree of a graph reverse_cuthill_mckee - - compute permutation for reverse Cuthill - McKee ordering maximum_flow - - solve the maximum flow problem for a graph maximum_bipartite_matching - - compute a maximum matching of a bipartite graph min_weight_full_bipartite_matching - compute a minimum weight full matching of a bipartite graph structural_rank - - compute the structural rank of a graph NegativeCycleError "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "autosummary",
            "args0": [
              ":toctree: generated/"
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "construct_dist_matrix csgraph_from_dense csgraph_from_masked csgraph_masked_from_dense csgraph_to_dense csgraph_to_masked reconstruct_path "
                  }
                }
              ],
              "inner": []
            }
          }
        }
      ],
      "title": "Contents"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This module uses graphs which are stored in a matrix format. A graph with N nodes can be represented by an (N x N) adjacency matrix G. If there is a connection from node i to node j, then G[i, j] = w, where w is the weight of the connection. For nodes i and j which are not connected, the value depends on the representation:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "for dense array representations, non-edges are represented by   G[i, j] = 0, infinity, or NaN."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "for dense masked representations (of type np.ma.MaskedArray), non-edges   are represented by masked values. This can be useful when graphs with   zero-weight edges are desired."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "for sparse array representations, non-edges are represented by   non-entries in the matrix. This sort of sparse representation also   allows for edges with zero weights."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "As a concrete example, imagine that you would like to represent the following undirected graph::                "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "G\n\n0)\n  \\\n   2\n    \\\n    (1)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This graph has three nodes, where node 0 and 1 are connected by an edge of weight 2, and nodes 0 and 2 are connected by an edge of weight 1. We can construct the dense, masked, and sparse representations as follows, keeping in mind that an undirected graph is represented by a symmetric matrix::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> G_dense = np.array([[0, 2, 1],\n...                     [2, 0, 0],\n...                     [1, 0, 0]])\n>>> G_masked = np.ma.masked_values(G_dense, 0)\n>>> from scipy.sparse import csr_matrix\n>>> G_sparse = csr_matrix(G_dense)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This becomes more difficult when zero edges are significant. For example, consider the situation when we slightly modify the above graph::               "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "G2\n\n(0)\n   \\\n    2\n     \\\n     (1)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This is identical to the previous graph, except nodes 0 and 2 are connected by an edge of zero weight. In this case, the dense representation above leads to ambiguities: how can non-edges be represented if zero is a meaningful value? In this case, either a masked or sparse representation must be used to eliminate the ambiguity::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> G2_data = np.array([[np.inf, 2,      0     ],\n...                     [2,      np.inf, np.inf],\n...                     [0,      np.inf, np.inf]])\n>>> G2_masked = np.ma.masked_invalid(G2_data)\n>>> from scipy.sparse.csgraph import csgraph_from_dense\n>>> # G2_sparse = csr_matrix(G2_data) would give the wrong result\n>>> G2_sparse = csgraph_from_dense(G2_data, null_value=np.inf)\n>>> G2_sparse.data\narray([ 2.,  0.,  2.,  0.])"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Here we have used a utility routine from the csgraph submodule in order to convert the dense representation to a sparse representation which can be understood by the algorithms in submodule. By viewing the data array, we can see that the zero values are explicitly encoded in the graph."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Graph Representations"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Matrices may represent either directed or undirected graphs. This is specified throughout the csgraph module by a boolean keyword. Graphs are assumed to be directed by default. In a directed graph, traversal from node i to node j can be accomplished over the edge G[i, j], but not the edge G[j, i].  Consider the following dense graph::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> G_dense = np.array([[0, 1, 0],\n...                     [2, 0, 3],\n...                     [0, 4, 0]])"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "When "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "directed=True"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " we get the graph::        "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "---1--> ---3-->\n)     (1)     (2)\n<--2--- <--4---"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In a non-directed graph, traversal from node i to node j can be accomplished over either G[i, j] or G[j, i].  If both edges are not null, and the two have unequal weights, then the smaller of the two is used."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "So for the same graph, when "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "directed=False"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " we get the graph::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "(0)--1--(1)--2--(2)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Note that a symmetric matrix will represent an undirected graph, regardless of whether the 'directed' keyword is set to True or False. In this case, using "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "directed=True"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " generally leads to more efficient computation."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The routines in this module accept as input either scipy.sparse representations (csr, csc, or lil format), masked representations, or dense representations with non-edges indicated by zeros, infinities, and NaN entries."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Directed vs. undirected"
    }
  ]
}
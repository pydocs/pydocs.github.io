{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.sparse.linalg.dsolve"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/scipy/sparse/linalg/dsolve/__init__.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "scipy.signal.filter_design.optimize._differentiable_functions.sps.linalg.dsolve"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.7.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "scipy.sparse.linalg.dsolve",
  "arbitrary": [
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The default solver is SuperLU (included in the scipy distribution), which can solve real or complex linear systems in both single and double precisions.  It is automatically replaced by UMFPACK, if available.  Note that UMFPACK works in double precision only, so switch it off by::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> use_solver(useUmfpack=False)"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "to solve in the single precision. See also use_solver documentation."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Example session::      "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": ">>> from scipy.sparse import csc_matrix, spdiags\n>>> from numpy import array\n>>> from scipy.sparse.linalg import spsolve, use_solver\n>>>\n>>> print(\"Inverting a sparse linear system:\")\n>>> print(\"The sparse matrix (constructed from diagonals):\")\n>>> a = spdiags([[1, 2, 3, 4, 5], [6, 5, 8, 9, 10]], [0, 1], 5, 5)\n>>> b = array([1, 2, 3, 4, 5])\n>>> print(\"Solve: single precision complex:\")\n>>> use_solver( useUmfpack = False )\n>>> a = a.astype('F')\n>>> x = spsolve(a, b)\n>>> print(x)\n>>> print(\"Error: \", a*x-b)\n>>>\n>>> print(\"Solve: double precision complex:\")\n>>> use_solver( useUmfpack = True )\n>>> a = a.astype('D')\n>>> x = spsolve(a, b)\n>>> print(x)\n>>> print(\"Error: \", a*x-b)\n>>>\n>>> print(\"Solve: double precision:\")\n>>> a = a.astype('d')\n>>> x = spsolve(a, b)\n>>> print(x)\n>>> print(\"Error: \", a*x-b)\n>>>\n>>> print(\"Solve: single precision:\")\n>>> use_solver( useUmfpack = False )\n>>> a = a.astype('f')\n>>> x = spsolve(a, b.astype('f'))\n>>> print(x)\n>>> print(\"Error: \", a*x-b)"
          }
        }
      ],
      "title": "Linear Solvers"
    }
  ]
}
{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "To remove in the future \u2013\u2013 numpy.lib.format"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/numpy/lib/format.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "numpy.lib.format"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "1.22.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "numpy.lib.format",
  "arbitrary": [
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Binary serialization"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "A simple format for saving numpy arrays to disk with the full information about them."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npy"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " format is the standard binary file format in NumPy for persisting a "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "single"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npz"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " format is the standard format for persisting "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "multiple"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " NumPy arrays on disk. A "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npz"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " file is a zip file containing multiple "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npy"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " files, one for each array."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "NPY format"
    },
    {
      "children": [
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Can represent all NumPy arrays including nested record arrays and   object arrays."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Represents the data in its native binary form."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Supports Fortran-contiguous arrays directly."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Stores all of the necessary information to reconstruct the array   including shape and dtype on a machine of a different   architecture.  Both little-endian and big-endian arrays are   supported, and a file with little-endian numbers will yield   a little-endian array on any machine reading the file. The   types are described in terms of their actual sizes. For example,   if a machine with a 64-bit C \"long int\" writes out an array with   \"long ints\", a reading machine with 32-bit C \"long ints\" will yield   an array with 64-bit integers."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Is straightforward to reverse engineer. Datasets often live longer than   the programs that created them. A competent developer should be   able to create a solution in their preferred programming language to   read most "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          ".npy"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " files that they have been given without much   documentation."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Allows memory-mapping of the data. See "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": "open_memmap",
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Can be read from a filelike stream object instead of an actual file."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Stores object arrays, i.e. arrays containing elements that are arbitrary   Python objects. Files with object arrays are not to be mmapable, but   can be read and written to disk."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": "Capabilities"
    },
    {
      "children": [
        {
          "type": "BulletList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Arbitrary subclasses of numpy.ndarray are not completely preserved.   Subclasses will be accepted for writing, but only the array data will   be written out. A regular numpy.ndarray object will be created   upon reading the file."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Admonition",
          "data": {
            "kind": "warning",
            "title": "",
            "children": [
              {
                "inline": [
                  {
                    "type": "Words",
                    "data": {
                      "value": "Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by ' f0 ' , ' f1 ' , etc. Such arrays will not round - trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the ``loadedarray.view ( correct_dtype)`` method. "
                    }
                  }
                ],
                "inner": []
              }
            ]
          }
        }
      ],
      "title": "Limitations"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "We recommend using the "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npy"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npz"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npy"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npz"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "File extensions"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "numpy.io",
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " will still be able to read and write Version 1.0 files."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Version numbering"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The first 6 bytes are a magic string: exactly "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "\\x93NUMPY"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The next 1 byte is an unsigned byte: the major version number of the file format, e.g. "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "\\x01"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "\\x00"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". Note: the version of the file format is not tied to the version of the numpy package."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The next HEADER_LEN bytes form the header data describing the array's format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline ("
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "\\n"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ") and padded with spaces ("
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "\\x20"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ") to make the total of "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "len(magic string) + 2 + len(length) + HEADER_LEN"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " be evenly divisible by 64 for alignment purposes."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The dictionary contains three keys:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockQuote",
          "data": {
            "value": [
              "\"descr\" : dtype.descr",
              "  An object that can be passed as an argument to the `numpy.dtype`",
              "  constructor to create the array's dtype.",
              "\"fortran_order\" : bool",
              "  Whether the array data is Fortran-contiguous or not. Since",
              "  Fortran-contiguous arrays are a common form of non-C-contiguity,",
              "  we allow them to be written directly to disk for efficiency.",
              "\"shape\" : tuple of int",
              "  The shape of the array."
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Following the header comes the array data. If the dtype contains Python objects (i.e. "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "dtype.hasobject is True"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "fortran_order"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ") bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "shape=()"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " means there is 1 element) by "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "dtype.itemsize"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Format Version 1.0"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The version 1.0 format only allowed the array header to have a total size of 65535 bytes.  This can be exceeded by structured arrays with a large number of columns.  The version 2.0 format extends the header size to 4 GiB. "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "numpy.save",
                  "reference": {
                    "module": "numpy",
                    "version": "1.22.1",
                    "kind": "module",
                    "path": "numpy.save"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The description of the fourth element of the header therefore has become: \"The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.\""
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Format Version 2.0"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Format Version 3.0"
    },
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    ".npy"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " format, including motivation for creating it and a comparison of alternatives, is described in the "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": "\"npy-format\" NEP <neps:nep-0001-npy-format>",
                  "domain": null,
                  "role": "doc"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", however details have evolved with time and this document is more current."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": "Notes"
    }
  ]
}
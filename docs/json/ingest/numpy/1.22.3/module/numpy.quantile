Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.15.0 €ögMethodsÙ¯‚€öeNotesÙ¯‚‘Ù¹‚•Ù§oGiven a vector Ù¡aVÙ§k of length Ù¡aNÙ§w, the q-th quantile of Ù¡aVÙ§n is the value Ù¡aqÙ§x@ of the way from the minimum to the maximum in a sorted copy of Ù¡aVÙ§xG. The values and distances of the two nearest neighbors as well as the Ù¢„fmethodÙ „ööelocalfmethodelocalõÙ§x` parameter will determine the quantile if the normalized ranking does not match the location of Ù¡aqÙ§x5 exactly. This function is the same as the median if Ù¡eq=0.5Ù§x, the same as the minimum if Ù¡eq=0.0Ù§x  and the same as the maximum if Ù¡eq=1.0Ù§a.€Ù¹‚‰Ù§nThis optional Ù¢„fmethodÙ „ööelocalfmethodelocalõÙ§x^ parameter specifies the method to use when the desired quantile lies between two data points Ù¡ei < jÙ§e. If Ù¡agÙ§x3 is the fractional part of the index surrounded by Ù¡aiÙ§x? and alpha and beta are correction constants modifying i and j.€Ù¤x0i + g = ( q - alpha) / ( n - alpha - beta + 1 ) Ù¹‚Ù§x*The different methods then work as follows€ÙÁÙÅ‚Ù¹‚Ù§minverted_cdf:€Ù¹‚Ù§xxmethod 1 of H&F .     This method gives discontinuous results:     * if g > 0 ; then take j     * if g = 0 ; then take i€ÙÁÙÅ‚Ù¹‚Ù§vaveraged_inverted_cdf:€Ù¹‚Ù§x‡method 2 of H&F .     This method give discontinuous results:     * if g > 0 ; then take j     * if g = 0 ; then average between bounds€ÙÁÙÅ‚Ù¹‚Ù§tclosest_observation:€Ù¹‚Ù§x·method 3 of H&F .     This method give discontinuous results:     * if g > 0 ; then take j     * if g = 0 and index is odd ; then take j     * if g = 0 and index is even ; then take i€ÙÁÙÅ‚Ù¹‚Ù§xinterpolated_inverted_cdf:€Ù¹‚Ù§x_method 4 of H&F .     This method give continuous results using:     * alpha = 0     * beta = 1€ÙÁÙÅ‚Ù¹‚Ù§fhazen:€Ù¹‚Ù§xcmethod 5 of H&F .     This method give continuous results using:     * alpha = 1/2     * beta = 1/2€ÙÁÙÅ‚Ù¹‚Ù§hweibull:€Ù¹‚Ù§x_method 6 of H&F .     This method give continuous results using:     * alpha = 0     * beta = 0€ÙÁÙÅ‚Ù¹‚Ù§glinear:€Ù¹‚Ù§x_method 7 of H&F .     This method give continuous results using:     * alpha = 1     * beta = 1€ÙÁÙÅ‚Ù¹‚Ù§pmedian_unbiased:€Ù¹‚Ù§xÓmethod 8 of H&F .     This method is probably the best method if the sample     distribution function is unknown (see reference).     This method give continuous results using:     * alpha = 1/3     * beta = 1/3€ÙÁÙÅ‚Ù¹‚Ù§pnormal_unbiased:€Ù¹‚Ù§xÎmethod 9 of H&F .     This method is probably the best method if the sample     distribution function is known to be normal.     This method give continuous results using:     * alpha = 3/8     * beta = 3/8€ÙÁÙÅ‚Ù¹‚Ù§flower:€Ù¹‚ƒÙ§x9NumPy method kept for backwards compatibility.     Takes Ù¡aiÙ§x as the interpolation point.€ÙÁÙÅ‚Ù¹‚Ù§ghigher:€Ù¹‚ƒÙ§x9NumPy method kept for backwards compatibility.     Takes Ù¡ajÙ§x as the interpolation point.€ÙÁÙÅ‚Ù¹‚Ù§hnearest:€Ù¹‚…Ù§x9NumPy method kept for backwards compatibility.     Takes Ù¡aiÙ§d or Ù¡ajÙ§w, whichever is nearest.€ÙÁÙÅ‚Ù¹‚Ù§imidpoint:€Ù¹‚ƒÙ§x8NumPy method kept for backwards compatibility.     Uses Ù¡k(i + j) / 2Ù§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒaajarray_likeÙ¹‚Ù§x8Input array or object that can be converted to an array.€Ù°ƒaqsarray_like of floatÙ¹‚Ù§xVQuantile or sequence of quantiles to compute, which must be between 0 and 1 inclusive.€Ù°ƒdaxisx#{int, tuple of int, None}, optionalÙ¹‚Ù§x†Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.€Ù°ƒcoutqndarray, optionalÙ¹‚Ù§x´Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary.€Ù°ƒooverwrite_inputnbool, optionalÙ¹‚…Ù§x$If True, then allow the input array Ù¢„aaÙ „ööelocalaaelocalõÙ§xf to be modified by intermediate calculations, to save memory. In this case, the contents of the input Ù¢„aaÙ „ööelocalaaelocalõÙ§x, after this function completes is undefined.€Ù°ƒfmethodmstr, optional…Ù¹‚Ù§xèThis parameter specifies the method to use for estimating the quantile.  There are many different methods, some unique to NumPy. See the notes for explanation.  The options sorted by their R type as summarized in the H&F paper  are:€ÙÇ‰Ù¹‚Ù§n'inverted_cdf'€Ù¹‚Ù§w'averaged_inverted_cdf'€Ù¹‚Ù§u'closest_observation'€Ù¹‚Ù§x'interpolated_inverted_cdf'€Ù¹‚Ù§g'hazen'€Ù¹‚Ù§i'weibull'€Ù¹‚Ù§s'linear'  (default)€Ù¹‚Ù§q'median_unbiased'€Ù¹‚Ù§q'normal_unbiased'€Ù¹‚Ù§xŒThe first three methods are discontiuous.  NumPy further defines the following discontinuous variations of the default 'linear' (7.) option:€ÙÈ„Ù¹‚Ù§g'lower'€Ù¹‚Ù§i'higher',€Ù¹‚Ù§j'midpoint'€Ù¹‚Ù§i'nearest'€ÙÆƒnversionchangedf1.22.0Ù¹‚Ù§xuThis argument was previously called " interpolation " and only offered the " linear " default and last four options. €Ù°ƒhkeepdimsnbool, optionalÙ¹‚ƒÙ§x¸If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€Ù°ƒminterpolationmstr, optional‚Ù¹‚Ù§x0Deprecated name for the method keyword argument.€ÙÆƒjdeprecateddTODOÙ¹‚Ù§g1.22.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒhquantileqscalar or ndarrayÙ¹‚Ù§cIf Ù¢„aqÙ „ööelocalaqelocalõÙ§x is a single quantile and Ù£ƒiaxis=NoneööÙ§x¶, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of Ù¢„aaÙ „ööelocalaaelocalõÙ§x8. If the input contains integers or floats smaller than Ù¡gfloat64Ù§x, the output data-type is Ù¡gfloat64Ù§xG. Otherwise, the output data-type is the same as that of the input. If Ù¢„coutÙ „ööelocalcoutelocalõÙ§x. is specified, that array is returned instead.€ögSummaryÙ¯‚Ù¹‚Ù§x?Compute the q-th quantile of the data along the specified axis.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesjReferencesx/numpy/lib/function_base.py/r<class 'function'>nnumpy.quantileÙ¯‚ŠÙ´ƒ˜!Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`aax*array([[10,  7,  4],
       [ 3,  2,  1]])fexecedÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a)c3.5fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)varray([6.5, 4.5, 2.5])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)parray([7.,  2.])fexecedÙ´ƒ“Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`hkeepdimsÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)xarray([[7.],
       [2.]])fexecedÙ´ƒ˜1Ù±‚`amÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`coutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„jzeros_likeÙ „enumpyf1.22.3fmodulepnumpy.zeros_likefmoduleõÙ±‚`a(Ù±‚`amÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`coutÙ±‚aoa=Ù±‚`coutÙ±‚`a)varray([6.5, 4.5, 2.5])fexecedÙ´ƒÙ±‚`amvarray([6.5, 4.5, 2.5])fexecedÙ´ƒ˜Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`aaÙ±‚aoa.Ù±‚`Ù¢„dcopyÙ „enumpyf1.22.3fmodulejnumpy.copyfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hquantileÙ „enumpyf1.22.3fmodulennumpy.quantilefmoduleõÙ±‚`a(Ù±‚`abÙ±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`ooverwrite_inputÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)parray([7.,  2.])fexecedÙ´ƒÙ±‚akfassertÙ±‚`a Ù±‚bowcnotÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„callÙ „enumpyf1.22.3fmoduleinumpy.allfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚`abÙ±‚`a)`fexecedÙ¹‚ƒÙ§iSee also Ù¢„pnumpy.percentileÙ „enumpyf1.22.3fmodulepnumpy.percentilefmoduleõÙ§x% for a visualization of most methods.€ö„Ù¼ƒÙ»ƒdmeanjnumpy.meanõ€öÙ¼ƒÙ»ƒfmedianlnumpy.medianõÙ¹‚‚Ù§nequivalent to Ù¡rquantile(..., 0.5)€öÙ¼ƒÙ»ƒknanquantileqnumpy.nanquantileõ€öÙ¼ƒÙ»ƒjpercentilepnumpy.percentileõÙ¹‚Ù§x9equivalent to quantile, but with q in the range [0, 100].€öf1.22.3Ù«xrquantile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, interpolation=None)önnumpy.quantile€
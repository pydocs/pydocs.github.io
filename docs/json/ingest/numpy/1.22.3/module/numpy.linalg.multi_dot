Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚„Ù¢„imulti_dotÙ „enumpyf1.22.3fmodulevnumpy.linalg.multi_dotfmoduleõÙ§h chains Ù¢„inumpy.dotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ§xŠ and uses optimal parenthesization of the matrices  . Depending on the shapes of the matrices, this can speed up the multiplication a lot.€Ù¹‚Ù§xšIf the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.€Ù¹‚ƒÙ§iThink of Ù¢„imulti_dotÙ „enumpyf1.22.3fmodulevnumpy.linalg.multi_dotfmoduleõÙ§k as::      €ÙÀx>def multi_dot(arrays): return functools.reduce(np.dot, arrays)ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚Ù§xZThe cost for a matrix multiplication can be calculated with the following function::      €ÙÀx?def cost(A, B):
    return A.shape[0] * A.shape[1] * B.shape[1]Ù¹‚ƒÙ§xAssume we have three matrices Ù¥xA_{10x100}, B_{100x5}, C_{5x50}Ù§a.€Ù¹‚Ù§xHThe costs for the two different parenthesizations are as follows::      €ÙÀxtcost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒfarraysvsequence of array_likeÙ¹‚Ù§x–If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.€Ù°ƒcoutqndarray, optional‚Ù¹‚ƒÙ§x×Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for Ù£ƒidot(a, b)ööÙ§xŠ. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.19.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfoutputgndarrayÙ¹‚Ù§x/Returns the dot product of the supplied arrays.€ögSummaryÙ¯‚Ù¹‚Ù§x„Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsojReferenceshExampleseNotesw/numpy/linalg/linalg.py
/r<class 'function'>vnumpy.linalg.multi_dotÙ¯‚‚Ù´ƒ˜iÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„imulti_dotÙ „enumpyf1.22.3fmodulevnumpy.linalg.multi_dotfmoduleõÙ±‚`a
Ù±‚bc1s# Prepare some dataÙ±‚`a
Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmie10000Ù±‚`a,Ù±‚`a Ù±‚bmic100Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aBÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmic100Ù±‚`a,Ù±‚`a Ù±‚bmid1000Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aCÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmid1000Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aDÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmic333Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚bc1x# the actual dot multiplicationÙ±‚`a
Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„imulti_dotÙ „enumpyf1.22.3fmodulevnumpy.linalg.multi_dotfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aBÙ±‚`a,Ù±‚`a Ù±‚`aCÙ±‚`a,Ù±‚`a Ù±‚`aDÙ±‚`a]Ù±‚`a)`fexecedÙ´ƒ˜4Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aBÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`aCÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`aDÙ±‚`a)Ù±‚`a
Ù±‚bc1d# orÙ±‚`a
Ù±‚`a_Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aBÙ±‚`a)Ù±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aCÙ±‚`a)Ù±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aDÙ±‚`a)`fexecedöÙ¼ƒÙ»ƒinumpy.dotinumpy.dotõÙ¹‚Ù§x&dot multiplication with two arguments.€öf1.22.3Ù«xmulti_dot(arrays, *, out=None)övnumpy.linalg.multi_dot€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚‡Ù§uUsing an instance of Ù¢„herrstateÙ „enumpyf1.22.3fmodulennumpy.errstatefmoduleõÙ§x¢ as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with Ù¢„fseterrÙ „enumpyf1.22.3fmodulelnumpy.seterrfmoduleõÙ§e and Ù¢„jseterrcallÙ „enumpyf1.22.3fmodulepnumpy.seterrcallfmoduleõÙ§x5, and upon exiting it is reset to what it was before.€ÙÆƒnversionchangedf1.17.0Ù¹‚Ù§xº`errstate` is also usable as a function decorator, saving a level of indentation if an entire function is wrapped. See : py : class : `contextlib.ContextDecorator` for more information. €ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚ƒÙ§x`For complete documentation of the types of floating-point exceptions and treatment options, see Ù¢„fseterrÙ „enumpyf1.22.3fmodulelnumpy.seterrfmoduleõÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒfkwargsx{divide, over, under, invalid}Ù¹‚Ù§x÷Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x2Context manager for floating-point error handling.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡iSignaturegSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesr/numpy/__init__.pyön<class 'type'>nnumpy.errstateÙ¯‚‡Ù´ƒÙ±‚`folderrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fseterrÙ „enumpyf1.22.3fmodulelnumpy.seterrfmoduleõÙ±‚`a(Ù±‚bnbÙ¢„callÙ „enumpyf1.22.3fmoduleinumpy.allfmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fignoreÙ±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1x$# Set error handling to known state.`hcompiledÙ´ƒŠÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmfb0.varray([nan, inf, inf])hcompiledÙ´ƒ˜Ù±‚akdwithÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„herrstateÙ „enumpyf1.22.3fmodulennumpy.errstatefmoduleõÙ±‚`a(Ù±‚`fdivideÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dwarnÙ±‚bs1a'Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a)Ù±‚`a Ù±‚aoa/Ù±‚`a Ù±‚bmfb0.varray([nan, inf, inf])hcompiledÙ´ƒ‡Ù±‚`bnpÙ±‚aoa.Ù±‚`dsqrtÙ±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a)cnanhcompiledÙ´ƒ–Ù±‚akdwithÙ±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„herrstateÙ „enumpyf1.22.3fmodulennumpy.errstatefmoduleõÙ±‚`a(Ù±‚`ginvalidÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1eraiseÙ±‚bs1a'Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`bnpÙ±‚aoa.Ù±‚`dsqrtÙ±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a)x~Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
FloatingPointError: invalid value encountered in sqrthcompiledÙ¹‚Ù§x@Outside the context the error handling behavior has not changed:€Ù´ƒ…Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fgeterrÙ „enumpyf1.22.3fmodulelnumpy.geterrfmoduleõÙ±‚`a(Ù±‚`a)xN{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}hcompiledö„Ù¼ƒÙ»ƒfgeterrlnumpy.geterrõ€öÙ¼ƒÙ»ƒjgeterrcallpnumpy.geterrcallõ€öÙ¼ƒÙ»ƒfseterrlnumpy.seterrõ€öÙ¼ƒÙ»ƒjseterrcallpnumpy.seterrcallõ€öf1.22.3Ù«rerrstate(**kwargs)önnumpy.errstate€
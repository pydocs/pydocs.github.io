Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§xÁThis iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.€Ù¹‚…Ù§x1Functions returning an index along an axis, like Ù¢„gargsortÙ „enumpyf1.22.3fmodulemnumpy.argsortfmoduleõÙ§e and Ù¢„largpartitionÙ „enumpyf1.22.3fmodulernumpy.argpartitionfmoduleõÙ§x-, produce suitable indices for this function.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.15.0 €ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚‰Ù§x=This is equivalent to (but faster than) the following use of Ù¢„gndindexÙ „enumpyf1.22.3fmodulemnumpy.ndindexfmoduleõÙ§e and Ù£ƒbs_ööÙ§u, which sets each of Ù¡biiÙ§e and Ù¡bkkÙ§x to a tuple of indices::      €ÙÀyNi, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
J = indices.shape[axis]  # Need not equal M
out = np.empty(Ni + (J,) + Nk)

for ii in ndindex(Ni):
    for kk in ndindex(Nk):
        a_1d       = a      [ii + s_[:,] + kk]
        indices_1d = indices[ii + s_[:,] + kk]
        out_1d     = out    [ii + s_[:,] + kk]
        for j in range(J):
            out_1d[j] = a_1d[indices_1d[j]]Ù¹‚Ù§xUEquivalently, eliminating the inner loop, the last two lines would be::              €ÙÀxout_1d[:] = a_1d[indices_1d]öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒcarrxndarray (Ni..., M, Nk...)Ù¹‚Ù§lSource array€Ù°ƒgindicesxndarray (Ni..., J, Nk...)Ù¹‚…Ù§x'Indices to take along each 1d slice of Ù¢„carrÙ „ööelocalcarrelocalõÙ§x`. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against Ù¢„carrÙ „ööelocalcarrelocalõÙ§a.€Ù°ƒdaxiscintÙ¹‚…Ù§xŒThe axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ§e and Ù¢„gargsortÙ „enumpyf1.22.3fmodulemnumpy.argsortfmoduleõÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`xout: ndarray (Ni..., J, Nk...)Ù¹‚Ù§sThe indexed result.€ögSummaryÙ¯‚Ù¹‚Ù§xFTake values from the input array by matching 1d index and data slices.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshSee AlsohExamplesx/numpy/lib/shape_base.py8r<class 'function'>unumpy.take_along_axisÙ¯‚Ù¹‚Ù§uFor this sample array€Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib30Ù±‚`a,Ù±‚`a Ù±‚bmib20Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmib60Ù±‚`a,Ù±‚`a Ù±‚bmib40Ù±‚`a,Ù±‚`a Ù±‚bmib50Ù±‚`a]Ù±‚`a]Ù±‚`a)`fexecedÙ¹‚Ù§xGWe can sort either by using sort directly, or argsort and this function€Ù´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)x*array([[10, 20, 30],
       [40, 50, 60]])fexecedÙ´ƒ’Ù±‚`baiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gargsortÙ „enumpyf1.22.3fmodulemnumpy.argsortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`baix$array([[0, 2, 1],
       [1, 2, 0]])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„otake_along_axisÙ „enumpyf1.22.3fmoduleunumpy.take_along_axisfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`baiÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)x*array([[10, 20, 30],
       [40, 50, 60]])fexecedÙ¹‚Ù§x=The same works for max and min, if you expand the dimensions:€Ù´ƒ•Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kexpand_dimsÙ „enumpyf1.22.3fmoduleqnumpy.expand_dimsfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`cmaxÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)xarray([[30],
       [60]])fexecedÙ´ƒ˜Ù±‚`baiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kexpand_dimsÙ „enumpyf1.22.3fmoduleqnumpy.expand_dimsfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fargmaxÙ „enumpyf1.22.3fmodulelnumpy.argmaxfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`baixarray([[1],
       [0]])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„otake_along_axisÙ „enumpyf1.22.3fmoduleunumpy.take_along_axisfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`baiÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)xarray([[30],
       [60]])fexecedÙ¹‚Ù§xRIf we want to get the max and min at the same time, we can stack the indices first€Ù´ƒ˜JÙ±‚`fai_minÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kexpand_dimsÙ „enumpyf1.22.3fmoduleqnumpy.expand_dimsfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fargminÙ „enumpyf1.22.3fmodulelnumpy.argminfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`fai_maxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kexpand_dimsÙ „enumpyf1.22.3fmoduleqnumpy.expand_dimsfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fargmaxÙ „enumpyf1.22.3fmodulelnumpy.argmaxfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`baiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„kconcatenateÙ „enumpyf1.22.3fmoduleqnumpy.concatenatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`fai_minÙ±‚`a,Ù±‚`a Ù±‚`fai_maxÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`baixarray([[0, 1],
       [1, 0]])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„otake_along_axisÙ „enumpyf1.22.3fmoduleunumpy.take_along_axisfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`baiÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a)x"array([[10, 30],
       [40, 60]])fexecedö‚Ù¼ƒÙ»ƒnput_along_axistnumpy.put_along_axisõÙ¹‚Ù§xJPut values into the destination array by matching 1d index and data slices€öÙ¼ƒÙ»ƒdtakejnumpy.takeõÙ¹‚Ù§x=Take along an axis, using the same indices for every 1d slice€öf1.22.3Ù«x#take_along_axis(arr, indices, axis)öunumpy.take_along_axis€
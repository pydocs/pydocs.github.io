Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚•Ù§x7=========  =============  ============================ Ù¢„erightÙ „enumpyf1.22.3fmodulexnumpy.ma.core.right_shiftfmoduleõÙ§x"    order of bins  returned index Ù£ƒaiööÙ§xB satisfies =========  =============  ============================ Ù¡eFalseÙ§q  increasing     Ù¡xbins[i-1] <= x < bins[i]Ù§a Ù¡dTrueÙ§r   increasing     Ù¡xbins[i-1] < x <= bins[i]Ù§a Ù¡eFalseÙ§q  decreasing     Ù¡xbins[i-1] > x >= bins[i]Ù§a Ù¡dTrueÙ§r   decreasing     Ù¡xbins[i-1] >= x > bins[i]Ù§x7 =========  =============  ============================€Ù¹‚‡Ù§mIf values in Ù¢„axÙ „ööelocalaxelocalõÙ§x are beyond the bounds of Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§g, 0 or Ù¡ilen(bins)Ù§x is returned as appropriate.€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚‡Ù§mIf values in Ù¢„axÙ „ööelocalaxelocalõÙ§xD are such that they fall outside the bin range, attempting to index Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§w with the indices that Ù¢„hdigitizeÙ „enumpyf1.22.3fmodulennumpy.digitizefmoduleõÙ§x& returns will result in an IndexError.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.10.0 €Ù¹‚„Ù£ƒknp.digitizeööÙ§x is  implemented in terms of Ù£ƒonp.searchsortedööÙ§xÙ. This means that a binary search is used to bin the values, which scales much better for larger number of bins than the previous linear search. It also removes the requirement for the input array to be 1-dimensional.€Ù¹‚ƒÙ§xFor monotonically _increasing_ Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§x&, the following are equivalent::      €ÙÀxFnp.digitize(x, bins, right=True)
np.searchsorted(bins, x, side='left')Ù¹‚ƒÙ§xPNote that as the order of the arguments are reversed, the side must be too. The Ù¢„lsearchsortedÙ „enumpyf1.22.3fmodulernumpy.searchsortedfmoduleõÙ§xx call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaxjarray_likeÙ¹‚Ù§xpInput array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.€Ù°ƒdbinsjarray_likeÙ¹‚Ù§x8Array of bins. It has to be 1-dimensional and monotonic.€Ù°ƒerightnbool, optionalÙ¹‚Ù§y*Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] <= x < bins[i] is the default behavior for monotonically increasing bins.€öfRaisesÙ¯‚‚Ù°ƒ`jValueErrorÙ¹‚ƒÙ§cIf Ù¢„dbinsÙ „ööelocaldbinselocalõÙ§r is not monotonic.€Ù°ƒ`iTypeErrorÙ¹‚Ù§x$If the type of the input is complex.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒgindicesondarray of intsÙ¹‚ƒÙ§x*Output array of indices, of same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§xJReturn the indices of the bins to which each value in input array belongs.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/lib/function_base.pyr<class 'function'>nnumpy.digitizeÙ¯‚„Ù´ƒ˜>Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc0.2Ù±‚`a,Ù±‚`a Ù±‚bmfc6.4Ù±‚`a,Ù±‚`a Ù±‚bmfc3.0Ù±‚`a,Ù±‚`a Ù±‚bmfc1.6Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc0.0Ù±‚`a,Ù±‚`a Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmfc4.0Ù±‚`a,Ù±‚`a Ù±‚bmfd10.0Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`dindsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hdigitizeÙ „enumpyf1.22.3fmodulennumpy.digitizefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚`a)Ù±‚`a
Ù±‚`dindssarray([1, 4, 3, 2])fexecedÙ´ƒ˜4Ù±‚akcforÙ±‚`a Ù±‚`anÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnberangeÙ±‚`a(Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„dsizeÙ „enumpyf1.22.3fmodulejnumpy.sizefmoduleõÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`b  Ù±‚bnbeprintÙ±‚`a(Ù±‚`dbinsÙ±‚`a[Ù±‚`dindsÙ±‚`a[Ù±‚`anÙ±‚`a]Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2b<=Ù±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚`anÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2a<Ù±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`dbinsÙ±‚`a[Ù±‚`dindsÙ±‚`a[Ù±‚`anÙ±‚`a]Ù±‚`a]Ù±‚`a)xH...
0.0 <= 0.2 < 1.0
4.0 <= 6.4 < 10.0
2.5 <= 3.0 < 4.0
1.0 <= 1.6 < 2.5fexecedÙ´ƒ˜>Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc1.2Ù±‚`a,Ù±‚`a Ù±‚bmfd10.0Ù±‚`a,Ù±‚`a Ù±‚bmfd12.4Ù±‚`a,Ù±‚`a Ù±‚bmfd15.5Ù±‚`a,Ù±‚`a Ù±‚bmfc20.Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`dbinsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib15Ù±‚`a,Ù±‚`a Ù±‚bmib20Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hdigitizeÙ „enumpyf1.22.3fmodulennumpy.digitizefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`dbinsÙ±‚`a,Ù±‚`Ù¢„erightÙ „enumpyf1.22.3fmodulexnumpy.ma.core.right_shiftfmoduleõÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)varray([1, 2, 3, 4, 4])fexecedÙ´ƒŒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hdigitizeÙ „enumpyf1.22.3fmodulennumpy.digitizefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`dbinsÙ±‚`a,Ù±‚`Ù¢„erightÙ „enumpyf1.22.3fmodulexnumpy.ma.core.right_shiftfmoduleõÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)varray([1, 3, 3, 4, 5])fexecedö„Ù¼ƒÙ»ƒhbincountnnumpy.bincountõ€öÙ¼ƒÙ»ƒihistogramonumpy.histogramõ€öÙ¼ƒÙ»ƒlsearchsortedrnumpy.searchsortedõ€öÙ¼ƒÙ»ƒfuniquelnumpy.uniqueõ€öf1.22.3Ù«xdigitize(x, bins, right=False)önnumpy.digitize€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚ƒÙ§xmCalculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all Ù¨Ù§elargeÙ§q singular values.€ÙÆƒnversionchangedd1.14Ù¹‚Ù§x&Can now operate on stacks of matrices €ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚‹Ù§x*The pseudo-inverse of a matrix A, denoted Ù¥cA^+Ù§xG, is defined as: "the matrix that 'solves' [the least-squares problem] Ù¥fAx = bÙ§l," i.e., if Ù¥g\bar{x}Ù§x is said solution, then Ù¥cA^+Ù§x is that matrix such that Ù¥n\bar{x} = A^+bÙ§a.€Ù¹‚‹Ù§xIt can be shown that if Ù¥tQ_1 \Sigma Q_2^T = AÙ§x0 is the singular value decomposition of A, then Ù¥xA^+ = Q_2 \Sigma^+ Q_1^TÙ§h, where Ù¥gQ_{1,2}Ù§x are orthogonal matrices, Ù¥f\SigmaÙ§xm is a diagonal matrix consisting of A's so-called singular values, (followed, typically, by zeros), and then Ù¥h\Sigma^+Ù§xo is simply the diagonal matrix consisting of the reciprocals of A's singular values (again, followed by zeros).€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaav(..., M, N) array_likeÙ¹‚Ù§x2Matrix or stack of matrices to be pseudo-inverted.€Ù°ƒercondx(...) array_like of floatÙ¹‚ƒÙ§xHCutoff for small singular values. Singular values less than or equal to Ù¡xrcond * largest_singular_valueÙ§x; are set to zero. Broadcasts against the stack of matrices.€Ù°ƒihermitiannbool, optional‚Ù¹‚ƒÙ§iIf True, Ù¢„aaÙ „ööelocalaaelocalõÙ§xˆ is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.17.0 €öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§x)If the SVD computation does not converge.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaBs(..., N, M) ndarrayÙ¹‚‰Ù§vThe pseudo-inverse of Ù¢„aaÙ „ööelocalaaelocalõÙ§e. If Ù¢„aaÙ „ööelocalaaelocalõÙ§f is a Ù¢„fmatrixÙ „enumpyf1.22.3fmodulelnumpy.matrixfmoduleõÙ§v instance, then so is Ù¢„aBÙ „ööelocalaBelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x7Compute the (Moore-Penrose) pseudo-inverse of a matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNotesjReferenceshExamplesw/numpy/linalg/linalg.pyor<class 'function'>qnumpy.linalg.pinvÙ¯‚ƒÙ¹‚…Ù§x"The following example checks that Ù¡oa * a+ * a == aÙ§e and Ù¡qa+ * a * a+ == a+Ù§a:€Ù´ƒ˜6Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`erandnÙ±‚`a(Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a
Ù±‚`aBÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dpinvÙ „enumpyf1.22.3fmoduleqnumpy.linalg.pinvfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aBÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a)Ù±‚`a)Ù±‚`a)dTruefexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aBÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aBÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`aBÙ±‚`a)Ù±‚`a)Ù±‚`a)dTruefexecedöƒÙ¼ƒÙ»ƒqscipy.linalg.pinvööÙ¹‚Ù§xSimilar function in SciPy.€öÙ¼ƒÙ»ƒrscipy.linalg.pinv2ööÙ¹‚Ù§x&Similar function in SciPy (SVD-based).€öÙ¼ƒÙ»ƒrscipy.linalg.pinvhööÙ¹‚Ù§xACompute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.€öf1.22.3Ù«x%pinv(a, rcond=1e-15, hermitian=False)öqnumpy.linalg.pinv€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚…Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§n is of length Ù£ƒen + 1ööÙ§x", this function returns the value:€Ù¤xCp ( x) = c_0 * He_0 ( x) + c_1 * He_1 ( x) + ... + c_n * He_n ( x) Ù¹‚‡Ù§nThe parameter Ù¢„axÙ „ööelocalaxelocalõÙ§xw is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support multiplication and addition both with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù¹‚Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§v is a 1-D array, then Ù£ƒdp(x)ööÙ§x will have the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§f.  If Ù¢„acÙ „ööelocalacelocalõÙ§xK is multidimensional, then the shape of the result depends on the value of Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§e. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§x5 is true the shape will be c.shape[1:] + x.shape. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§xJ is false the shape will be c.shape[1:]. Note that scalars have shape (,).€Ù¹‚Ù§xxTrailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x?The evaluation uses Clenshaw recursion, aka synthetic division.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaxxarray_like, compatible objectÙ¹‚‡Ù§cIf Ù¢„axÙ „ööelocalaxelocalõÙ§x| is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support addition and multiplication with with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒacjarray_likeÙ¹‚…Ù§xgArray of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If Ù¢„acÙ „ööelocalacelocalõÙ§x¦ is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒftensorqboolean, optional‚Ù¹‚Ù§xjIf True, the shape of the coefficient array is extended with ones on the right, one for each dimension of Ù¢„axÙ „ööelocalaxelocalõÙ§x_. Scalars have dimension 0 for this action. The result is that every column of coefficients in Ù¢„acÙ „ööelocalacelocalõÙ§x# is evaluated for every element of Ù¢„axÙ „ööelocalaxelocalõÙ§l. If False, Ù¢„axÙ „ööelocalaxelocalõÙ§x" is broadcast over the columns of Ù¢„acÙ „ööelocalacelocalõÙ§x2 for the evaluation.  This keyword is useful when Ù¢„acÙ „ööelocalacelocalõÙ§x0 is multidimensional. The default value is True.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfvaluesundarray, algebra_likeÙ¹‚Ù§x1The shape of the return value is described above.€ögSummaryÙ¯‚Ù¹‚Ù§x(Evaluate an HermiteE series at points x.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/polynomial/hermite_e.pyr<class 'function'>x#numpy.polynomial.hermite_e.hermevalÙ¯‚‚Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„ihermite_eÙ „enumpyf1.22.3fmodulexnumpy.polynomial.hermite_efmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hhermevalÙ „enumpyf1.22.3fmodulex#numpy.polynomial.hermite_e.hermevalfmoduleõÙ±‚`a
Ù±‚`dcoefÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„hhermevalÙ „enumpyf1.22.3fmodulex#numpy.polynomial.hermite_e.hermevalfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`dcoefÙ±‚`a)c3.0fexecedÙ´ƒ“Ù±‚`Ù¢„hhermevalÙ „enumpyf1.22.3fmodulex#numpy.polynomial.hermite_e.hermevalfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚bmia4Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dcoefÙ±‚`a)x&array([[ 3., 14.],
       [31., 54.]])fexecedö„Ù¼ƒÙ»ƒkhermegrid2dx&numpy.polynomial.hermite_e.hermegrid2dõ€öÙ¼ƒÙ»ƒkhermegrid3dx&numpy.polynomial.hermite_e.hermegrid3dõ€öÙ¼ƒÙ»ƒjhermeval2dx%numpy.polynomial.hermite_e.hermeval2dõ€öÙ¼ƒÙ»ƒjhermeval3dx%numpy.polynomial.hermite_e.hermeval3dõ€öf1.22.3Ù«xhermeval(x, c, tensor=True)öx#numpy.polynomial.hermite_e.hermeval€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚ƒÙ§x¿Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates Ù¢„fpyfuncÙ „enumpyf1.22.3fmodulepnumpy.frompyfuncfmoduleõÙ§xy over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.€Ù¹‚…Ù§xThe data type of the output of Ù¢„jvectorizedÙ „ööelocaljvectorizedelocalõÙ§xs is determined by calling the function with the first element of the input.  This can be avoided by specifying the Ù¢„fotypesÙ „enumpyf1.22.3fmodulex7numpy.lib.function_base.vectorize._get_ufunc_and_otypesfmoduleõÙ§j argument.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚ƒÙ§dThe Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ§xs function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.€Ù¹‚‡Ù§cIf Ù¢„fotypesÙ „enumpyf1.22.3fmodulex7numpy.lib.function_base.vectorize._get_ufunc_and_otypesfmoduleõÙ§x¤ is not specified, then a call to the function with the first argument will be used to determine the number of outputs.  The results of this call will be cached if Ù¢„ecacheÙ „ööelocalecacheelocalõÙ§d is Ù¡dTrueÙ§xÅ to prevent calling the function twice.  However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.€Ù¹‚ƒÙ§x'The new keyword argument interface and Ù¢„hexcludedÙ „ööelocalhexcludedelocalõÙ§x/ argument support further degrades performance.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒfpyfunchcallableÙ¹‚Ù§xA python function or method.€Ù°ƒfotypesxstr or list of dtypes, optionalÙ¹‚Ù§x°The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.€Ù°ƒcdocmstr, optionalÙ¹‚ƒÙ§xCThe docstring for the function. If None, the docstring will be the Ù¡npyfunc.__doc__Ù§a.€Ù°ƒhexcludedmset, optional‚Ù¹‚ƒÙ§xSet of strings or integers representing the positional or keyword arguments for which the function will not be vectorized.  These will be passed directly to Ù¢„fpyfuncÙ „enumpyf1.22.3fmodulepnumpy.frompyfuncfmoduleõÙ§l unmodified.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒecachenbool, optional‚Ù¹‚…Ù§cIf Ù¡dTrueÙ§xN, then cache the first function call that determines the number of outputs if Ù¢„fotypesÙ „enumpyf1.22.3fmodulex7numpy.lib.function_base.vectorize._get_ufunc_and_otypesfmoduleõÙ§q is not provided.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒisignaturepstring, optional‚Ù¹‚‡Ù§x0Generalized universal function signature, e.g., Ù¡n(m,n),(n)->(m)Ù§x; for vectorized matrix-vector multiplication. If provided, Ù¡fpyfuncÙ§x will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, Ù¡fpyfuncÙ§x0 is assumed to take scalars as input and output.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.12.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒjvectorizedhcallableÙ¹‚Ù§tVectorized function.€ögSummaryÙ¯‚Ù¹‚Ù§xGeneralized function class.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰iSignaturegSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesr/numpy/__init__.pyön<class 'type'>onumpy.vectorizeÙ¯‚Ù´ƒ˜/Ù±‚akcdefÙ±‚`a Ù±‚bnffmyfuncÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚bs2a"Ù±‚bs2x'Return a-b if a>b, otherwise return a+bÙ±‚bs2a"Ù±‚`a
Ù±‚`d    Ù±‚akbifÙ±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa>Ù±‚`a Ù±‚`abÙ±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚akÙ¢„freturnÙ „enumpyf1.22.3fmodulex.numpy.ma.core._convert2ma._replace_return_typefmoduleõÙ±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`abÙ±‚`a
Ù±‚`d    Ù±‚akdelseÙ±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚akÙ¢„freturnÙ „enumpyf1.22.3fmodulex.numpy.ma.core._convert2ma._replace_return_typefmoduleõÙ±‚`a Ù±‚`aaÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`ab`fexecedÙ´ƒ˜Ù±‚`evfuncÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`fmyfuncÙ±‚`a)Ù±‚`a
Ù±‚`evfuncÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)sarray([3, 4, 1, 2])fexecedÙ¹‚ƒÙ§x2The docstring is taken from the input function to Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ§x unless it is specified:€Ù´ƒƒÙ±‚`evfuncÙ±‚aoa.Ù±‚bvmg__doc__x)'Return a-b if a>b, otherwise return a+b'fexecedÙ´ƒ•Ù±‚`evfuncÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`fmyfuncÙ±‚`a,Ù±‚`a Ù±‚`cdocÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1sVectorized `myfunc`Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`evfuncÙ±‚aoa.Ù±‚bvmg__doc__u'Vectorized `myfunc`'fexecedÙ¹‚Ù§xcThe output type is determined by evaluating the first element of the input, unless it is specified:€Ù´ƒ˜Ù±‚`coutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`evfuncÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚bnbdtypeÙ±‚`a(Ù±‚`coutÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)u<class 'numpy.int64'>fexecedÙ´ƒ˜0Ù±‚`evfuncÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`fmyfuncÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fotypesÙ „enumpyf1.22.3fmodulex7numpy.lib.function_base.vectorize._get_ufunc_and_otypesfmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚bnbefloatÙ±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`coutÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`evfuncÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚bnbdtypeÙ±‚`a(Ù±‚`coutÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a)w<class 'numpy.float64'>fexecedÙ¹‚…Ù§dThe Ù¢„hexcludedÙ „ööelocalhexcludedelocalõÙ§x´ argument can be used to prevent vectorizing over certain arguments.  This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ§a:€Ù´ƒ˜jÙ±‚akcdefÙ±‚`a Ù±‚bnfimypolyvalÙ±‚`a(Ù±‚`apÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`b_pÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbdlistÙ±‚`a(Ù±‚`apÙ±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚`cresÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`b_pÙ±‚aoa.Ù±‚`cpopÙ±‚`a(Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚akewhileÙ±‚`a Ù±‚`b_pÙ±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚`cresÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cresÙ±‚aoa*Ù±‚`axÙ±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`b_pÙ±‚aoa.Ù±‚`cpopÙ±‚`a(Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚akÙ¢„freturnÙ „enumpyf1.22.3fmodulex.numpy.ma.core._convert2ma._replace_return_typefmoduleõÙ±‚`a Ù±‚`cresÙ±‚`a
Ù±‚`hvpolyvalÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`imypolyvalÙ±‚`a,Ù±‚`a Ù±‚`hexcludedÙ±‚aoa=Ù±‚`a[Ù±‚bs1a'Ù±‚bs1apÙ±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`hvpolyvalÙ±‚`a(Ù±‚`apÙ±‚aoa=Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)marray([3, 6])fexecedÙ¹‚Ù§xGPositional arguments may also be excluded by specifying their position:€Ù´ƒ˜Ù±‚`hvpolyvalÙ±‚aoa.Ù±‚`hexcludedÙ±‚aoa.Ù±‚`caddÙ±‚`a(Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`hvpolyvalÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)marray([3, 6])fexecedÙ¹‚ƒÙ§dThe Ù¢„isignatureÙ „ööelocalisignatureelocalõÙ§xÆ argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:€Ù´ƒ˜LÙ±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„estatsÙ „enumpyf1.22.3fmodulexnumpy.lib.arraypad._get_statsfmoduleõÙ±‚`a
Ù±‚`hpearsonrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`Ù¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„estatsÙ „enumpyf1.22.3fmodulexnumpy.lib.arraypad._get_statsfmoduleõÙ±‚aoa.Ù±‚`hpearsonrÙ±‚`a,Ù±‚`a
Ù±‚`p                Ù±‚`isignatureÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1n(n),(n)->(),()Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`hpearsonrÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)x&(array([ 1., -1.]), array([ 0.,  0.]))fexecedÙ¹‚Ù§x Or for a vectorized convolution:€Ù´ƒ˜(Ù±‚`Ù¢„hconvolveÙ „enumpyf1.22.3fmodulennumpy.convolvefmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ivectorizeÙ „enumpyf1.22.3fmoduleonumpy.vectorizefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hconvolveÙ „enumpyf1.22.3fmodulennumpy.convolvefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`isignatureÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1l(n),(m)->(k)Ù±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„hconvolveÙ „enumpyf1.22.3fmodulennumpy.convolvefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ceyeÙ „enumpyf1.22.3fmoduleinumpy.eyefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)x„array([[1., 2., 1., 0., 0., 0.],
       [0., 1., 2., 1., 0., 0.],
       [0., 0., 1., 2., 1., 0.],
       [0., 0., 0., 1., 2., 1.]])fexecedöÙ¼ƒÙ»ƒjfrompyfuncpnumpy.frompyfuncõÙ¹‚Ù§x6Takes an arbitrary Python function and returns a ufunc€öf1.22.3Ù«xTvectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None)öonumpy.vectorize€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚ƒÙ§xÃFirst of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = Ù¢„vnumpy.lib.index_tricksÙ „enumpyf1.22.3fmodulevnumpy.lib.index_tricksfmoduleõÙ§b):€Ù¹‚‚Ù¡xFnp.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])Ù§a.€Ù¹‚Ù§xABut this omits some subtleties.  Here is a fully general summary:€Ù¹‚“Ù§xGiven an "index" array (Ù¢„aaÙ „ööelocalaaelocalõÙ§x ) of integers and a sequence of Ù¡anÙ§i arrays (Ù¢„gchoicesÙ „ööelocalgchoiceselocalõÙ§c), Ù¢„aaÙ „ööelocalaaelocalõÙ§xe and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these Ù¨Ù§bBaÙ§e and Ù¨Ù§xBchoices[i], i =
0,...,n-1Ù§x we have that, necessarily, Ù¡xBa.shape == Bchoices[i].shapeÙ§j for each Ù¡aiÙ§x .  Then, a new array with shape Ù¡hBa.shapeÙ§w is created as follows:€ÙÈÙ¹‚‘Ù§cif Ù¡lmode='raise'Ù§x6 (the default), then, first of all, each element of   Ù¡aaÙ§k (and thus Ù¡bBaÙ§w) must be in the range Ù¡h[0, n-1]Ù§v; now, suppose   that Ù¡aiÙ§x% (in that range) is the value at the Ù¡q(j0, j1, ..., jm)Ù§o   position in Ù¡bBaÙ§xJ - then the value at the same position in the new array   is the value in Ù¡kBchoices[i]Ù§w at that same position;€ÙÈÙ¹‚‰Ù§cif Ù¡kmode='wrap'Ù§l, values in Ù£ƒaaööÙ§k (and thus Ù£ƒbBaööÙ§x`) may be any (signed)   integer; modular arithmetic is used to map integers outside the range   Ù£ƒh[0, n-1]ööÙ§xH back into that range; and then the new array is constructed   as above;€ÙÈÙ¹‚‹Ù§cif Ù¡kmode='clip'Ù§l, values in Ù£ƒaaööÙ§k (and thus Ù¡bBaÙ§xX) may be any (signed)   integer; negative integers are mapped to 0; values greater than Ù¡cn-1Ù§q   are mapped to Ù¡cn-1Ù§x1; and then the new array is constructed as above.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚ƒÙ§xeTo reduce the chance of misinterpretation, even though the following "abuse" is nominally supported, Ù¢„gchoicesÙ „ööelocalgchoiceselocalõÙ§x‰ should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaaiint arrayÙ¹‚‰Ù§x$This array must contain integers in Ù¡h[0, n-1]Ù§h, where Ù¡anÙ§x" is the number of choices, unless Ù¡imode=wrapÙ§d or Ù¡imode=clipÙ§x., in which cases any integers are permissible.€Ù°ƒgchoicesrsequence of arraysÙ¹‚‡Ù§oChoice arrays. Ù¢„aaÙ „ööelocalaaelocalõÙ§xE and all of the choices must be broadcastable to the same shape.  If Ù¢„gchoicesÙ „ööelocalgchoiceselocalõÙ§xd is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to Ù¡pchoices.shape[0]Ù§x&) is taken as defining the "sequence".€Ù°ƒcoutoarray, optionalÙ¹‚…Ù§xuIf provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that Ù¢„coutÙ „ööelocalcoutelocalõÙ§w is always buffered if Ù¡lmode='raise'Ù§x); use other modes for better performance.€Ù°ƒdmodex-{'raise' (default), 'wrap', 'clip'}, optionalÙ¹‚ƒÙ§xSpecifies how indices outside Ù¡h[0, n-1]Ù§q will be treated:€öfRaisesÙ¯‚Ù°ƒ`xValueError: shape mismatchÙ¹‚ƒÙ§cIf Ù¢„aaÙ „ööelocalaaelocalõÙ§xC and each choice array are not all broadcastable to the same shape.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒlmerged_arrayearrayÙ¹‚Ù§rThe merged result.€ögSummaryÙ¯‚Ù¹‚Ù§xKConstruct an array from an index array and a list of arrays to choose from.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/core/fromnumeric.py3r<class 'function'>lnumpy.chooseÙ¯‚‡Ù´ƒ˜[Ù±‚`gchoicesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib11Ù±‚`a,Ù±‚`a Ù±‚bmib12Ù±‚`a,Ù±‚`a Ù±‚bmib13Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`b  Ù±‚`a[Ù±‚bmib20Ù±‚`a,Ù±‚`a Ù±‚bmib21Ù±‚`a,Ù±‚`a Ù±‚bmib22Ù±‚`a,Ù±‚`a Ù±‚bmib23Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmib30Ù±‚`a,Ù±‚`a Ù±‚bmib31Ù±‚`a,Ù±‚`a Ù±‚bmib32Ù±‚`a,Ù±‚`a Ù±‚bmib33Ù±‚`a]Ù±‚`a]Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fchooseÙ „enumpyf1.22.3fmodulelnumpy.choosefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gchoicesÙ±‚`a
Ù±‚bc1xB# the first element of the result will be the first element of theÙ±‚`a
Ù±‚bc1x@# third (2+1) "array" in choices, namely, 20; the second elementÙ±‚`a
Ù±‚bc1xD# will be the second element of the fourth (3+1) choice array, i.e.,Ù±‚`a
Ù±‚bc1j# 31, etc.Ù±‚`a
Ù±‚`a)warray([20, 31, 12,  3])fexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fchooseÙ „enumpyf1.22.3fmodulelnumpy.choosefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gchoicesÙ±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„dclipÙ „enumpyf1.22.3fmodulejnumpy.clipfmoduleõÙ±‚bs1a'Ù±‚`a)Ù±‚`a Ù±‚bc1s# 4 goes to 3 (4-1)warray([20, 31, 12,  3])fexecedÙ´ƒ˜Ù±‚bc1x## because there are 4 choice arraysÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fchooseÙ „enumpyf1.22.3fmodulelnumpy.choosefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gchoicesÙ±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1dwrapÙ±‚bs1a'Ù±‚`a)Ù±‚`a Ù±‚bc1u# 4 goes to (4 mod 4)warray([20,  1, 12,  3])fexecedÙ´ƒÙ±‚bc1i# i.e., 0`fexecedÙ¹‚Ù§x5A couple examples illustrating how choose broadcasts:€Ù´ƒ˜;Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a
Ù±‚`gchoicesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a]Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fchooseÙ „enumpyf1.22.3fmodulelnumpy.choosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`gchoicesÙ±‚`a)xHarray([[ 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10]])fexecedÙ´ƒ˜tÙ±‚bc1x# With thanks to Anne ArchibaldÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bc1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚bmia3Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bc2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fchooseÙ „enumpyf1.22.3fmodulelnumpy.choosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`bc1Ù±‚`a,Ù±‚`a Ù±‚`bc2Ù±‚`a)Ù±‚`a)Ù±‚`a Ù±‚bc1x/# result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2x¶array([[[ 1,  1,  1,  1,  1],
        [ 2,  2,  2,  2,  2],
        [ 3,  3,  3,  3,  3]],
       [[-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5]]])fexecedö‚Ù¼ƒÙ»ƒnndarray.chooseööÙ¹‚Ù§qequivalent method€öÙ¼ƒÙ»ƒunumpy.take_along_axisunumpy.take_along_axisõÙ¹‚ƒÙ§nPreferable if Ù¢„gchoicesÙ „ööelocalgchoiceselocalõÙ§l is an array€öf1.22.3Ù«x*choose(a, choices, out=None, mode='raise')ölnumpy.choose€
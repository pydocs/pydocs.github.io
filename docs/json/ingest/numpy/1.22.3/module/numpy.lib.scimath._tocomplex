Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x°The input is returned as a complex array of the smallest type that will fit the original data: types like single, byte, short, etc. become csingle, while others become cdouble.€Ù¹‚Ù§x#A copy of the input is always made.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒcarrearray€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`earrayÙ¹‚Ù§xCAn array with the same input data as the input but in complex form.€ögSummaryÙ¯‚Ù¹‚ƒÙ§rConvert its input Ù¢„carrÙ „ööelocalcarrelocalõÙ§t to a complex array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersgReturnshExamplesu/numpy/lib/scimath.py1r<class 'function'>vnumpy.emath._tocomplexÙ¯‚Ù¹‚Ù§x'First, consider an input of type short:€Ù´ƒ”Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„eshortÙ „enumpyf1.22.3fmodulex&numpy.core.arrayprint.dtype_short_reprfmoduleõÙ±‚`a)`fexecedÙ´ƒ‘Ù±‚`bacÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„clibÙ „enumpyf1.22.3fmoduleinumpy.libfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gscimathÙ „enumpyf1.22.3fmoduleqnumpy.lib.scimathfmoduleõÙ±‚aoa.Ù±‚`Ù¢„j_tocomplexÙ „enumpyf1.22.3fmodulexnumpy.lib.scimath._tocomplexfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`bacx0array([1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64)fexecedÙ´ƒƒÙ±‚`bacÙ±‚aoa.Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõrdtype('complex64')fexecedÙ¹‚Ù§xaIf the input is of type double, the output is correspondingly of the complex double type as well:€Ù´ƒ”Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`bnpÙ±‚aoa.Ù±‚`fdoubleÙ±‚`a)`fexecedÙ´ƒ‘Ù±‚`bbcÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„clibÙ „enumpyf1.22.3fmoduleinumpy.libfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gscimathÙ „enumpyf1.22.3fmoduleqnumpy.lib.scimathfmoduleõÙ±‚aoa.Ù±‚`Ù¢„j_tocomplexÙ „enumpyf1.22.3fmodulexnumpy.lib.scimath._tocomplexfmoduleõÙ±‚`a(Ù±‚`abÙ±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`bbcxarray([1.+0.j, 2.+0.j, 3.+0.j])fexecedÙ´ƒƒÙ±‚`bbcÙ±‚aoa.Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõsdtype('complex128')fexecedÙ¹‚Ù§xuNote that even if the input was complex to begin with, a copy is still made, since the astype() method always copies:€Ù´ƒ”Ù±‚`acÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`bnpÙ±‚aoa.Ù±‚`gcsingleÙ±‚`a)`fexecedÙ´ƒ‘Ù±‚`bccÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„clibÙ „enumpyf1.22.3fmoduleinumpy.libfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gscimathÙ „enumpyf1.22.3fmoduleqnumpy.lib.scimathfmoduleõÙ±‚aoa.Ù±‚`Ù¢„j_tocomplexÙ „enumpyf1.22.3fmodulexnumpy.lib.scimath._tocomplexfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`bccx2array([1.+0.j,  2.+0.j,  3.+0.j], dtype=complex64)fexecedÙ´ƒ‰Ù±‚`acÙ±‚`a Ù±‚aoa*Ù±‚aoa=Ù±‚`a Ù±‚bmia2Ù±‚`a;Ù±‚`a Ù±‚`acx2array([2.+0.j,  4.+0.j,  6.+0.j], dtype=complex64)fexecedÙ´ƒÙ±‚`bccx2array([1.+0.j,  2.+0.j,  3.+0.j], dtype=complex64)fexecedö€f1.22.3Ù«o_tocomplex(arr)öxnumpy.lib.scimath._tocomplex€
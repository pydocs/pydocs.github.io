Ùª­jAttributesÙ¯‚‡Ù°ƒcvar`€Ù°ƒhbuf_size`€Ù°ƒestart`€Ù°ƒdstop`€Ù°ƒdstep`€Ù°ƒeshape`€Ù°ƒdflat`€öpExtended SummaryÙ¯‚‚Ù¹‚„Ù¢„lArrayteratorÙ „enumpyf1.22.3fmodulex#numpy.lib.arrayterator.ArrayteratorfmoduleõÙ§x¯ creates a buffered iterator for reading big arrays in small contiguous blocks. The class is useful for objects stored in the file system. It allows iteration over the object Ù¨Ù§gwithoutÙ§xP reading everything in memory; instead, small blocks are read and iterated over.€Ù¹‚‚Ù¢„lArrayteratorÙ „enumpyf1.22.3fmodulex#numpy.lib.arrayterator.ArrayteratorfmoduleõÙ§x¥ can be used with any object that supports multidimensional slices. This includes NumPy arrays, but also variables from Scientific.IO.NetCDF or pynetcdf for example.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚‰Ù§xƒThe algorithm works by first finding a "running dimension", along which the blocks will be extracted. Given an array of dimensions Ù¡q(d1, d2, ..., dn)Ù§j, e.g. if Ù¢„hbuf_sizeÙ „ööelocalhbuf_sizeelocalõÙ§q is smaller than Ù¡bd1Ù§x;, the first dimension will be used. If, on the other hand, Ù¡ud1 < buf_size < d1*d2Ù§xÏ the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒcvarjarray_likeÙ¹‚Ù§xThe object to iterate over.€Ù°ƒhbuf_sizemint, optionalÙ¹‚…Ù§tThe buffer size. If Ù¢„hbuf_sizeÙ „ööelocalhbuf_sizeelocalõÙ§xJ is supplied, the maximum amount of data that will be read into memory is Ù¢„hbuf_sizeÙ „ööelocalhbuf_sizeelocalõÙ§xT elements. Default is None, which will read as many element as possible into memory.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x!Buffered iterator for big arrays.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersjAttributeshSee AlsoeNoteshExamplesx/numpy/lib/arrayterator.pyn<class 'type'>vnumpy.lib.ArrayteratorÙ¯‚ƒÙ´ƒ˜8Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia4Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a
Ù±‚`fa_itorÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„clibÙ „enumpyf1.22.3fmoduleinumpy.libfmoduleõÙ±‚aoa.Ù±‚`Ù¢„lArrayteratorÙ „enumpyf1.22.3fmodulex#numpy.lib.arrayterator.ArrayteratorfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`fa_itorÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõl(3, 4, 5, 6)fexecedÙ¹‚…Ù§xNow we can iterate over Ù¡fa_itorÙ§x/, and it will return arrays of size two. Since Ù¢„hbuf_sizeÙ „ööelocalhbuf_sizeelocalõÙ§xQ was smaller than any dimension, the first dimension will be iterated over first:€Ù´ƒ˜#Ù±‚akcforÙ±‚`a Ù±‚`fsubarrÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`fa_itorÙ±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akbifÙ±‚`a Ù±‚bowcnotÙ±‚`a Ù±‚`fsubarrÙ±‚aoa.Ù±‚`Ù¢„callÙ „enumpyf1.22.3fmoduleinumpy.allfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚bnbeprintÙ±‚`a(Ù±‚`fsubarrÙ±‚`a,Ù±‚`a Ù±‚`fsubarrÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚`a)Ù±‚`a Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚bc1x# [[[[0 1]]]] (1, 1, 1, 2)`fexecedöƒÙ¼ƒÙ»ƒhflatiternnumpy.flatiterõÙ¹‚Ù§tFlat array iterator.€öÙ¼ƒÙ»ƒfmemmaplnumpy.memmapõÙ¹‚Ù§x@Create a memory-map to an array stored in a binary file on disk.€öÙ¼ƒÙ»ƒkndenumerateqnumpy.ndenumerateõÙ¹‚Ù§x Multidimensional array iterator.€öf1.22.3Ù«ööx#numpy.lib.arrayterator.Arrayterator€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§xjCovariance indicates the level to which two variables vary together. If we examine N-dimensional samples, Ù¥xX = [x_1, x_2, ... x_N]^TÙ§x%, then the covariance matrix element Ù¥fC_{ij}Ù§v is the covariance of Ù¥cx_iÙ§e and Ù¥cx_jÙ§n. The element Ù¥fC_{ii}Ù§t is the variance of Ù¥cx_iÙ§a.€Ù¹‚Ù§x.See the notes for an outline of the algorithm.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚‡Ù§xIAssume that the observations are in the columns of the observation array Ù¢„amÙ „ööelocalamelocalõÙ§i and let Ù¡lf = fweightsÙ§e and Ù¡la = aweightsÙ§xQ for brevity. The steps to compute the weighted covariance are as follows::      €ÙÀy>>> m = np.arange(10, dtype=np.float64)
>>> f = np.arange(10) * 2
>>> a = np.arange(10) ** 2.
>>> ddof = 1
>>> w = f * a
>>> v1 = np.sum(w)
>>> v2 = np.sum(w * a)
>>> m -= np.sum(m * w, axis=None, keepdims=True) / v1
>>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)Ù¹‚‡Ù§oNote that when Ù¡fa == 1Ù§x, the normalization factor Ù¡xv1 / (v1**2 - ddof * v2)Ù§n goes over to Ù¡v1 / (np.sum(f) - ddof)Ù§n as it should.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒamjarray_likeÙ¹‚…Ù§xOA 1-D or 2-D array containing multiple variables and observations. Each row of Ù¢„amÙ „ööelocalamelocalõÙ§x^ represents a variable, and each column a single observation of all those variables. Also see Ù¢„frowvarÙ „ööelocalfrowvarelocalõÙ§g below.€Ù°ƒaytarray_like, optionalÙ¹‚…Ù§x1An additional set of variables and observations. Ù¢„ayÙ „ööelocalayelocalõÙ§x has the same form as that of Ù¢„amÙ „ööelocalamelocalõÙ§a.€Ù°ƒfrowvarnbool, optionalÙ¹‚ƒÙ§cIf Ù¢„frowvarÙ „ööelocalfrowvarelocalõÙ§xÍ is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.€Ù°ƒdbiasnbool, optionalÙ¹‚‹Ù§x$Default normalization (False) is by Ù¡g(N - 1)Ù§h, where Ù¡aNÙ§x= is the number of observations given (unbiased estimate). If Ù¢„dbiasÙ „ööelocaldbiaselocalõÙ§x# is True, then normalization is by Ù¡aNÙ§x6. These values can be overridden by using the keyword Ù¡dddofÙ§x in numpy versions >= 1.5.€Ù°ƒdddofmint, optional‚Ù¹‚Ù§gIf not Ù¡dNoneÙ§x the default value implied by Ù¢„dbiasÙ „ööelocaldbiaselocalõÙ§x is overridden. Note that Ù¡fddof=1Ù§x1 will return the unbiased estimate, even if both Ù¢„hfweightsÙ „ööelocalhfweightselocalõÙ§e and Ù¢„haweightsÙ „ööelocalhaweightselocalõÙ§t are specified, and Ù¡fddof=0Ù§xU will return the simple average. See the notes for the details. The default value is Ù¡dNoneÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§d1.5 €Ù°ƒhfweightsxarray_like, int, optional‚Ù¹‚Ù§xg1-D array of integer frequency weights; the number of times each observation vector should be repeated.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e1.10 €Ù°ƒhaweightstarray_like, optional‚Ù¹‚ƒÙ§x¹1-D array of observation vector weights. These relative weights are typically large for observations considered "important" and smaller for observations considered less "important". If Ù¡fddof=0Ù§xQ the array of weights can be used to assign probabilities to observation vectors.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e1.10 €Ù°ƒedtypesdata-type, optional‚Ù¹‚ƒÙ§xMData-type of the result. By default, the return data-type will have at least Ù¢„mnumpy.float64Ù „enumpyf1.22.3fmodulemnumpy.float64fmoduleõÙ§k precision.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e1.20 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚Ù§x'The covariance matrix of the variables.€ögSummaryÙ¯‚Ù¹‚Ù§x5Estimate a covariance matrix, given data and weights.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/lib/function_base.py	r<class 'function'>inumpy.covÙ¯‚‰Ù¹‚…Ù§xConsider two variables, Ù¥cx_0Ù§e and Ù¥cx_1Ù§x8, which correlate perfectly, but in opposite directions:€Ù´ƒ˜%Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.TfmoduleõÙ±‚`a
Ù±‚`axx$array([[0, 1, 2],
       [2, 1, 0]])fexecedÙ¹‚…Ù§iNote how Ù¥cx_0Ù§q increases while Ù¥cx_1Ù§x5 decreases. The covariance matrix shows this clearly:€Ù´ƒ†Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ccovÙ „enumpyf1.22.3fmoduleinumpy.covfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)x&array([[ 1., -1.],
       [-1.,  1.]])fexecedÙ¹‚‡Ù§rNote that element Ù¥gC_{0,1}Ù§x&, which shows the correlation between Ù¥cx_0Ù§e and Ù¥cx_1Ù§n, is negative.€Ù¹‚…Ù§rFurther, note how Ù£ƒaxööÙ§e and Ù¢„ayÙ „ööelocalayelocalõÙ§n are combined:€Ù´ƒ˜9Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmfc2.1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`b  Ù±‚bmfc4.3Ù±‚`a]Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`b  Ù±‚bmfc1.1Ù±‚`a,Ù±‚`b  Ù±‚bmfd0.12Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„aXÙ „enumpyf1.22.3fmodulexnumpy.random._pcg64.PCG64DXSMfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„estackÙ „enumpyf1.22.3fmoduleknumpy.stackfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ccovÙ „enumpyf1.22.3fmoduleinumpy.covfmoduleõÙ±‚`a(Ù±‚`Ù¢„aXÙ „enumpyf1.22.3fmodulexnumpy.random._pcg64.PCG64DXSMfmoduleõÙ±‚`a)xOarray([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])fexecedÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ccovÙ „enumpyf1.22.3fmoduleinumpy.covfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)xOarray([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])fexecedÙ´ƒ†Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ccovÙ „enumpyf1.22.3fmoduleinumpy.covfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a)larray(11.71)fexecedöÙ¼ƒÙ»ƒhcorrcoefnnumpy.corrcoefõÙ¹‚Ù§xNormalized covariance matrix€öf1.22.3Ù«x_cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None, *, dtype=None)öinumpy.cov€
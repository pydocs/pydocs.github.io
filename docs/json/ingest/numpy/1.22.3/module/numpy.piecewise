Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xGiven a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚…Ù§xXThis is similar to choose or select, except that functions are evaluated on elements of Ù¢„axÙ „ööelocalaxelocalõÙ§x/ that satisfy the corresponding condition from Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§a.€Ù¹‚Ù§xThe result is::          €ÙÀxe|--
|funclist[0](x[condlist[0]])
|funclist[1](x[condlist[1]])
|...
|funclist[n2](x[condlist[n2]])
|--öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaxqndarray or scalarÙ¹‚Ù§qThe input domain.€Ù°ƒhcondlistx#list of bool arrays or bool scalarsƒÙ¹‚‡Ù§x0Each boolean array corresponds to a function in Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§l.  Wherever Ù£ƒkcondlist[i]ööÙ§j is True, Ù£ƒnfunclist[i](x)ööÙ§x is used as the output value.€Ù¹‚‡Ù§vEach boolean array in Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§t selects a piece of Ù¢„axÙ „ööelocalaxelocalõÙ§x/, and should therefore be of the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§a.€Ù¹‚‡Ù§nThe length of Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§x must correspond to that of Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§x*. If one extra function is given, i.e. if Ù¡x"len(funclist) == len(condlist) + 1Ù§xX, then that extra function is the default value, used wherever all conditions are false.€Ù°ƒhfunclistx.list of callables, f(x,*args,**kw), or scalarsÙ¹‚…Ù§x Each function is evaluated over Ù¢„axÙ „ööelocalaxelocalõÙ§xĞ wherever its corresponding condition is True.  It should take a 1d array as input and give an 1d array or a scalar value as output.  If, instead of a callable, a scalar is provided then a constant function (Ù¡plambda x: scalarÙ§m) is assumed.€Ù°ƒdargsotuple, optionalÙ¹‚‡Ù§xAny further arguments given to Ù¢„ipiecewiseÙ „enumpyf1.22.3fmoduleonumpy.piecewisefmoduleõÙ§x= are passed to the functions upon execution, i.e., if called Ù¡xpiecewise(..., ..., 1, 'a')Ù§x", then each function is called as Ù¡lf(x, 1, 'a')Ù§a.€Ù°ƒbkwndict, optionalÙ¹‚‡Ù§x"Keyword arguments used in calling Ù¢„ipiecewiseÙ „enumpyf1.22.3fmoduleonumpy.piecewisefmoduleõÙ§x= are passed to the functions upon execution, i.e., if called Ù¡xpiecewise(..., ..., alpha=1)Ù§x", then each function is called as Ù¡mf(x, alpha=1)Ù§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚‡Ù§xTThe output is the same shape and type as x and is found by calling the functions in Ù¢„hfunclistÙ „ööelocalhfunclistelocalõÙ§x  on the appropriate portions of Ù¢„axÙ „ööelocalaxelocalõÙ§x&, as defined by the boolean arrays in Ù¢„hcondlistÙ „ööelocalhcondlistelocalõÙ§xC.  Portions not covered by any condition have a default value of 0.€ögSummaryÙ¯‚Ù¹‚Ù§x&Evaluate a piecewise-defined function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/lib/function_base.pygr<class 'function'>onumpy.piecewiseÙ¯‚†Ù¹‚…Ù§x+Define the sigma function, which is -1 for Ù¡ex < 0Ù§l and +1 for Ù¡fx >= 0Ù§a.€Ù´ƒ˜2Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmfc2.5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „enumpyf1.22.3fmoduleonumpy.piecewisefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)x%array([-1., -1., -1.,  1.,  1.,  1.])fexecedÙ¹‚‰Ù§x$Define the absolute value, which is Ù¡b-xÙ§e for Ù¡dx <0Ù§e and Ù¡axÙ§e for Ù¡fx >= 0Ù§a.€Ù´ƒ˜*Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „enumpyf1.22.3fmoduleonumpy.piecewisefmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`axÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚akÙ¢„flambdaÙ „enumpyf1.22.3fmodulex%numpy.testing._private.utils.<lambda>fmoduleõÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚aoa-Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚akÙ¢„flambdaÙ „enumpyf1.22.3fmodulex%numpy.testing._private.utils.<lambda>fmoduleõÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a]Ù±‚`a)x*array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])fexecedÙ¹‚Ù§x*Apply the same function to a scalar value.€Ù´ƒ˜1Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia2Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ipiecewiseÙ „enumpyf1.22.3fmoduleonumpy.piecewisefmoduleõÙ±‚`a(Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`ayÙ±‚`a Ù±‚aoa<Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa>Ù±‚aoa=Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚akÙ¢„flambdaÙ „enumpyf1.22.3fmodulex%numpy.testing._private.utils.<lambda>fmoduleõÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚aoa-Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚akÙ¢„flambdaÙ „enumpyf1.22.3fmodulex%numpy.testing._private.utils.<lambda>fmoduleõÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚`a]Ù±‚`a)harray(2)fexecedöƒÙ¼ƒÙ»ƒfchooselnumpy.chooseõ€öÙ¼ƒÙ»ƒfselectlnumpy.selectõ€öÙ¼ƒÙ»ƒewhereknumpy.whereõ€öf1.22.3Ù«x-piecewise(x, condlist, funclist, *args, **kw)öonumpy.piecewise€
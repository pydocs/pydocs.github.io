Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‡Ù§mFor an array Ù¢„aaÙ „ööelocalaaelocalõÙ§f with Ù¡ka.ndim >= 2Ù§x5, the diagonal is the list of locations with indices Ù¡la[i, ..., i]Ù§x\ all identical. This function modifies the input array in-place, it does not return a value.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.4.0 €Ù¹‚ƒÙ§x'This functionality can be obtained via Ù¢„ldiag_indicesÙ „enumpyf1.22.3fmodulernumpy.diag_indicesfmoduleõÙ§xz, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaatarray, at least 2-D.Ù¹‚Ù§x@Array whose diagonal is to be filled, it gets modified in-place.€Ù°ƒcvaltscalar or array_likeÙ¹‚…Ù§x&Value(s) to write on the diagonal. If Ù¢„cvalÙ „ööelocalcvalelocalõÙ§xR is scalar, the value is written along the diagonal. If array-like, the flattened Ù¢„cvalÙ „ööelocalcvalelocalõÙ§xT is written along the diagonal, repeating if necessary to fill all diagonal entries.€Ù°ƒdwrapdboolÙ¹‚Ù§x¥For tall matrices in NumPy version up to 1.6.2, the diagonal "wrapped" after N columns. You can have this behavior with this option. This affects only tall matrices.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x@Fill the main diagonal of the given array of any dimensionality.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesx/numpy/lib/index_tricks.pyr<class 'function'>snumpy.fill_diagonalÙ¯‚Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`aax6array([[5, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])fexecedÙ¹‚Ù§x-The same function can operate on a 4-D array:€Ù´ƒ˜"Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)`fexecedÙ¹‚Ù§x&We only show a few blocks for clarity:€Ù´ƒ‡Ù±‚`aaÙ±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]x6array([[4, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])fexecedÙ´ƒ‡Ù±‚`aaÙ±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]x6array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 0]])fexecedÙ´ƒ‡Ù±‚`aaÙ±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]x6array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 4]])fexecedÙ¹‚Ù§x+The wrap option affects only tall matrices:€Ù´ƒ˜ Ù±‚bc1w# tall matrices no wrapÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aaxZarray([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [0, 0, 0]])fexecedÙ´ƒ˜%Ù±‚bc1t# tall matrices wrapÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚`dwrapÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`aaxZarray([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [4, 0, 0]])fexecedÙ´ƒ˜%Ù±‚bc1o# wide matricesÙ±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚`dwrapÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`aaxHarray([[4, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 4, 0, 0]])fexecedÙ¹‚…Ù§xPThe anti-diagonal can be filled by reversing the order of elements using either Ù¢„lnumpy.flipudÙ „enumpyf1.22.3fmodulelnumpy.flipudfmoduleõÙ§d or Ù¢„lnumpy.fliplrÙ „enumpyf1.22.3fmodulelnumpy.fliplrfmoduleõÙ§a.€Ù´ƒ˜,Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a;Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ffliplrÙ „enumpyf1.22.3fmodulelnumpy.fliplrfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1q# Horizontal flipÙ±‚`a
Ù±‚`aax6array([[0, 0, 1],
       [0, 2, 0],
       [3, 0, 0]])fexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mfill_diagonalÙ „enumpyf1.22.3fmodulesnumpy.fill_diagonalfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„fflipudÙ „enumpyf1.22.3fmodulelnumpy.flipudfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1o# Vertical flipÙ±‚`a
Ù±‚`aax6array([[0, 0, 3],
       [0, 2, 0],
       [1, 0, 0]])fexecedÙ¹‚Ù§xZNote that the order in which the diagonal is filled varies depending on the flip function.€ö‚Ù¼ƒÙ»ƒldiag_indicesrnumpy.diag_indicesõ€öÙ¼ƒÙ»ƒqdiag_indices_fromwnumpy.diag_indices_fromõ€öf1.22.3Ù«x!fill_diagonal(a, val, wrap=False)ösnumpy.fill_diagonal€
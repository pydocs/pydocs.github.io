Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚ƒÙ§x(The optimal order array is then used by Ù£ƒl_multi_dot()ööÙ§x to do the multiplication.€Ù¹‚„Ù§xAlso return the cost matrix if Ù£ƒlreturn_costsööÙ§d is Ù¡dTrue€Ù¹‚Ù§xŠThe implementation CLOSELY follows Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.€Ù·ƒrcost[i, j] = min([x;    cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)x    for k in range(i, j)])ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xCReturn a np.array that encodes the optimal order of mutiplications.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryw/numpy/linalg/linalg.py
½r<class 'function'>x1numpy.linalg.linalg._multi_dot_matrix_chain_orderÙ¯‚€ö€f1.22.3Ù«x9_multi_dot_matrix_chain_order(arrays, return_costs=False)öx1numpy.linalg.linalg._multi_dot_matrix_chain_order€
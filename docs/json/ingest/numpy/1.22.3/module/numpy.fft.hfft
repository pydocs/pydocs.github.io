Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚ŠÙ¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ§a/Ù¢„eihfftÙ „enumpyf1.22.3fmoduleonumpy.fft.ihfftfmoduleõÙ§x are a pair analogous to Ù¢„drfftÙ „enumpyf1.22.3fmodulennumpy.fft.rfftfmoduleõÙ§a/Ù¢„eirfftÙ „enumpyf1.22.3fmoduleonumpy.fft.irfftfmoduleõÙ§x‰, but for the opposite case: here the signal has Hermitian symmetry in the time domain and is real in the frequency domain. So here it's Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ§xG for which you must supply the length of the result if it is to be odd.€ÙÈ‚Ù¹‚ƒÙ§feven: Ù¡x!ihfft(hfft(a, 2*len(a) - 2)) == aÙ§x, within roundoff error,€Ù¹‚ƒÙ§eodd: Ù¡x!ihfft(hfft(a, 2*len(a) - 1)) == aÙ§x, within roundoff error.€Ù¹‚‡Ù§xjThe correct interpretation of the hermitian input depends on the length of the original data, as given by Ù¢„anÙ „ööelocalanelocalõÙ§xh. This is because each input shape could correspond to either an odd or even length signal. By default, Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ§x÷ assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal Ù©Ù§dmustÙ§j be given.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚Ù§pThe input array.€Ù°ƒanmint, optionalÙ¹‚Ù§x2Length of the transformed axis of the output. For Ù¢„anÙ „ööelocalanelocalõÙ§p output points, Ù¡hn//2 + 1Ù§x‰ input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If Ù¢„anÙ „ööelocalanelocalõÙ§x! is not given, it is taken to be Ù¡g2*(m-1)Ù§g where Ù¡amÙ§x8 is the length of the input along the axis specified by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§a.€Ù°ƒdaxismint, optionalÙ¹‚Ù§xHAxis over which to compute the FFT. If not given, the last axis is used.€Ù°ƒdnormx*{"backward", "ortho", "forward"}, optionalƒÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.10.0 €Ù¹‚ƒÙ§xNormalization mode (see Ù¢„inumpy.fftÙ „enumpyf1.22.3fmoduleinumpy.fftfmoduleõÙ§xŒ). Default is "backward". Indicates which direction of the forward/backward pair of transforms is scaled and with what normalization factor.€ÙÆƒlversionaddedf1.20.0Ù¹‚Ù§x2The " backward " , " forward " values were added. €öfRaisesÙ¯‚Ù°ƒ`jIndexErrorÙ¹‚…Ù§cIf Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x is not a valid axis of Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚‘Ù§xLThe truncated or zero-padded input, transformed along the axis indicated by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§u, or the last one if Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x9 is not specified. The length of the transformed axis is Ù¢„anÙ „ööelocalanelocalõÙ§i, or, if Ù¢„anÙ „ööelocalanelocalõÙ§o is not given, Ù¡g2*m - 2Ù§g where Ù¡amÙ§x\ is the length of the transformed axis of the input. To get an odd number of output points, Ù¢„anÙ „ööelocalanelocalõÙ§x$ must be specified, for instance as Ù¡g2*m - 1Ù§u in the typical case,€ögSummaryÙ¯‚Ù¹‚Ù§xOCompute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/fft/_pocketfft.pyr<class 'function'>nnumpy.fft.hfftÙ¯‚…Ù´ƒ˜$Ù±‚`fsignalÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚`a(Ù±‚`fsignalÙ±‚`a)xMarray([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may varyfexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ±‚`a(Ù±‚`fsignalÙ±‚`a[Ù±‚`a:Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚bc1x# Input first half of signalx*array([15.,  -4.,   0.,  -1.,   0.,  -4.])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ±‚`a(Ù±‚`fsignalÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`b  Ù±‚bc1x"# Input entire signal and truncatex*array([15.,  -4.,   0.,  -1.,   0.,  -4.])fexecedÙ´ƒ˜+Ù±‚`fsignalÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`ajÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmfb1.Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dconjÙ „enumpyf1.22.3fmodulewnumpy.ma.core.conjugatefmoduleõÙ±‚`a(Ù±‚`fsignalÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.TfmoduleõÙ±‚`a)Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`fsignalÙ±‚`c   Ù±‚bc1x# check Hermitian symmetryxBarray([[ 0.-0.j,  -0.+0.j], # may vary
       [ 0.+0.j,  0.-0.j]])fexecedÙ´ƒÙ±‚`mfreq_spectrumÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ±‚`a(Ù±‚`fsignalÙ±‚`a)Ù±‚`a
Ù±‚`mfreq_spectrumx&array([[ 1.,  1.],
       [ 2., -2.]])fexecedö‚Ù¼ƒÙ»ƒeihfftonumpy.fft.ihfftõÙ¹‚ƒÙ§oThe inverse of Ù¢„dhfftÙ „enumpyf1.22.3fmodulennumpy.fft.hfftfmoduleõÙ§a.€öÙ¼ƒÙ»ƒdrfftnnumpy.fft.rfftõÙ¹‚Ù§x/Compute the one-dimensional FFT for real input.€öf1.22.3Ù«x#hfft(a, n=None, axis=-1, norm=None)önnumpy.fft.hfft€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚ƒÙ§x)Array containing data to be averaged. If Ù¢„aaÙ „ööelocalaaelocalõÙ§x, is not an array, a conversion is attempted.€Ù°ƒdaxisx&None or int or tuple of ints, optionalƒÙ¹‚ƒÙ§x$Axis or axes along which to average Ù¢„aaÙ „ööelocalaaelocalõÙ§x“.  The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù¹‚Ù§xIf axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.€Ù°ƒgweightstarray_like, optionalƒÙ¹‚Ù§x2An array of weights associated with the values in Ù¢„aaÙ „ööelocalaaelocalõÙ§p. Each value in Ù¢„aaÙ „ööelocalaaelocalõÙ§x’ contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of Ù¢„aaÙ „ööelocalaaelocalõÙ§x/ along the given axis) or of the same shape as Ù¢„aaÙ „ööelocalaaelocalõÙ§e. If Ù£ƒlweights=NoneööÙ§s, then all data in Ù¢„aaÙ „ööelocalaaelocalõÙ§xK are assumed to have a weight equal to one.  The 1-D calculation is::      €ÙÀx%avg = sum(a * weights) / sum(weights)Ù¹‚…Ù§wThe only constraint on Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ§i is that Ù£ƒlsum(weights)ööÙ§o must not be 0.€Ù°ƒhreturnednbool, optionalÙ¹‚Ù§kDefault is Ù¡eFalseÙ§e. If Ù¡dTrueÙ§m, the tuple (Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ§b, Ù£ƒnsum_of_weightsööÙ§x:) is returned, otherwise only the average is returned. If Ù£ƒlweights=NoneööÙ§b, Ù£ƒnsum_of_weightsööÙ§xI is equivalent to the number of elements over which the average is taken.€öfRaisesÙ¯‚‚Ù°ƒ`qZeroDivisionErrorÙ¹‚ƒÙ§x*When all weights along axis are zero. See Ù¢„pnumpy.ma.averageÙ „enumpya*capiwnumpy.ma.extras.averagefmoduleõÙ§x, for a version robust to this type of error.€Ù°ƒ`iTypeErrorÙ¹‚…Ù§vWhen the length of 1D Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ§x! is not the same as the shape of Ù¢„aaÙ „ööelocalaaelocalõÙ§l along axis.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒxretval, [sum_of_weights]tarray_type or doubleÙ¹‚˜Ù§x2Return the average along the specified axis. When Ù¢„hreturnedÙ „ööelocalhreturnedelocalõÙ§d is Ù¡dTrueÙ§xi, return a tuple with the average as the first element and the sum of the weights as the second element. Ù£ƒnsum_of_weightsööÙ§x is of the same type as Ù¢„fretvalÙ „enumpyf1.22.3fmodulex.numpy.ctypeslib._concrete_ndptr._check_retval_fmoduleõÙ§x2. The result dtype follows a genereal pattern. If Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ§x+ is None, the result dtype will be that of Ù¢„aaÙ „ööelocalaaelocalõÙ§f , or Ù¡gfloat64Ù§d if Ù¢„aaÙ „ööelocalaaelocalõÙ§x is integral. Otherwise, if Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ§q is not None and Ù¢„aaÙ „ööelocalaaelocalõÙ§xo is non- integral, the result type will be the type of lowest precision capable of representing values of both Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ§e. If Ù¢„aaÙ „ööelocalaaelocalõÙ§x` happens to be integral, the previous rules still applies but the result dtype will at least be Ù¡gfloat64Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§x6Compute the weighted average along the specified axis.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnsfRaiseshSee AlsohExamplesx/numpy/lib/function_base.py‹r<class 'function'>mnumpy.averageÙ¯‚‡Ù´ƒÙ±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`ddatasarray([1, 2, 3, 4])hcompiledÙ´ƒ†Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a)c2.5hcompiledÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib11Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a)c4.0hcompiledÙ´ƒ•Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`ddatax-array([[0, 1],
       [2, 3],
       [4, 5]])hcompiledÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚bmfb1.Ù±‚aoa/Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚aoa/Ù±‚bmia4Ù±‚`a]Ù±‚`a)xarray([0.75, 2.75, 4.75])hcompiledÙ´ƒ”Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚bmfb1.Ù±‚aoa/Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmfb3.Ù±‚aoa/Ù±‚bmia4Ù±‚`a]Ù±‚`a)xqTraceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.hcompiledÙ´ƒ˜:Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „enumpyf1.22.3fmodulejnumpy.onesfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`hfloat128Ù±‚`a)Ù±‚`a
Ù±‚`awÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„donesÙ „enumpyf1.22.3fmodulejnumpy.onesfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icomplex64Ù „enumpyf1.22.3fmoduleonumpy.complex64fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`cavgÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gaverageÙ „enumpyf1.22.3fmodulemnumpy.averagefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„gweightsÙ „enumpyf1.22.3fmodulex-numpy.lib.histograms._ravel_and_check_weightsfmoduleõÙ±‚aoa=Ù±‚`awÙ±‚`a)Ù±‚`a
Ù±‚bnbeprintÙ±‚`a(Ù±‚`cavgÙ±‚aoa.Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚`a)jcomplex256hcompiledöƒÙ¼ƒÙ»ƒjma.averageööÙ¹‚Ù§xJaverage for masked arrays -- useful if your data contains "missing" values€öÙ¼ƒÙ»ƒdmeanjnumpy.meanõ€öÙ¼ƒÙ»ƒqnumpy.result_typeqnumpy.result_typeõÙ¹‚Ù§x\Returns the type that results from applying the numpy type promotion rules to the arguments.€öf1.22.3Ù«x3average(a, axis=None, weights=None, returned=False)ömnumpy.average€
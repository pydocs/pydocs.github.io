Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚‰Ù§x:This function computes the inverse of the one-dimensional Ù¨Ù§anÙ§x<-point discrete Fourier Transform of real input computed by Ù¢„drfftÙ „enumpyf1.22.3fmodulennumpy.fft.rfftfmoduleõÙ§r. In other words, Ù¡xirfft(rfft(a), len(a)) == aÙ§x8 to within numerical accuracy. (See Notes below for why Ù¡flen(a)Ù§t is necessary here.)€Ù¹‚ƒÙ§x4The input is expected to be in the form returned by Ù¢„drfftÙ „enumpyf1.22.3fmodulennumpy.fft.rfftfmoduleõÙ§y5, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency.  Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚‰Ù§xReturns the real valued Ù¢„anÙ „ööelocalanelocalõÙ§x--point inverse discrete Fourier transform of Ù¢„aaÙ „ööelocalaaelocalõÙ§h, where Ù¢„aaÙ „ööelocalaaelocalõÙ§xN contains the non-negative frequency terms of a Hermitian-symmetric sequence. Ù¢„anÙ „ööelocalanelocalõÙ§x, is the length of the result, not the input.€Ù¹‚‰Ù§rIf you specify an Ù¢„anÙ „ööelocalanelocalõÙ§k such that Ù¢„aaÙ „ööelocalaaelocalõÙ§x‰ must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to Ù£ƒamööÙ§x& points via Fourier interpolation by: Ù¡xa_resamp = irfft(rfft(a), m)Ù§a.€Ù¹‚‡Ù§xjThe correct interpretation of the hermitian input depends on the length of the original data, as given by Ù¢„anÙ „ööelocalanelocalõÙ§xh. This is because each input shape could correspond to either an odd or even length signal. By default, Ù¢„eirfftÙ „enumpyf1.22.3fmoduleonumpy.fft.irfftfmoduleõÙ§xÿ assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input Ù©Ù§dmustÙ§j be given.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚Ù§pThe input array.€Ù°ƒanmint, optionalÙ¹‚Ù§x2Length of the transformed axis of the output. For Ù¢„anÙ „ööelocalanelocalõÙ§p output points, Ù¡fn//2+1Ù§x‰ input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If Ù¢„anÙ „ööelocalanelocalõÙ§x! is not given, it is taken to be Ù¡g2*(m-1)Ù§g where Ù¡amÙ§x8 is the length of the input along the axis specified by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§a.€Ù°ƒdaxismint, optionalÙ¹‚Ù§xPAxis over which to compute the inverse FFT. If not given, the last axis is used.€Ù°ƒdnormx*{"backward", "ortho", "forward"}, optionalƒÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.10.0 €Ù¹‚ƒÙ§xNormalization mode (see Ù¢„inumpy.fftÙ „enumpyf1.22.3fmoduleinumpy.fftfmoduleõÙ§xŒ). Default is "backward". Indicates which direction of the forward/backward pair of transforms is scaled and with what normalization factor.€ÙÆƒlversionaddedf1.20.0Ù¹‚Ù§x2The " backward " , " forward " values were added. €öfRaisesÙ¯‚Ù°ƒ`jIndexErrorÙ¹‚…Ù§cIf Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x is not a valid axis of Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚Ù§xLThe truncated or zero-padded input, transformed along the axis indicated by Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§u, or the last one if Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x9 is not specified. The length of the transformed axis is Ù¢„anÙ „ööelocalanelocalõÙ§i, or, if Ù¢„anÙ „ööelocalanelocalõÙ§o is not given, Ù¡g2*(m-1)Ù§g where Ù¡amÙ§x\ is the length of the transformed axis of the input. To get an odd number of output points, Ù¢„anÙ „ööelocalanelocalõÙ§s must be specified.€ögSummaryÙ¯‚Ù¹‚ƒÙ§xComputes the inverse of Ù¢„drfftÙ „enumpyf1.22.3fmodulennumpy.fft.rfftfmoduleõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/fft/_pocketfft.pyr<class 'function'>onumpy.fft.irfftÙ¯‚ƒÙ´ƒ—Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„difftÙ „enumpyf1.22.3fmodulennumpy.fft.ifftfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`ajÙ±‚`a]Ù±‚`a)x5array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may varyfexecedÙ´ƒ“Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cfftÙ „enumpyf1.22.3fmodulemnumpy.fft.fftfmoduleõÙ±‚aoa.Ù±‚`Ù¢„eirfftÙ „enumpyf1.22.3fmoduleonumpy.fft.irfftfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a]Ù±‚`a)xarray([0.,  1.,  0.,  0.])fexecedÙ¹‚…Ù§x6Notice how the last term in the input to the ordinary Ù¢„difftÙ „enumpyf1.22.3fmodulennumpy.fft.ifftfmoduleõÙ§xo is the complex conjugate of the second term, and the output has zero imaginary part everywhere.  When calling Ù¢„eirfftÙ „enumpyf1.22.3fmoduleonumpy.fft.irfftfmoduleõÙ§xR, the negative frequencies are not specified, and the output array is purely real.€ö…Ù¼ƒÙ»ƒcfftmnumpy.fft.fftõÙ¹‚Ù§xThe one-dimensional FFT.€öÙ¼ƒÙ»ƒfirfft2pnumpy.fft.irfft2õÙ¹‚Ù§x5The inverse of the two-dimensional FFT of real input.€öÙ¼ƒÙ»ƒfirfftnpnumpy.fft.irfftnõÙ¹‚ƒÙ§sThe inverse of the Ù¨Ù§anÙ§x-dimensional FFT of real input.€öÙ¼ƒÙ»ƒinumpy.fftööÙ¹‚Ù§x/For definition of the DFT and conventions used.€öÙ¼ƒÙ»ƒdrfftnnumpy.fft.rfftõÙ¹‚ƒÙ§x0The one-dimensional FFT of real input, of which Ù¢„eirfftÙ „enumpyf1.22.3fmoduleonumpy.fft.irfftfmoduleõÙ§l is inverse.€öf1.22.3Ù«x$irfft(a, n=None, axis=-1, norm=None)öonumpy.fft.irfft€
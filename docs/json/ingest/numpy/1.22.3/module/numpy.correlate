Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x^This function computes the correlation as generally defined in signal processing texts::      €ÙÀx%c_{av}[k] = sum_n a[n+k] * conj(v[n])Ù¹‚Ù§xVwith a and v sequences being zero-padded where necessary and conj being the conjugate.€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§xŒThe definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is::      €ÙÀx$c'_{av}[k] = sum_n a[n] conj(v[n+k])Ù¹‚…Ù§twhich is related to Ù¡ic_{av}[k]Ù§d by Ù¡wc'_{av}[k] = c_{av}[-k]Ù§a.€Ù¹‚„Ù¢„onumpy.correlateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ§x} may perform slowly in large arrays (i.e. n = 1e5) because it does not use the FFT to compute the convolution; in that case, Ù¢„vscipy.signal.correlateÙ „escipya*capix#scipy.signal._signaltools.correlatefmoduleõÙ§u might be preferable.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒda, vjarray_likeÙ¹‚Ù§pInput sequences.€Ù°ƒdmodex#{'valid', 'same', 'full'}, optionalÙ¹‚…Ù§mRefer to the Ù¢„hconvolveÙ „enumpyf1.22.3fmodulennumpy.convolvefmoduleõÙ§x6 docstring.  Note that the default is 'valid', unlike Ù¢„hconvolveÙ „enumpyf1.22.3fmodulennumpy.convolvefmoduleõÙ§t, which uses 'full'.€Ù°ƒlold_behaviordboolÙ¹‚„Ù¢„lold_behaviorÙ „ööelocallold_behaviorelocalõÙ§x> was removed in NumPy 1.10. If you need the old behavior, use Ù£ƒtmultiarray.correlateööÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚…Ù§xDiscrete cross-correlation of Ù¢„aaÙ „ööelocalaaelocalõÙ§e and Ù¢„avÙ „ööelocalavelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x1Cross-correlation of two 1-dimensional sequences.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesv/numpy/core/numeric.pyr<class 'function'>onumpy.correlateÙ¯‚‡Ù´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a)larray([3.5])fexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2dsameÙ±‚bs2a"Ù±‚`a)xarray([2. ,  3.5,  3. ])fexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2Ù¢„dfullÙ „enumpyf1.22.3fmodulejnumpy.fullfmoduleõÙ±‚bs2a"Ù±‚`a)x$array([0.5,  2. ,  3.5,  3. ,  0. ])fexecedÙ¹‚Ù§xUsing complex sequences:€Ù´ƒ˜%Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚aoa+Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚aoa-Ù±‚bmia1Ù±‚`ajÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`ajÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1Ù¢„dfullÙ „enumpyf1.22.3fmodulejnumpy.fullfmoduleõÙ±‚bs1a'Ù±‚`a)x>array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])fexecedÙ¹‚ƒÙ§xqNote that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., Ù¡xc_{va}[k] = c^{*}_{av}[-k]Ù§a:€Ù´ƒ˜%Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„icorrelateÙ „enumpyf1.22.3fmoduleonumpy.correlatefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfc0.5Ù±‚`ajÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚aoa+Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚aoa-Ù±‚bmia1Ù±‚`ajÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1Ù¢„dfullÙ „enumpyf1.22.3fmodulejnumpy.fullfmoduleõÙ±‚bs1a'Ù±‚`a)x>array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])fexecedöƒÙ¼ƒÙ»ƒhconvolvennumpy.convolveõÙ¹‚Ù§x>Discrete, linear convolution of two one-dimensional sequences.€öÙ¼ƒÙ»ƒtmultiarray.correlateööÙ¹‚Ù§x(Old, no conjugate, version of correlate.€öÙ¼ƒÙ»ƒvscipy.signal.correlatex#scipy.signal._signaltools.correlateõÙ¹‚Ù§x8uses FFT which has superior performance on large arrays.€öf1.22.3Ù«xcorrelate(a, v, mode='valid')öonumpy.correlate€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x¤For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero).€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaxjarray_likeÙ¹‚Ù§qfirst input array€Ù°ƒayjarray_likeÙ¹‚Ù§rsecond input array€Ù°ƒedtypeodtype, optionalÙ¹‚…Ù§uData-type to convert Ù¢„axÙ „ööelocalaxelocalõÙ§e and Ù¢„ayÙ „ööelocalayelocalõÙ§x to if given. Default is None.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdnulpjarray_likeÙ¹‚Ù§xLnumber of representable floating point numbers between each item in x and y.€ögSummaryÙ¯‚Ù¹‚Ù§xZFor each item in x and y, return the number of representable floating points between them.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametersgReturnseNoteshExamplesx /numpy/testing/_private/utils.pyqr<class 'function'>x&numpy.testing._private.utils.nulp_diffÙ¯‚Ù¹‚Ù§x°# By definition, epsilon is the smallest number such as 1 + eps != 1, so # there should be exactly one ULP between 1 and 1 + eps >>> nulp_diff(1, 1 + np.finfo(x.dtype).eps) 1.0€ö€f1.22.3Ù«xnulp_diff(x, y, dtype=None)öx&numpy.testing._private.utils.nulp_diff€
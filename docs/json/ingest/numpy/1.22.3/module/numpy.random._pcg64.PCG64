Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‹Ù¹‚…Ù§xpPCG-64 is a 128-bit implementation of O'Neill's permutation congruential generator (, ). PCG-64 has a period of Ù¥g2^{128}Ù§x@ and supports advancing an arbitrary number of steps as well as Ù¥g2^{127}Ù§xn streams. The specific member of the PCG family that we use is PCG XSL RR 128/64 as described in the paper ().€Ù¹‚„Ù¡ePCG64Ù§x³ provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers. These are not directly consumable in Python and must be consumed by a Ù¡iGeneratorÙ§x2 or similar object that supports low-level access.€Ù¹‚ƒÙ§tSupports the method Ù¢„gadvanceÙ „enumpyf1.22.3fmodulex$numpy.core._internal._Stream.advancefmoduleõÙ§x| to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.€Ù¹‚Ù©Ù§qState and Seeding€Ù¹‚ƒÙ§dThe Ù¡ePCG64Ù§xô state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.€Ù¹‚ƒÙ§xThe input seed is processed by Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§xF to generate both values. The increment is not independently settable.€Ù¹‚Ù©Ù§qParallel Features€Ù¹‚ƒÙ§xOThe preferred way to use a BitGenerator in parallel applications is to use the Ù¢„rSeedSequence.spawnÙ „enumpyf1.22.3fmodulex7numpy.random.bit_generator.ISpawnableSeedSequence.spawnfmoduleõÙ§xQ method to obtain entropy values, and to use these to generate new BitGenerators:€ÙÀxŒ>>> from numpy.random import Generator, PCG64, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(PCG64(s)) for s in sg.spawn(10)]Ù¹‚Ù©Ù§wCompatibility Guarantee€Ù¹‚‚Ù¡ePCG64Ù§xX makes a guarantee that a fixed seed will always produce the same random integer stream.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒdseedx5{None, int, array_like[ints], SeedSequence}, optionalÙ¹‚Ù§xA seed to initialize the Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§xO. If None, then fresh, unpredictable entropy will be pulled from the OS. If an Ù¡cintÙ§d or Ù¡parray_like[ints]Ù§x& is passed, then it will be passed to Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§w to derive the initial Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§x state. One may also pass in a Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§j instance.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x;BitGenerator for the PCG-64 pseudo-random number generator.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…iSignaturegSummaryjParameterseNotesjReferencesx)/numpy/random/_pcg64.cpython-39-darwin.soön<class 'type'>rnumpy.random.PCG64Ù¯‚€ö€f1.22.3Ù«pPCG64(seed=None)öxnumpy.random._pcg64.PCG64€
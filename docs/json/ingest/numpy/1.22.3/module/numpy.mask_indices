Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§gAssume Ù¢„imask_funcÙ „ööelocalimask_funcelocalõÙ§x2 is a function that, for a square array a of size Ù¡f(n, n)Ù§x! with a possible offset argument Ù¢„akÙ „ööelocalakelocalõÙ§q, when called as Ù¡omask_func(a, k)Ù§xE returns a new array with zeros in certain locations (functions like Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ§d or Ù¢„dtrilÙ „enumpyf1.22.3fmodulejnumpy.trilfmoduleõÙ§xg do precisely this). Then this function returns the indices where the non-zero values would be located.€ögMethodsÙ¯‚€öeNotesÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.4.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒancintÙ¹‚Ù§xDThe returned indices will be valid to access arrays of shape (n, n).€Ù°ƒimask_funchcallableÙ¹‚‹Ù§x6A function whose call signature is similar to that of Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ§b, Ù¢„dtrilÙ „enumpyf1.22.3fmodulejnumpy.trilfmoduleõÙ§k. That is, Ù¡omask_func(x, k)Ù§x& returns a boolean array, shaped like Ù£ƒaxööÙ§b. Ù¢„akÙ „ööelocalakelocalõÙ§x) is an optional argument to the function.€Ù°ƒakfscalarÙ¹‚‡Ù§x0An optional argument which is passed through to Ù¢„imask_funcÙ „ööelocalimask_funcelocalõÙ§q. Functions like Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ§b, Ù¢„dtrilÙ „enumpyf1.22.3fmodulejnumpy.trilfmoduleõÙ§x9 take a second argument that is interpreted as an offset.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒgindicesptuple of arrays.Ù¹‚…Ù§dThe Ù¢„anÙ „ööelocalanelocalõÙ§x8 arrays of indices corresponding to the locations where Ù¡xmask_func(np.ones((n, n)), k)Ù§i is True.€ögSummaryÙ¯‚Ù¹‚Ù§xEReturn the indices to access (n, n) arrays, given a masking function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/lib/twodim_base.py7r<class 'function'>rnumpy.mask_indicesÙ¯‚‰Ù¹‚Ù§x`These are the indices that would allow you to access the upper triangular part of any 3x3 array:€Ù´ƒÙ±‚`biuÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„lmask_indicesÙ „enumpyf1.22.3fmodulernumpy.mask_indicesfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ±‚`a)`fexecedÙ¹‚ƒÙ§pFor example, if Ù£ƒaaööÙ§p is a 3x3 array:€Ù´ƒ”Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia9Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a
Ù±‚`aax6array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])fexecedÙ´ƒ„Ù±‚`aaÙ±‚`a[Ù±‚`biuÙ±‚`a]xarray([0, 1, 2, 4, 5, 8])fexecedÙ¹‚Ù§x…An offset can be passed also to the masking function.  This gets us the indices starting on the first diagonal right of the main one:€Ù´ƒ’Ù±‚`ciu1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„lmask_indicesÙ „enumpyf1.22.3fmodulernumpy.mask_indicesfmoduleõÙ±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)`fexecedÙ¹‚Ù§x.with which we now extract only three elements:€Ù´ƒ„Ù±‚`aaÙ±‚`a[Ù±‚`ciu1Ù±‚`a]parray([1, 2, 5])fexecedö„Ù¼ƒÙ»ƒdtriljnumpy.trilõ€öÙ¼ƒÙ»ƒltril_indicesrnumpy.tril_indicesõ€öÙ¼ƒÙ»ƒdtriujnumpy.triuõ€öÙ¼ƒÙ»ƒltriu_indicesrnumpy.triu_indicesõ€öf1.22.3Ù«xmask_indices(n, mask_func, k=0)örnumpy.mask_indices€
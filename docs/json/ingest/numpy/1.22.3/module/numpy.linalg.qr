Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‰Ù§rFactor the matrix Ù¢„aaÙ „ööelocalaaelocalõÙ§d as Ù¨Ù§bqrÙ§h, where Ù¢„aqÙ „ööelocalaqelocalõÙ§t is orthonormal and Ù¢„arÙ „ööelocalarelocalõÙ§u is upper-triangular.€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚‰Ù§x,This is an interface to the LAPACK routines Ù¡fdgeqrfÙ§b, Ù¡fzgeqrfÙ§b, Ù¡fdorgqrÙ§f, and Ù¡fzungqrÙ§a.€Ù¹‚Ù§xmFor more information on the qr factorization, see for example: https://en.wikipedia.org/wiki/QR_factorization€Ù¹‚‡Ù§nSubclasses of Ù¢„gndarrayÙ „enumpyf1.22.3fmodulemnumpy.ndarrayfmoduleõÙ§x0 are preserved except for the 'raw' mode. So if Ù¢„aaÙ „ööelocalaaelocalõÙ§l is of type Ù¢„fmatrixÙ „enumpyf1.22.3fmodulelnumpy.matrixfmoduleõÙ§x-, all the return values will be matrices too.€Ù¹‚ƒÙ§yINew 'reduced', 'complete', and 'raw' options for mode were added in NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In addition the options 'full' and 'economic' were deprecated.  Because 'full' was the previous default and 'reduced' is the new default, backward compatibility can be maintained by letting Ù¢„dmodeÙ „ööelocaldmodeelocalõÙ§yœ default. The 'raw' option was added so that LAPACK routines that can multiply arrays by q using the Householder reflectors can be used. Note that in this case the returned arrays are of type np.double or np.cdouble and the h array is transposed to be FORTRAN compatible.  No routines using the 'raw' return are currently exposed by numpy, but some are available in lapack_lite and just await the necessary work.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒaaxarray_like, shape (..., M, N)Ù¹‚Ù§x;An array-like object with the dimensionality of at least 2.€Ù°ƒdmodex-{'reduced', 'complete', 'r', 'raw'}, optionalÙ¹‚Ù§vIf K = min(M, N), then€öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§sIf factoring fails.€öhReceivesÙ¯‚€ögReturnsÙ¯‚ƒÙ°ƒaqx%ndarray of float or complex, optionalÙ¹‚Ù§yKA matrix with orthonormal columns. When mode = 'complete' the result is an orthogonal/unitary matrix depending on whether or not a is real/complex. The determinant may be either +/- 1 in that case. In case the number of dimensions in the input array is greater than 2 then a stack of the matrices with above properties is returned.€Ù°ƒarx%ndarray of float or complex, optionalÙ¹‚Ù§x…The upper-triangular matrix or a stack of upper-triangular matrices if the number of dimensions in the input array is greater than 2.€Ù°ƒh(h, tau)x-ndarrays of np.double or np.cdouble, optionalÙ¹‚Ù§x¿The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated  'economic' mode only h is returned.€ögSummaryÙ¯‚Ù¹‚Ù§x)Compute the qr factorization of a matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesw/numpy/linalg/linalg.pyr<class 'function'>onumpy.linalg.qrÙ¯‚ŠÙ´ƒ˜3Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`erandnÙ±‚`a(Ù±‚bmia9Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a
Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„bqrÙ „enumpyf1.22.3fmoduleonumpy.linalg.qrfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a)Ù±‚`a)Ù±‚`b  Ù±‚bc1q# a does equal qrdTruefexecedÙ´ƒ˜Ù±‚`br2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„bqrÙ „enumpyf1.22.3fmoduleonumpy.linalg.qrfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`dmodeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1arÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`arÙ±‚`a,Ù±‚`a Ù±‚`br2Ù±‚`a)Ù±‚`b  Ù±‚bc1x,# mode='r' returns the same r as mode='full'dTruefexecedÙ´ƒ˜,Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`fnormalÙ±‚`a(Ù±‚`Ù¢„dsizeÙ „enumpyf1.22.3fmodulejnumpy.sizefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚`a Ù±‚bc1x"# Stack of 2 x 2 matrices as inputÙ±‚`a
Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„bqrÙ „enumpyf1.22.3fmoduleonumpy.linalg.qrfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`aqÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõi(3, 2, 2)fexecedÙ´ƒƒÙ±‚`arÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõi(3, 2, 2)fexecedÙ´ƒ‘Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hallcloseÙ „enumpyf1.22.3fmodulennumpy.allclosefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`fmatmulÙ±‚`a(Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a)Ù±‚`a)dTruefexecedÙ¹‚ƒÙ§x%Example illustrating a common use of Ù¢„bqrÙ „enumpyf1.22.3fmoduleonumpy.linalg.qrfmoduleõÙ§x#: solving of least squares problems€Ù·ƒx+A = array([[0, 1], [1, 1], [1, 1], [2, 1]])vx = array([[y0], [m]])xb = array([[1], [0], [2], [1]])Ù¹‚…Ù§xWIf A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then Ù¡vx = inv(r) * (q.T) * bÙ§x..  (In numpy practice, however, we simply use Ù¢„elstsqÙ „enumpyf1.22.3fmodulernumpy.linalg.lstsqfmoduleõÙ§b.)€Ù´ƒ˜+Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.Afmoduleõx<array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])fexecedÙ´ƒ˜FÙ±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚`arÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„bqrÙ „enumpyf1.22.3fmoduleonumpy.linalg.qrfmoduleõÙ±‚`a(Ù±‚`Ù¢„aAÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.AfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`apÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`aqÙ±‚aoa.Ù±‚`Ù¢„aTÙ „enumpyf1.22.3fmodulex"numpy.matrixlib.defmatrix.matrix.TfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„cdotÙ „enumpyf1.22.3fmoduleinumpy.dotfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚aoa.Ù±‚`Ù¢„cinvÙ „enumpyf1.22.3fmodulepnumpy.linalg.invfmoduleõÙ±‚`a(Ù±‚`arÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`apÙ±‚`a)xarray([  1.1e-16,   1.0e+00])fexecedö‚Ù¼ƒÙ»ƒoscipy.linalg.qrööÙ¹‚Ù§xSimilar function in SciPy.€öÙ¼ƒÙ»ƒoscipy.linalg.rqööÙ¹‚Ù§x%Compute RQ decomposition of a matrix.€öf1.22.3Ù«uqr(a, mode='reduced')öonumpy.linalg.qr€
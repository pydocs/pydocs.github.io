Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.4.0 €öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒancintÙ¹‚Ù§xDThe size of the arrays for which the returned indices will be valid.€Ù°ƒakmint, optionalÙ¹‚ƒÙ§uDiagonal offset (see Ù¢„dtriuÙ „enumpyf1.22.3fmodulejnumpy.triufmoduleõÙ§n for details).€Ù°ƒammint, optional‚ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.9.0 €Ù¹‚…Ù§x[The column dimension of the arrays for which the returned arrays will be valid. By default Ù¢„amÙ „ööelocalamelocalõÙ§s is taken equal to Ù¢„anÙ „ööelocalanelocalõÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdindsx'tuple, shape(2) of ndarrays, shape(`n`)Ù¹‚…Ù§x§The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.  Can be used to slice a ndarray of shape(Ù¢„anÙ „ööelocalanelocalõÙ§b, Ù¢„anÙ „ööelocalanelocalõÙ§b).€ögSummaryÙ¯‚Ù¹‚Ù§x=Return the indices for the upper-triangle of an (n, m) array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/lib/twodim_base.pyór<class 'function'>rnumpy.triu_indicesÙ¯‚ŠÙ¹‚Ù§xªCompute two different sets of indices to access 4x4 arrays, one for the upper triangular part starting at the main diagonal, and one starting two diagonals further right:€Ù´ƒ˜Ù±‚`ciu1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ltriu_indicesÙ „enumpyf1.22.3fmodulernumpy.triu_indicesfmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`ciu2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ltriu_indicesÙ „enumpyf1.22.3fmodulernumpy.triu_indicesfmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)`fexecedÙ¹‚Ù§x1Here is how they can be used with a sample array:€Ù´ƒ”Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmib16Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aaxdarray([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])fexecedÙ¹‚Ù§rBoth for indexing:€Ù´ƒ„Ù±‚`aaÙ±‚`a[Ù±‚`ciu1Ù±‚`a]x$array([ 0,  1,  2, ..., 10, 11, 15])fexecedÙ¹‚Ù§xAnd for assigning values:€Ù´ƒ‹Ù±‚`aaÙ±‚`a[Ù±‚`ciu1Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia1Ù±‚`a
Ù±‚`aaxdarray([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])fexecedÙ¹‚Ù§xWThese cover only a small part of the whole array (two diagonals right of the main one):€Ù´ƒ‹Ù±‚`aaÙ±‚`a[Ù±‚`ciu2Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmib10Ù±‚`a
Ù±‚`aaxtarray([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])fexecedö„Ù¼ƒÙ»ƒlmask_indicesrnumpy.mask_indicesõÙ¹‚Ù§x6generic function accepting an arbitrary mask function.€öÙ¼ƒÙ»ƒdtriljnumpy.trilõ€öÙ¼ƒÙ»ƒltril_indicesrnumpy.tril_indicesõÙ¹‚Ù§x'similar function, for lower-triangular.€öÙ¼ƒÙ»ƒdtriujnumpy.triuõ€öf1.22.3Ù«xtriu_indices(n, k=0, m=None)örnumpy.triu_indices€
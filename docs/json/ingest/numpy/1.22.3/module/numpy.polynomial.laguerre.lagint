Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚˜Ù§x)Returns the Laguerre series coefficients Ù¢„acÙ „ööelocalacelocalõÙ§l integrated Ù¢„amÙ „ööelocalamelocalõÙ§l times from Ù¢„dlbndÙ „ööelocaldlbndelocalõÙ§g along Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x,. At each iteration the resulting series is Ù©Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x and an integration constant, Ù¢„akÙ „ööelocalakelocalõÙ§x”, is added. The scaling factor is for use in a linear change of variable.  ("Buyer beware": note that, depending on what one is doing, one may want Ù¢„csclÙ „ööelocalcsclelocalõÙ§xr to be the reciprocal of what one might expect; for more information, see the Notes section below.)  The argument Ù¢„acÙ „ööelocalacelocalõÙ§xj is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the series Ù¡sL_0 + 2*L_1 + 3*L_2Ù§x  while [[1,2],[1,2]] represents Ù¡xE1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)Ù§n if axis=0 is Ù¡axÙ§o and axis=1 is Ù¡ayÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x,Note that the result of each integration is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§xP. Why is this important to note?  Say one is making a linear change of variable Ù¥ju = ax + bÙ§x in an integral relative to Ù£ƒaxööÙ§h.  Then Ù¥idx = du/aÙ§x, so one will need to set Ù¢„csclÙ „ööelocalcsclelocalõÙ§j equal to Ù¥c1/aÙ§x1 - perhaps not what one would have first thought.€Ù¹‚Ù§xãAlso note that, in general, the result of integrating a C-series needs to be "reprojected" onto the C-series basis set.  Thus, typically, the result of this function is "unintuitive," albeit correct; see Examples section below.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒacjarray_likeÙ¹‚ƒÙ§x*Array of Laguerre series coefficients. If Ù¢„acÙ „ööelocalacelocalõÙ§xˆ is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.€Ù°ƒammint, optionalÙ¹‚Ù§x4Order of integration, must be positive. (Default: 1)€Ù°ƒakx{[], list, scalar}, optionalÙ¹‚‰Ù§x=Integration constant(s).  The value of the first integral at Ù¡dlbndÙ§xE is the first value in the list, the value of the second integral at Ù¡dlbndÙ§x is the second value, etc.  If Ù¡gk == []Ù§x3 (the default), all constants are set to zero.  If Ù¡fm == 1Ù§x1, a single scalar can be given instead of a list.€Ù°ƒdlbndpscalar, optionalÙ¹‚Ù§x-The lower bound of the integral. (Default: 0)€Ù°ƒcsclpscalar, optionalÙ¹‚…Ù§x)Following each integration the result is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x7 before the integration constant is added. (Default: 1)€Ù°ƒdaxismint, optional‚Ù¹‚Ù§x4Axis over which the integral is taken. (Default: 0).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚‰Ù§cIf Ù¡em < 0Ù§b, Ù¡jlen(k) > mÙ§b, Ù¡rnp.ndim(lbnd) != 0Ù§e, or Ù¡qnp.ndim(scl) != 0Ù§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaSgndarrayÙ¹‚Ù§x-Laguerre series coefficients of the integral.€ögSummaryÙ¯‚Ù¹‚Ù§xIntegrate a Laguerre series.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/polynomial/laguerre.py¥r<class 'function'>x numpy.polynomial.laguerre.lagintÙ¯‚…Ù´ƒ–Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„hlaguerreÙ „enumpyf1.22.3fmodulexnumpy.polynomial.laguerrefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a
Ù±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)xarray([ 1.,  1.,  1., -3.])fexecedÙ´ƒÙ±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`amÙ±‚aoa=Ù±‚bmia2Ù±‚`a)x array([ 1.,  0.,  0., -4.,  3.])fexecedÙ´ƒÙ±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚bmia1Ù±‚`a)xarray([ 2.,  1.,  1., -3.])fexecedÙ´ƒÙ±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dlbndÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)xarray([11.5,  1. ,  1. , -3. ])fexecedÙ´ƒ˜Ù±‚`Ù¢„flagintÙ „enumpyf1.22.3fmodulex numpy.polynomial.laguerre.lagintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`amÙ±‚aoa=Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dlbndÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)xJarray([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may varyfexecedöÙ¼ƒÙ»ƒflagderx numpy.polynomial.laguerre.lagderõ€öf1.22.3Ù«x+lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0)öx numpy.polynomial.laguerre.lagint€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚‰Ù§vFor positive integers Ù¢„anÙ „ööelocalanelocalõÙ§xT, the power is computed by repeated matrix squarings and matrix multiplications. If Ù¡fn == 0Ù§x=, the identity matrix of the same shape as M is returned. If Ù¡en < 0Ù§x1, the inverse is computed and then raised to the Ù¡fabs(n)Ù§a.€ÙÆƒdnote`Ù¹‚Ù§x7Stacks of object matrices are not currently supported. €ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒaav(..., M, M) array_likeÙ¹‚Ù§wMatrix to be "powered".€Ù°ƒancintÙ¹‚Ù§xMThe exponent can be any integer or long integer, positive, negative, or zero.€öfRaisesÙ¯‚Ù°ƒ`kLinAlgErrorÙ¹‚Ù§x^For matrices that are not square or that (for negative powers) cannot be inverted numerically.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒda**nx$(..., M, M) ndarray or matrix objectÙ¹‚…Ù§x/The return value is the same shape and type as Ù£ƒaMööÙ§x\; if the exponent is positive or zero then the type of the elements is the same as those of Ù£ƒaMööÙ§x>. If the exponent is negative the elements are floating-point.€ögSummaryÙ¯‚Ù¹‚ƒÙ§x-Raise a square matrix to the (integer) power Ù¢„anÙ „ööelocalanelocalõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnsfRaiseshExamplesw/numpy/linalg/linalg.py)r<class 'function'>xnumpy.linalg.matrix_powerÙ¯‚†Ù´ƒ˜0Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„flinalgÙ „enumpyf1.22.3fmodulelnumpy.linalgfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„lmatrix_powerÙ „enumpyf1.22.3fmodulexnumpy.linalg.matrix_powerfmoduleõÙ±‚`a
Ù±‚`aiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚bc1x%# matrix equiv. of the imaginary unitÙ±‚`a
Ù±‚`Ù¢„lmatrix_powerÙ „enumpyf1.22.3fmodulexnumpy.linalg.matrix_powerfmoduleõÙ±‚`a(Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a Ù±‚bc1m# should = -ix"array([[ 0, -1],
       [ 1,  0]])fexecedÙ´ƒ‡Ù±‚`Ù¢„lmatrix_powerÙ „enumpyf1.22.3fmodulexnumpy.linalg.matrix_powerfmoduleõÙ±‚`a(Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)xarray([[1, 0],
       [0, 1]])fexecedÙ´ƒŠÙ±‚`Ù¢„lmatrix_powerÙ „enumpyf1.22.3fmodulexnumpy.linalg.matrix_powerfmoduleõÙ±‚`a(Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚aoa-Ù±‚bmia3Ù±‚`a)Ù±‚`a Ù±‚bc1x+# should = 1/(-i) = i, but w/ f.p. elementsx&array([[ 0.,  1.],
       [-1.,  0.]])fexecedÙ¹‚Ù§x#Somewhat more sophisticated example€Ù´ƒ˜4Ù±‚`aqÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aqÙ±‚`a[Ù±‚bmia0Ù±‚`a:Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚`aiÙ±‚`a
Ù±‚`aqÙ±‚`a[Ù±‚bmia2Ù±‚`a:Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a:Ù±‚bmia4Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`aiÙ±‚`a
Ù±‚`aqÙ±‚`a Ù±‚bc1x2# one of the three quaternion units not equal to 1xtarray([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])fexecedÙ´ƒ‰Ù±‚`Ù¢„lmatrix_powerÙ „enumpyf1.22.3fmodulexnumpy.linalg.matrix_powerfmoduleõÙ±‚`a(Ù±‚`aqÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚bc1n# = -np.eye(4)xtarray([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])fexecedö€f1.22.3Ù«rmatrix_power(a, n)öxnumpy.linalg.matrix_power€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xnCompute an array where the subarrays contain index values 0, 1, ... varying only along the corresponding axis.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚‰Ù§xƒThe output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if Ù¢„jdimensionsÙ „enumpyf1.22.3fmodulex/numpy.lib.function_base._parse_input_dimensionsfmoduleõÙ§l is a tuple Ù¡o(r0, ..., rN-1)Ù§k of length Ù¡aNÙ§v, the output shape is Ù¡r(N, r0, ..., rN-1)Ù§a.€Ù¹‚…Ù§nThe subarrays Ù¡ggrid[k]Ù§x- contains the N-D array of indices along the Ù¡dk-thÙ§x axis. Explicitly::      €ÙÀxgrid[k, i0, i1, ..., iN-1] = iköpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒjdimensionspsequence of intsÙ¹‚Ù§vThe shape of the grid.€Ù°ƒedtypeodtype, optionalÙ¹‚Ù§xData type of the result.€Ù°ƒfsparseqboolean, optional‚Ù¹‚Ù§x_Return a sparse representation of the grid instead of a dense representation. Default is False.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e1.17 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdgridx one ndarray or tuple of ndarraysÙÁ‚ÙÅ‚Ù¹‚Ù§sIf sparse is False:€Ù¹‚ƒÙ§x'Returns one array of grid indices,     Ù¡x3grid.shape = (len(dimensions),) + tuple(dimensions)Ù§a.€ÙÅ‚Ù¹‚Ù§rIf sparse is True:€Ù¹‚ƒÙ§x$Returns a tuple of arrays, with     Ù¡x5grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)Ù§x( with     dimensions[i] in the ith place€ögSummaryÙ¯‚Ù¹‚Ù§x3Return an array representing the indices of a grid.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesv/numpy/core/numeric.pyr<class 'function'>mnumpy.indicesÙ¯‚‹Ù´ƒ“Ù±‚`dgridÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`dgridÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõi(2, 2, 3)fexecedÙ´ƒ†Ù±‚`dgridÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`h        Ù±‚bc1m# row indicesx$array([[0, 0, 0],
       [1, 1, 1]])fexecedÙ´ƒ†Ù±‚`dgridÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`h        Ù±‚bc1p# column indicesx$array([[0, 1, 2],
       [0, 1, 2]])fexecedÙ¹‚Ù§x2The indices can be used as an index into an array.€Ù´ƒ˜-Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmib20Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`crowÙ±‚`a,Ù±‚`a Ù±‚`ccolÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a[Ù±‚`crowÙ±‚`a,Ù±‚`a Ù±‚`ccolÙ±‚`a]x$array([[0, 1, 2],
       [4, 5, 6]])fexecedÙ¹‚ƒÙ§xoNote that it would be more straightforward in the above example to extract the required elements directly with Ù¡ix[:2, :3]Ù§a.€Ù¹‚Ù§xOIf sparse is set to true, the grid will be returned in a sparse representation.€Ù´ƒ˜Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚`ajÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`fsparseÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`aiÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõf(2, 1)fexecedÙ´ƒƒÙ±‚`ajÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõf(1, 3)fexecedÙ´ƒƒÙ±‚`aiÙ±‚`h        Ù±‚bc1m# row indicesxarray([[0],
       [1]])fexecedÙ´ƒƒÙ±‚`ajÙ±‚`h        Ù±‚bc1p# column indicesrarray([[0, 1, 2]])fexecedöƒÙ¼ƒÙ»ƒhmeshgridnnumpy.meshgridõ€öÙ¼ƒÙ»ƒemgridöö€öÙ¼ƒÙ»ƒeogridöö€öf1.22.3Ù«x6indices(dimensions, dtype=<class 'int'>, sparse=False)ömnumpy.indices€
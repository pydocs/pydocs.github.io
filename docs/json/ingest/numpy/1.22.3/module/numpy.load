Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ÙÆƒgwarningx<Loading files that contain object arrays uses the ``pickle``Ù¹‚Ù§xÜmodule, which is not secure against erroneous or maliciously constructed data. Consider passing ``allow_pickle=False`` to load data that is known not to contain object arrays for the safer handling of untrusted sources. €ögMethodsÙ¯‚€öeNotesÙ¯‚ÙÈ†Ù¹‚Ù§x]If the file contains pickle data, then whatever object is stored   in the pickle is returned.€Ù¹‚ƒÙ§qIf the file is a Ù¡d.npyÙ§x' file, then a single array is returned.€Ù¹‚…Ù§qIf the file is a Ù¡d.npzÙ§x? file, then a dictionary-like object is   returned, containing Ù¡q{filename: array}Ù§x5 key-value pairs, one for   each file in the archive.€Ù¹‚ƒÙ§qIf the file is a Ù¡d.npzÙ§xs file, the returned value supports the   context manager protocol in a similar fashion to the open function::      €ÙÀx/with load('foo.npz') as data:
    a = data['a']Ù¹‚Ù§xIThe underlying file descriptor is closed when exiting the 'with'   block.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒdfilex)file-like object, string, or pathlib.PathÙ¹‚‡Ù§x5The file to read. File-like objects must support the Ù¡fseek()Ù§e and Ù¡fread()Ù§xF methods. Pickled files require that the file-like object support the Ù¡jreadline()Ù§p method as well.€Ù°ƒimmap_modex&{None, 'r+', 'r', 'w+', 'c'}, optionalÙ¹‚ƒÙ§xAIf not None, then memory-map the file, using the given mode (see Ù¢„lnumpy.memmapÙ „enumpyf1.22.3fmodulelnumpy.memmapfmoduleõÙ§y
 for a detailed description of the modes).  A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray.  Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.€Ù°ƒlallow_picklenbool, optional‚Ù¹‚Ù§xéAllow loading pickled object arrays stored in npy files. Reasons for disallowing pickles include security, as loading pickled data can execute arbitrary code. If pickles are disallowed, loading object arrays will fail. Default: False€ÙÆƒnversionchangedf1.16.3Ù¹‚Ù§x5Made default False in response to CVE - 2019 - 6446. €Ù°ƒkfix_importsnbool, optionalÙ¹‚ƒÙ§xOnly useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If Ù¢„kfix_importsÙ „ööelocalkfix_importselocalõÙ§xZ is True, pickle will try to map the old Python 2 names to the new names used in Python 3.€Ù°ƒhencodingmstr, optionalÙ¹‚Ù§y(What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than 'latin1', 'ASCII', and 'bytes' are not allowed, as they can corrupt numerical data. Default: 'ASCII'€öfRaisesÙ¯‚ƒÙ°ƒ`gOSErrorÙ¹‚Ù§x3If the input file does not exist or cannot be read.€Ù°ƒ`oUnpicklingErrorÙ¹‚ƒÙ§cIf Ù¡qallow_pickle=TrueÙ§x,, but the file cannot be loaded as a pickle.€Ù°ƒ`jValueErrorÙ¹‚ƒÙ§x'The file contains an object array, but Ù¡rallow_pickle=FalseÙ§g given.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfresultxarray, tuple, dict, etc.Ù¹‚ƒÙ§xData stored in the file. For Ù¡d.npzÙ§x` files, the returned instance of NpzFile class must be closed to avoid leaking file descriptors.€ögSummaryÙ¯‚Ù¹‚…Ù§x$Load arrays or pickled objects from Ù¡d.npyÙ§b, Ù¡d.npzÙ§r or pickled files.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExampless/numpy/lib/npyio.pyr<class 'function'>jnumpy.loadÙ¯‚ˆÙ¹‚Ù§x&Store data to disk, and load it again:€Ù´ƒ˜.Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsaveÙ „enumpyf1.22.3fmodulejnumpy.savefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1h/tmp/123Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dloadÙ „enumpyf1.22.3fmodulejnumpy.loadfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1l/tmp/123.npyÙ±‚bs1a'Ù±‚`a)x$array([[1, 2, 3],
       [4, 5, 6]])fexecedÙ¹‚Ù§x1Store compressed data to disk, and load it again:€Ù´ƒ˜RÙ±‚`aaÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`abÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„esavezÙ „enumpyf1.22.3fmoduleknumpy.savezfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1l/tmp/123.npzÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`aaÙ±‚aoa=Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚aoa=Ù±‚`abÙ±‚`a)Ù±‚`a
Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dloadÙ „enumpyf1.22.3fmodulejnumpy.loadfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1l/tmp/123.npzÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`ddataÙ±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a]x$array([[1, 2, 3],
       [4, 5, 6]])fexecedÙ´ƒ†Ù±‚`ddataÙ±‚`a[Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a]marray([1, 2])fexecedÙ´ƒ…Ù±‚`ddataÙ±‚aoa.Ù±‚`Ù¢„ecloseÙ „enumpyf1.22.3fmodulexnumpy.lib.npyio.NpzFile.closefmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¹‚Ù§xLMem-map the stored array, and then access the second row directly from disk:€Ù´ƒ˜Ù±‚`Ù¢„aXÙ „enumpyf1.22.3fmodulexnumpy.random._pcg64.PCG64DXSMfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dloadÙ „enumpyf1.22.3fmodulejnumpy.loadfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1l/tmp/123.npyÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`immap_modeÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1arÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„aXÙ „enumpyf1.22.3fmodulexnumpy.random._pcg64.PCG64DXSMfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`a:Ù±‚`a]qmemmap([4, 5, 6])fexecedö†Ù¼ƒÙ»ƒvlib.format.open_memmapxnumpy.lib.format.open_memmapõÙ¹‚ƒÙ§xCreate or load a memory-mapped Ù¡d.npyÙ§f file.€öÙ¼ƒÙ»ƒgloadtxtmnumpy.loadtxtõ€öÙ¼ƒÙ»ƒfmemmaplnumpy.memmapõÙ¹‚Ù§x9Create a memory-map to an array stored in a file on disk.€öÙ¼ƒÙ»ƒdsavejnumpy.saveõ€öÙ¼ƒÙ»ƒesavezknumpy.savezõ€öÙ¼ƒÙ»ƒpsavez_compressedvnumpy.savez_compressedõ€öf1.22.3Ù«xRload(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII')öjnumpy.load€
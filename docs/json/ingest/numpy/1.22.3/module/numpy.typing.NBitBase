Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚‡Ù§x7Used exclusively for the purpose static type checking, Ù¢„hNBitBaseÙ „enumpyf1.22.3fmoduleunumpy.typing.NBitBasefmoduleõÙ§x represents the base of a hierarchical set of subclasses. Each subsequent subclass is herein used for representing a lower level of precision, Ù¨Ù§de.g.Ù§a Ù¡u64Bit > 32Bit > 16BitÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§e1.20 €ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚ƒÙ§tA type representing Ù¢„lnumpy.numberÙ „enumpyf1.22.3fmodulelnumpy.numberfmoduleõÙ§x' precision during static type checking.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryhExamplesx/numpy/typing/__init__.py°n<class 'type'>unumpy.typing.NBitBaseÙ¯‚‡Ù¹‚‡Ù§x"Below is a typical usage example: Ù¢„hNBitBaseÙ „enumpyf1.22.3fmoduleunumpy.typing.NBitBasefmoduleõÙ§x¨ is herein used for annotating a function that takes a float and integer of arbitrary precision as arguments and returns a new float of whichever precision is largest (Ù¨Ù§de.g.Ù§a Ù¡x#np.float16 + np.int64 -> np.float64Ù§b).€Ù¿ƒjcode-block€Ù¹‚Ù§gpython €Ù·„x&>>> from __future__ import annotationsx->>> from typing import TypeVar, TYPE_CHECKINGv>>> import numpy as npx>>> import numpy.typing as nptÙ·‚x*>>> T1 = TypeVar("T1", bound=npt.NBitBase)x*>>> T2 = TypeVar("T2", bound=npt.NBitBase)Ù·‚xK>>> def add(a: np.floating[T1], b: np.integer[T2]) -> np.floating[T1 | T2]:t...     return a + bÙ·ƒt>>> a = np.float16()r>>> b = np.int64()s>>> out = add(a, b)Ù·†u>>> if TYPE_CHECKING:w...     reveal_locals()x)...     # note: Revealed local types are:x;...     # note:     a: numpy.floating[numpy.typing._16Bit*]x@...     # note:     b: numpy.signedinteger[numpy.typing._64Bit*]x=...     # note:     out: numpy.floating[numpy.typing._64Bit*]ö€f1.22.3Ù«ööunumpy.typing.NBitBase€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ÙÆƒgwarning`Ù¹‚Ù§x±This function can be exponentially slow for some inputs, unless `max_work` is set to a finite number or ``MAY_SHARE_BOUNDS``. If in doubt, use `numpy.may_share_memory` instead. €ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒda, bgndarrayÙ¹‚Ù§lInput arrays€Ù°ƒhmax_workmint, optional‚Ù¹‚Ù§xEffort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:€ÙÁ‚ÙÅ‚Ù¹‚Ù§x#max_work=MAY_SHARE_EXACT  (default)€Ù¹‚Ù§xÇThe problem is solved exactly. In this case, the function returns     True only if there is an element shared between the arrays. Finding     the exact solution may take extremely long in some cases.€ÙÅ‚Ù¹‚Ù§xmax_work=MAY_SHARE_BOUNDS€Ù¹‚Ù§x.Only the memory bounds of a and b are checked.€öfRaisesÙ¯‚Ù°ƒ`rnumpy.TooHardErrorÙ¹‚Ù§rExceeded max_work.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutdbool€ögSummaryÙ¯‚Ù¹‚Ù§x%Determine if two arrays share memory.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆiSignaturegSummarypExtended SummaryjParametersfRaisesgReturnshSee AlsohExamplesööx$<class 'builtin_function_or_method'>x*numpy.core._multiarray_umath.shares_memoryÙ¯‚†Ù´ƒ˜,Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mshares_memoryÙ „enumpyf1.22.3fmodulesnumpy.shares_memoryfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a]Ù±‚`a)Ù±‚`a)eFalsehcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mshares_memoryÙ „enumpyf1.22.3fmodulesnumpy.shares_memoryfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)dTruehcompiledÙ´ƒ”Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mshares_memoryÙ „enumpyf1.22.3fmodulesnumpy.shares_memoryfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a[Ù±‚bmia1Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a)eFalsehcompiledÙ¹‚ƒÙ§x„Checking whether two arrays share memory is NP-complete, and runtime may increase exponentially in the number of dimensions. Hence, Ù¢„hmax_workÙ „ööelocalhmax_workelocalõÙ§xu should generally be set to a finite number, as it is possible to construct examples that take extremely long to run:€Ù´ƒ˜xÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„clibÙ „enumpyf1.22.3fmoduleinumpy.libfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„mstride_tricksÙ „enumpyf1.22.3fmodulewnumpy.lib.stride_tricksfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„jas_stridedÙ „enumpyf1.22.3fmodulex"numpy.lib.stride_tricks.as_stridedfmoduleõÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmii192163377Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dint8Ù „enumpyf1.22.3fmodulejnumpy.int8fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„bx1Ù „enumpyf1.22.3fmodulepnumpy.complex128fmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jas_stridedÙ „enumpyf1.22.3fmodulex"numpy.lib.stride_tricks.as_stridedfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`gstridesÙ±‚aoa=Ù±‚`a(Ù±‚bmie36674Ù±‚`a,Ù±‚`a Ù±‚bmie61119Ù±‚`a,Ù±‚`a Ù±‚bmie85569Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmid1049Ù±‚`a,Ù±‚`a Ù±‚bmid1049Ù±‚`a,Ù±‚`a Ù±‚bmid1049Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bx2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„jas_stridedÙ „enumpyf1.22.3fmodulex"numpy.lib.stride_tricks.as_stridedfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a[Ù±‚bmih64023025Ù±‚`a:Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gstridesÙ±‚aoa=Ù±‚`a(Ù±‚bmie12223Ù±‚`a,Ù±‚`a Ù±‚bmie12224Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚aoa=Ù±‚`a(Ù±‚bmid1049Ù±‚`a,Ù±‚`a Ù±‚bmid1049Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„mshares_memoryÙ „enumpyf1.22.3fmodulesnumpy.shares_memoryfmoduleõÙ±‚`a(Ù±‚`Ù¢„bx1Ù „enumpyf1.22.3fmodulepnumpy.complex128fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bx2Ù±‚`a,Ù±‚`a Ù±‚`hmax_workÙ±‚aoa=Ù±‚bmid1000Ù±‚`a)xLTraceback (most recent call last):
...
numpy.TooHardError: Exceeded max_workhcompiledÙ¹‚…Ù§hRunning Ù¡xnp.shares_memory(x1, x2)Ù§i without Ù¢„hmax_workÙ „ööelocalhmax_workelocalõÙ§xo set takes around 1 minute for this case. It is possible to find problems that take still significantly longer.€öÙ¼ƒÙ»ƒpmay_share_memoryvnumpy.may_share_memoryõ€öf1.22.3Ù«x%shares_memory(a, b, /, max_work=None)öx*numpy.core._multiarray_umath.shares_memory€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§xMMasked values of True exclude the corresponding element from any computation.€Ù¹‚Ù§rConstruction::    €ÙÀx¹x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                shrink=True, order=None)ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒddatajarray_likeÙ¹‚Ù§kInput data.€Ù°ƒdmaskrsequence, optionalÙ¹‚ƒÙ§xIMask. Must be convertible to an array of booleans with the same shape as Ù¢„ddataÙ „ööelocalddataelocalõÙ§x.. True indicates a masked (i.e. invalid) data.€Ù°ƒedtypeodtype, optionalÙ¹‚‰Ù§xData type of the output. If Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ§x) is None, the type of the data argument (Ù¡jdata.dtypeÙ§n) is used. If Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ§x  is not None and different from Ù¡jdata.dtypeÙ§v, a copy is performed.€Ù°ƒdcopynbool, optionalÙ¹‚Ù§xWWhether to copy the input data (True), or to use a reference instead. Default is False.€Ù°ƒesuboknbool, optionalÙ¹‚…Ù§x Whether to return a subclass of Ù¢„kMaskedArrayÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArrayfmoduleõÙ§x if possible (True) or a plain Ù¢„kMaskedArrayÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArrayfmoduleõÙ§r. Default is True.€Ù°ƒendminmint, optionalÙ¹‚Ù§x+Minimum number of dimensions. Default is 0.€Ù°ƒjfill_valuepscalar, optionalÙ¹‚Ù§xjValue used to fill in the masked values when necessary. If None, a default based on the data-type is used.€Ù°ƒikeep_masknbool, optionalÙ¹‚…Ù§sWhether to combine Ù¢„dmaskÙ „ööelocaldmaskelocalõÙ§x@ with the mask of the input data, if any (True), or to use only Ù¢„dmaskÙ „ööelocaldmaskelocalõÙ§x) for the output (False). Default is True.€Ù°ƒihard_masknbool, optionalÙ¹‚Ù§xhWhether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.€Ù°ƒfshrinknbool, optionalÙ¹‚Ù§x?Whether to force compression of an empty mask. Default is True.€Ù°ƒeorderx{'C', 'F', 'A'}, optionalÙ¹‚Ù§y¯Specify the order of the array.  If order is 'C', then the array will be in C-contiguous order (last-index varies the fastest). If order is 'F', then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is 'A' (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x+An array class with possibly masked values.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametershExamplesq/numpy/ma/core.py˜r<class 'function'>nnumpy.ma.arrayÙ¯‚‡Ù¹‚…Ù§dThe Ù¡dmaskÙ§xK can be initialized with an array of boolean values with the same shape as Ù¡ddataÙ§a.€Ù´ƒ˜8Ù±‚`ddataÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia6Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„kMaskedArrayÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArrayfmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚`a[Ù±‚`a[Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`x                              Ù±‚`a[Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkcdTrueÙ±‚`a]Ù±‚`a]Ù±‚`a)xŠmasked_array(
  data=[[0, --, 2],
        [3, 4, --]],
  mask=[[False,  True, False],
        [False, False,  True]],
  fill_value=999999)hcompiledÙ¹‚…Ù§sAlternatively, the Ù¡dmaskÙ§xH can be initialized to homogeneous boolean array with the same shape as Ù¡ddataÙ§x& by passing in a scalar boolean value:€Ù´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„kMaskedArrayÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArrayfmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)xˆmasked_array(
  data=[[0, 1, 2],
        [3, 4, 5]],
  mask=[[False, False, False],
        [False, False, False]],
  fill_value=999999)hcompiledÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„kMaskedArrayÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArrayfmoduleõÙ±‚`a(Ù±‚`ddataÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)xmasked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=999999,
  dtype=int64)hcompiledÙÆƒdnote`Ù¹‚Ù§xäThe recommended practice for initializing ``mask`` with a scalar boolean value is to use ``True`` / ``False`` rather than ``np.True_`` / ``np.False_``. The reason is : attr : `nomask` is represented internally as ``np.False_``. €Ù·‚x>>> np.False_ is np.ma.nomaskdTrueö€f1.22.3Ù«xarray(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)ösnumpy.ma.core.array€
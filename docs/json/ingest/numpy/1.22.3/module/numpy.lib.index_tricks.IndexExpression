Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚ÙÆƒdnote`Ù¹‚Ù§xjUse one of the two predefined instances `index_exp` or `s_` rather than directly using `IndexExpression`. €Ù¹‚‰Ù§xAFor any index combination, including slicing and axis insertion, Ù¡ja[indices]Ù§p is the same as Ù¡xa[np.index_exp[indices]]Ù§o for any array Ù£ƒaaööÙ§k. However, Ù¡unp.index_exp[indices]Ù§xŒ can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚ƒÙ§xYou can do all this with Ù£ƒgslice()ööÙ§xŠ plus a few special objects, but there's a lot to remember and this version is simpler because it uses the standard array indexing syntax.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒimaketupledboolÙ¹‚Ù§x If True, always returns a tuple.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x0A nicer way to build up index tuples for arrays.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershSee AlsoeNoteshExamplesx/numpy/lib/index_tricks.pyÇn<class 'type'>x&numpy.lib.index_tricks.IndexExpressionÙ¯‚ƒÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`bs_Ù±‚`a[Ù±‚bmia2Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]qslice(2, None, 2)fexecedÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`iindex_expÙ±‚`a[Ù±‚bmia2Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]t(slice(2, None, 2),)fexecedÙ´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a[Ù±‚`bnpÙ±‚aoa.Ù±‚`bs_Ù±‚`a[Ù±‚bmia2Ù±‚`a:Ù±‚`a:Ù±‚bmia2Ù±‚`a]Ù±‚`a]marray([2, 4])fexecedö‚Ù¼ƒÙ»ƒiindex_expööÙ¹‚ƒÙ§x1Predefined instance that always returns a tuple: Ù£ƒx+index_exp = IndexExpression(maketuple=True)ööÙ§a.€öÙ¼ƒÙ»ƒbs_ööÙ¹‚ƒÙ§x.Predefined instance without tuple conversion: Ù£ƒx%s_ = IndexExpression(maketuple=False)ööÙ§a.€öf1.22.3Ù«ööx&numpy.lib.index_tricks.IndexExpression€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§xHThe result is built by combining the results of 1d Vandermonde matrices,€Ù¤xaW [ i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_ { k=0}^N { V_k ( x_k) [ i_0, \ldots, i_M, j_k]} Ù¹‚Ù§ewhere€Ù¤xíN &= \texttt { len ( points)} = \texttt { len ( degrees)} = \texttt { len ( vander\_fs)} \\ M &= \texttt { points [ k].ndim} \\ V_k &= \texttt { vander\_fs [ k]} \\ x_k &= \texttt { points [ k]} \\ 0 \le j_k &\le \texttt { degrees [ k]} Ù¹‚ƒÙ§xExpanding the one-dimensional Ù¥cV_kÙ§q functions gives:€Ù¤xeW [ i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_ { k=0}^N { B_ { k, j_k} ( x_k [ i_0, \ldots, i_M])} Ù¹‚‡Ù§fwhere Ù¥gB_{k,m}Ù§xG is the m'th basis of the polynomial construction used along dimension Ù¥akÙ§x. For a regular polynomial, Ù¥xB_{k, m}(x) = P_m(x) = x^mÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒivander_fsx.Sequence[function(array_like, int) -> ndarray]Ù¹‚‚Ù§x5The 1d vander function to use for each axis, such as Ù¡jpolyvander€Ù°ƒfpointstSequence[array_like]Ù¹‚ƒÙ§xìArrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. This must be the same length as Ù¢„ivander_fsÙ „ööelocalivander_fselocalõÙ§a.€Ù°ƒgdegreesmSequence[int]Ù¹‚ƒÙ§xUThe maximum degree (inclusive) to use for each axis. This must be the same length as Ù¢„ivander_fsÙ „ööelocalivander_fselocalõÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒivander_ndgndarrayÙ¹‚ƒÙ§rAn array of shape Ù¡x/points[0].shape + tuple(d + 1 for d in degrees)Ù§a.€ögSummaryÙ¯‚Ù¹‚Ù§x;A generalization of the Vandermonde matrix for N dimensions€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersgReturnsx/numpy/polynomial/polyutils.pyyr<class 'function'>x%numpy.polynomial.polyutils._vander_ndÙ¯‚€ö€f1.22.3Ù«x&_vander_nd(vander_fs, points, degrees)öx%numpy.polynomial.polyutils._vander_nd€
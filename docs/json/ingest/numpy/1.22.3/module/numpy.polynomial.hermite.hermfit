Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚Ù§x6Return the coefficients of a Hermite series of degree Ù¢„cdegÙ „ööelocalcdegelocalõÙ§x2 that is the least squares fit to the data values Ù¢„ayÙ „ööelocalayelocalõÙ§q given at points Ù¢„axÙ „ööelocalaxelocalõÙ§e. If Ù¢„ayÙ „ööelocalayelocalõÙ§x7 is 1-D the returned coefficients will also be 1-D. If Ù¢„ayÙ „ööelocalayelocalõÙ§x7 is 2-D multiple fits are done, one for each column of Ù¢„ayÙ „ööelocalayelocalõÙ§x‚, and the resulting coefficients are stored in the corresponding columns of a 2-D return. The fitted polynomial(s) are in the form€Ù¤x6p ( x) = c_0 + c_1 * H_1 ( x) + ... + c_n * H_n ( x), Ù¹‚…Ù§fwhere Ù£ƒanööÙ§d is Ù¢„cdegÙ „ööelocalcdegelocalõÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‡Ù¹‚ƒÙ§x7The solution is the coefficients of the Hermite series Ù£ƒapööÙ§x6 that minimizes the sum of the weighted squared errors€Ù¤x'E = \sum_j w_j^2 * |y_j - p ( x_j)|^2, Ù¹‚ƒÙ§jwhere the Ù¥cw_jÙ§xe are the weights. This problem is solved by setting up the (typically) overdetermined matrix equation€Ù¤tV ( x) * c = w * y, Ù¹‚Ù§fwhere Ù£ƒaVööÙ§x. is the weighted pseudo Vandermonde matrix of Ù¢„axÙ „ööelocalaxelocalõÙ§b, Ù£ƒacööÙ§x( are the coefficients to be solved for, Ù¢„awÙ „ööelocalawelocalõÙ§r are the weights, Ù¢„ayÙ „ööelocalayelocalõÙ§xb are the observed values.  This equation is then solved using the singular value decomposition of Ù£ƒaVööÙ§a.€Ù¹‚‡Ù§x"If some of the singular values of Ù£ƒaVööÙ§x. are so small that they are neglected, then a Ù¢„kRankWarningÙ „enumpyf1.22.3fmoduleqnumpy.RankWarningfmoduleõÙ§x” will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning.  The Ù¢„ercondÙ „ööelocalercondelocalõÙ§x— parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.€Ù¹‚‹Ù§xXFits using Hermite series are probably most useful when the data can be approximated by Ù¡qsqrt(w(x)) * p(x)Ù§h, where Ù£ƒdw(x)ööÙ§x0 is the Hermite weight. In that case the weight Ù¡msqrt(w(x[i]))Ù§x* should be used together with data values Ù¡ry[i]/sqrt(w(x[i]))Ù§x&. The weight function is available as Ù¢„jhermweightÙ „enumpyf1.22.3fmodulex#numpy.polynomial.hermite.hermweightfmoduleõÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒaxvarray_like, shape (M,)Ù¹‚ƒÙ§x%x-coordinates of the M sample points Ù¡l(x[i], y[i])Ù§a.€Ù°ƒayx array_like, shape (M,) or (M, K)Ù¹‚Ù§xºy-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column.€Ù°ƒcdeguint or 1-D array_likeÙ¹‚…Ù§x)Degree(s) of the fitting polynomials. If Ù¢„cdegÙ „ööelocalcdegelocalõÙ§x7 is a single integer all terms up to and including the Ù¢„cdegÙ „ööelocalcdegelocalõÙ§x•'th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead.€Ù°ƒercondofloat, optionalÙ¹‚Ù§xòRelative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases.€Ù°ƒdfullnbool, optionalÙ¹‚Ù§xÆSwitch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.€Ù°ƒawx"array_like, shape (`M`,), optionalÙ¹‚‹Ù§x!Weights. If not None, the weight Ù¡dw[i]Ù§x# applies to the unsquared residual Ù¡oy[i] - y_hat[i]Ù§d at Ù¡dx[i]Ù§xD. Ideally the weights are chosen so that the errors of the products Ù¡iw[i]*y[i]Ù§xI all have the same variance.  When using inverse-variance weighting, use Ù¡tw[i] = 1/sigma(y[i])Ù§x.  The default value is None.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒdcoefxndarray, shape (M,) or (M, K)Ù¹‚‡Ù§x2Hermite coefficients ordered from low to high. If Ù¢„ayÙ „ööelocalayelocalõÙ§x8 was 2-D, the coefficients for the data in column k  of Ù¢„ayÙ „ööelocalayelocalõÙ§o are in column Ù£ƒakööÙ§a.€Ù°ƒx)[residuals, rank, singular_values, rcond]dlistƒÙ¹‚‚Ù§x"These values are only returned if Ù¡lfull == True€ÙÈ„Ù¹‚Ù§x>residuals -- sum of squared residuals of the least squares fit€Ù¹‚Ù§x;rank -- the numerical rank of the scaled Vandermonde matrix€Ù¹‚Ù§xCsingular_values -- singular values of the scaled Vandermonde matrix€Ù¹‚ƒÙ§rrcond -- value of Ù£ƒercondööÙ§a.€Ù¹‚ƒÙ§vFor more details, see Ù¢„rnumpy.linalg.lstsqÙ „enumpyf1.22.3fmodulernumpy.linalg.lstsqfmoduleõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x,Least squares fit of Hermite series to data.€öhWarningsÙ¯‚€öeWarnsÙ¯‚Ù°ƒ`kRankWarning‚Ù¹‚ƒÙ§xhThe rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if Ù¡mfull == FalseÙ§x$.  The warnings can be turned off by€ÙÀxG>>> import warnings
>>> warnings.simplefilter('ignore', np.RankWarning)öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnseWarnshSee AlsoeNotesjReferenceshExamplesx/numpy/polynomial/hermite.pyûr<class 'function'>x numpy.polynomial.hermite.hermfitÙ¯‚Ù´ƒ˜RÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„ghermiteÙ „enumpyf1.22.3fmodulexnumpy.polynomial.hermitefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ghermfitÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermfitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„ghermvalÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermvalfmoduleõÙ±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a)Ù±‚`a
Ù±‚`cerrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`erandnÙ±‚`a(Ù±‚bnbclenÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a)Ù±‚aoa/Ù±‚bmib10Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„ghermvalÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermvalfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`cerrÙ±‚`a
Ù±‚`Ù¢„ghermfitÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermfitfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)x*array([1.0218, 1.9986, 2.9999]) # may varyfexecedöŠÙ¼ƒÙ»ƒghermvalx numpy.polynomial.hermite.hermvalõÙ¹‚Ù§xEvaluates a Hermite series.€öÙ¼ƒÙ»ƒjhermvanderx#numpy.polynomial.hermite.hermvanderõÙ¹‚Ù§x%Vandermonde matrix of Hermite series.€öÙ¼ƒÙ»ƒjhermweightx#numpy.polynomial.hermite.hermweightõÙ¹‚Ù§wHermite weight function€öÙ¼ƒÙ»ƒrnumpy.linalg.lstsqrnumpy.linalg.lstsqõÙ¹‚Ù§x-Computes a least-squares fit from the matrix.€öÙ¼ƒÙ»ƒx"numpy.polynomial.chebyshev.chebfitx"numpy.polynomial.chebyshev.chebfitõ€öÙ¼ƒÙ»ƒx#numpy.polynomial.hermite_e.hermefitx#numpy.polynomial.hermite_e.hermefitõ€öÙ¼ƒÙ»ƒx numpy.polynomial.laguerre.lagfitx numpy.polynomial.laguerre.lagfitõ€öÙ¼ƒÙ»ƒx numpy.polynomial.legendre.legfitx numpy.polynomial.legendre.legfitõ€öÙ¼ƒÙ»ƒx#numpy.polynomial.polynomial.polyfitx#numpy.polynomial.polynomial.polyfitõ€öÙ¼ƒÙ»ƒx"scipy.interpolate.UnivariateSplineööÙ¹‚Ù§uComputes spline fits.€öf1.22.3Ù«x2hermfit(x, y, deg, rcond=None, full=False, w=None)öx numpy.polynomial.hermite.hermfit€
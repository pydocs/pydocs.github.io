Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚‰Ù§oThe linear map Ù¡poffset + scale*xÙ§v that maps the domain Ù¢„coldÙ „ööelocalcoldelocalõÙ§o to the domain Ù¢„cnewÙ „ööelocalcnewelocalõÙ§x is applied to the points Ù¢„axÙ „ööelocalaxelocalõÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§xEffectively, this implements:€Ù¤x&x\_out = new [ 0] + m ( x - old [ 0]) Ù¹‚Ù§ewhere€Ù¤x8m = \frac { new [ 1] - new [ 0]} { old [ 1] - old [ 0]} öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒaxjarray_likeÙ¹‚ƒÙ§xPoints to be mapped. If Ù¢„axÙ „ööelocalaxelocalõÙ§x7 is a subtype of ndarray the subtype will be preserved.€Ù°ƒhold, newjarray_likeÙ¹‚Ù§xxThe two domains that determine the map.  Each must (successfully) convert to 1-d arrays containing precisely two values.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒex_outgndarrayÙ¹‚ƒÙ§x%Array of points of the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§x>, after application of the linear map between the two domains.€ögSummaryÙ¯‚Ù¹‚Ù§x!Apply linear map to input points.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/polynomial/polyutils.py/r<class 'function'>x$numpy.polynomial.polyutils.mapdomainÙ¯‚†Ù´ƒ˜9Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ipolyutilsÙ „enumpyf1.22.3fmodulexnumpy.polynomial.polyutilsfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚`bpuÙ±‚`a
Ù±‚`jold_domainÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`jnew_domainÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚bmia2Ù±‚aoa*Ù±‚`bnpÙ±‚aoa.Ù±‚`bpiÙ±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmia6Ù±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`axx+array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])fexecedÙ´ƒ“Ù±‚`ex_outÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpuÙ±‚aoa.Ù±‚`Ù¢„imapdomainÙ „enumpyf1.22.3fmodulex$numpy.polynomial.polyutils.mapdomainfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`jold_domainÙ±‚`a,Ù±‚`a Ù±‚`jnew_domainÙ±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`ex_outxgarray([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary
        6.28318531])fexecedÙ´ƒÙ±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`bpuÙ±‚aoa.Ù±‚`Ù¢„imapdomainÙ „enumpyf1.22.3fmodulex$numpy.polynomial.polyutils.mapdomainfmoduleõÙ±‚`a(Ù±‚`ex_outÙ±‚`a,Ù±‚`a Ù±‚`jnew_domainÙ±‚`a,Ù±‚`a Ù±‚`jold_domainÙ±‚`a)xarray([0., 0., 0., 0., 0., 0.])fexecedÙ¹‚Ù§xuAlso works for complex numbers (and thus can be used to map any line in the complex plane to any other line therein).€Ù´ƒ˜LÙ±‚`aiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbgcomplexÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚`coldÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`aiÙ±‚`a)Ù±‚`a
Ù±‚`cnewÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`aiÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`aiÙ±‚`a)Ù±‚`a
Ù±‚`azÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚`coldÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`coldÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`azxIarray([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])fexecedÙ´ƒ“Ù±‚`enew_zÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpuÙ±‚aoa.Ù±‚`Ù¢„imapdomainÙ „enumpyf1.22.3fmodulex$numpy.polynomial.polyutils.mapdomainfmoduleõÙ±‚`a(Ù±‚`azÙ±‚`a,Ù±‚`a Ù±‚`coldÙ±‚`a,Ù±‚`a Ù±‚`cnewÙ±‚`a)Ù±‚`a;Ù±‚`a Ù±‚`enew_zxTarray([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may varyfexecedö‚Ù¼ƒÙ»ƒigetdomainx$numpy.polynomial.polyutils.getdomainõ€öÙ¼ƒÙ»ƒhmapparmsx#numpy.polynomial.polyutils.mapparmsõ€öf1.22.3Ù«vmapdomain(x, old, new)öx$numpy.polynomial.polyutils.mapdomain€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚˜Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§n is called as Ù£ƒsres = func(a, axis)ööÙ§h, where Ù£ƒdaxisööÙ§x is the first element of Ù¢„daxesÙ „ööelocaldaxeselocalõÙ§n.  The result Ù£ƒcresööÙ§x> of the function call must have either the same dimensions as Ù¢„aaÙ „ööelocalaaelocalõÙ§x or one less dimension.  If Ù£ƒcresööÙ§x has one less dimension than Ù¢„aaÙ „ööelocalaaelocalõÙ§x!, a dimension is inserted before Ù£ƒdaxisööÙ§o.  The call to Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x# is then repeated for each axis in Ù¢„daxesÙ „ööelocaldaxeselocalõÙ§g, with Ù£ƒcresööÙ§w as the first argument.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒdfunchfunctionÙ¹‚ƒÙ§x'This function must take two arguments, Ù£ƒmfunc(a, axis)ööÙ§a.€Ù°ƒaajarray_likeÙ¹‚Ù§lInput array.€Ù°ƒdaxesjarray_likeÙ¹‚ƒÙ§pAxes over which Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x+ is applied; the elements must be integers.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒoapply_over_axisgndarrayÙ¹‚…Ù§x;The output array.  The number of dimensions is the same as Ù¢„aaÙ „ööelocalaaelocalõÙ§x;, but the shape can be different.  This depends on whether Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§x; changes the shape of its output with respect to its input.€ögSummaryÙ¯‚Ù¹‚Ù§x/Apply a function repeatedly over multiple axes.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshSee AlsohExampless/numpy/ma/extras.pyÆr<class 'function'>xnumpy.ma.apply_over_axesÙ¯‚„Ù´ƒ˜9Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmib24Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a,Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚bmia0Ù±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`fmaskedÙ±‚`a
Ù±‚`aaÙ±‚`a[Ù±‚`a:Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚`a:Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`fmaskedÙ±‚`a
Ù±‚`aay¯masked_array(
  data=[[[0, --, 2, 3],
         [--, --, --, --],
         [8, 9, 10, 11]],
        [[12, --, 14, 15],
         [--, --, --, --],
         [20, 21, 22, 23]]],
  mask=[[[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]],
        [[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]]],
  fill_value=999999)fexecedÙ´ƒ–Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„oapply_over_axesÙ „enumpyf1.22.3fmoduleunumpy.apply_over_axesfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„csumÙ „enumpyf1.22.3fmoduleinumpy.sumfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a)xŠmasked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)fexecedÙ¹‚Ù§x.Tuple axis arguments to ufuncs are equivalent:€Ù´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„csumÙ „enumpyf1.22.3fmoduleinumpy.sumfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚bmia1Ù±‚`a)Ù±‚`a)xŠmasked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)fexecedöÙ¼ƒÙ»ƒpapply_along_axisvnumpy.apply_along_axisõÙ¹‚Ù§x@Apply a function to 1-D slices of an array along the given axis.€öf1.22.3Ù«xapply_over_axes(func, a, axes)öxnumpy.ma.extras.apply_over_axes€
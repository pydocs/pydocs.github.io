Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§yThe various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:€ÙÁ‚ÙÅ‚Ù¹‚Ù§x7=========== ======= ============= ============ ========€Ù¹‚Ù§x3kind      speed   worst case    work space   stable€ÙÅ‚Ù¹‚Ù§yŠ=========== ======= ============= ============ ======== 'quicksort'    1     O(n^2)            0          no 'heapsort'     3     O(n*log(n))       0          no 'mergesort'    2     O(n*log(n))      ~n/2        yes 'timsort'      2     O(n*log(n))      ~n/2        yes =========== ======= ============= ============ ========  .. note:: The datatype determines which of 'mergesort' or 'timsort'€Ù¹‚Ù§xris actually used, even if 'mergesort' is specified. User selection    at a finer scale is not currently available.€Ù¹‚Ù§xÏAll the sort algorithms make temporary copies of the data when sorting along any but the last axis.  Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis.€Ù¹‚Ù§xîThe sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.€Ù¹‚Ù§xÂPrevious to numpy 1.4.0 sorting real and complex arrays containing nan values led to undefined behaviour. In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is:€Ù·‚p* Real: [R, nan]x3* Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]Ù¹‚Ù§x¨where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.12.0 €Ù¹‚…Ù§xquicksort has been changed to ÙË‚iintrosortx'https://en.wikipedia.org/wiki/IntrosortÙ§x<. When sorting does not make enough progress it switches to ÙË‚hheapsortx&https://en.wikipedia.org/wiki/HeapsortÙ§xD. This implementation makes quicksort O(n*log(n)) in the worst case.€Ù¹‚…Ù§x“'stable' automatically chooses the best stable sorting algorithm for the data type being sorted. It, along with 'mergesort' is currently mapped to ÙË‚gtimsortx%https://en.wikipedia.org/wiki/TimsortÙ§d or ÙË‚jradix sortx(https://en.wikipedia.org/wiki/Radix_sortÙ§x¢ depending on the data type. API forward compatibility currently limits the ability to select the implementation and it is hardwired for the different data types.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.17.0 €Ù¹‚ƒÙ§xıTimsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to ÙË‚tCPython listsort.txtx?https://github.com/python/cpython/blob/3.7/Objects/listsort.txtÙ§x}. 'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).€ÙÆƒnversionchangeddTODOÙ¹‚Ù§g1.18.0 €Ù¹‚Ù§x<NaT now sorts to the end of arrays for consistency with NaN.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaajarray_likeÙ¹‚Ù§sArray to be sorted.€Ù°ƒdaxisuint or None, optionalÙ¹‚Ù§x}Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.€Ù°ƒdkindx:{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional‚Ù¹‚Ù§ySorting algorithm. The default is 'quicksort'. Note that both 'stable' and 'mergesort' use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The 'mergesort' option is retained for backwards compatibility.€ÙÆƒnversionchangedg1.15.0.Ù¹‚Ù§x!The ' stable ' option was added. €Ù°ƒeorderxstr or list of str, optionalÙ¹‚ƒÙ§eWhen Ù¢„aaÙ „ööelocalaaelocalõÙ§y$ is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒlsorted_arraygndarrayÙ¹‚ƒÙ§x$Array of the same type and shape as Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x!Return a sorted copy of an array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/core/fromnumeric.pyTr<class 'function'>jnumpy.sortÙ¯‚‡Ù´ƒ˜Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia4Ù±‚`a]Ù±‚`a,Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`p                Ù±‚bc1x# sort along the last axisxarray([[1, 4],
       [1, 3]])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`e     Ù±‚bc1x# sort the flattened arraysarray([1, 1, 3, 4])fexecedÙ´ƒÙ±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`h        Ù±‚bc1x# sort along the first axisxarray([[1, 1],
       [3, 4]])fexecedÙ¹‚ƒÙ§hUse the Ù¢„eorderÙ „ööelocaleorderelocalõÙ§xC keyword to specify a field to use when sorting a structured array:€Ù´ƒ˜sÙ±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚bs1a'Ù±‚bs1dnameÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1cS10Ù±‚bs1a'Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1fheightÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1cageÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`fvaluesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚`a(Ù±‚bs1a'Ù±‚bs1fArthurÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmfc1.8Ù±‚`a,Ù±‚`a Ù±‚bmib41Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1hLancelotÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmfc1.9Ù±‚`a,Ù±‚`a Ù±‚bmib38Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`j          Ù±‚`a(Ù±‚bs1a'Ù±‚bs1gGalahadÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bmfc1.7Ù±‚`a,Ù±‚`a Ù±‚bmib38Ù±‚`a)Ù±‚`a]Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`fvaluesÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚`a)Ù±‚`g       Ù±‚bc1x# create a structured arrayÙ±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`eorderÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fheightÙ±‚bs1a'Ù±‚`a)Ù±‚`x                        Ù±‚bc1p# doctest: +SKIPx¢array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
       ('Lancelot', 1.8999999999999999, 38)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])fexecedÙ¹‚Ù§x+Sort by age, then height if ages are equal:€Ù´ƒ–Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dsortÙ „enumpyf1.22.3fmodulejnumpy.sortfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`eorderÙ±‚aoa=Ù±‚`a[Ù±‚bs1a'Ù±‚bs1cageÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1fheightÙ±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`o               Ù±‚bc1p# doctest: +SKIPx¢array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
       ('Arthur', 1.8, 41)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])fexecedö…Ù¼ƒÙ»ƒgargsortmnumpy.argsortõÙ¹‚Ù§nIndirect sort.€öÙ¼ƒÙ»ƒglexsortmnumpy.lexsortõÙ¹‚Ù§x&Indirect stable sort on multiple keys.€öÙ¼ƒÙ»ƒlndarray.sortööÙ¹‚Ù§x!Method to sort an array in-place.€öÙ¼ƒÙ»ƒipartitiononumpy.partitionõÙ¹‚Ù§mPartial sort.€öÙ¼ƒÙ»ƒlsearchsortedrnumpy.searchsortedõÙ¹‚Ù§x Find elements in a sorted array.€öf1.22.3Ù«x'sort(a, axis=-1, kind=None, order=None)öjnumpy.sort€
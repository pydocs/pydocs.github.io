Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚…Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§n is of length Ù£ƒen + 1ööÙ§x!, this function returns the value€Ù¤x)p ( x) = c_0 + c_1 * x + ... + c_n * x^n Ù¹‚‡Ù§nThe parameter Ù¢„axÙ „ööelocalaxelocalõÙ§xw is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support multiplication and addition both with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù¹‚Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§v is a 1-D array, then Ù£ƒdp(x)ööÙ§x will have the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§f.  If Ù¢„acÙ „ööelocalacelocalõÙ§xK is multidimensional, then the shape of the result depends on the value of Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§e. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§x5 is true the shape will be c.shape[1:] + x.shape. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§xJ is false the shape will be c.shape[1:]. Note that scalars have shape (,).€Ù¹‚Ù§xxTrailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x$The evaluation uses Horner's method.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaxxarray_like, compatible objectÙ¹‚‡Ù§cIf Ù¢„axÙ „ööelocalaxelocalõÙ§x| is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support addition and multiplication with with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒacjarray_likeÙ¹‚…Ù§xgArray of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If Ù¢„acÙ „ööelocalacelocalõÙ§x¦ is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒftensorqboolean, optional‚Ù¹‚Ù§xjIf True, the shape of the coefficient array is extended with ones on the right, one for each dimension of Ù¢„axÙ „ööelocalaxelocalõÙ§x_. Scalars have dimension 0 for this action. The result is that every column of coefficients in Ù¢„acÙ „ööelocalacelocalõÙ§x# is evaluated for every element of Ù¢„axÙ „ööelocalaxelocalõÙ§l. If False, Ù¢„axÙ „ööelocalaxelocalõÙ§x" is broadcast over the columns of Ù¢„acÙ „ööelocalacelocalõÙ§x2 for the evaluation.  This keyword is useful when Ù¢„acÙ „ööelocalacelocalõÙ§x0 is multidimensional. The default value is True.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfvaluesxndarray, compatible objectÙ¹‚Ù§x3The shape of the returned array is described above.€ögSummaryÙ¯‚Ù¹‚Ù§x"Evaluate a polynomial at points x.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/polynomial/polynomial.py˜r<class 'function'>x#numpy.polynomial.polynomial.polyvalÙ¯‚†Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ±‚`a
Ù±‚`Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)c6.0fexecedÙ´ƒ“Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`aaxarray([[0, 1],
       [2, 3]])fexecedÙ´ƒÙ±‚`Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)x(array([[ 1.,   6.],
       [17.,  34.]])fexecedÙ´ƒ•Ù±‚`dcoefÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„greshapeÙ „enumpyf1.22.3fmodulemnumpy.reshapefmoduleõÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚bc1x# multidimensional coefficientsÙ±‚`a
Ù±‚`dcoefxarray([[0, 1],
       [2, 3]])fexecedÙ´ƒÙ±‚`Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dcoefÙ±‚`a,Ù±‚`a Ù±‚`ftensorÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)x$array([[2.,  4.],
       [4.,  7.]])fexecedÙ´ƒÙ±‚`Ù¢„gpolyvalÙ „enumpyf1.22.3fmodulemnumpy.polyvalfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dcoefÙ±‚`a,Ù±‚`a Ù±‚`ftensorÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)parray([2.,  7.])fexecedö„Ù¼ƒÙ»ƒjpolygrid2dx&numpy.polynomial.polynomial.polygrid2dõ€öÙ¼ƒÙ»ƒjpolygrid3dx&numpy.polynomial.polynomial.polygrid3dõ€öÙ¼ƒÙ»ƒipolyval2dx%numpy.polynomial.polynomial.polyval2dõ€öÙ¼ƒÙ»ƒipolyval3dx%numpy.polynomial.polynomial.polyval3dõ€öf1.22.3Ù«xpolyval(x, c, tensor=True)öx#numpy.polynomial.polynomial.polyval€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x™Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,..., xn.€ÙÆƒnversionchangedc1.9Ù¹‚Ù§x#1 - D and 0 - D cases are allowed. €ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§yThis function supports both indexing conventions through the indexing keyword argument.  Giving the string 'ij' returns a meshgrid with matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for 'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is illustrated by the following code snippet::      €ÙÀxîxv, yv = np.meshgrid(x, y, indexing='ij')
for i in range(nx):
    for j in range(ny):
        # treat xv[i,j], yv[i,j]

xv, yv = np.meshgrid(x, y, indexing='xy')
for i in range(nx):
    for j in range(ny):
        # treat xv[j,i], yv[j,i]Ù¹‚Ù§xIIn the 1-D and 0-D case, the indexing and sparse keywords have no effect.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒnx1, x2,..., xnjarray_likeÙ¹‚Ù§x21-D arrays representing the coordinates of a grid.€Ù°ƒhindexingv{'xy', 'ij'}, optional‚Ù¹‚Ù§xZCartesian ('xy', default) or matrix ('ij') indexing of output. See Notes for more details.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒfsparsenbool, optionalƒÙ¹‚‰Ù§xAIf True the shape of the returned coordinate array for dimension Ù¨Ù§aiÙ§q is reduced from Ù¡u(N1, ..., Ni, ... Nn)Ù§d to Ù¡x(1, ..., 1, Ni, 1, ..., 1)Ù§x=.  These sparse coordinate grids are intended to be use with Ù£ƒsbasics.broadcastingöcrefÙ§xo.  When all coordinates are used in an expression, broadcasting still leads to a fully-dimensonal result array.€Ù¹‚Ù§qDefault is False.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €Ù°ƒdcopynbool, optional‚Ù¹‚ƒÙ§xxIf False, a view into the original arrays are returned in order to conserve memory.  Default is True.  Please note that Ù¡xsparse=False, copy=FalseÙ§xÂ will likely return non-contiguous arrays.  Furthermore, more than one element of a broadcast array may refer to a single memory location.  If you need to write to the arrays, make copies first.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒnX1, X2,..., XNgndarrayÙ¹‚‘Ù§lFor vectors Ù¢„bx1Ù „enumpyf1.22.3fmodulepnumpy.complex128fmoduleõÙ§b, Ù¢„bx2Ù „ööelocalbx2elocalõÙ§x,..., 'xn' with lengths Ù¡jNi=len(xi)Ù§j , return Ù¡r(N1, N2, N3,...Nn)Ù§x# shaped arrays if indexing='ij' or Ù¡r(N2, N1, N3,...Nn)Ù§x5 shaped arrays if indexing='xy' with the elements of Ù£ƒbxiööÙ§x; repeated to fill the matrix along the first dimension for Ù¢„bx1Ù „enumpyf1.22.3fmodulepnumpy.complex128fmoduleõÙ§q, the second for Ù¢„bx2Ù „ööelocalbx2elocalõÙ§k and so on.€ögSummaryÙ¯‚Ù¹‚Ù§x3Return coordinate matrices from coordinate vectors.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshSee AlsohExamplesx/numpy/lib/function_base.pyÅr<class 'function'>nnumpy.meshgridÙ¯‚ŠÙ´ƒ˜BÙ±‚`bnxÙ±‚`a,Ù±‚`a Ù±‚`bnyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`bnxÙ±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`bnyÙ±‚`a)Ù±‚`a
Ù±‚`bxvÙ±‚`a,Ù±‚`a Ù±‚`byvÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a
Ù±‚`bxvx0array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])fexecedÙ´ƒÙ±‚`byvx.array([[0.,  0.,  0.],
       [1.,  1.,  1.]])fexecedÙ´ƒ˜Ù±‚`bxvÙ±‚`a,Ù±‚`a Ù±‚`byvÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`fsparseÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1x# make sparse output arraysÙ±‚`a
Ù±‚`bxvxarray([[0. ,  0.5,  1. ]])fexecedÙ´ƒÙ±‚`byvxarray([[0.],
       [1.]])fexecedÙ¹‚„Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ§xx is very useful to evaluate functions on a grid.  If the function depends on all coordinates, you can use the parameter Ù¡ksparse=TrueÙ§x% to save memory and computation time.€Ù´ƒ˜YÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmic101Ù±‚`a)Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hlinspaceÙ „enumpyf1.22.3fmodulennumpy.linspacefmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmic101Ù±‚`a)Ù±‚`a
Ù±‚bc1x# full coorindate arraysÙ±‚`a
Ù±‚`bxxÙ±‚`a,Ù±‚`a Ù±‚`byyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a
Ù±‚`bzzÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`dsqrtÙ±‚`a(Ù±‚`bxxÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`byyÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`bxxÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`byyÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bzzÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõx$((101, 101), (101, 101), (101, 101))fexecedÙ´ƒ˜:Ù±‚bc1x# sparse coordinate arraysÙ±‚`a
Ù±‚`bxsÙ±‚`a,Ù±‚`a Ù±‚`bysÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hmeshgridÙ „enumpyf1.22.3fmodulennumpy.meshgridfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`fsparseÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`bzsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`dsqrtÙ±‚`a(Ù±‚`bxsÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`bysÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`bxsÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bysÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚aoa.Ù±‚`Ù¢„eshapeÙ „enumpyf1.22.3fmoduleknumpy.shapefmoduleõx ((1, 101), (101, 1), (101, 101))fexecedÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„karray_equalÙ „enumpyf1.22.3fmoduleqnumpy.array_equalfmoduleõÙ±‚`a(Ù±‚`bzzÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚`a)dTruefexecedÙ´ƒ˜/Ù±‚bknfimportÙ±‚`a Ù±‚bnnÙ¢„jmatplotlibÙ „jmatplotlibe3.5.1fmodulejmatplotlibfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fpyplotÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚bnnÙ¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚`a
Ù±‚`ahÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hcontourfÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.contourffmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a,Ù±‚`a Ù±‚`bzsÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„daxisÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.axisfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1fscaledÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„hcolorbarÙ „jmatplotlibe3.5.1fmodulexmatplotlib.pyplot.colorbarfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cpltÙ „jmatplotlibe3.5.1fmoduleqmatplotlib.pyplotfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dshowÙ „jmatplotlibe3.5.1fmodulevmatplotlib.pyplot.showfmoduleõÙ±‚`a(Ù±‚`a)`fexecedÙ¸xfig-numpy.meshgrid-0.pngö‚Ù¼ƒÙ»ƒemgridööÙ¹‚Ù§xAConstruct a multi-dimensional "meshgrid" using indexing notation.€öÙ¼ƒÙ»ƒeogridööÙ¹‚Ù§xGConstruct an open multi-dimensional "meshgrid" using indexing notation.€öf1.22.3Ù«x5meshgrid(*xi, copy=True, sparse=False, indexing='xy')önnumpy.meshgrid€
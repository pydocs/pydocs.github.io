Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚“Ù§x)Returns the Legendre series coefficients Ù¢„acÙ „ööelocalacelocalõÙ§p differentiated Ù¢„amÙ „ööelocalamelocalõÙ§m times along Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x1.  At each iteration the result is multiplied by Ù¢„csclÙ „ööelocalcsclelocalõÙ§xN (the scaling factor is for use in a linear change of variable). The argument Ù¢„acÙ „ööelocalacelocalõÙ§xj is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the series Ù¡u1*L_0 + 2*L_1 + 3*L_2Ù§x  while [[1,2],[1,2]] represents Ù¡xE1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)Ù§n if axis=0 is Ù¡axÙ§o and axis=1 is Ù¡ayÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§xÖIn general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be "unintuitive," albeit correct; see Examples section below.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒacjarray_likeÙ¹‚Ù§x³Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.€Ù°ƒammint, optionalÙ¹‚Ù§x?Number of derivatives taken, must be non-negative. (Default: 1)€Ù°ƒcsclpscalar, optionalÙ¹‚…Ù§x&Each differentiation is multiplied by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x'.  The end result is multiplication by Ù¡fscl**mÙ§x?.  This is for use in a linear change of variable. (Default: 1)€Ù°ƒdaxismint, optional‚Ù¹‚Ù§x6Axis over which the derivative is taken. (Default: 0).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcdergndarrayÙ¹‚Ù§x"Legendre series of the derivative.€ögSummaryÙ¯‚Ù¹‚Ù§x Differentiate a Legendre series.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/polynomial/legendre.pydr<class 'function'>x numpy.polynomial.legendre.legderÙ¯‚„Ù´ƒ˜"Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hlegendreÙ „enumpyf1.22.3fmodulexnumpy.polynomial.legendrefmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚`aLÙ±‚`a
Ù±‚`acÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a,Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegderÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legderfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a)xarray([  6.,   9.,  20.])fexecedÙ´ƒ‰Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegderÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legderfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)larray([60.])fexecedÙ´ƒŒÙ±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegderÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legderfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`csclÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)xarray([ -6.,  -9., -20.])fexecedÙ´ƒŒÙ±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegderÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legderfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚aoa-Ù±‚bmia1Ù±‚`a)sarray([  9.,  60.])fexecedöÙ¼ƒÙ»ƒflegintx numpy.polynomial.legendre.legintõ€öf1.22.3Ù«xlegder(c, m=1, scl=1, axis=0)öx numpy.polynomial.legendre.legder€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚ƒÙ§nThe result is Ù©Ù§cnotÙ§o a MaskedArray!€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒjfill_valuetarray_like, optionalÙ¹‚ƒÙ§x´The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the Ù¢„jfill_valueÙ „enumpyf1.22.3fmodulex$numpy.ma.core.MaskedArray.fill_valuefmoduleõÙ§x( attribute of the array is used instead.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒlfilled_arraygndarrayÙ¹‚‰Ù§jA copy of Ù¡dselfÙ§x" with invalid entries replaced by Ù¨Ù§jfill_valueÙ§x2 (be it the function argument or the attribute of Ù¡dselfÙ§f), or Ù¡dselfÙ§xE itself as an ndarray if there are no invalid entries to be replaced.€ögSummaryÙ¯‚Ù¹‚ƒÙ§xEReturn a copy of self, with masked values filled with a given value. Ù©Ù§gHoweverÙ§xU, if there are no masked values to fill, self will be returned instead as an ndarray.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummaryjParametersgReturnseNoteshExamplesq/numpy/ma/core.py•r<class 'function'>xnumpy.ma.MaskedArray.filledÙ¯‚…Ù´ƒ˜1Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a,Ù±‚bmia4Ù±‚`a,Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚bmia0Ù±‚`a,Ù±‚bmia1Ù±‚`a,Ù±‚bmia0Ù±‚`a,Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„jfill_valueÙ „enumpyf1.22.3fmodulex$numpy.ma.core.MaskedArray.fill_valuefmoduleõÙ±‚aoa=Ù±‚aoa-Ù±‚bmic999Ù±‚`a)Ù±‚`a
Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„ffilledÙ „enumpyf1.22.3fmoduletnumpy.ma.core.filledfmoduleõÙ±‚`a(Ù±‚`a)x%array([   1,    2, -999,    4, -999])hcompiledÙ´ƒˆÙ±‚`axÙ±‚aoa.Ù±‚`Ù¢„ffilledÙ „enumpyf1.22.3fmoduletnumpy.ma.core.filledfmoduleõÙ±‚`a(Ù±‚`Ù¢„jfill_valueÙ „enumpyf1.22.3fmodulex$numpy.ma.core.MaskedArray.fill_valuefmoduleõÙ±‚aoa=Ù±‚bmid1000Ù±‚`a)x%array([   1,    2, 1000,    4, 1000])hcompiledÙ´ƒˆÙ±‚bnbdtypeÙ±‚`a(Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„ffilledÙ „enumpyf1.22.3fmoduletnumpy.ma.core.filledfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a)w<class 'numpy.ndarray'>hcompiledÙ¹‚ƒÙ§xeSubclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, Ù¢„ffilledÙ „enumpyf1.22.3fmoduletnumpy.ma.core.filledfmoduleõÙ§t returns a recarray:€Ù´ƒ˜PÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a(Ù±‚aoa-Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚aoa-Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1ei8,i8Ù±‚bs1a'Ù±‚`a)Ù±‚aoa.Ù±‚`Ù¢„dviewÙ „enumpyf1.22.3fmodulexnumpy.ma.core.MaskedArray.viewfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hrecarrayÙ „enumpyf1.22.3fmodulennumpy.recarrayfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`amÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„bmaÙ „enumpyf1.22.3fmodulehnumpy.mafmoduleõÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚`a[Ù±‚`a(Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚bkceFalseÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`amÙ±‚aoa.Ù±‚`Ù¢„ffilledÙ „enumpyf1.22.3fmoduletnumpy.ma.core.filledfmoduleõÙ±‚`a(Ù±‚`a)x_rec.array([(999999,      2), (    -3, 999999)],
          dtype=[('f0', '<i8'), ('f1', '<i8')])hcompiledö€f1.22.3Ù«xfilled(self, fill_value=None)öx numpy.ma.core.MaskedArray.filled€
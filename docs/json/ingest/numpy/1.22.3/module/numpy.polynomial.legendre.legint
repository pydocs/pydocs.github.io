Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚˜Ù§x)Returns the Legendre series coefficients Ù¢„acÙ „ööelocalacelocalõÙ§l integrated Ù¢„amÙ „ööelocalamelocalõÙ§l times from Ù¢„dlbndÙ „ööelocaldlbndelocalõÙ§g along Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x,. At each iteration the resulting series is Ù©Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x and an integration constant, Ù¢„akÙ „ööelocalakelocalõÙ§x”, is added. The scaling factor is for use in a linear change of variable.  ("Buyer beware": note that, depending on what one is doing, one may want Ù¢„csclÙ „ööelocalcsclelocalõÙ§xr to be the reciprocal of what one might expect; for more information, see the Notes section below.)  The argument Ù¢„acÙ „ööelocalacelocalõÙ§xj is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the series Ù¡sL_0 + 2*L_1 + 3*L_2Ù§x  while [[1,2],[1,2]] represents Ù¡xE1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)Ù§n if axis=0 is Ù¡axÙ§o and axis=1 is Ù¡ayÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x,Note that the result of each integration is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§xP. Why is this important to note?  Say one is making a linear change of variable Ù¥ju = ax + bÙ§x in an integral relative to Ù£ƒaxööÙ§h.  Then Ù¥idx = du/aÙ§x, so one will need to set Ù¢„csclÙ „ööelocalcsclelocalõÙ§j equal to Ù¥c1/aÙ§x1 - perhaps not what one would have first thought.€Ù¹‚Ù§xãAlso note that, in general, the result of integrating a C-series needs to be "reprojected" onto the C-series basis set.  Thus, typically, the result of this function is "unintuitive," albeit correct; see Examples section below.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒacjarray_likeÙ¹‚Ù§x³Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.€Ù°ƒammint, optionalÙ¹‚Ù§x4Order of integration, must be positive. (Default: 1)€Ù°ƒakx{[], list, scalar}, optionalÙ¹‚‰Ù§x=Integration constant(s).  The value of the first integral at Ù¡dlbndÙ§xE is the first value in the list, the value of the second integral at Ù¡dlbndÙ§x is the second value, etc.  If Ù¡gk == []Ù§x3 (the default), all constants are set to zero.  If Ù¡fm == 1Ù§x1, a single scalar can be given instead of a list.€Ù°ƒdlbndpscalar, optionalÙ¹‚Ù§x-The lower bound of the integral. (Default: 0)€Ù°ƒcsclpscalar, optionalÙ¹‚…Ù§x)Following each integration the result is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x7 before the integration constant is added. (Default: 1)€Ù°ƒdaxismint, optional‚Ù¹‚Ù§x4Axis over which the integral is taken. (Default: 0).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚‰Ù§cIf Ù¡em < 0Ù§b, Ù¡jlen(k) > mÙ§b, Ù¡rnp.ndim(lbnd) != 0Ù§e, or Ù¡qnp.ndim(scl) != 0Ù§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaSgndarrayÙ¹‚Ù§x2Legendre series coefficient array of the integral.€ögSummaryÙ¯‚Ù¹‚Ù§xIntegrate a Legendre series.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/polynomial/legendre.pyÀr<class 'function'>x numpy.polynomial.legendre.legintÙ¯‚…Ù´ƒ˜ Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„hlegendreÙ „enumpyf1.22.3fmodulexnumpy.polynomial.legendrefmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚`aLÙ±‚`a
Ù±‚`acÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a)Ù±‚`a
Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegintÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legintfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a)xFarray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may varyfexecedÙ´ƒ‰Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegintÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legintfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)x†array([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary
         -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])fexecedÙ´ƒ‹Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegintÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legintfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚bmia3Ù±‚`a)xG array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may varyfexecedÙ´ƒŒÙ±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegintÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legintfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`dlbndÙ±‚aoa=Ù±‚aoa-Ù±‚bmia2Ù±‚`a)xFarray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may varyfexecedÙ´ƒ‹Ù±‚`aLÙ±‚aoa.Ù±‚`Ù¢„flegintÙ „enumpyf1.22.3fmodulex numpy.polynomial.legendre.legintfmoduleõÙ±‚`a(Ù±‚`acÙ±‚`a,Ù±‚`a Ù±‚`csclÙ±‚aoa=Ù±‚bmia2Ù±‚`a)xFarray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may varyfexecedöÙ¼ƒÙ»ƒflegderx numpy.polynomial.legendre.legderõ€öf1.22.3Ù«x+legint(c, m=1, k=[], lbnd=0, scl=1, axis=0)öx numpy.polynomial.legendre.legint€
Ùª­jAttributesÙ¯‚Ù°ƒtlock: threading.Lock`Ù¹‚Ù§xÖLock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator's lock.€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ŒÙ¹‚„Ù¡gMT19937Ù§x´ provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers . These are not directly consumable in Python and must be consumed by a Ù¡iGeneratorÙ§x2 or similar object that supports low-level access.€Ù¹‚Ù§xbThe Python stdlib module "random" also contains a Mersenne Twister pseudo-random number generator.€Ù¹‚Ù©Ù§qState and Seeding€Ù¹‚ƒÙ§dThe Ù¡gMT19937Ù§x° state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.€Ù¹‚ƒÙ§xThe input seed is processed by Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§xd to fill the whole state. The first element is reset such that only its most significant bit is set.€Ù¹‚Ù©Ù§qParallel Features€Ù¹‚ƒÙ§xOThe preferred way to use a BitGenerator in parallel applications is to use the Ù¢„rSeedSequence.spawnÙ „enumpyf1.22.3fmodulex7numpy.random.bit_generator.ISpawnableSeedSequence.spawnfmoduleõÙ§xQ method to obtain entropy values, and to use these to generate new BitGenerators:€ÙÀx>>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(MT19937(s)) for s in sg.spawn(10)]Ù¹‚…Ù§xAnother method is to use Ù£ƒnMT19937.jumpedööÙ§x  which advances the state as-if Ù¥g2^{128}Ù§xï random numbers have been generated (, ). This allows the original sequence to be split so that distinct segments can be used in each worker process. All generators should be chained to ensure that the segments come from the same sequence.€ÙÀy>>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> bit_generator = MT19937(sg)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    # Chain the BitGenerators
...    bit_generator = bit_generator.jumped()Ù¹‚Ù©Ù§wCompatibility Guarantee€Ù¹‚‚Ù¡gMT19937Ù§x\ makes a guarantee that a fixed seed and will always produce the same random integer stream.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒdseedx5{None, int, array_like[ints], SeedSequence}, optionalÙ¹‚Ù§xA seed to initialize the Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§xO. If None, then fresh, unpredictable entropy will be pulled from the OS. If an Ù¡cintÙ§d or Ù¡parray_like[ints]Ù§x& is passed, then it will be passed to Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§w to derive the initial Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§x state. One may also pass in a Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§j instance.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xBContainer for the Mersenne Twister pseudo-random number generator.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†iSignaturegSummaryjParametersjAttributeseNotesjReferencesx+/numpy/random/_mt19937.cpython-39-darwin.soön<class 'type'>tnumpy.random.MT19937Ù¯‚€ö€f1.22.3Ù«rMT19937(seed=None)öxnumpy.random._mt19937.MT19937€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ƒÙ¹‚…Ù§xÆWhen axis is not None, this function does the same thing as "fancy" indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as Ù¡xnp.take(arr, indices, axis=3)Ù§r is equivalent to Ù¡varr[:,:,:,indices,...]Ù§a.€Ù¹‚‰Ù§xMExplained without fancy indexing, this is equivalent to the following use of Ù¢„gndindexÙ „enumpyf1.22.3fmodulemnumpy.ndindexfmoduleõÙ§u, which sets each of Ù¡biiÙ§b, Ù¡bjjÙ§f, and Ù¡bkkÙ§x to a tuple of indices::      €ÙÀxÉNi, Nk = a.shape[:axis], a.shape[axis+1:]
Nj = indices.shape
for ii in ndindex(Ni):
    for jj in ndindex(Nj):
        for kk in ndindex(Nk):
            out[ii + jj + kk] = a[ii + (indices[jj],) + kk]ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚…Ù§xBBy eliminating the inner loop in the description above, and using Ù£ƒbs_ööÙ§x  to build simple slice objects, Ù¢„dtakeÙ „enumpyf1.22.3fmodulejnumpy.takefmoduleõÙ§xP can be expressed  in terms of applying fancy indexing to each 1-d slice::      €ÙÀxšNi, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
    for kk in ndindex(Nj):
        out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]Ù¹‚ƒÙ§xLFor this reason, it is equivalent to (but faster than) the following use of Ù¢„papply_along_axisÙ „enumpyf1.22.3fmodulevnumpy.apply_along_axisfmoduleõÙ§f      €ÙÀx>out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaaxarray_like (Ni..., M, Nk...)Ù¹‚Ù§qThe source array.€Ù°ƒgindicesrarray_like (Nj...)ƒÙ¹‚Ù§x%The indices of the values to extract.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.8.0 €Ù¹‚Ù§xAlso allow scalars for indices.€Ù°ƒdaxismint, optionalÙ¹‚Ù§xTThe axis over which to select values. By default, the flattened input array is used.€Ù°ƒcoutx'ndarray, optional (Ni..., Nj..., Nk...)Ù¹‚…Ù§xqIf provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that Ù¢„coutÙ „ööelocalcoutelocalõÙ§w is always buffered if Ù£ƒlmode='raise'ööÙ§x); use other modes for better performance.€Ù°ƒdmodex#{'raise', 'wrap', 'clip'}, optionalƒÙ¹‚Ù§x0Specifies how out-of-bounds indices will behave.€ÙÈƒÙ¹‚Ù§x#'raise' -- raise an error (default)€Ù¹‚Ù§u'wrap' -- wrap around€Ù¹‚Ù§x'clip' -- clip to the range€Ù¹‚Ù§x¸'clip' mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutxndarray (Ni..., Nj..., Nk...)Ù¹‚ƒÙ§x(The returned array has the same type as Ù¢„aaÙ „ööelocalaaelocalõÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x*Take elements from an array along an axis.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshSee AlsoeNoteshExamplesx/numpy/core/fromnumeric.py]r<class 'function'>jnumpy.takeÙ¯‚…Ù´ƒ˜.Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a]Ù±‚`a
Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtakeÙ „enumpyf1.22.3fmodulejnumpy.takefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a)parray([4, 3, 6])fexecedÙ¹‚ƒÙ§sIn this example if Ù¢„aaÙ „ööelocalaaelocalõÙ§x- is an ndarray, "fancy" indexing can be used.€Ù´ƒÙ±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a[Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a]parray([4, 3, 6])fexecedÙ¹‚ƒÙ§cIf Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ§x> is not one dimensional, the output also has these dimensions.€Ù´ƒ˜Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„dtakeÙ „enumpyf1.22.3fmodulejnumpy.takefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`a[Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a]Ù±‚`a)xarray([[4, 3],
       [5, 7]])fexecedöƒÙ¼ƒÙ»ƒhcompressnnumpy.compressõÙ¹‚Ù§x"Take elements using a boolean mask€öÙ¼ƒÙ»ƒlndarray.takeööÙ¹‚Ù§qequivalent method€öÙ¼ƒÙ»ƒotake_along_axisunumpy.take_along_axisõÙ¹‚Ù§x8Take elements by matching the array and the index arrays€öf1.22.3Ù«x3take(a, indices, axis=None, out=None, mode='raise')öjnumpy.take€
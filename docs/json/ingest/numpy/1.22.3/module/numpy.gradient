Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§yThe gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.€ögMethodsÙ¯‚€öeNotesÙ¯‚‰Ù¹‚‰Ù§nAssuming that Ù¥jf\in C^{3}Ù§h (i.e., Ù¥afÙ§x0 has at least 3 continuous derivatives) and let Ù¥eh_{*}Ù§xD be a non-homogeneous stepsize, we minimize the "consistency error" Ù¥h\eta_{i}Ù§xe between the true gradient and its estimate from a linear combination of the neighboring grid-points:€Ù¤x°\eta_ { i} = f_ { i}^ { \left ( 1\right)} - \left [ \alpha f\left ( x_ { i}\right) + \beta f\left ( x_ { i} + h_ { d}\right) + \gamma f\left ( x_ { i} - h_ { s}\right) \right] Ù¹‚…Ù§pBy substituting Ù¥pf(x_{i} + h_{d})Ù§e and Ù¥pf(x_{i} - h_{s})Ù§xb with their Taylor series expansion, this translates into solving the following the linear system:€Ù¤xœ\left\ { \begin { array} { r} \alpha+\beta+\gamma=0 \\ \beta h_ { d} - \gamma h_ { s}=1 \\ \beta h_ { d}^ { 2}+\gamma h_ { s}^ { 2}=0 \end { array} \right. Ù¹‚ƒÙ§xThe resulting approximation of Ù¥kf_{i}^{(1)}Ù§r is the following:€Ù¤ya\hat f_ { i}^ { ( 1)} = \frac { h_ { s}^ { 2}f\left ( x_ { i} + h_ { d}\right) + \left ( h_ { d}^ { 2} - h_ { s}^ { 2}\right)f\left ( x_ { i}\right) - h_ { d}^ { 2}f\left ( x_ { i} - h_ { s}\right)} { h_ { s}h_ { d}\left ( h_ { d} + h_ { s}\right)} + \mathcal { O}\left ( \frac { h_ { d}h_ { s}^ { 2} + h_ { s}h_ { d}^ { 2}} { h_ { d} + h_ { s}}\right) Ù¹‚ƒÙ§xIt is worth noting that if Ù¥kh_{s}=h_{d}Ù§xP (i.e., data are evenly spaced) we find the standard second order approximation:€Ù¤x„\hat f_ { i}^ { ( 1)}= \frac { f\left ( x_ { i+1}\right) - f\left ( x_ { i - 1}\right)} { 2h} + \mathcal { O}\left ( h^ { 2}\right) Ù¹‚Ù§x`With a similar procedure the forward/backward approximations used for boundaries can be derived.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒafjarray_likeÙ¹‚Ù§x?An N-dimensional array containing samples of a scalar function.€Ù°ƒgvarargsx!list of scalar or array, optionalƒÙ¹‚Ù§xeSpacing between f values. Default unitary spacing for all dimensions. Spacing can be specified using:€ÙÇ„Ù¹‚Ù§x>single scalar to specify a sample distance for all dimensions.€Ù¹‚‡Ù§xLN scalars to specify a constant sample distance for each dimension.    i.e. Ù¢„bdxÙ „enumpyf1.22.3fmodulex)numpy.lib.shape_base._make_along_axis_idxfmoduleõÙ§b, Ù¢„bdyÙ „enumpyf1.22.3fmodulex"numpy.core.einsumfunc._greedy_pathfmoduleõÙ§b, Ù£ƒbdzööÙ§e, ...€Ù¹‚Ù§xN arrays to specify the coordinates of the values along each    dimension of F. The length of the array must match the size of    the corresponding dimension€Ù¹‚Ù§xAAny combination of N scalars/arrays with the meaning of 2. and 3.€Ù¹‚ƒÙ§cIf Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§xK is given, the number of varargs must equal the number of axes. Default: 1.€Ù°ƒjedge_orderp{1, 2}, optional‚Ù¹‚Ù§x[Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.9.1 €Ù°ƒdaxisx&None or int or tuple of ints, optional‚Ù¹‚Ù§xãGradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§g1.11.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒhgradientxndarray or list of ndarrayÙ¹‚Ù§x¶A list of ndarrays (or a single ndarray if there is only one dimension) corresponding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.€ögSummaryÙ¯‚Ù¹‚Ù§x.Return the gradient of an N-dimensional array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnshExampleseNotesjReferencesx/numpy/lib/function_base.py±r<class 'function'>nnumpy.gradientÙ¯‚Ù´ƒ˜'Ù±‚`afÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmib11Ù±‚`a,Ù±‚`a Ù±‚bmib16Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a)x%array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])fexecedÙ´ƒ‰Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)x0array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])fexecedÙ¹‚Ù§x‘Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:€Ù´ƒ–Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„farangeÙ „enumpyf1.22.3fmodulelnumpy.arangefmoduleõÙ±‚`a(Ù±‚`afÙ±‚aoa.Ù±‚`Ù¢„dsizeÙ „enumpyf1.22.3fmodulejnumpy.sizefmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)x*array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])fexecedÙ¹‚Ù§uOr a non uniform one:€Ù´ƒ˜*Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfb0.Ù±‚`a,Ù±‚`a Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmfc3.5Ù±‚`a,Ù±‚`a Ù±‚bmfb4.Ù±‚`a,Ù±‚`a Ù±‚bmfb6.Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a,Ù±‚`a Ù±‚`axÙ±‚`a)x*array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])fexecedÙ¹‚Ù§x³For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:€Ù´ƒ˜%Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a)xd[array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
       [1. , 1. , 1. ]])]fexecedÙ¹‚Ù§x\In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1€Ù´ƒ˜?Ù±‚`Ù¢„bdxÙ „enumpyf1.22.3fmodulex)numpy.lib.shape_base._make_along_axis_idxfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmfb2.Ù±‚`a
Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bmfb1.Ù±‚`a,Ù±‚`a Ù±‚bmfc1.5Ù±‚`a,Ù±‚`a Ù±‚bmfc3.5Ù±‚`a]Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bdxÙ „enumpyf1.22.3fmodulex)numpy.lib.shape_base._make_along_axis_idxfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)xj[array([[ 1. ,  1. , -0.5],
       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
       [2. , 1.7, 0.5]])]fexecedÙ¹‚‚Ù§x;It is possible to specify how boundaries are treated using Ù¢„jedge_orderÙ „ööelocaljedge_orderelocalõ€Ù´ƒ˜-Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`afÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`axÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a
Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a,Ù±‚`a Ù±‚`jedge_orderÙ±‚aoa=Ù±‚bmia1Ù±‚`a)xarray([1.,  2.,  4.,  6.,  7.])fexecedÙ´ƒ‹Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`afÙ±‚`a,Ù±‚`a Ù±‚`jedge_orderÙ±‚aoa=Ù±‚bmia2Ù±‚`a)xarray([0., 2., 4., 6., 8.])fexecedÙ¹‚ƒÙ§dThe Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§xT keyword can be used to specify a subset of axes of which the gradient is calculated€Ù´ƒ˜*Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hgradientÙ „enumpyf1.22.3fmodulennumpy.gradientfmoduleõÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a5Ù „enumpyf1.22.3fmoduletnumpy.typing._256BitfmoduleõÙ±‚`a]Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`daxisÙ±‚aoa=Ù±‚bmia0Ù±‚`a)x0array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])fexecedö€f1.22.3Ù«x.gradient(f, *varargs, axis=None, edge_order=1)önnumpy.gradient€
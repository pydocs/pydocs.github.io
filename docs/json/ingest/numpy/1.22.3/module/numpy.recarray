Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xgArrays may have a data-types containing fields, analogous to columns in a spread sheet.  An example is Ù¡v[(x, int), (y, float)]Ù§x-, where each entry in the array is a pair of Ù¡l(int, float)Ù§xL.  Normally, these attributes are accessed using dictionary lookups such as Ù¡harr['x']Ù§e and Ù¡harr['y']Ù§xP.  Record arrays allow the fields to be accessed as members of the array, using Ù¡earr.xÙ§e and Ù¡earr.yÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚ƒÙ§x$This constructor can be compared to Ù¡eemptyÙ§x†: it creates a new record array but does not fill it with data.  To create a record array from data, use one of the following methods:€ÙÇƒÙ¹‚‚Ù§xECreate a standard ndarray and convert it to a record array,    using Ù¡uarr.view(np.recarray)€Ù¹‚ƒÙ§hUse the Ù¢„cbufÙ „ööelocalcbufelocalõÙ§i keyword.€Ù¹‚ƒÙ§dUse Ù£ƒrnp.rec.fromrecordsööÙ§a.€öpOther ParametersÙ¯‚†Ù°ƒftitlesvtuple of str, optionalÙ¹‚Ù§x+Aliases for column names.  For example, if Ù¢„enamesÙ „ööelocalenameselocalõÙ§f were Ù¡o('x', 'y', 'z')Ù§e and Ù¢„ftitlesÙ „ööelocalftitleselocalõÙ§d is Ù¡x0('x_coordinate', 'y_coordinate', 'z_coordinate')Ù§g, then Ù¡harr['x']Ù§w is equivalent to both Ù¡earr.xÙ§e and Ù¡parr.x_coordinateÙ§a.€Ù°ƒibyteorderx{'<', '>', '='}, optionalÙ¹‚Ù§xByte-order for all fields.€Ù°ƒgalignednbool, optionalÙ¹‚Ù§x3Align the fields in memory as the C-compiler would.€Ù°ƒgstrideswtuple of ints, optionalÙ¹‚ƒÙ§hBuffer (Ù¢„cbufÙ „ööelocalcbufelocalõÙ§xƒ) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).€Ù°ƒfoffsetmint, optionalÙ¹‚ƒÙ§vStart reading buffer (Ù¢„cbufÙ „ööelocalcbufelocalõÙ§x) from this offset onwards.€Ù°ƒeordert{'C', 'F'}, optionalÙ¹‚Ù§x:Row-major (C-style) or column-major (Fortran-style) order.€öjParametersÙ¯‚…Ù°ƒeshapeetupleÙ¹‚Ù§vShape of output array.€Ù°ƒedtypesdata-type, optionalÙ¹‚‹Ù§xEThe desired data-type.  By default, the data-type is determined from Ù¢„gformatsÙ „ööelocalgformatselocalõÙ§b, Ù¢„enamesÙ „ööelocalenameselocalõÙ§b, Ù¢„ftitlesÙ „ööelocalftitleselocalõÙ§b, Ù¢„galignedÙ „ööelocalgalignedelocalõÙ§e and Ù¢„ibyteorderÙ „enumpyf1.22.3fmodulex4numpy.core._multiarray_tests.run_byteorder_converterfmoduleõÙ§a.€Ù°ƒgformatsxlist of data-types, optionalÙ¹‚Ù§xAA list containing the data-types for the different columns, e.g. Ù¡r['i4', 'f8', 'i4']Ù§c.  Ù¢„gformatsÙ „ööelocalgformatselocalõÙ§f does Ù¨Ù§cnotÙ§x: support the new convention of using types directly, i.e. Ù¡q(int, float, int)Ù§l. Note that Ù¢„gformatsÙ „ööelocalgformatselocalõÙ§x) must be a list, not a tuple. Given that Ù¢„gformatsÙ „ööelocalgformatselocalõÙ§x. is somewhat limited, we recommend specifying Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ§i instead.€Ù°ƒenamesvtuple of str, optionalÙ¹‚ƒÙ§xThe name of each column, e.g. Ù¡o('x', 'y', 'z')Ù§a.€Ù°ƒcbufpbuffer, optionalÙ¹‚‡Ù§xHBy default, a new array is created of the given shape and data-type. If Ù¢„cbufÙ „ööelocalcbufelocalõÙ§x‰ is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer.  In this case, the Ù¢„foffsetÙ „ööelocalfoffsetelocalõÙ§e and Ù¢„gstridesÙ „ööelocalgstrideselocalõÙ§x keywords are available.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcrechrecarrayÙ¹‚Ù§x(Empty array of the given shape and type.€ögSummaryÙ¯‚Ù¹‚Ù§x?Construct an ndarray that allows field access using attributes.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParameterspOther ParametersgReturnshSee AlsoeNoteshExamplesr/numpy/__init__.pyön<class 'type'>nnumpy.recarrayÙ¯‚‰Ù¹‚…Ù§x!Create an array with two fields, Ù¡axÙ§e and Ù¡ayÙ§a:€Ù´ƒ˜7Ù±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „enumpyf1.22.3fmoduleknumpy.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a(Ù±‚bmfc1.0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmfc3.0Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚`a(Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1c<f8Ù±‚bs1a'Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1ayÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1c<i8Ù±‚bs1a'Ù±‚`a)Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`axx=array([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])fexecedÙ´ƒ†Ù±‚`axÙ±‚`a[Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a]oarray([1., 3.])fexecedÙ¹‚Ù§x!View the array as a record array:€Ù´ƒŒÙ±‚`axÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`dviewÙ±‚`a(Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hrecarrayÙ „enumpyf1.22.3fmodulennumpy.recarrayfmoduleõÙ±‚`a)`fexecedÙ´ƒƒÙ±‚`axÙ±‚aoa.Ù±‚`axoarray([1., 3.])fexecedÙ´ƒƒÙ±‚`axÙ±‚aoa.Ù±‚`aymarray([2, 4])fexecedÙ¹‚Ù§x!Create a new, empty record array:€Ù´ƒ˜-Ù±‚`bnpÙ±‚aoa.Ù±‚`Ù¢„hrecarrayÙ „enumpyf1.22.3fmodulennumpy.recarrayfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚`a(Ù±‚bs1a'Ù±‚bs1axÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1ayÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbefloatÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bs1a'Ù±‚bs1azÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbcintÙ±‚`a)Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚bc1o#doctest: +SKIPx£rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),
       (3471280, 1.2134086255804012e-316, 0)],
      dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])fexecedöƒÙ¼ƒÙ»ƒxcore.records.fromrecordsööÙ¹‚Ù§x#Construct a record array from data.€öÙ¼ƒÙ»ƒmformat_parsersnumpy.format_parserõÙ¹‚Ù§x2determine a data-type from formats, names, titles.€öÙ¼ƒÙ»ƒfrecordlnumpy.recordõÙ¹‚ƒÙ§xfundamental data-type for Ù¢„hrecarrayÙ „enumpyf1.22.3fmodulennumpy.recarrayfmoduleõÙ§a.€öf1.22.3Ù«öönnumpy.recarray€
Ùª­jAttributesÙ¯‚Ù°ƒtlock: threading.Lock`Ù¹‚Ù§xÖLock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator's lock.€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚…Ù§xßPhilox is a 64-bit PRNG that uses a counter-based design based on weaker (and faster) versions of cryptographic functions . Instances using different values of the key produce independent sequences.  Philox has a period of Ù¥k2^{256} - 1Ù§xL and supports arbitrary advancing and jumping the sequence in increments of Ù¥g2^{128}Ù§xJ. These features allow multiple non-overlapping sequences to be generated.€Ù¹‚„Ù¡fPhiloxÙ§x³ provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers. These are not directly consumable in Python and must be consumed by a Ù¡iGeneratorÙ§x2 or similar object that supports low-level access.€Ù¹‚Ù©Ù§qState and Seeding€Ù¹‚ƒÙ§dThe Ù¡fPhiloxÙ§yN state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.€Ù¹‚…Ù§jThe input Ù¡dseedÙ§q is processed by Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§x. to generate the key. The counter is set to 0.€Ù¹‚‡Ù§xAlternately, one can omit the Ù¡dseedÙ§w parameter and set the Ù¡ckeyÙ§e and Ù¡gcounterÙ§j directly.€Ù¹‚Ù©Ù§qParallel Features€Ù¹‚ƒÙ§xOThe preferred way to use a BitGenerator in parallel applications is to use the Ù¢„rSeedSequence.spawnÙ „enumpyf1.22.3fmodulex7numpy.random.bit_generator.ISpawnableSeedSequence.spawnfmoduleõÙ§xQ method to obtain entropy values, and to use these to generate new BitGenerators:€ÙÀx>>> from numpy.random import Generator, Philox, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(Philox(s)) for s in sg.spawn(10)]Ù¹‚ŠÙ¡fPhiloxÙ§x5 can be used in parallel applications by calling the Ù¡fjumpedÙ§x% method  to advances the state as-if Ù¥g2^{128}Ù§x4 random numbers have been generated. Alternatively, Ù¡gadvanceÙ§xU can be used to advance the counter for any positive step in [0, 2**256). When using Ù¡fjumpedÙ§x[, all generators should be chained to ensure that the segments come from the same sequence.€ÙÀxÌ>>> from numpy.random import Generator, Philox
>>> bit_generator = Philox(1234)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    bit_generator = bit_generator.jumped()Ù¹‚ƒÙ§oAlternatively, Ù¡fPhiloxÙ§xr can be used in parallel applications by using a sequence of distinct keys where each instance uses different key.€ÙÀxa>>> key = 2**96 + 2**33 + 2**17 + 2**9
>>> rg = [Generator(Philox(key=key+i)) for i in range(10)]Ù¹‚Ù©Ù§wCompatibility Guarantee€Ù¹‚„Ù¡fPhiloxÙ§x  makes a guarantee that a fixed Ù¡dseedÙ§x4 will always produce the same random integer stream.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒdseedx5{None, int, array_like[ints], SeedSequence}, optionalÙ¹‚Ù§xA seed to initialize the Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§xO. If None, then fresh, unpredictable entropy will be pulled from the OS. If an Ù¡cintÙ§d or Ù¡parray_like[ints]Ù§x& is passed, then it will be passed to Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§w to derive the initial Ù¢„lBitGeneratorÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.BitGeneratorfmoduleõÙ§x state. One may also pass in a Ù¢„lSeedSequenceÙ „enumpyf1.22.3fmodulex'numpy.random.bit_generator.SeedSequencefmoduleõÙ§j instance.€Ù°ƒgcounterx!{None, int, array_like}, optionalÙ¹‚Ù§x¦Counter to use in the Philox state. Can be either a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array. If not provided, the RNG is initialized at 0.€Ù°ƒckeyx!{None, int, array_like}, optionalÙ¹‚‡Ù§x(Key to use in the Philox state.  Unlike Ù¡dseedÙ§xk, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. Ù¢„ckeyÙ „ööelocalckeyelocalõÙ§e and Ù¡dseedÙ§u cannot both be used.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x?Container for the Philox (4x64) pseudo-random number generator.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡iSignaturegSummaryjParametersjAttributeseNoteshExamplesjReferencesx*/numpy/random/_philox.cpython-39-darwin.soön<class 'type'>snumpy.random.PhiloxÙ¯‚Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„iGeneratorÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„fPhiloxÙ „enumpyf1.22.3fmodulexnumpy.random._philox.PhiloxfmoduleõÙ±‚`a
Ù±‚`brgÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iGeneratorÙ „enumpyf1.22.3fmodulex!numpy.random._generator.GeneratorfmoduleõÙ±‚`a(Ù±‚`Ù¢„fPhiloxÙ „enumpyf1.22.3fmodulexnumpy.random._philox.PhiloxfmoduleõÙ±‚`a(Ù±‚bmid1234Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`brgÙ±‚aoa.Ù±‚`ostandard_normalÙ±‚`a(Ù±‚`a)o0.123  # randomfexecedö€f1.22.3Ù«x)Philox(seed=None, counter=None, key=None)öxnumpy.random._philox.Philox€
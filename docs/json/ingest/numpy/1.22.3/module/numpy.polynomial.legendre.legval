Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚…Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§n is of length Ù£ƒen + 1ööÙ§x", this function returns the value:€Ù¤x@p ( x) = c_0 * L_0 ( x) + c_1 * L_1 ( x) + ... + c_n * L_n ( x) Ù¹‚‡Ù§nThe parameter Ù¢„axÙ „ööelocalaxelocalõÙ§xw is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support multiplication and addition both with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù¹‚Ù§cIf Ù¢„acÙ „ööelocalacelocalõÙ§v is a 1-D array, then Ù£ƒdp(x)ööÙ§x will have the same shape as Ù¢„axÙ „ööelocalaxelocalõÙ§f.  If Ù¢„acÙ „ööelocalacelocalõÙ§xK is multidimensional, then the shape of the result depends on the value of Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§e. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§x5 is true the shape will be c.shape[1:] + x.shape. If Ù¢„ftensorÙ „ööelocalftensorelocalõÙ§xJ is false the shape will be c.shape[1:]. Note that scalars have shape (,).€Ù¹‚Ù§xxTrailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x?The evaluation uses Clenshaw recursion, aka synthetic division.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaxxarray_like, compatible objectÙ¹‚‡Ù§cIf Ù¢„axÙ „ööelocalaxelocalõÙ§x| is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, Ù¢„axÙ „ööelocalaxelocalõÙ§xh or its elements must support addition and multiplication with with themselves and with the elements of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒacjarray_likeÙ¹‚…Ù§xgArray of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If Ù¢„acÙ „ööelocalacelocalõÙ§x¦ is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of Ù¢„acÙ „ööelocalacelocalõÙ§a.€Ù°ƒftensorqboolean, optional‚Ù¹‚Ù§xjIf True, the shape of the coefficient array is extended with ones on the right, one for each dimension of Ù¢„axÙ „ööelocalaxelocalõÙ§x_. Scalars have dimension 0 for this action. The result is that every column of coefficients in Ù¢„acÙ „ööelocalacelocalõÙ§x# is evaluated for every element of Ù¢„axÙ „ööelocalaxelocalõÙ§l. If False, Ù¢„axÙ „ööelocalaxelocalõÙ§x" is broadcast over the columns of Ù¢„acÙ „ööelocalacelocalõÙ§x2 for the evaluation.  This keyword is useful when Ù¢„acÙ „ööelocalacelocalõÙ§x0 is multidimensional. The default value is True.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfvaluesundarray, algebra_likeÙ¹‚Ù§x1The shape of the return value is described above.€ögSummaryÙ¯‚Ù¹‚Ù§x'Evaluate a Legendre series at points x.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesx/numpy/polynomial/legendre.py@r<class 'function'>x numpy.polynomial.legendre.legvalÙ¯‚€ö„Ù¼ƒÙ»ƒileggrid2dx#numpy.polynomial.legendre.leggrid2dõ€öÙ¼ƒÙ»ƒileggrid3dx#numpy.polynomial.legendre.leggrid3dõ€öÙ¼ƒÙ»ƒhlegval2dx"numpy.polynomial.legendre.legval2dõ€öÙ¼ƒÙ»ƒhlegval3dx"numpy.polynomial.legendre.legval3dõ€öf1.22.3Ù«xlegval(x, c, tensor=True)öx numpy.polynomial.legendre.legval€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚˜Ù§x(Returns the Hermite series coefficients Ù¢„acÙ „ööelocalacelocalõÙ§l integrated Ù¢„amÙ „ööelocalamelocalõÙ§l times from Ù¢„dlbndÙ „ööelocaldlbndelocalõÙ§g along Ù¢„daxisÙ „ööelocaldaxiselocalõÙ§x,. At each iteration the resulting series is Ù©Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x and an integration constant, Ù¢„akÙ „ööelocalakelocalõÙ§x”, is added. The scaling factor is for use in a linear change of variable.  ("Buyer beware": note that, depending on what one is doing, one may want Ù¢„csclÙ „ööelocalcsclelocalõÙ§xr to be the reciprocal of what one might expect; for more information, see the Notes section below.)  The argument Ù¢„acÙ „ööelocalacelocalõÙ§xj is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the series Ù¡sH_0 + 2*H_1 + 3*H_2Ù§x  while [[1,2],[1,2]] represents Ù¡xE1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)Ù§n if axis=0 is Ù¡axÙ§o and axis=1 is Ù¡ayÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§x,Note that the result of each integration is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§xP. Why is this important to note?  Say one is making a linear change of variable Ù¥ju = ax + bÙ§x in an integral relative to Ù£ƒaxööÙ§h.  Then Ù¥idx = du/aÙ§x, so one will need to set Ù¢„csclÙ „ööelocalcsclelocalõÙ§j equal to Ù¥c1/aÙ§x1 - perhaps not what one would have first thought.€Ù¹‚Ù§xãAlso note that, in general, the result of integrating a C-series needs to be "reprojected" onto the C-series basis set.  Thus, typically, the result of this function is "unintuitive," albeit correct; see Examples section below.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒacjarray_likeÙ¹‚Ù§x²Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.€Ù°ƒammint, optionalÙ¹‚Ù§x4Order of integration, must be positive. (Default: 1)€Ù°ƒakx{[], list, scalar}, optionalÙ¹‚‰Ù§x=Integration constant(s).  The value of the first integral at Ù¡dlbndÙ§xE is the first value in the list, the value of the second integral at Ù¡dlbndÙ§x is the second value, etc.  If Ù¡gk == []Ù§x3 (the default), all constants are set to zero.  If Ù¡fm == 1Ù§x1, a single scalar can be given instead of a list.€Ù°ƒdlbndpscalar, optionalÙ¹‚Ù§x-The lower bound of the integral. (Default: 0)€Ù°ƒcsclpscalar, optionalÙ¹‚…Ù§x)Following each integration the result is Ù¨Ù§jmultipliedÙ§d by Ù¢„csclÙ „ööelocalcsclelocalõÙ§x7 before the integration constant is added. (Default: 1)€Ù°ƒdaxismint, optional‚Ù¹‚Ù§x4Axis over which the integral is taken. (Default: 0).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.7.0 €öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚‰Ù§cIf Ù¡em < 0Ù§b, Ù¡jlen(k) > mÙ§b, Ù¡rnp.ndim(lbnd) != 0Ù§e, or Ù¡qnp.ndim(scl) != 0Ù§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaSgndarrayÙ¹‚Ù§x,Hermite series coefficients of the integral.€ögSummaryÙ¯‚Ù¹‚Ù§xIntegrate a Hermite series.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/numpy/polynomial/hermite.py¨r<class 'function'>x numpy.polynomial.hermite.hermintÙ¯‚…Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„enumpyÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jpolynomialÙ „enumpyf1.22.3fmodulepnumpy.polynomialfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„ghermiteÙ „enumpyf1.22.3fmodulexnumpy.polynomial.hermitefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a
Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`a Ù±‚bc1x# integrate once, value 0 at 0.xarray([1. , 0.5, 0.5, 0.5])fexecedÙ´ƒ‘Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`amÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a Ù±‚bc1x'# integrate twice, value & deriv 0 at 0xSarray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may varyfexecedÙ´ƒ‘Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a Ù±‚bc1x# integrate once, value 1 at 0.xarray([2. , 0.5, 0.5, 0.5])fexecedÙ´ƒ’Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dlbndÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)Ù±‚`a Ù±‚bc1x# integrate once, value 0 at -1xarray([-2. ,  0.5,  0.5,  0.5])fexecedÙ´ƒ˜Ù±‚`Ù¢„ghermintÙ „enumpyf1.22.3fmodulex numpy.polynomial.hermite.hermintfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a,Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`amÙ±‚aoa=Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`akÙ±‚aoa=Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dlbndÙ±‚aoa=Ù±‚aoa-Ù±‚bmia1Ù±‚`a)xSarray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may varyfexecedöÙ¼ƒÙ»ƒghermderx numpy.polynomial.hermite.hermderõ€öf1.22.3Ù«x,hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0)öx numpy.polynomial.hermite.hermint€
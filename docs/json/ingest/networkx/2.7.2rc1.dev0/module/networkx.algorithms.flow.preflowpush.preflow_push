Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x°This function returns the residual network resulting after computing the maximum flow. See below for details about the conventions NetworkX uses for defining residual networks.€Ù¹‚Ù§xSThis algorithm has a running time of $O(n^2 \sqrt{m})$ for $n$ nodes and $m$ edges.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚˜Ù§uThe residual network Ù£ƒaRödsampÙ§u from an input graph Ù£ƒaGödsampÙ§w has the same nodes as Ù£ƒaGödsampÙ§b. Ù£ƒaRödsampÙ§x, is a DiGraph that contains a pair of edges Ù£ƒf(u, v)ödsampÙ§e and Ù£ƒf(v, u)ödsampÙ§e iff Ù£ƒf(u, v)ödsampÙ§x) is not a self-loop, and at least one of Ù£ƒf(u, v)ödsampÙ§e and Ù£ƒf(v, u)ödsampÙ§k exists in Ù£ƒaGödsampÙ§p. For each node Ù£ƒauödsampÙ§d in Ù£ƒaRödsampÙ§b, Ù£ƒtR.nodes[u]['excess']ödsampÙ§x- represents the difference between flow into Ù£ƒauödsampÙ§q and flow out of Ù£ƒauödsampÙ§a.€Ù¹‚˜Ù§nFor each edge Ù£ƒf(u, v)ödsampÙ§d in Ù£ƒaRödsampÙ§b, Ù£ƒsR[u][v]['capacity']ödsampÙ§x is equal to the capacity of Ù£ƒf(u, v)ödsampÙ§d in Ù£ƒaGödsampÙ§q if it exists in Ù£ƒaGödsampÙ§x1 or zero otherwise. If the capacity is infinite, Ù£ƒsR[u][v]['capacity']ödsampÙ§xs will have a high arbitrary finite value that does not affect the solution of the problem. This value is stored in Ù£ƒnR.graph['inf']ödsampÙ§p. For each edge Ù£ƒf(u, v)ödsampÙ§d in Ù£ƒaRödsampÙ§b, Ù£ƒoR[u][v]['flow']ödsampÙ§x! represents the flow function of Ù£ƒf(u, v)ödsampÙ§o and satisfies Ù£ƒx#R[u][v]['flow'] == -R[v][u]['flow']ödsampÙ§a.€Ù¹‚Ù§x/The flow value, defined as the total flow into Ù£ƒatödsampÙ§x, the sink, is stored in Ù£ƒuR.graph['flow_value']ödsampÙ§r. Reachability to Ù£ƒatödsampÙ§r using only edges Ù£ƒf(u, v)ödsampÙ§k such that Ù£ƒx%R[u][v]['flow'] < R[u][v]['capacity']ödsampÙ§s induces a minimum Ù£ƒasödsampÙ§a-Ù£ƒatödsampÙ§e cut.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒaGnNetworkX graphÙ¹‚Ù§x›Edges of the graph are expected to have an attribute called 'capacity'. If this attribute is not present, the edge is considered to have infinite capacity.€Ù°ƒasdnodeÙ¹‚Ù§xSource node for the flow.€Ù°ƒatdnodeÙ¹‚Ù§wSink node for the flow.€Ù°ƒhcapacityfstringÙ¹‚Ù§xáEdges of the graph G are expected to have an attribute capacity that indicates how much flow the edge can support. If this attribute is not present, the edge is considered to have infinite capacity. Default value: 'capacity'.€Ù°ƒhresidualnNetworkX graphÙ¹‚Ù§x{Residual network on which the algorithm is to be executed. If None, a new residual network is created. Default value: None.€Ù°ƒsglobal_relabel_freqninteger, floatÙ¹‚Ù§x•Relative frequency of applying the global relabeling heuristic to speed up the algorithm. If it is None, the heuristic is disabled. Default value: 1.€Ù°ƒjvalue_onlydboolÙ¹‚Ù§x’If False, compute a maximum flow; otherwise, compute a maximum preflow which is enough for computing the maximum flow value. Default value: False.€öfRaisesÙ¯‚‚Ù°ƒ`mNetworkXErrorÙ¹‚Ù§x•The algorithm does not support MultiGraph and MultiDiGraph. If the input graph is an instance of one of these two classes, a NetworkXError is raised.€Ù°ƒ`qNetworkXUnboundedÙ¹‚Ù§x—If the graph has a path of infinite capacity, the value of a feasible flow on the graph is unbounded above and the function raises a NetworkXUnbounded.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaRpNetworkX DiGraphÙ¹‚Ù§x2Residual network after computing the maximum flow.€ögSummaryÙ¯‚Ù¹‚Ù§xTFind a maximum single-commodity flow using the highest-label preflow-push algorithm.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx'networkx/algorithms/flow/preflowpush.pyr<class 'function'>xnetworkx.flow.preflow_pushÙ¯‚†Ù´ƒ‹Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„hnetworkxÙ „hnetworkxm2.7.2rc1.dev0fmodulehnetworkxfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jalgorithmsÙ „hnetworkxm2.7.2rc1.dev0fmodulesnetworkx.algorithmsfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„dflowÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.flowfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„lpreflow_pushÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.preflowpush.preflow_pushfmoduleõ`fexecedÙ¹‚Ù§xËThe functions that implement flow algorithms and output a residual network, such as this one, are not imported to the base NetworkX namespace, so you have to explicitly import them from the flow package.€Ù´ƒ˜ÖÙ±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„gDiGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulex networkx.classes.digraph.DiGraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2aaÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc3.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2abÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc1.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2aaÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2acÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc3.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2abÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2acÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc5.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2abÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2adÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc4.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2adÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2aeÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc2.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2acÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc2.0Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bs2a"Ù±‚bs2aeÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hcapacityÙ±‚aoa=Ù±‚bmfc3.0Ù±‚`a)Ù±‚`a
Ù±‚`aRÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„lpreflow_pushÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.preflowpush.preflow_pushfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„rmaximum_flow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚`aRÙ±‚aoa.Ù±‚`Ù¢„egraphÙ „hnetworkxm2.7.2rc1.dev0fmodulevnetworkx.classes.graphfmoduleõÙ±‚`a[Ù±‚bs2a"Ù±‚bs2Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚bs2a"Ù±‚`a]dTruefexecedÙ´ƒ•Ù±‚bc1x1# preflow_push also stores the maximum flow valueÙ±‚`a
Ù±‚bc1x,# in the excess attribute of the sink node tÙ±‚`a
Ù±‚`Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚`aRÙ±‚aoa.Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚`a[Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2fexcessÙ±‚bs2a"Ù±‚`a]dTruefexecedÙ´ƒ˜(Ù±‚bc1x5# For some problems, you might only want to compute aÙ±‚`a
Ù±‚bc1r# maximum preflow.Ù±‚`a
Ù±‚`aRÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„lpreflow_pushÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.preflowpush.preflow_pushfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2axÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`jvalue_onlyÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚`aRÙ±‚aoa.Ù±‚`Ù¢„egraphÙ „hnetworkxm2.7.2rc1.dev0fmodulevnetworkx.classes.graphfmoduleõÙ±‚`a[Ù±‚bs2a"Ù±‚bs2Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚bs2a"Ù±‚`a]dTruefexecedÙ´ƒ‘Ù±‚`Ù¢„jflow_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.flow.maxflow.maximum_flow_valuefmoduleõÙ±‚`a Ù±‚aob==Ù±‚`a Ù±‚`aRÙ±‚aoa.Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚`a[Ù±‚bs2a"Ù±‚bs2ayÙ±‚bs2a"Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2fexcessÙ±‚bs2a"Ù±‚`a]dTruefexecedö„Ù¼ƒÙ»ƒledmonds_karpx1networkx.algorithms.flow.edmondskarp.edmonds_karpõÙ¹‚Ù§dmeth€öÙ¼ƒÙ»ƒlmaximum_flowx-networkx.algorithms.flow.maxflow.maximum_flowõÙ¹‚Ù§dmeth€öÙ¼ƒÙ»ƒkminimum_cutx,networkx.algorithms.flow.maxflow.minimum_cutõÙ¹‚Ù§dmeth€öÙ¼ƒÙ»ƒxshortest_augmenting_pathxHnetworkx.algorithms.flow.shortestaugmentingpath.shortest_augmenting_pathõÙ¹‚Ù§dmeth€öm2.7.2rc1.dev0Ù«xbpreflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False)öx1networkx.algorithms.flow.preflowpush.preflow_push€
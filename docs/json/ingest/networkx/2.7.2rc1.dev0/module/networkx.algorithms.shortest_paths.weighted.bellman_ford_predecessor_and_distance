Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x®The algorithm has a running time of $O(mn)$ where $n$ is the number of nodes and $m$ is the number of edges.  It is slower than Dijkstra but can handle negative edge weights.€Ù¹‚ƒÙ§x-If a negative cycle is detected, you can use Ù¢„sfind_negative_cycleÙ „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.algorithms.shortest_paths.weighted.find_negative_cyclefmoduleõÙ§x¶ to return the cycle and examine it. Shortest paths are not defined when a negative cycle exists because once reached, the path can cycle forever to build up arbitrarily low weights.€ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§xgEdge weight attributes must be numerical. Distances are calculated as sums of weighted edges traversed.€Ù¹‚Ù§xMThe dictionaries returned only have keys for nodes reachable from the source.€Ù¹‚Ù§x’In the case where the (di)graph is not connected, if a component not containing the source contains a negative (di)cycle, it will not be detected.€Ù¹‚„Ù§x<In NetworkX v2.1 and prior, the source node had predecessor Ù£ƒf[None]ööÙ§xF. In NetworkX v2.2 this changed to the source node having predecessor Ù£ƒb[]öö€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaGnNetworkX graphÙ¹‚Ù§xWThe algorithm works for all types of graphs, including directed graphs and multigraphs.€Ù°ƒrsource: node label`Ù¹‚Ù§vStarting node for path€Ù°ƒftargettnode label, optionalÙ¹‚Ù§tEnding node for path€Ù°ƒfweightrstring or function‚Ù¹‚‡Ù§x†If this is a string, then edge weights will be accessed via the edge attribute with this key (that is, the weight of the edge joining Ù£ƒauööÙ§d to Ù£ƒavööÙ§i will be Ù¡uG.edges[u, v][weight]Ù§xQ). If no such edge attribute exists, the weight of the edge is assumed to be one.€Ù¹‚Ù§yIf this is a function, the weight of an edge is the value returned by the function. The function must accept exactly three positional arguments: the two endpoints of an edge and the dictionary of edge attributes for that edge. The function must return a number.€Ù°ƒiheuristicdboolÙ¹‚Ù§xeDetermines whether to use a heuristic to early detect negative cycles at a hopefully negligible cost.€öfRaisesÙ¯‚‚Ù°ƒ`lNodeNotFoundÙ¹‚…Ù§cIf Ù£ƒfsourceööÙ§k is not in Ù¢„aGÙ „ööelocalaGelocalõÙ§a.€Ù°ƒ`qNetworkXUnboundedÙ¹‚Ù§xÑIf the (di)graph contains a negative (di)cycle, the algorithm raises an exception to indicate the presence of the negative (di)cycle.  Note: any negative weight edge in an undirected graph is a negative cycle.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒjpred, distldictionariesÙ¹‚Ù§xsReturns two dictionaries keyed by node to predecessor in the path and to the distance from the source respectively.€ögSummaryÙ¯‚Ù¹‚Ù§xTCompute shortest path lengths and predecessors on shortest paths in weighted graphs.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshExampleshSee AlsoeNotesx.networkx/algorithms/shortest_paths/weighted.py^r<class 'function'>x.networkx.bellman_ford_predecessor_and_distanceÙ¯‚…Ù´ƒ˜-Ù±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„jpath_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex&networkx.generators.classic.path_graphfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`lcreate_usingÙ±‚aoa=Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„gDiGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulex networkx.classes.digraph.DiGraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`dpredÙ±‚`a,Ù±‚`a Ù±‚`ddistÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„x%bellman_ford_predecessor_and_distanceÙ „hnetworkxm2.7.2rc1.dev0fmodulexQnetworkx.algorithms.shortest_paths.weighted.bellman_ford_predecessor_and_distancefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)Ù±‚`a
Ù±‚bnbfsortedÙ±‚`a(Ù±‚`dpredÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)x1[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]fexecedÙ´ƒˆÙ±‚bnbfsortedÙ±‚`a(Ù±‚`ddistÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)x([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]fexecedÙ´ƒ˜Ù±‚`dpredÙ±‚`a,Ù±‚`a Ù±‚`ddistÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„x%bellman_ford_predecessor_and_distanceÙ „hnetworkxm2.7.2rc1.dev0fmodulexQnetworkx.algorithms.shortest_paths.weighted.bellman_ford_predecessor_and_distancefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a)Ù±‚`a
Ù±‚bnbfsortedÙ±‚`a(Ù±‚`dpredÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)x1[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]fexecedÙ´ƒˆÙ±‚bnbfsortedÙ±‚`a(Ù±‚`ddistÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)x([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]fexecedÙ´ƒ˜/Ù±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kcycle_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex'networkx.generators.classic.cycle_graphfmoduleõÙ±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚`lcreate_usingÙ±‚aoa=Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„gDiGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulex networkx.classes.digraph.DiGraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2fweightÙ±‚bs2a"Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚aoa-Ù±‚bmia7Ù±‚`a
Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„x%bellman_ford_predecessor_and_distanceÙ „hnetworkxm2.7.2rc1.dev0fmodulexQnetworkx.algorithms.shortest_paths.weighted.bellman_ford_predecessor_and_distancefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)xiTraceback (most recent call last):
    ...
networkx.exception.NetworkXUnbounded: Negative cycle detected.qexception_in_execöÙ¼ƒÙ»ƒsfind_negative_cyclex?networkx.algorithms.shortest_paths.weighted.find_negative_cycleõ€öm2.7.2rc1.dev0Ù«x_bellman_ford_predecessor_and_distance(G, source, target=None, weight='weight', heuristic=False)öxQnetworkx.algorithms.shortest_paths.weighted.bellman_ford_predecessor_and_distance€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§x/A simple path is a path with no repeated nodes.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚Ù§xäThis algorithm uses a modified depth-first search to generate the paths .  A single path can be found in $O(V+E)$ time but the number of simple paths in a graph can be very large, e.g. $O(n!)$ in the complete graph of order $n$.€Ù¹‚‹Ù§x8This function does not check that a path exists between Ù¢„fsourceÙ „ööelocalfsourceelocalõÙ§e and Ù¢„ftargetÙ „ööelocalftargetelocalõÙ§xJ. For large graphs, this may result in very long runtimes. Consider using Ù¢„hhas_pathÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.shortest_paths.generic.has_pathfmoduleõÙ§x% to check that a path exists between Ù¢„fsourceÙ „ööelocalfsourceelocalõÙ§e and Ù¢„ftargetÙ „ööelocalftargetelocalõÙ§x. before calling this function on large graphs.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒaGnNetworkX graph€Ù°ƒfsourcednodeÙ¹‚Ù§vStarting node for path€Ù°ƒftargetenodesÙ¹‚Ù§x5Single node or iterable of nodes at which to end path€Ù°ƒfcutoffqinteger, optionalÙ¹‚Ù§xFDepth to stop the search. Only paths of length <= cutoff are returned.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`xpath_generator: generatorÙ¹‚Ù§xŸA generator that produces lists of simple paths.  If there are no paths between the source and target within the given cutoff the generator produces no output.€ögSummaryÙ¯‚Ù¹‚Ù§x?Generate all simple paths in the graph G from source to target.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshExampleseNotesjReferenceshSee Alsox#networkx/algorithms/simple_paths.pyTr<class 'function'>xnetworkx.all_simple_pathsÙ¯‚‡Ù·‰x>>> G = nx.complete_graph(4)x;>>> for path in nx.all_simple_paths(G, source=0, target=3):s...     print(path)c...l[0, 1, 2, 3]i[0, 1, 3]l[0, 2, 1, 3]i[0, 2, 3]f[0, 3]Ù·ƒx@>>> paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)v>>> print(list(paths))x[[0, 1, 3], [0, 2, 3], [0, 3]]Ù·ˆx6>>> paths = nx.all_simple_paths(G, source=0, target=3)x.>>> for path in map(nx.utils.pairwise, paths):x...     print(list(path))x[(0, 1), (1, 2), (2, 3)]p[(0, 1), (1, 3)]x[(0, 2), (2, 1), (1, 3)]p[(0, 2), (2, 3)]h[(0, 3)]Ù·x>>> G = nx.complete_graph(4)x@>>> for path in nx.all_simple_paths(G, source=0, target=[3, 2]):s...     print(path)c...i[0, 1, 2]l[0, 1, 2, 3]i[0, 1, 3]l[0, 1, 3, 2]f[0, 2]l[0, 2, 1, 3]i[0, 2, 3]f[0, 3]l[0, 3, 1, 2]i[0, 3, 2]Ù·x>>> from itertools import chainx!>>> from itertools import productx!>>> from itertools import starmapx!>>> from functools import partialc>>>x >>> chaini = chain.from_iterablec>>>x4>>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])x3>>> roots = (v for v, d in G.in_degree() if d == 0)x5>>> leaves = (v for v, d in G.out_degree() if d == 0)x/>>> all_paths = partial(nx.all_simple_paths, G)x<>>> list(chaini(starmap(all_paths, product(roots, leaves))))v[[0, 1, 2], [0, 3, 2]]Ù·Šx4>>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])x3>>> roots = (v for v, d in G.in_degree() if d == 0)x5>>> leaves = (v for v, d in G.out_degree() if d == 0)r>>> all_paths = []v>>> for root in roots:x...     for leaf in leaves:x6...         paths = nx.all_simple_paths(G, root, leaf)x#...         all_paths.extend(paths)m>>> all_pathsv[[0, 1, 2], [0, 3, 2]]Ù·‰x4>>> G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])x3>>> roots = (v for v, d in G.in_degree() if d == 0)x5>>> leaves = [v for v, d in G.out_degree() if d == 0]r>>> all_paths = []v>>> for root in roots:x4...     paths = nx.all_simple_paths(G, root, leaves)x...     all_paths.extend(paths)m>>> all_pathsx,[[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]öƒÙ¼ƒÙ»ƒrall_shortest_pathsx=networkx.algorithms.shortest_paths.generic.all_shortest_pathsõ€öÙ¼ƒÙ»ƒhhas_pathx3networkx.algorithms.shortest_paths.generic.has_pathõ€öÙ¼ƒÙ»ƒmshortest_pathx8networkx.algorithms.shortest_paths.generic.shortest_pathõ€öm2.7.2rc1.dev0Ù«x0all_simple_paths(G, source, target, cutoff=None)öx1networkx.algorithms.simple_paths.all_simple_paths€
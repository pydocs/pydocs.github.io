Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚Ù§xµThe idea is that using a 2-tuple (priority, element) works for sorting, but not for dict lookup because priorities are often floating point values so round-off can mess up equality.€Ù¹‚Ù§xSo, we need inequalities to look at the priority (for sorting) and equality (and hash) to look at the element to enable updates to the priority.€Ù¹‚‡Ù§xHUnfortunately, this class can be tricky to work with if you forget that Ù£ƒf__lt__ööÙ§x compares the priority while Ù£ƒf__eq__ööÙ§x compares the element. In Ù£ƒxgreedy_modularity_communities()ööÙ§xa the following code is used to check that two _HeapElements differ in either element or priority:€Ù·x@if d_oldmax != row_max or d_oldmax.priority != row_max.priority:Ù¹‚Ù§x¶If the priorities are the same, this implementation uses the element as a tiebreaker. This provides compatibility with older systems that use tuples to combine priority and elements.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x>This proxy class separates the heap element from its priority.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryxnetworkx/utils/mapped_queue.py	n<class 'type'>x(networkx.utils.mapped_queue._HeapElementÙ¯‚€ö€m2.7.2rc1.dev0Ù«ööx(networkx.utils.mapped_queue._HeapElement€
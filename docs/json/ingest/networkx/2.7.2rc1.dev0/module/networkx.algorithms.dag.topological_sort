Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xìA topological sort is a nonunique permutation of the nodes of a directed graph such that an edge from u to v implies that u appears before v in the topological sort order. This ordering is valid only if the graph has no directed cycles.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§xjThis algorithm is based on a description and proof in "Introduction to Algorithms: A Creative Approach"  .€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒaGpNetworkX digraphÙ¹‚Ù§xA directed acyclic graph (DAG)€öfRaisesÙ¯‚ƒÙ°ƒ`mNetworkXErrorÙ¹‚…Ù§xCTopological sort is defined for directed graphs only. If the graph Ù¢„aGÙ „ööelocalaGelocalõÙ§r is undirected, a Ù£ƒmNetworkXErroröcexcÙ§k is raised.€Ù°ƒ`rNetworkXUnfeasibleÙ¹‚‡Ù§cIf Ù¢„aGÙ „ööelocalaGelocalõÙ§xH is not a directed acyclic graph (DAG) no topological sort exists and a Ù£ƒrNetworkXUnfeasibleöcexcÙ§x2 exception is raised.  This can also be raised if Ù¢„aGÙ „ööelocalaGelocalõÙ§x: is changed while the returned iterator is being processed€Ù°ƒ`lRuntimeErrorÙ¹‚ƒÙ§cIf Ù¢„aGÙ „ööelocalaGelocalõÙ§x; is changed while the returned iterator is being processed.€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x;Returns a generator of nodes in topologically sorted order.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚Ù°ƒ`enodesÙ¹‚Ù§x-Yields the nodes in topological sorted order.€ö‰gSummarypExtended SummaryjParametersfYieldsfRaiseshExampleseNoteshSee AlsojReferencesxnetworkx/algorithms/dag.pyär<class 'function'>xnetworkx.topological_sortÙ¯‚„Ù¹‚Ù§x1To get the reverse order of the topological sort:€Ù´ƒ˜)Ù±‚`bDGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„gDiGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulex networkx.classes.digraph.DiGraphfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bnbdlistÙ±‚`a(Ù±‚bnbÙ¢„hreversedÙ „hnetworkxm2.7.2rc1.dev0fmodulex'networkx.utils.contextmanagers.reversedfmoduleõÙ±‚`a(Ù±‚bnbdlistÙ±‚`a(Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„ptopological_sortÙ „hnetworkxm2.7.2rc1.dev0fmodulex(networkx.algorithms.dag.topological_sortfmoduleõÙ±‚`a(Ù±‚`bDGÙ±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a)i[3, 2, 1]fexecedÙ¹‚ƒÙ§yMIf your DiGraph naturally has the edges representing tasks/inputs and nodes representing people/processes that initiate tasks, then topological_sort is not quite what you need. You will have to change the tasks to nodes with dependence reflected by edges. The result is a kind of topological sort of the edges. This can be done with Ù¢„snetworkx.line_graphÙ „hnetworkxa*capix#networkx.generators.line.line_graphfmoduleõÙ§l as follows:€Ù´ƒÙ±‚bnbdlistÙ±‚`a(Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„ptopological_sortÙ „hnetworkxm2.7.2rc1.dev0fmodulex(networkx.algorithms.dag.topological_sortfmoduleõÙ±‚`a(Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„jline_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex#networkx.generators.line.line_graphfmoduleõÙ±‚`a(Ù±‚`bDGÙ±‚`a)Ù±‚`a)Ù±‚`a)p[(1, 2), (2, 3)]fexecedö‚Ù¼ƒÙ»ƒxis_directed_acyclic_graphx1networkx.algorithms.dag.is_directed_acyclic_graphõ€öÙ¼ƒÙ»ƒx lexicographical_topological_sortx8networkx.algorithms.dag.lexicographical_topological_sortõ€öm2.7.2rc1.dev0Ù«stopological_sort(G)öx(networkx.algorithms.dag.topological_sort€
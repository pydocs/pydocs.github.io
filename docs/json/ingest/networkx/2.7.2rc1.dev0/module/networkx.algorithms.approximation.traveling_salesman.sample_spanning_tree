Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§xtThe edge weights are multiplicative, so the probability of each tree is proportional to the product of edge weights.€Ù¹‚Ù§x,The algorithm itself uses algorithm A8 in  .€Ù¹‚Ù§yWe 'shuffle' the edges in the graph, and then probabilistically determine weather to add the edge conditioned on all of the previous edges which where added to the tree. Probabilities are calculated using Kirchhoff's Matrix Tree Theorem and a weighted Laplacian matrix.€Ù¹‚Ù§xAt each iteration, we contract the edges we have decided to include in the sampled tree and delete those which we have decided not to include.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaGhnx.GraphÙ¹‚Ù§x,An undirected version of the original graph.€Ù°ƒjlambda_keyfstringÙ¹‚Ù§x8The edge key for the edge attribute holding edge weight.€Ù°ƒdseedx(integer, random_state, or None (default)Ù¹‚ƒÙ§x1Indicator of random number generation state. See Ù£ƒvRandomness<randomness>öcrefÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`hnx.GraphÙ¹‚ƒÙ§x2A spanning tree using the distribution defined by Ù£ƒegammaööÙ§a.€ögSummaryÙ¯‚Ù¹‚Ù§x<Sample a spanning tree using the edges weights of the graph.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametersgReturnsjReferencesx7networkx/algorithms/approximation/traveling_salesman.py°r<class 'function'>x>networkx.approximation.traveling_salesman.sample_spanning_treeÙ¯‚€ö€m2.7.2rc1.dev0Ù«x.sample_spanning_tree(G, lambda_key, seed=None)öxInetworkx.algorithms.approximation.traveling_salesman.sample_spanning_tree€
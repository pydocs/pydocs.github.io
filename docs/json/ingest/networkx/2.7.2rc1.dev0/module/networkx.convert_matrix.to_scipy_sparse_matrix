Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚†Ù¹‚Ù§xIFor directed graphs, matrix entry i,j corresponds to an edge from i to j.€Ù¹‚Ù§x›The matrix entries are populated using the edge attribute held in parameter weight. When an edge does not have that attribute, the value of the entry is 1.€Ù¹‚Ù§xFFor multiple edges the matrix values are the sums of the edge weights.€Ù¹‚‰Ù§eWhen Ù¢„hnodelistÙ „ööelocalhnodelistelocalõÙ§x  does not contain every node in Ù¢„aGÙ „ööelocalaGelocalõÙ§x5, the adjacency matrix is built from the subgraph of Ù¢„aGÙ „ööelocalaGelocalõÙ§x! that is induced by the nodes in Ù¢„hnodelistÙ „ööelocalhnodelistelocalõÙ§a.€Ù¹‚Ù§y;The convention used for self-loop edges in graphs is to assign the diagonal matrix entry value to the weight attribute of the edge (or the number 1 if the edge has no weight attribute).  If the alternate convention of doubling the edge weight is desired the resulting Scipy sparse matrix can be modified as follows:€ÙÀx™>>> G = nx.Graph([(1, 1)])
>>> A = nx.to_scipy_sparse_matrix(G)
>>> print(A.todense())
[[1]]
>>> A.setdiag(A.diagonal() * 2)
>>> print(A.todense())
[[2]]öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaGegraphÙ¹‚Ù§x7The NetworkX graph used to construct the sparse matrix.€Ù°ƒhnodelistnlist, optionalÙ¹‚…Ù§x;The rows and columns are ordered according to the nodes in Ù¢„hnodelistÙ „ööelocalhnodelistelocalõÙ§e. If Ù¢„hnodelistÙ „ööelocalhnodelistelocalõÙ§x5 is None, then the ordering is produced by G.nodes().€Ù°ƒedtypexNumPy data-type, optionalÙ¹‚Ù§xZA valid NumPy dtype used to initialize the array. If None, then the NumPy default is used.€Ù°ƒfweightx,string or None   optional (default='weight')Ù¹‚Ù§xqThe edge attribute that holds the numerical value used for the edge weight.  If None then all edge weights are 1.€Ù°ƒfformatx8str in {'bsr', 'csr', 'csc', 'coo', 'lil', 'dia', 'dok'}Ù¹‚Ù§xŸThe type of the matrix to be returned (default 'csr').  For some algorithms different implementations of sparse matrices can perform better.  See  for details.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒaAsSciPy sparse matrixÙ¹‚Ù§wGraph adjacency matrix.€ögSummaryÙ¯‚Ù¹‚Ù§x<Returns the graph adjacency matrix as a SciPy sparse matrix.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummaryjParametersgReturnseNoteshExamplesjReferencesxnetworkx/convert_matrix.py r<class 'function'>xnetworkx.to_scipy_sparse_matrixÙ¯‚…Ù´ƒ˜Ù±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„lMultiDiGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulex*networkx.classes.multidigraph.MultiDiGraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bmia2Ù±‚`a)a0fexecedÙ´ƒ‰Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)a0fexecedÙ´ƒÙ±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)a0fexecedÙ´ƒ‰Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)a1fexecedÙ´ƒ˜ Ù±‚`aSÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„vto_scipy_sparse_matrixÙ „hnetworkxm2.7.2rc1.dev0fmodulex.networkx.convert_matrix.to_scipy_sparse_matrixfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`hnodelistÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚bnbÙ¢„eprintÙ „hnetworkxm2.7.2rc1.dev0fmodulex*networkx.algorithms.similarity.debug_printfmoduleõÙ±‚`a(Ù±‚`aSÙ±‚aoa.Ù±‚`gtodenseÙ±‚`a(Ù±‚`a)Ù±‚`a)x[[0 2 0]
 [1 0 0]
 [0 0 4]]fexecedö€m2.7.2rc1.dev0Ù«xSto_scipy_sparse_matrix(G, nodelist=None, dtype=None, weight='weight', format='csr')öx.networkx.convert_matrix.to_scipy_sparse_matrix€
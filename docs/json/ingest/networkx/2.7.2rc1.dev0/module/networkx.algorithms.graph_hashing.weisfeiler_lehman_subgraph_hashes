Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§xÈThe dictionary is keyed by node to a list of hashes in increasingly sized induced subgraphs containing the nodes within 2*k edges of the key node for increasing integer k until all nodes are included.€Ù¹‚Ù§y%The function iteratively aggregates and hashes neighbourhoods of each node. This is achieved for each step by replacing for each node its label from the previous iteration with its hashed 1-hop neighborhood aggregate. The new node label is then appended to a list of node labels for each node.€Ù¹‚ƒÙ§xuTo aggregate neighborhoods at each step for a node $n$, all labels of nodes adjacent to $n$ are concatenated. If the Ù£ƒiedge_attrööÙ§xö parameter is set, labels for each neighboring node are prefixed with the value of this attribute along the connecting edge from this neighbor to node $n$. The resulting string is then hashed to compress this information into a fixed digest size.€Ù¹‚Ù§xİThus, at the $i$th iteration nodes within $2i$ distance influence any given hashed node label. We can therefore say that at depth $i$ for node $n$ we have a hash for a subgraph induced by the $2i$-hop neighborhood of $n$.€Ù¹‚Ù§xŞCan be used to to create general Weisfeiler-Lehman graph kernels, or generate features for graphs or nodes, for example to generate 'words' in a graph as seen in the 'graph2vec' algorithm. See  &  respectively for details.€Ù¹‚Ù§x—Hashes are identical for isomorphic subgraphs and there exist strong guarantees that non-isomorphic graphs will get different hashes. See  for details.€Ù¹‚Ù§x¢If no node or edge attributes are provided, the degree of each node is used as its initial label. Otherwise, node and/or edge labels are used to compute the hash.€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚ƒÙ§x@To hash the full graph when subgraph hashes are not needed, use Ù¢„xweisfeiler_lehman_graph_hashÙ „hnetworkxm2.7.2rc1.dev0fmodulex>networkx.algorithms.graph_hashing.weisfeiler_lehman_graph_hashfmoduleõÙ§p for efficiency.€Ù¹‚Ù§xCSimilarity between hashes does not imply similarity between graphs.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒhG: graph`Ù¹‚Ù§xZThe graph to be hashed. Can have node and/or edge attributes. Can also have no attributes.€Ù°ƒxedge_attr: string, default=None`Ù¹‚Ù§x^The key in edge attribute dictionary to be used for hashing. If None, edge labels are ignored.€Ù°ƒxnode_attr: string, default=None`Ù¹‚Ù§x…The key in node attribute dictionary to be used for hashing. If None, and no edge_attr given, use the degrees of the nodes as labels.€Ù°ƒxiterations: int, default=3`Ù¹‚Ù§xONumber of neighbor aggregations to perform. Should be larger for larger graphs.€Ù°ƒxdigest_size: int, default=16`Ù¹‚Ù§xaSize (in bits) of blake2b hash digest to use for hashing node labels. The default size is 16 bits€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒtnode_subgraph_hashesddictÙ¹‚Ù§xA dictionary with each key given by a node in G, and each value given by the subgraph hashes in order of depth from the key node.€ögSummaryÙ¯‚Ù¹‚Ù§x/Return a dictionary of subgraph hashes by node.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshExampleseNotesjReferenceshSee Alsox$networkx/algorithms/graph_hashing.py r<class 'function'>x*networkx.weisfeiler_lehman_subgraph_hashesÙ¯‚ˆÙ¹‚Ù§x*Finding similar nodes in different graphs:€Ù´ƒ˜¯Ù±‚`bG1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„eGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.graph.GraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`bG1Ù±‚aoa.Ù±‚`nadd_edges_fromÙ±‚`a(Ù±‚`a[Ù±‚`a
Ù±‚`d    Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a)Ù±‚`a
Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bG2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„eGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.graph.GraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`bG2Ù±‚aoa.Ù±‚`nadd_edges_fromÙ±‚`a(Ù±‚`a[Ù±‚`a
Ù±‚`d    Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a)Ù±‚`a
Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`ig1_hashesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„x!weisfeiler_lehman_subgraph_hashesÙ „hnetworkxm2.7.2rc1.dev0fmodulexCnetworkx.algorithms.graph_hashing.weisfeiler_lehman_subgraph_hashesfmoduleõÙ±‚`a(Ù±‚`bG1Ù±‚`a,Ù±‚`a Ù±‚`jiterationsÙ±‚aoa=Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`kdigest_sizeÙ±‚aoa=Ù±‚bmia8Ù±‚`a)Ù±‚`a
Ù±‚`ig2_hashesÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„x!weisfeiler_lehman_subgraph_hashesÙ „hnetworkxm2.7.2rc1.dev0fmodulexCnetworkx.algorithms.graph_hashing.weisfeiler_lehman_subgraph_hashesfmoduleõÙ±‚`a(Ù±‚`bG2Ù±‚`a,Ù±‚`a Ù±‚`jiterationsÙ±‚aoa=Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`kdigest_sizeÙ±‚aoa=Ù±‚bmia8Ù±‚`a)`fexecedÙ¹‚Ù§xœEven though G1 and G2 are not isomorphic (they have different numbers of edges), the hash sequence of depth 3 for node 1 in G1 and node 5 in G2 are similar:€Ù´ƒ„Ù±‚`ig1_hashesÙ±‚`a[Ù±‚bmia1Ù±‚`a]x<['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']fexecedÙ´ƒ„Ù±‚`ig2_hashesÙ±‚`a[Ù±‚bmia5Ù±‚`a]x<['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc']fexecedÙ¹‚Ù§yThe first 2 WL subgraph hashes match. From this we can conclude that it's very likely the neighborhood of 4 hops around these nodes are isomorphic: each iteration aggregates 1-hop neighbourhoods meaning hashes at depth $n$ are influenced by every node within $2n$ hops.€Ù¹‚Ù§x_However the neighborhood of 6 hops is no longer isomorphic since their 3rd hash does not match.€Ù¹‚Ù§x^These nodes may be candidates to be classified together since their local topology is similar.€öÙ¼ƒÙ»ƒxweisfeiler_lehman_graph_hashx>networkx.algorithms.graph_hashing.weisfeiler_lehman_graph_hashõ€öm2.7.2rc1.dev0Ù«xbweisfeiler_lehman_subgraph_hashes(G, edge_attr=None, node_attr=None, iterations=3, digest_size=16)öxCnetworkx.algorithms.graph_hashing.weisfeiler_lehman_subgraph_hashes€
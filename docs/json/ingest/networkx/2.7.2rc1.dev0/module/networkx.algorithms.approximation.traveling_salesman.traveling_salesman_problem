Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x°This function allows approximate solution to the traveling salesman problem on networks that are not complete graphs and/or where the salesman does not need to visit all nodes.€Ù¹‚‡Ù§x|This function proceeds in two steps. First, it creates a complete graph using the all-pairs shortest_paths between nodes in Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ§x. Edge weights in the new graph are the lengths of the paths between each pair of nodes in the original graph. Second, an algorithm (default: Ù¢„lchristofidesÙ „hnetworkxm2.7.2rc1.dev0fmodulexAnetworkx.algorithms.approximation.traveling_salesman.christofidesfmoduleõÙ§t for undirected and Ù¢„masadpour_atspÙ „hnetworkxm2.7.2rc1.dev0fmodulexBnetworkx.algorithms.approximation.traveling_salesman.asadpour_atspfmoduleõÙ§xt for directed) is used to approximate the minimal Hamiltonian cycle on this new graph. The available algorithms are:€Ù·…n- christofidesl- greedy_tspx- simulated_annealing_tspx- threshold_accepting_tspo- asadpour_atspÙ¹‚…Ù§xyOnce the Hamiltonian Cycle is found, this function post-processes to accommodate the structure of the original graph. If Ù¢„ecycleÙ „ööelocalecycleelocalõÙ§d is Ù¡eFalseÙ§xÌ, the biggest weight edge is removed to make a Hamiltonian path. Then each edge on the new complete graph used for that analysis is replaced by the shortest_path between those nodes on the original graph.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaGnNetworkX graphÙ¹‚Ù§xA possibly weighted graph€Ù°ƒenodesx%collection of nodes (default=G.nodes)Ù¹‚Ù§x.collection (list, set, etc.) of nodes to visit€Ù°ƒfweightx#string, optional (default="weight")Ù¹‚Ù§xpEdge data key corresponding to the edge weight. If any edge does not have this attribute the weight is set to 1.€Ù°ƒecycletbool (default: True)Ù¹‚Ù§x¢Indicates whether a cycle should be returned, or a path. Note: the cycle is the approximate minimal cycle. The path simply removes the biggest edge in that cycle.€Ù°ƒfmethodxfunction (default: None)„Ù¹‚‰Ù§xÆA function that returns a cycle on all nodes and approximates the solution to the traveling salesman problem on a complete graph. The returned cycle is then used to find a corresponding solution on Ù¢„aGÙ „ööelocalaGelocalõÙ§b. Ù¢„fmethodÙ „ööelocalfmethodelocalõÙ§x! should be callable; take inputs Ù¢„aGÙ „ööelocalaGelocalõÙ§f, and Ù¢„fweightÙ „ööelocalfweightelocalõÙ§x-; and return a list of nodes along the cycle.€Ù¹‚‰Ù§xProvided options include Ù¢„lchristofidesÙ „hnetworkxm2.7.2rc1.dev0fmodulexAnetworkx.algorithms.approximation.traveling_salesman.christofidesfmoduleõÙ§b, Ù¢„jgreedy_tspÙ „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.algorithms.approximation.traveling_salesman.greedy_tspfmoduleõÙ§b, Ù¢„wsimulated_annealing_tspÙ „hnetworkxm2.7.2rc1.dev0fmodulexLnetworkx.algorithms.approximation.traveling_salesman.simulated_annealing_tspfmoduleõÙ§e and Ù¢„wthreshold_accepting_tspÙ „hnetworkxm2.7.2rc1.dev0fmodulexLnetworkx.algorithms.approximation.traveling_salesman.threshold_accepting_tspfmoduleõÙ§a.€Ù¹‚‹Ù§cIf Ù£ƒnmethod is NoneööÙ§f: use Ù¢„lchristofidesÙ „hnetworkxm2.7.2rc1.dev0fmodulexAnetworkx.algorithms.approximation.traveling_salesman.christofidesfmoduleõÙ§p for undirected Ù¢„aGÙ „ööelocalaGelocalõÙ§e and Ù¢„wthreshold_accepting_tspÙ „hnetworkxm2.7.2rc1.dev0fmodulexLnetworkx.algorithms.approximation.traveling_salesman.threshold_accepting_tspfmoduleõÙ§n for directed Ù¢„aGÙ „ööelocalaGelocalõÙ§a.€Ù¹‚ƒÙ§xnTo specify parameters for these provided functions, construct lambda functions that state the specific value. Ù¢„fmethodÙ „ööelocalfmethodelocalõÙ§x$ must have 2 inputs. (See examples).€öfRaisesÙ¯‚Ù°ƒ`mNetworkXErrorÙ¹‚ƒÙ§cIf Ù¢„aGÙ „ööelocalaGelocalõÙ§xa is a directed graph it has to be strongly connected or the complete version cannot be generated.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`dlistÙ¹‚…Ù§qList of nodes in Ù¢„aGÙ „ööelocalaGelocalõÙ§x@ along a path with an approximation of the minimal path through Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ§a.€ögSummaryÙ¯‚Ù¹‚ƒÙ§xFind the shortest path in Ù¢„aGÙ „ööelocalaGelocalõÙ§x connecting specified nodes€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnsfRaiseshExamplesx7networkx/algorithms/approximation/traveling_salesman.pyÇr<class 'function'>x1networkx.approximation.traveling_salesman_problemÙ¯‚„Ù´ƒ˜6Ù±‚`ctspÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„mapproximationÙ „hnetworkxm2.7.2rc1.dev0fmodulex!networkx.algorithms.approximationfmoduleõÙ±‚aoa.Ù±‚`Ù¢„xtraveling_salesman_problemÙ „hnetworkxm2.7.2rc1.dev0fmodulexOnetworkx.algorithms.approximation.traveling_salesman.traveling_salesman_problemfmoduleõÙ±‚`a
Ù±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kcycle_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex'networkx.generators.classic.cycle_graphfmoduleõÙ±‚`a(Ù±‚bmia9Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚`a[Ù±‚bmia4Ù±‚`a]Ù±‚`a[Ù±‚bmia5Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2fweightÙ±‚bs2a"Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia5Ù±‚`b  Ù±‚bc1x# all other weights are 1Ù±‚`a
Ù±‚`ctspÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚aoa=Ù±‚`a[Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a)x'[3, 2, 1, 0, 8, 7, 6, 7, 8, 0, 1, 2, 3]fexecedÙ´ƒ˜LÙ±‚`dpathÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`ctspÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`ecycleÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`dpathÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`a(Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)dTruefexecedÙ¹‚Ù§xKBuild (curry) your own function to provide parameter values to the methods.€Ù´ƒ˜{Ù±‚`fSA_tspÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„mapproximationÙ „hnetworkxm2.7.2rc1.dev0fmodulex!networkx.algorithms.approximationfmoduleõÙ±‚aoa.Ù±‚`Ù¢„wsimulated_annealing_tspÙ „hnetworkxm2.7.2rc1.dev0fmodulexLnetworkx.algorithms.approximation.traveling_salesman.simulated_annealing_tspfmoduleõÙ±‚`a
Ù±‚`fmethodÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚akflambdaÙ±‚`a Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`bwtÙ±‚`a:Ù±‚`a Ù±‚`fSA_tspÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2fgreedyÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚`bwtÙ±‚`a,Ù±‚`a Ù±‚`dtempÙ±‚aoa=Ù±‚bmic500Ù±‚`a)Ù±‚`a
Ù±‚`dpathÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`ctspÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`ecycleÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a,Ù±‚`a Ù±‚`fmethodÙ±‚aoa=Ù±‚`fmethodÙ±‚`a)Ù±‚`a
Ù±‚`dpathÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`a(Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmia5Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia7Ù±‚`a,Ù±‚`a Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚bmia4Ù±‚`a]Ù±‚`a)dTruefexecedö€m2.7.2rc1.dev0Ù«xStraveling_salesman_problem(G, weight='weight', nodes=None, cycle=True, method=None)öxOnetworkx.algorithms.approximation.traveling_salesman.traveling_salesman_problem€
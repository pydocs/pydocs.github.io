Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚†Ù¹‚ƒÙ§dThe Ù¨Ù§neffective sizeÙ§yT of a node's ego network is based on the concept of redundancy. A person's ego network has redundancy to the extent that her contacts are connected to each other as well. The nonredundant part of a person's relationships it's the effective size of her ego network .  Formally, the effective size of a node $u$, denoted $e(u)$, is defined by€Ù¤xle ( u) = \sum_ { v \in N ( u) \setminus \ { u\}} \left ( 1 - \sum_ { w \in N ( v)} p_ { uw} m_ { vw}\right) Ù¹‚ƒÙ§y'where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the normalized mutual weight of the (directed or undirected) edges joining $u$ and $v$, for each vertex $u$ and $v$ . And $m_{vw}$ is the mutual weight of $v$ and $w$ divided by $v$ highest mutual weight with any of its neighbors. The Ù¨Ù§mmutual weightÙ§x€ of $u$ and $v$ is the sum of the weights of edges joining them (edge weights are assumed to be one if the graph is unweighted).€Ù¹‚Ù§xrFor the case of unweighted and undirected graphs, Borgatti proposed a simplified formula to compute effective size€Ù¤xe ( u) = n - \frac { 2t} { n} Ù¹‚…Ù§fwhere Ù£ƒatööÙ§xJ is the number of ties in the ego network (not including ties to ego) and Ù£ƒanööÙ§x( is the number of nodes (excluding ego).€ögMethodsÙ¯‚€öeNotesÙ¯‚‚Ù¹‚ƒÙ§x)Burt also defined the related concept of Ù¨Ù§jefficiencyÙ§x€ of a node's ego network, which is its effective size divided by the degree of that node . So you can easily compute efficiency:€ÙÀx¬>>> G = nx.DiGraph()
>>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])
>>> esize = nx.effective_size(G)
>>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaGnNetworkX graphÙ¹‚…Ù§uThe graph containing Ù¡avÙ§xQ. Directed graphs are treated like undirected graphs when computing neighbors of Ù¡avÙ§a.€Ù°ƒenodesscontainer, optionalÙ¹‚ƒÙ§x Container of nodes in the graph Ù¡aGÙ§xV to compute the effective size. If None, the effective size of every node is computed.€Ù°ƒfweightxNone or string, optionalÙ¹‚Ù§xnIf None, all edge weights are considered equal. Otherwise holds the name of the edge attribute used as weight.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`ddictÙ¹‚Ù§xKDictionary with nodes as keys and the effective size of the node as values.€ögSummaryÙ¯‚Ù¹‚ƒÙ§x5Returns the effective size of all nodes in the graph Ù¡aGÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNoteshSee AlsojReferencesx&networkx/algorithms/structuralholes.py2r<class 'function'>wnetworkx.effective_sizeÙ¯‚€öÙ¼ƒÙ»ƒjconstraintx.networkx.algorithms.structuralholes.constraintõ€öm2.7.2rc1.dev0Ù«x*effective_size(G, nodes=None, weight=None)öx2networkx.algorithms.structuralholes.effective_size€
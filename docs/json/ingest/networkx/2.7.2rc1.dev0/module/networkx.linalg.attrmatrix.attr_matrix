Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚ƒÙ§hIf only Ù¢„aGÙ „ööelocalaGelocalõÙ§x8 is passed in, then the adjacency matrix is constructed.€Ù¹‚‰Ù§x9Let A be a discrete set of values for the node attribute Ù¢„inode_attrÙ „ööelocalinode_attrelocalõÙ§x~. Then the elements of A represent the rows and columns of the constructed matrix. Now, iterate through every edge e=(u,v) in Ù¢„aGÙ „ööelocalaGelocalõÙ§x. and consider the value of the edge attribute Ù¢„iedge_attrÙ „ööelocaliedge_attrelocalõÙ§x5.  If ua and va are the values of the node attribute Ù¢„inode_attrÙ „ööelocalinode_attrelocalõÙ§xl for u and v, respectively, then the value of the edge attribute is added to the matrix element at (ua, va).€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚‚Ù°ƒedtypexNumPy data-type, optionalÙ¹‚Ù§xáA valid NumPy dtype used to initialize the array. Keep in mind certain dtypes can yield unexpected results if the array is to be normalized. The parameter is passed to numpy.zeros(). If unspecified, the NumPy default is used.€Ù°ƒeordert{'C', 'F'}, optionalÙ¹‚Ù§x¿Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory. This parameter is passed to numpy.zeros(). If unspecified, the NumPy default is used.€öjParametersÙ¯‚…Ù°ƒaGegraphÙ¹‚Ù§x6The NetworkX graph used to construct the NumPy matrix.€Ù°ƒiedge_attrmstr, optionalÙ¹‚Ù§yWEach element of the matrix represents a running total of the specified edge attribute for edges whose node attributes correspond to the rows/cols of the matirx. The attribute must be present for all edges in the graph. If no attribute is specified, then we just count the number of edges whose node attributes correspond to the matrix element.€Ù°ƒinode_attrmstr, optionalÙ¹‚Ù§yOEach row and column in the matrix represents a particular value of the node attribute.  The attribute must be present for all nodes in the graph. Note, the values of this attribute should be reliably hashable. So, float values are not recommended. If no attribute is specified, then the rows and columns will be the nodes of the graph.€Ù°ƒjnormalizednbool, optionalÙ¹‚Ù§xDIf True, then each row is normalized by the summation of its values.€Ù°ƒhrc_ordernlist, optionalÙ¹‚Ù§xÀA list of the node attribute values. This list specifies the ordering of rows and columns of the array. If no ordering is provided, then the ordering will be random (and also, a return value).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaMlNumPy matrixÙ¹‚Ù§uThe attribute matrix.€Ù°ƒhorderingdlistÙ¹‚…Ù§cIf Ù¢„hrc_orderÙ „ööelocalhrc_orderelocalõÙ§x> was specified, then only the matrix is returned. However, if Ù¢„hrc_orderÙ „ööelocalhrc_orderelocalõÙ§xN was None, then the ordering used to construct the matrix is returned as well.€ögSummaryÙ¯‚Ù¹‚Ù§x/Returns a NumPy matrix using attributes from G.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParameterspOther ParametersgReturnshExamplesxnetworkx/linalg/attrmatrix.pyr<class 'function'>tnetworkx.attr_matrixÙ¯‚Ù¹‚Ù§xConstruct an adjacency matrix:€Ù´ƒ˜OÙ±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„eGraphÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.graph.GraphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`ithicknessÙ±‚aoa=Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`ithicknessÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`ithicknessÙ±‚aoa=Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kattr_matrixÙ „hnetworkxm2.7.2rc1.dev0fmodulex&networkx.linalg.attrmatrix.attr_matrixfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`hrc_orderÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)xBmatrix([[0., 1., 1.],
        [1., 0., 1.],
        [1., 1., 0.]])fexecedÙ¹‚Ù§xBAlternatively, we can obtain the matrix describing edge thickness.€Ù´ƒ˜Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kattr_matrixÙ „hnetworkxm2.7.2rc1.dev0fmodulex&networkx.linalg.attrmatrix.attr_matrixfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`iedge_attrÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2ithicknessÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hrc_orderÙ±‚aoa=Ù±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)xBmatrix([[0., 1., 2.],
        [1., 0., 3.],
        [2., 3., 0.]])fexecedÙ¹‚Ù§xeWe can also color the nodes and ask for the probability distribution over all edges (u,v) describing:€Ù·x!Pr(v has color Y | u has color X)Ù´ƒ˜\Ù±‚`aGÙ±‚aoa.Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2Ù¢„ecolorÙ „hnetworkxm2.7.2rc1.dev0fmodulex)networkx.algorithms.bipartite.basic.colorfmoduleõÙ±‚bs2a"Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bs2a"Ù±‚bs2credÙ±‚bs2a"Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚`a[Ù±‚bmia1Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2Ù¢„ecolorÙ „hnetworkxm2.7.2rc1.dev0fmodulex)networkx.algorithms.bipartite.basic.colorfmoduleõÙ±‚bs2a"Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bs2a"Ù±‚bs2credÙ±‚bs2a"Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`Ù¢„enodesÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.classes.function.nodesfmoduleõÙ±‚`a[Ù±‚bmia2Ù±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2Ù¢„ecolorÙ „hnetworkxm2.7.2rc1.dev0fmodulex)networkx.algorithms.bipartite.basic.colorfmoduleõÙ±‚bs2a"Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bs2a"Ù±‚bs2dblueÙ±‚bs2a"Ù±‚`a
Ù±‚`brcÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a[Ù±‚bs2a"Ù±‚bs2credÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2dblueÙ±‚bs2a"Ù±‚`a]Ù±‚`a
Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kattr_matrixÙ „hnetworkxm2.7.2rc1.dev0fmodulex&networkx.linalg.attrmatrix.attr_matrixfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`inode_attrÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2Ù¢„ecolorÙ „hnetworkxm2.7.2rc1.dev0fmodulex)networkx.algorithms.bipartite.basic.colorfmoduleõÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`jnormalizedÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a,Ù±‚`a Ù±‚`hrc_orderÙ±‚aoa=Ù±‚`brcÙ±‚`a)xDmatrix([[0.33333333, 0.66666667],
        [1.        , 0.        ]])fexecedÙ¹‚Ù§x9For example, the above tells us that for all edges (u,v):€Ù·‚x Pr( v is red  | u is red)  = 1/3x Pr( v is blue | u is red)  = 2/3Ù·‚xPr( v is red  | u is blue) = 1xPr( v is blue | u is blue) = 0Ù¹‚Ù§xCFinally, we can obtain the total weights listed by the node colors.€Ù´ƒ˜Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kattr_matrixÙ „hnetworkxm2.7.2rc1.dev0fmodulex&networkx.linalg.attrmatrix.attr_matrixfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`iedge_attrÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2fweightÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`inode_attrÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2Ù¢„ecolorÙ „hnetworkxm2.7.2rc1.dev0fmodulex)networkx.algorithms.bipartite.basic.colorfmoduleõÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hrc_orderÙ±‚aoa=Ù±‚`brcÙ±‚`a)x$matrix([[3., 2.],
        [2., 0.]])fexecedÙ¹‚Ù§xGThus, the total weight over all edges (u,v) with u and v having colors:€Ù·„x>(red, red)   is 3   # the sole contribution is from edge (0,1)x>(red, blue)  is 2   # contributions from edges (0,2) and (1,2)xC(blue, red)  is 2   # same as (red, blue) since graph is undirectedx<(blue, blue) is 0   # there are no edges with blue endpointsö€m2.7.2rc1.dev0Ù«xgattr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None)öx&networkx.linalg.attrmatrix.attr_matrix€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xÉA maximum spanning tree is a subgraph of the graph (a tree) with the maximum possible sum of edge weights.  A spanning forest is a union of the spanning trees for each connected component of the graph.€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚Ù§xhFor BorÅ¯vka's algorithm, each edge must have a weight attribute, and each edge weight must be distinct.€Ù¹‚Ù§xoFor the other algorithms, if the graph edges do not have a weight attribute a default weight of 1 will be used.€Ù¹‚Ù§xTModified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒaGpundirected GraphÙ¹‚ƒÙ§xAn undirected graph. If Ù¢„aGÙ „ööelocalaGelocalõÙ§x_ is connected, then the algorithm finds a spanning tree. Otherwise, a spanning forest is found.€Ù°ƒialgorithmfstringÙ¹‚Ù§x‡The algorithm to use when finding a maximum spanning tree. Valid choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.€Ù°ƒfweightfstringÙ¹‚Ù§x3Edge data key to use for weight (default 'weight').€Ù°ƒdkeysdboolÙ¹‚ƒÙ§xEWhether to yield edge key in multigraphs in addition to the edge. If Ù¢„aGÙ „ööelocalaGelocalõÙ§x& is not a multigraph, this is ignored.€Ù°ƒddatanbool, optionalÙ¹‚Ù§x0If True yield the edge data along with the edge.€Ù°ƒjignore_nanubool (default: False)Ù¹‚ƒÙ§xHIf a NaN is found as an edge weight normally an exception is raised. If Ù£ƒrignore_nan is TrueööÙ§x# then that edge is ignored instead.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒeedgeshiteratorƒÙ¹‚Ù§x5An iterator over edges in a maximum spanning tree of Ù¢„aGÙ „ööelocalaGelocalõÙ§x. Edges connecting nodes Ù£ƒauööÙ§e and Ù£ƒavööÙ§x are represented as tuples: Ù£ƒl(u, v, k, d)ööÙ§d or Ù£ƒi(u, v, k)ööÙ§d or Ù£ƒi(u, v, d)ööÙ§d or Ù£ƒf(u, v)öö€Ù¹‚‹Ù§cIf Ù¢„aGÙ „ööelocalaGelocalõÙ§r is a multigraph, Ù¢„dkeysÙ „hnetworkxm2.7.2rc1.dev0fmodulex:networkx.readwrite.graphml.GraphMLReader.find_graphml_keysfmoduleõÙ§x  indicates whether the edge key Ù£ƒakööÙ§x; will be reported in the third position in the edge tuple. Ù¢„ddataÙ „ööelocalddataelocalõÙ§x% indicates whether the edge datadict Ù£ƒadööÙ§x* will appear at the end of the edge tuple.€Ù¹‚‹Ù§cIf Ù¢„aGÙ „ööelocalaGelocalõÙ§x% is not a multigraph, the tuples are Ù£ƒi(u, v, d)ööÙ§d if Ù¢„ddataÙ „ööelocalddataelocalõÙ§l is True or Ù£ƒf(u, v)ööÙ§d if Ù¢„ddataÙ „ööelocalddataelocalõÙ§j is False.€ögSummaryÙ¯‚Ù¹‚Ù§xLGenerate edges in a maximum spanning forest of an undirected weighted graph.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshExampleseNotesxnetworkx/algorithms/tree/mst.py¿r<class 'function'>xnetworkx.maximum_spanning_edgesÙ¯‚…Ù´ƒ‰Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„hnetworkxÙ „hnetworkxm2.7.2rc1.dev0fmodulehnetworkxfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jalgorithmsÙ „hnetworkxm2.7.2rc1.dev0fmodulesnetworkx.algorithmsfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„dtreeÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.treefmoduleõ`fexecedÙ¹‚Ù§x2Find maximum spanning edges by Kruskal's algorithm€Ù´ƒ˜IÙ±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kcycle_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex'networkx.generators.classic.cycle_graphfmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„cmstÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.tree.mstfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dtreeÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.treefmoduleõÙ±‚aoa.Ù±‚`Ù¢„vmaximum_spanning_edgesÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.tree.mst.maximum_spanning_edgesfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`ialgorithmÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2Ù¢„gkruskalÙ „hnetworkxm2.7.2rc1.dev0fmodulex.networkx.algorithms.tree.mst.kruskal_mst_edgesfmoduleõÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`ddataÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`hedgelistÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbdlistÙ±‚`a(Ù±‚`Ù¢„cmstÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.tree.mstfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚bnbfsortedÙ±‚`a(Ù±‚bnbfsortedÙ±‚`a(Ù±‚`aeÙ±‚`a)Ù±‚`a Ù±‚akcforÙ±‚`a Ù±‚`aeÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`hedgelistÙ±‚`a)x[[0, 1], [0, 3], [1, 2]]fexecedÙ¹‚Ù§x/Find maximum spanning edges by Prim's algorithm€Ù´ƒ˜KÙ±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„kcycle_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex'networkx.generators.classic.cycle_graphfmoduleõÙ±‚`a(Ù±‚bmia4Ù±‚`a)Ù±‚`a
Ù±‚`aGÙ±‚aoa.Ù±‚`hadd_edgeÙ±‚`a(Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„a3Ù „hnetworkxm2.7.2rc1.dev0fmodulex?networkx.generators.degree_seq.DegreeSequenceRandomGraph.phase3fmoduleõÙ±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bmia2Ù±‚`a)Ù±‚`b  Ù±‚bc1x# assign weight 2 to edge 0-3Ù±‚`a
Ù±‚`Ù¢„cmstÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.tree.mstfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„dtreeÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.treefmoduleõÙ±‚aoa.Ù±‚`Ù¢„vmaximum_spanning_edgesÙ „hnetworkxm2.7.2rc1.dev0fmodulex3networkx.algorithms.tree.mst.maximum_spanning_edgesfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`ialgorithmÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2Ù¢„dprimÙ „hnetworkxm2.7.2rc1.dev0fmodulex+networkx.algorithms.tree.mst.prim_mst_edgesfmoduleõÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`ddataÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`hedgelistÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbdlistÙ±‚`a(Ù±‚`Ù¢„cmstÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.tree.mstfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚bnbfsortedÙ±‚`a(Ù±‚bnbfsortedÙ±‚`a(Ù±‚`aeÙ±‚`a)Ù±‚`a Ù±‚akcforÙ±‚`a Ù±‚`aeÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`hedgelistÙ±‚`a)x[[0, 1], [0, 3], [2, 3]]fexecedö€m2.7.2rc1.dev0Ù«xgmaximum_spanning_edges(G, algorithm='kruskal', weight='weight', keys=True, data=True, ignore_nan=False)öx3networkx.algorithms.tree.mst.maximum_spanning_edges€
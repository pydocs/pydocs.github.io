Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x¥The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that for all v, w in V there is an edge (v, w) in E+ if and only if there is a path from v to w in G.€Ù¹‚Ù§y<Handling of paths from v to v has some flexibility within this definition. A reflexive transitive closure creates a self-loop for the path from v to v of length 0. The usual transitive closure creates a self-loop only if a cycle exists (a path from v to v with length > 0). We also allow an option for no self-loops.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒaGnNetworkX GraphÙ¹‚Ù§x'A directed/undirected graph/multigraph.€Ù°ƒireflexivex'Bool or None, optional (default: False)Ù¹‚Ù§yDetermines when cycles create self-loops in the Transitive Closure. If True, trivial cycles (length 0) create self-loops. The result is a reflexive tranistive closure of G. If False (the default) non-trivial cycles create self-loops. If None, self-loops are not created.€öfRaisesÙ¯‚Ù°ƒ`mNetworkXErrorÙ¹‚„Ù§cIf Ù¢„ireflexiveÙ „ööelocalireflexiveelocalõÙ§h not in Ù£ƒs{None, True, False}öö€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`nNetworkX graphÙ¹‚‚Ù§xThe transitive closure of Ù¢„aGÙ „ööelocalaGelocalõ€ögSummaryÙ¯‚Ù¹‚Ù§x%Returns transitive closure of a graph€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnsfRaiseshExamplesjReferencesxnetworkx/algorithms/dag.py\r<class 'function'>xnetworkx.transitive_closureÙ¯‚…Ù¹‚ƒÙ§xEThe treatment of trivial (i.e. length 0) cycles is controlled by the Ù¢„ireflexiveÙ „ööelocalireflexiveelocalõÙ§k parameter.€Ù·„x%>>> DG = nx.DiGraph([(1, 2), (2, 3)])x3>>> TC = nx.transitive_closure(DG, reflexive=False)n>>> TC.edges()x%OutEdgeView([(1, 2), (1, 3), (2, 3)])Ù·„x->>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1)])x3>>> TC = nx.transitive_closure(DG, reflexive=False)n>>> TC.edges()xUOutEdgeView([(1, 2), (1, 3), (1, 1), (2, 3), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)])Ù·„x%>>> DG = nx.DiGraph([(1, 2), (2, 3)])x2>>> TC = nx.transitive_closure(DG, reflexive=True)n>>> TC.edges()x=OutEdgeView([(1, 2), (1, 1), (1, 3), (2, 3), (2, 2), (3, 3)])Ù·„x->>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1)])x2>>> TC = nx.transitive_closure(DG, reflexive=None)n>>> TC.edges()x=OutEdgeView([(1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2)])ö€m2.7.2rc1.dev0Ù«x&transitive_closure(G, reflexive=False)öx*networkx.algorithms.dag.transitive_closure€
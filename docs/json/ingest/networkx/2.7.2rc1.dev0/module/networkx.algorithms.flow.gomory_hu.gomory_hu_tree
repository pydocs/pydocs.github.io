Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§xA Gomory-Hu tree of an undirected graph with capacities is a weighted tree that represents the minimum s-t cuts for all s-t pairs in the graph.€Ù¹‚…Ù§qIt only requires Ù£ƒcn-1ööÙ§x1 minimum cut computations instead of the obvious Ù£ƒhn(n-1)/2ööÙ§x°. The tree represents all s-t cuts as the minimum cut value among any pair of nodes is the minimum edge weight in the shortest path between the two nodes in the Gomory-Hu tree.€Ù¹‚Ù§xìThe Gomory-Hu tree also has the property that removing the edge with the minimum weight in the shortest path between any two nodes leaves two connected components that form a partition of the nodes in G that defines the minimum s-t cut.€Ù¹‚Ù§x'See Examples section below for details.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§x»This implementation is based on Gusfield approach  to compute Comory-Hu trees, which does not require node contractions and has the same computational complexity than the original method.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒaGnNetworkX graphÙ¹‚Ù§pUndirected graph€Ù°ƒhcapacityfstringÙ¹‚Ù§xáEdges of the graph G are expected to have an attribute capacity that indicates how much flow the edge can support. If this attribute is not present, the edge is considered to have infinite capacity. Default value: 'capacity'.€Ù°ƒiflow_funchfunctionÙ¹‚…Ù§xDFunction to perform the underlying flow computations. Default value Ù¢„ledmonds_karpÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.edmondskarp.edmonds_karpfmoduleõÙ§xY. This function performs better in sparse graphs with right tailed degree distributions. Ù¢„xshortest_augmenting_pathÙ „hnetworkxm2.7.2rc1.dev0fmodulexHnetworkx.algorithms.flow.shortestaugmentingpath.shortest_augmenting_pathfmoduleõÙ§x& will perform better in denser graphs.€öfRaisesÙ¯‚‚Ù°ƒ`vNetworkXNotImplementedÙ¹‚Ù§x&Raised if the input graph is directed.€Ù°ƒ`mNetworkXErrorÙ¹‚Ù§x,Raised if the input graph is an empty Graph.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒdTreenNetworkX graphÙ¹‚Ù§xDA NetworkX graph representing the Gomory-Hu tree of the input graph.€ögSummaryÙ¯‚Ù¹‚Ù§x4Returns the Gomory-Hu tree of an undirected graph G.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‰gSummarypExtended SummaryjParametersgReturnsfRaiseshExampleseNoteshSee AlsojReferencesx%networkx/algorithms/flow/gomory_hu.pyr<class 'function'>wnetworkx.gomory_hu_treeÙ¯‚…Ù´ƒ˜¦Ù±‚`aGÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„qkarate_club_graphÙ „hnetworkxm2.7.2rc1.dev0fmodulex,networkx.generators.social.karate_club_graphfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„sset_edge_attributesÙ „hnetworkxm2.7.2rc1.dev0fmodulex-networkx.classes.function.set_edge_attributesfmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2hcapacityÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`aTÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„ngomory_hu_treeÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.gomory_hu.gomory_hu_treefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a)Ù±‚`a
Ù±‚bc1x/# The value of the minimum cut between any pairÙ±‚`a
Ù±‚bc1x1# of nodes in G is the minimum edge weight in theÙ±‚`a
Ù±‚bc1x,# shortest path between the two nodes in theÙ±‚`a
Ù±‚bc1q# Gomory-Hu tree.Ù±‚`a
Ù±‚akÙ¢„cdefÙ „hnetworkxm2.7.2rc1.dev0fmodulex"networkx.utils.misc.default_openerfmoduleõÙ±‚`a Ù±‚bnfx$minimum_edge_weight_in_shortest_pathÙ±‚`a(Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`dpathÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„mshortest_pathÙ „hnetworkxm2.7.2rc1.dev0fmodulex8networkx.algorithms.shortest_paths.generic.shortest_pathfmoduleõÙ±‚`a(Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a,Ù±‚`a Ù±‚`fweightÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2fweightÙ±‚bs2a"Ù±‚`a)Ù±‚`a
Ù±‚`d    Ù±‚akfreturnÙ±‚`a Ù±‚bnbcminÙ±‚`a(Ù±‚`a(Ù±‚`aTÙ±‚`a[Ù±‚`auÙ±‚`a]Ù±‚`a[Ù±‚`avÙ±‚`a]Ù±‚`a[Ù±‚bs2a"Ù±‚bs2fweightÙ±‚bs2a"Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a(Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a)Ù±‚`a Ù±‚akcforÙ±‚`a Ù±‚`a(Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a Ù±‚bowbinÙ±‚`a Ù±‚bnbczipÙ±‚`a(Ù±‚`dpathÙ±‚`a,Ù±‚`a Ù±‚`dpathÙ±‚`a[Ù±‚bmia1Ù±‚`a:Ù±‚`a]Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmib33Ù±‚`a
Ù±‚`Ù¢„icut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dedgeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`x$minimum_edge_weight_in_shortest_pathÙ±‚`a(Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„icut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõb10fexecedÙ´ƒŒÙ±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„qminimum_cut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)b10fexecedÙ´ƒ˜ˆÙ±‚bc1x<# The Comory-Hu tree also has the property that removing theÙ±‚`a
Ù±‚bc1x;# edge with the minimum weight in the shortest path betweenÙ±‚`a
Ù±‚bc1x9# any two nodes leaves two connected components that formÙ±‚`a
Ù±‚bc1x<# a partition of the nodes in G that defines the minimum s-tÙ±‚`a
Ù±‚bc1f# cut.Ù±‚`a
Ù±‚`Ù¢„icut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dedgeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`x$minimum_edge_weight_in_shortest_pathÙ±‚`a(Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a
Ù±‚`aTÙ±‚aoa.Ù±‚`kremove_edgeÙ±‚`a(Ù±‚aoa*Ù±‚`dedgeÙ±‚`a)Ù±‚`a
Ù±‚`aUÙ±‚`a,Ù±‚`a Ù±‚`aVÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbdlistÙ±‚`a(Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„tconnected_componentsÙ „hnetworkxm2.7.2rc1.dev0fmodulex=networkx.algorithms.components.connected.connected_componentsfmoduleõÙ±‚`a(Ù±‚`aTÙ±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚bc1x:# Thus U and V form a partition that defines a minimum cutÙ±‚`a
Ù±‚bc1x9# between u and v in G. You can compute the edge cut set,Ù±‚`a
Ù±‚bc1x7# that is, the set of edges that if removed from G willÙ±‚`a
Ù±‚bc1x2# disconnect u from v in G, with this information:Ù±‚`a
Ù±‚`fcutsetÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bnbcsetÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚akcforÙ±‚`a Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`dnbrsÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`a(Ù±‚`a(Ù±‚`anÙ±‚`a,Ù±‚`a Ù±‚`aGÙ±‚`a[Ù±‚`anÙ±‚`a]Ù±‚`a)Ù±‚`a Ù±‚akcforÙ±‚`a Ù±‚`anÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`aUÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`fcutsetÙ±‚aoa.Ù±‚`fupdateÙ±‚`a(Ù±‚`a(Ù±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a)Ù±‚`a Ù±‚akcforÙ±‚`a Ù±‚`ayÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`dnbrsÙ±‚`a Ù±‚akbifÙ±‚`a Ù±‚`ayÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`aVÙ±‚`a)Ù±‚`a
Ù±‚bc1x6# Because we have set the capacities of all edges to 1Ù±‚`a
Ù±‚bc1x# the cutset contains ten edgesÙ±‚`a
Ù±‚bnbclenÙ±‚`a(Ù±‚`fcutsetÙ±‚`a)b10fexecedÙ´ƒ˜3Ù±‚bc1x;# You can use any maximum flow algorithm for the underlyingÙ±‚`a
Ù±‚bc1x0# flow computations using the argument flow_funcÙ±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„hnetworkxÙ „hnetworkxm2.7.2rc1.dev0fmodulehnetworkxfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„jalgorithmsÙ „hnetworkxm2.7.2rc1.dev0fmodulesnetworkx.algorithmsfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„dflowÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.flowfmoduleõÙ±‚`a
Ù±‚`aTÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„ngomory_hu_treeÙ „hnetworkxm2.7.2rc1.dev0fmodulex1networkx.algorithms.flow.gomory_hu.gomory_hu_treefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`iflow_funcÙ±‚aoa=Ù±‚`Ù¢„dflowÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.flowfmoduleõÙ±‚aoa.Ù±‚`Ù¢„qboykov_kolmogorovÙ „hnetworkxm2.7.2rc1.dev0fmodulex;networkx.algorithms.flow.boykovkolmogorov.boykov_kolmogorovfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„icut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõÙ±‚`a,Ù±‚`a Ù±‚`dedgeÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`x$minimum_edge_weight_in_shortest_pathÙ±‚`a(Ù±‚`aTÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a)Ù±‚`a
Ù±‚`Ù¢„icut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõb10fexecedÙ´ƒ“Ù±‚`bnxÙ±‚aoa.Ù±‚`Ù¢„qminimum_cut_valueÙ „hnetworkxm2.7.2rc1.dev0fmodulex2networkx.algorithms.flow.maxflow.minimum_cut_valuefmoduleõÙ±‚`a(Ù±‚`aGÙ±‚`a,Ù±‚`a Ù±‚`auÙ±‚`a,Ù±‚`a Ù±‚`avÙ±‚`a,Ù±‚`a Ù±‚`iflow_funcÙ±‚aoa=Ù±‚`Ù¢„dflowÙ „hnetworkxm2.7.2rc1.dev0fmodulexnetworkx.algorithms.flowfmoduleõÙ±‚aoa.Ù±‚`Ù¢„qboykov_kolmogorovÙ „hnetworkxm2.7.2rc1.dev0fmodulex;networkx.algorithms.flow.boykovkolmogorov.boykov_kolmogorovfmoduleõÙ±‚`a)b10fexecedö‚Ù¼ƒÙ»ƒlmaximum_flowx-networkx.algorithms.flow.maxflow.maximum_flowõÙ¹‚Ù§dfunc€öÙ¼ƒÙ»ƒkminimum_cutx,networkx.algorithms.flow.maxflow.minimum_cutõÙ¹‚Ù§dfunc€öm2.7.2rc1.dev0Ù«x6gomory_hu_tree(G, capacity='capacity', flow_func=None)öx1networkx.algorithms.flow.gomory_hu.gomory_hu_tree€
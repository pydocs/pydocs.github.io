Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§y?Contains logic to dynamically resize a Dask cluster based on current use. This class needs to be paired with a system that can create and destroy Dask workers using a cluster resource manager.  Typically it is built into already existing solutions, rather than used directly by users. It is most commonly used from the Ù¡k.adapt(...)Ù§x( method of various Dask cluster classes.€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚‡Ù§xSubclasses can override Ù¢„oAdaptive.targetÙ „kdistributedi2021.10.0fmodulex+distributed.deploy.adaptive.Adaptive.targetfmoduleõÙ§e and Ù¢„xAdaptive.workers_to_closeÙ „kdistributedi2021.10.0fmodulex5distributed.deploy.adaptive.Adaptive.workers_to_closefmoduleõÙ§x to control when the cluster should be resized. The default implementation checks if there are too many tasks per worker or too little memory available (see Ù¢„xScheduler.adaptive_targetÙ „kdistributedi2021.10.0fmodulex/distributed.scheduler.Scheduler.adaptive_targetfmoduleõÙ§xŒ). The values for interval, min, max, wait_count and target_duration can be specified in the dask config under the distributed.adaptive key.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ˆÙ°ƒocluster: object`Ù¹‚Ù§x1Must have scale and scale_down methods/coroutines€Ù°ƒhintervalx#timedelta or str, default "1000 ms"Ù¹‚Ù§xMilliseconds between checks€Ù°ƒxwait_count: int, default 3`Ù¹‚Ù§x^Number of consecutive times that a worker should be suggested for removal before we remove it.€Ù°ƒx/target_duration: timedelta or str, default "5s"`Ù¹‚Ù§xXAmount of time we want a computation to take. This affects how aggressively we scale up.€Ù°ƒx!worker_key: Callable[WorkerState]`Ù¹‚Ù§xhFunction to group workers together when scaling down See Scheduler.workers_to_close for more information€Ù°ƒlminimum: int`Ù¹‚Ù§x(Minimum number of workers to keep around€Ù°ƒlmaximum: int`Ù¹‚Ù§x(Maximum number of workers to keep around€Ù°ƒi**kwargs:`Ù¹‚Ù§x6Extra parameters to pass to Scheduler.workers_to_close€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xCAdaptively allocate workers based on scheduler load.  A superclass.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametershExampleseNotesx/distributed/deploy/adaptive.pyn<class 'type'>tdistributed.AdaptiveÙ¯‚…Ù¹‚Ù§xBThis is commonly used from existing Dask classes, like KubeCluster€Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnodask_kubernetesÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`kKubeClusterÙ±‚`a
Ù±‚`Ù¢„gclusterÙ „kdistributedi2021.10.0fmodulexdistributed.deploy.clusterfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`kKubeClusterÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„gclusterÙ „kdistributedi2021.10.0fmodulexdistributed.deploy.clusterfmoduleõÙ±‚aoa.Ù±‚`eadaptÙ±‚`a(Ù±‚`gminimumÙ±‚aoa=Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚`gmaximumÙ±‚aoa=Ù±‚bmic100Ù±‚`a)`hcompiledÙ¹‚Ù§xfAlternatively you can use it from your own Cluster class by subclassing from Dask's Cluster superclass€Ù´ƒ˜/Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„kdistributedÙ „kdistributedi2021.10.0fmodulekdistributedfmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„fdeployÙ „kdistributedi2021.10.0fmodulerdistributed.deployfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„gClusterÙ „kdistributedi2021.10.0fmodulex"distributed.deploy.cluster.ClusterfmoduleõÙ±‚`a
Ù±‚akÙ¢„eclassÙ „kdistributedi2021.10.0fmodulexdistributed.scheduler.cclassfmoduleõÙ±‚`a Ù±‚bnciMyClusterÙ±‚`a(Ù±‚`Ù¢„gClusterÙ „kdistributedi2021.10.0fmodulex"distributed.deploy.cluster.ClusterfmoduleõÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚akcdefÙ±‚`a Ù±‚bnfhscale_upÙ±‚`a(Ù±‚bbpdselfÙ±‚`a,Ù±‚`a Ù±‚`anÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`h        Ù±‚bsdx"""" Bring worker count up to n """Ù±‚`a
Ù±‚`d    Ù±‚akcdefÙ±‚`a Ù±‚bnfjscale_downÙ±‚`a(Ù±‚bbpdselfÙ±‚`a,Ù±‚`a Ù±‚`gworkersÙ±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`g       Ù±‚bsdx,""" Remove worker addresses from cluster """`hcompiledÙ´ƒ•Ù±‚`Ù¢„gclusterÙ „kdistributedi2021.10.0fmodulexdistributed.deploy.clusterfmoduleõÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`iMyClusterÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`Ù¢„gclusterÙ „kdistributedi2021.10.0fmodulexdistributed.deploy.clusterfmoduleõÙ±‚aoa.Ù±‚`eadaptÙ±‚`a(Ù±‚`gminimumÙ±‚aoa=Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚`gmaximumÙ±‚aoa=Ù±‚bmic100Ù±‚`a)`hcompiledö€i2021.10.0Ù«ööx$distributed.deploy.adaptive.Adaptive€
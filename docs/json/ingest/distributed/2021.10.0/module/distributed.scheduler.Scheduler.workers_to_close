Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§y)This returns a list of workers that are good candidates to retire. These workers are not running anything and are storing relatively little data relative to their peers.  If all workers are idle then we still maintain enough workers to have enough RAM to store our data, with a comfortable buffer.€Ù¹‚ƒÙ§x"This is for use with systems like Ù¡xdistributed.deploy.adaptiveÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒlmemory_ratiofNumberÙ¹‚Ù§x‘Amount of extra space we want to have for our stored data. Defaults to 2, or that we want to have twice as much memory as we currently have data.€Ù°ƒancintÙ¹‚Ù§xNumber of workers to close€Ù°ƒgminimumcintÙ¹‚Ù§x(Minimum number of workers to keep around€Ù°ƒckeyuCallable(WorkerState)Ù¹‚Ù§x½An optional callable mapping a WorkerState object to a group affiliation. Groups will be closed together. This is useful when closing workers must be done collectively, such as by hostname.€Ù°ƒftargetcintÙ¹‚Ù§x/Target number of workers to have after we close€Ù°ƒiattributecstrÙ¹‚Ù§xdThe attribute of the WorkerState object to return, like "address" or "name".  Defaults to "address".€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`x7to_close: list of worker addresses that are OK to close€ögSummaryÙ¯‚Ù¹‚Ù§x,Find workers that we can close with low cost€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametershExamplesgReturnshSee Alsox/distributed/scheduler.py€r<class 'function'>x&distributed.Scheduler.workers_to_closeÙ¯‚‡Ù´ƒ…Ù±‚`Ù¢„ischedulerÙ „kdistributedi2021.10.0fmoduleudistributed.schedulerfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pworkers_to_closeÙ „kdistributedi2021.10.0fmodulex0distributed.scheduler.Scheduler.workers_to_closefmoduleõÙ±‚`a(Ù±‚`a)x4['tcp://192.168.0.1:1234', 'tcp://192.168.0.2:1234']hcompiledÙ¹‚Ù§x*Group workers by hostname prior to closing€Ù´ƒÙ±‚`Ù¢„ischedulerÙ „kdistributedi2021.10.0fmoduleudistributed.schedulerfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pworkers_to_closeÙ „kdistributedi2021.10.0fmodulex0distributed.scheduler.Scheduler.workers_to_closefmoduleõÙ±‚`a(Ù±‚`ckeyÙ±‚aoa=Ù±‚akflambdaÙ±‚`a Ù±‚`Ù¢„bwsÙ „kdistributedi2021.10.0fmodulesdistributed.comm.wsfmoduleõÙ±‚`a:Ù±‚`a Ù±‚`Ù¢„bwsÙ „kdistributedi2021.10.0fmodulesdistributed.comm.wsfmoduleõÙ±‚aoa.Ù±‚`dhostÙ±‚`a)x4['tcp://192.168.0.1:1234', 'tcp://192.168.0.1:4567']hcompiledÙ¹‚Ù§rRemove two workers€Ù´ƒˆÙ±‚`Ù¢„ischedulerÙ „kdistributedi2021.10.0fmoduleudistributed.schedulerfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pworkers_to_closeÙ „kdistributedi2021.10.0fmodulex0distributed.scheduler.Scheduler.workers_to_closefmoduleõÙ±‚`a(Ù±‚`anÙ±‚aoa=Ù±‚bmia2Ù±‚`a)`hcompiledÙ¹‚Ù§x?Keep enough workers to have twice as much memory as we we need.€Ù´ƒˆÙ±‚`Ù¢„ischedulerÙ „kdistributedi2021.10.0fmoduleudistributed.schedulerfmoduleõÙ±‚aoa.Ù±‚`Ù¢„pworkers_to_closeÙ „kdistributedi2021.10.0fmodulex0distributed.scheduler.Scheduler.workers_to_closefmoduleõÙ±‚`a(Ù±‚`lmemory_ratioÙ±‚aoa=Ù±‚bmia2Ù±‚`a)`hcompiledöÙ¼ƒÙ»ƒxScheduler.retire_workersx.distributed.scheduler.Scheduler.retire_workersõ€öi2021.10.0Ù«yworkers_to_close(self, comm=None, memory_ratio: 'int | float | None' = None, n: 'int | None' = None, key: 'Callable[[WorkerState], Hashable] | None' = None, minimum: 'int | None' = None, target: 'int | None' = None, attribute: str = 'address') -> 'list[str]'öx0distributed.scheduler.Scheduler.workers_to_close€
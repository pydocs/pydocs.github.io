Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒxworkers: list (optional)`Ù¹‚ƒÙ§x<List of worker addresses to retire. If not provided we call Ù¡pworkers_to_closeÙ§w which finds a good set€Ù°ƒvnames: list (optional)`Ù¹‚Ù§xList of worker names to retire.€Ù°ƒxremove: bool (defaults to True)`Ù¹‚Ù§xbWhether or not to remove the worker metadata immediately or else wait for the worker to contact us€Ù°ƒx'close_workers: bool (defaults to False)`Ù¹‚Ù§x‹Whether or not to actually close the worker explicitly from here. Otherwise we expect some external job scheduler to finish off the worker.€Ù°ƒn**kwargs: dict`Ù¹‚Ù§xSExtra options to pass to workers_to_close to determine which workers we should drop€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒ`xGDictionary mapping worker ID/address to dictionary of information about€Ù°ƒ`x$that worker for each retired worker.€ögSummaryÙ¯‚Ù¹‚Ù§x&Gracefully retire workers from cluster€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummaryjParametersgReturnshSee Alsox/distributed/scheduler.pyr<class 'function'>x$distributed.Scheduler.retire_workersÙ¯‚€öÙ¼ƒÙ»ƒxScheduler.workers_to_closex0distributed.scheduler.Scheduler.workers_to_closeõ€öi2021.10.0Ù«xxretire_workers(self, comm=None, workers=None, remove=True, close_workers=False, names=None, lock=True, **kwargs) -> dictöx.distributed.scheduler.Scheduler.retire_workers€
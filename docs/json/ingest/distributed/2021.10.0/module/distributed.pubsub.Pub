Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ˆÙ¹‚Ù§x˜This allows clients and workers to directly communicate data between each other with a typical Publish-Subscribe pattern.  This involves two components,€Ù¹‚Ù§x$Pub objects, into which we put data:€Ù·‚x>>> pub = Pub('my-topic')p>>> pub.put(123)Ù¹‚Ù§x,And Sub objects, from which we collect data:€Ù·ƒx>>> sub = Sub('my-topic')m>>> sub.get()c123Ù¹‚Ù§y+Many Pub and Sub objects can exist for the same topic.  All data sent from any Pub will be sent to all Sub objects on that topic that are currently connected.  Pub's and Sub's find each other using the scheduler, but they communicate directly with each other without coordination from the scheduler.€Ù¹‚Ù§yiPubs and Subs use the central scheduler to find each other, but not to mediate the communication.  This means that there is very little additional latency or overhead, and they are appropriate for very frequent data transfers.  For context, most data transfer first checks with the scheduler to find which workers should participate, and then does direct worker-to-worker transfers.  This checking in with the scheduler provides some stability guarantees, but also adds in a few extra network hops.  PubSub doesn't do this, and so is faster, but also can easily drop messages if Pubs or Subs disappear without notice.€Ù¹‚Ù§xÔWhen using a Pub or Sub from a Client all communications will be routed through the scheduler.  This can cause some performance degradation.  Pubs and Subs only operate at top-speed when they are both on workers.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒx#name: object (msgpack serializable)`Ù¹‚Ù§x?The name of the group of Pubs and Subs on which to participate.€Ù°ƒxworker: Worker (optional)`Ù¹‚‡Ù§xDThe worker to be used for publishing data. Defaults to the value of Ù¡n`get_worker()`Ù§l. If given, Ù¡fclientÙ§i must be Ù¡dNoneÙ§a.€Ù°ƒxclient: Client (optional)`Ù¹‚‡Ù§xKClient used for communication with the scheduler. Defaults to the value of Ù¡lget_client()Ù§l. If given, Ù¡fworkerÙ§i must be Ù¡dNoneÙ§a.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x+Publish data with Publish-Subscribe pattern€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametershExampleshSee Alsov/distributed/pubsub.pyÊn<class 'type'>odistributed.PubÙ¯‚‰Ù´ƒ˜*Ù±‚`cpubÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cPubÙ „kdistributedi2021.10.0fmodulevdistributed.pubsub.PubfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1hmy-topicÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`csubÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„cSubÙ „kdistributedi2021.10.0fmodulevdistributed.pubsub.SubfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1hmy-topicÙ±‚bs1a'Ù±‚`a)Ù±‚`a
Ù±‚`cpubÙ±‚aoa.Ù±‚`cputÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`csubÙ±‚aoa.Ù±‚`cgetÙ±‚`a(Ù±‚`a)i[1, 2, 3]hcompiledÙ¹‚Ù§x'You can also use sub within a for loop:€Ù´ƒÙ±‚akcforÙ±‚`a Ù±‚`cmsgÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`csubÙ±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚bnbÙ¢„eprintÙ „kdistributedi2021.10.0fmodulexdistributed.worker.printfmoduleõÙ±‚`a(Ù±‚`cmsgÙ±‚`a)`hcompiledÙ¹‚Ù§tor an async for loop€Ù´ƒ’Ù±‚akeasyncÙ±‚`a Ù±‚akcforÙ±‚`a Ù±‚`cmsgÙ±‚`a Ù±‚bowbinÙ±‚`a Ù±‚`csubÙ±‚`a:Ù±‚`b  Ù±‚bc1p# doctest: +SKIPÙ±‚`a
Ù±‚`d    Ù±‚bnbÙ¢„eprintÙ „kdistributedi2021.10.0fmodulexdistributed.worker.printfmoduleõÙ±‚`a(Ù±‚`cmsgÙ±‚`a)`lsyntax_errorÙ¹‚ƒÙ§nSimilarly the Ù¡d.getÙ§xc method will return an awaitable if used by an async client or within the IOLoop thread of a worker€Ù´ƒ‰Ù±‚akeawaitÙ±‚`a Ù±‚`csubÙ±‚aoa.Ù±‚`cgetÙ±‚`a(Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIP`lsyntax_errorÙ¹‚ƒÙ§xFYou can see the set of connected worker subscribers by looking at the Ù¡l.subscribersÙ§k attribute:€Ù´ƒƒÙ±‚`cpubÙ±‚aoa.Ù±‚`ksubscribersx#{'tcp://...': {},
 'tcp://...': {}}hcompiledöÙ¼ƒÙ»ƒcSubvdistributed.pubsub.Subõ€öi2021.10.0Ù«öövdistributed.pubsub.Pub€
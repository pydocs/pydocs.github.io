Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚ƒÙ§eThis ÙË‚isemaphorex5https://en.wikipedia.org/wiki/Semaphore_(programming)Ù§xù will track leases on the scheduler which can be acquired and released by an instance of this class. If the maximum amount of leases are already acquired, it is not possible to acquire more and the caller waits until another lease has been released.€Ù¹‚‡Ù§xmThe lifetime or leases are controlled using a timeout. This timeout is refreshed in regular intervals by the Ù¡fClientÙ§x¨ of this instance and provides protection from deadlocks or resource starvation in case of worker failure. The timeout can be controlled using the configuration option Ù¡x)distributed.scheduler.locks.lease-timeoutÙ§xV and the interval in which the scheduler verifies the timeout is set using the option Ù¡x5distributed.scheduler.locks.lease-validation-intervalÙ§a.€Ù¹‚Ù§xìA noticeable difference to the Semaphore of the python standard library is that this implementation does not allow to release more often than it was acquired. If this happens, a warning is emitted but the internal state is not modified.€ÙÆƒgwarning`Ù¹‚Ù§x˜This implementation is still in an experimental state and subtle changes in behavior may occur without any change in the major version of this library. €ÙÆƒgwarning`Ù¹‚Ù§xĞThis implementation is susceptible to lease overbooking in case of lease timeouts. It is advised to monitor log information and adjust above configuration options to suitable values for the user application. €ögMethodsÙ¯‚€öeNotesÙ¯‚„Ù¹‚Ù§xnIf a client attempts to release the semaphore but doesn't have a lease acquired, this will raise an exception.€Ù¹‚Ù§xPWhen a semaphore is closed, if, for that closed semaphore, a client attempts to:€ÙÈƒÙ¹‚Ù§x-Acquire a lease: an exception will be raised.€Ù¹‚Ù§x"Release: a warning will be logged.€Ù¹‚Ù§xClose: nothing will happen.€Ù¹‚ƒÙ§x•dask executes functions by default assuming they are pure, when using semaphore acquire/releases inside such a function, it must be noted that there Ù¨Ù§careÙ§x” in fact side-effects, thus, the function can no longer be considered pure. If this is not taken into account, this may lead to unexpected behavior.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒxmax_leases: int (optional)`Ù¹‚Ù§x¯The maximum amount of leases that may be granted at the same time. This effectively sets an upper limit to the amount of parallel access to a specific resource. Defaults to 1.€Ù°ƒwname: string (optional)`Ù¹‚Ù§xšName of the semaphore to acquire.  Choosing the same name allows two disconnected processes to coordinate.  If not given, a random name will be generated.€Ù°ƒnregister: bool`Ù¹‚Ù§xÿIf True, register the semaphore with the scheduler. This needs to be done before any leases can be acquired. If not done during initialization, this can also be done by calling the register method of this class. When registering, this needs to be awaited.€Ù°ƒxscheduler_rpc: ConnectionPool`Ù¹‚Ù§x‘The ConnectionPool to connect to the scheduler. If None is provided, it uses the worker or client pool. This paramter is mostly used for testing.€Ù°ƒlloop: IOLoop`Ù¹‚Ù§xjThe event loop this instance is using. If None is provided, reuse the loop of the active worker or client.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§iSemaphore€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParametershExampleseNotesx/distributed/semaphore.pyn<class 'type'>udistributed.SemaphoreÙ¯‚Ù´ƒ˜Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„kdistributedÙ „kdistributedi2021.10.0fmodulekdistributedfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„iSemaphoreÙ „kdistributedi2021.10.0fmodulexdistributed.semaphore.SemaphorefmoduleõÙ±‚`a
Ù±‚`csemÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iSemaphoreÙ „kdistributedi2021.10.0fmodulexdistributed.semaphore.SemaphorefmoduleõÙ±‚`a(Ù±‚`jmax_leasesÙ±‚aoa=Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`dnameÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1kmy_databaseÙ±‚bs1a'Ù±‚`a)y•...
... def access_resource(s, sem):
...     # This automatically acquires a lease from the semaphore (if available) which will be
...     # released when leaving the context manager.
...     with sem:
...         pass
...
... futures = client.map(access_resource, range(10), sem=sem)
... client.gather(futures)
... # Once done, close the semaphore to clean up the state on scheduler side.
... sem.close()hcompiledö€i2021.10.0Ù«ööxdistributed.semaphore.Semaphore€
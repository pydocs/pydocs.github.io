Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‡Ù¹‚Ù§xThis provides a connect method that mirrors the normal distributed.connect method, but provides connection sharing and tracks connection limits.€Ù¹‚ƒÙ§xThis object provides an Ù¡crpcÙ§w like interface::      €ÙÀx>>> rpc = ConnectionPool(limit=512)
>>> scheduler = rpc('127.0.0.1:8786')
>>> workers = [rpc(address) for address ...]

>>> info = yield scheduler.identity()Ù¹‚Ù§x[It creates enough comms to satisfy concurrent connections to any particular address::      €ÙÀx<>>> a, b = yield [scheduler.who_has(), scheduler.has_what()]Ù¹‚Ù§xIIt reuses existing comms so that we don't have to continuously reconnect.€Ù¹‚Ù§xŞIt also maintains a comm limit to avoid "too many open file handle" issues.  Whenever this maximum is reached we clear out all idling comms. If that doesn't do the trick then we wait until one of the occupied comms closes.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒjlimit: int`Ù¹‚Ù§x,The number of open comms to maintain at once€Ù°ƒqdeserialize: bool`Ù¹‚Ù§x@Whether or not to deserialize data by default or pass it through€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x%A maximum sized pool of Comm objects.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryjParameterst/distributed/core.pyvn<class 'type'>x!distributed.client.ConnectionPoolÙ¯‚€ö€i2021.10.0Ù«ööxdistributed.core.ConnectionPool€
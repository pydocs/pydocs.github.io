Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xMRandom walker algorithm is implemented for gray-level or multichannel images.€ögMethodsÙ¯‚€öeNotesÙ¯‚ŒÙ¹‚Ù§xMultichannel inputs are scaled with all channel data combined. Ensure all channels are separately normalized prior to running this algorithm.€Ù¹‚ƒÙ§dThe Ù¢„gspacingÙ „ööelocalgspacingelocalõÙ§x¼ argument is specifically for anisotropic datasets, where data points are spaced differently in one or more spatial dimensions. Anisotropic data is commonly encountered in medical imaging.€Ù¹‚Ù§x%The algorithm was first proposed in .€Ù¹‚Ù§xÕThe algorithm solves the diffusion equation at infinite times for sources placed on markers of each phase in turn. A pixel is labeled with the phase that has the greatest probability to diffuse first to the pixel.€Ù¹‚Ù§y½The diffusion equation is solved by minimizing x.T L x for each phase, where L is the Laplacian of the weighted graph of the image, and x is the probability that a marker of the given phase arrives first at a pixel by diffusion (x=1 on markers of the phase, x=0 on the other markers, and the other coefficients are looked for). Each pixel is attributed the label for which it has a maximal value of x. The Laplacian L of the image is defined as:€Ù·‚xB- L_ii = d_i, the number of neighbors of pixel i (the degree of i)x-- L_ij = -w_ij if i and j are adjacent pixelsÙ¹‚Ù§x“The weight w_ij is a decreasing function of the norm of the local gradient. This ensures that diffusion is easier between pixels of similar values.€Ù¹‚Ù§xRWhen the Laplacian is decomposed into blocks of marked and unmarked pixels::      €ÙÀqL = M B.T
    B AÙ¹‚Ù§xŠwith first indices corresponding to marked pixels, and then to unmarked pixels, minimizing x.T L x for one phase amount to solving::      €ÙÀmA x = - B x_mÙ¹‚Ù§xÅwhere x_m = 1 on markers of the given phase, and 0 on other markers. This linear system is solved in the algorithm using a direct method for small images, and an iterative method for larger images.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‰Ù°ƒddatajarray_likeÙ¹‚…Ù§x,Image to be segmented in phases. Gray-level Ù¢„ddataÙ „gskimagef0.17.2fmodulelskimage.datafmoduleõÙ§xÇ can be two- or three-dimensional; multichannel data can be three- or four- dimensional (multichannel=True) with the highest dimension denoting channels. Data spacing is assumed isotropic unless the Ù¢„gspacingÙ „ööelocalgspacingelocalõÙ§x keyword argument is used.€Ù°ƒflabelsxAarray of ints, of same shape as `data` without channels dimensionÙ¹‚…Ù§ywArray of seed markers labeled with different positive integers for different phases. Zero-labeled pixels are unlabeled pixels. Negative labels correspond to inactive pixels that are not taken into account (they are removed from the graph). If labels are not consecutive integers, the labels array will be transformed so that labels are consecutive. In the multichannel case, Ù¢„flabelsÙ „ööelocalflabelselocalõÙ§x3 should have the same shape as a single channel of Ù¢„ddataÙ „gskimagef0.17.2fmodulelskimage.datafmoduleõÙ§x5, i.e. without the final dimension denoting channels.€Ù°ƒdbetaofloat, optionalÙ¹‚ƒÙ§xCPenalization coefficient for the random walker motion (the greater Ù¢„dbetaÙ „ööelocaldbetaelocalõÙ§x$, the more difficult the diffusion).€Ù°ƒdmodex7string, available options {'cg', 'cg_j', 'cg_mg', 'bf'}‚Ù¹‚Ù§xBMode for solving the linear system in the random walker algorithm.€ÙÈ„Ù¹‚Ù§x¾'bf' (brute force): an LU factorization of the Laplacian is   computed. This is fast for small images (<1024x1024), but very slow   and memory-intensive for large images (e.g., 3-D volumes).€Ù¹‚Ù§xè'cg' (conjugate gradient): the linear system is solved iteratively   using the Conjugate Gradient method from scipy.sparse.linalg. This is   less memory-consuming than the brute force method for large images,   but it is quite slow.€Ù¹‚Ù§xÍ'cg_j' (conjugate gradient with Jacobi preconditionner): the   Jacobi preconditionner is applyed during the Conjugate   gradient method iterations. This may accelerate the   convergence of the 'cg' method.€Ù¹‚Ù§xñ'cg_mg' (conjugate gradient with multigrid preconditioner): a   preconditioner is computed using a multigrid solver, then the   solution is computed with the Conjugate Gradient method. This mode   requires that the pyamg module is installed.€Ù°ƒctolofloat, optionalÙ¹‚Ù§xxtolerance to achieve when solving the linear system using the conjugate gradient based modes ('cg', 'cg_j' and 'cg_mg').€Ù°ƒdcopynbool, optionalÙ¹‚ƒÙ§vIf copy is False, the Ù¢„flabelsÙ „ööelocalflabelselocalõÙ§xm array will be overwritten with the result of the segmentation. Use copy=False if you want to save on memory.€Ù°ƒlmultichannelnbool, optionalÙ¹‚Ù§xkIf True, input data is parsed as multichannel data (see 'data' above for proper input format in this case).€Ù°ƒpreturn_full_probnbool, optionalÙ¹‚Ù§x|If True, the probability that a pixel belongs to each of the labels will be returned, instead of only the most likely label.€Ù°ƒgspacingxiterable of floats, optionalÙ¹‚ƒÙ§x5Spacing between voxels in each spatial dimension. If Ù¡dNoneÙ§xH, then the spacing between pixels/voxels in each dimension is assumed 1.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒfoutputgndarrayÙÈ‚Ù¹‚…Ù§cIf Ù£ƒpreturn_full_probööÙ§x: is False, array of ints of same shape   and data type as Ù£ƒflabelsööÙ§xy, in which each pixel has been   labeled according to the marker that reached the pixel first   by anisotropic diffusion.€Ù¹‚‹Ù§cIf Ù£ƒpreturn_full_probööÙ§x% is True, array of floats of shape   Ù£ƒw(nlabels, labels.shape)ööÙ§b. Ù£ƒvoutput[label_nb, i, j]ööÙ§x! is the   probability that label Ù£ƒhlabel_nbööÙ§s reaches the pixel Ù£ƒf(i, j)ööÙ§i   first.€ögSummaryÙ¯‚Ù¹‚Ù§x6Random walker algorithm for segmentation from markers.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx3/skimage/segmentation/random_walker_segmentation.py
r<class 'function'>x"skimage.segmentation.random_walkerÙ¯‚Ù´ƒ˜qÙ±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`Ù¢„dseedÙ „gskimagef0.17.2fmodulex(skimage.util._regular_grid.regular_seedsfmoduleõÙ±‚`a(Ù±‚bmiÙ¢„a0Ù „gskimagef0.17.2fmodulex&skimage.color.delta_e.deltaE_ciede2000fmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„ezerosÙ „enumpyf1.22.3fmoduleknumpy.zerosfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a)Ù±‚`a)Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmfc0.2Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„frandomÙ „enumpyf1.22.3fmodulelnumpy.randomfmoduleõÙ±‚aoa.Ù±‚`drandÙ±‚`a(Ù±‚bmib10Ù±‚`a,Ù±‚`a Ù±‚bmib10Ù±‚`a)Ù±‚`a
Ù±‚`aaÙ±‚`a[Ù±‚bmia5Ù±‚`a:Ù±‚bmia8Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a:Ù±‚bmia8Ù±‚`a]Ù±‚`a Ù±‚aoa+Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`a
Ù±‚`abÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„jzeros_likeÙ „enumpyf1.22.3fmodulepnumpy.zeros_likefmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „gskimagef0.17.2fmodulerskimage.util.dtypefmoduleõÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„eint32Ù „enumpyf1.22.3fmodulesnumpy.signedintegerfmoduleõÙ±‚`a)Ù±‚`a
Ù±‚`abÙ±‚`a[Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia1Ù±‚`b  Ù±‚bc1x# Marker for first phaseÙ±‚`a
Ù±‚`abÙ±‚`a[Ù±‚bmia6Ù±‚`a,Ù±‚`a Ù±‚bmia6Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmia2Ù±‚`b  Ù±‚bc1x# Marker for second phaseÙ±‚`a
Ù±‚`Ù¢„mrandom_walkerÙ „gskimagef0.17.2fmodulex=skimage.segmentation.random_walker_segmentation.random_walkerfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚`a,Ù±‚`a Ù±‚`abÙ±‚`a)y“array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)hcompiledöÙ¼ƒÙ»ƒxskimage.morphology.watershedx(skimage.morphology._deprecated.watershedõÙ¹‚Ù§xxwatershed segmentation A segmentation algorithm based on mathematical morphology and "flooding" of regions from markers.€öf0.17.2Ù«x‚random_walker(data, labels, beta=130, mode='cg_j', tol=0.001, copy=True, multichannel=False, return_full_prob=False, spacing=None)öx=skimage.segmentation.random_walker_segmentation.random_walker€
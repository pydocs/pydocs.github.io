Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚ƒÙ§nNote that the Ù¡pmarching_cubes()Ù§x_ algorithm is recommended over this algorithm, because it's faster and produces better results.€ögMethodsÙ¯‚€öeNotesÙ¯‚ŠÙ¹‚Ù§xjThe marching cubes algorithm is implemented as described in . A simple explanation is available here::    €ÙÀx@http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.htmlÙ¹‚Ù§xƒThere are several known ambiguous cases in the marching cubes algorithm. Using point labeling as in , Figure 4, as shown::         €ÙÀx¾v8 ------ v7
 |       / |        y
 |      /  |        ^  z
----- v3   |        | /
v5 ----|- v6        |/          (note: NOT right handed!)
/      |  /          ----> x
       | /
----- v2Ù¹‚ƒÙ§x/Most notably, if v4, v8, v2, and v6 are all >= Ù¢„elevelÙ „ööelocalelevelelocalõÙ§y (or any generalization of this case) two parallel planes are generated by this algorithm, separating v4 and v8 from v2 and v6. An equally valid interpretation would be a single connected thin surface enclosing all four points. This is the best known ambiguity, though there are others.€Ù¹‚Ù§yThis algorithm does not attempt to resolve such ambiguities; it is a naive implementation of marching cubes as in , but may be a good beginning for work with more recent techniques (Dual Marching Cubes, Extended Marching Cubes, Cubic Marching Squares, etc.).€Ù¹‚ƒÙ§yBecause of interactions between neighboring cubes, the isosurface(s) generated by this algorithm are NOT guaranteed to be closed, particularly for complicated contours. Furthermore, this algorithm does not guarantee a single contour will be returned. Indeed, ALL isosurfaces which cross Ù¢„elevelÙ „ööelocalelevelelocalõÙ§x+ will be found, regardless of connectivity.€Ù¹‚ƒÙ§xÌThe output is a triangular mesh consisting of a set of unique vertices and connecting triangles. The order of these vertices and triangles in the output list is determined by the position of the smallest Ù¡ex,y,zÙ§xŠ (in lexicographical order) coordinate in the contour.  This is a side-effect of how the input array is traversed, but can be relied upon.€Ù¹‚Ù§xFThe generated mesh guarantees coherent orientation as of version 0.12.€Ù¹‚ƒÙ§x^To quantify the area of an isosurface generated by this algorithm, pass outputs directly into Ù¢„x!skimage.measure.mesh_surface_areaÙ „gskimagea*capix9skimage.measure._marching_cubes_classic.mesh_surface_areafmoduleõÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒfvolumex(M, N, P) array of doublesÙ¹‚ƒÙ§x7Input data volume to find isosurfaces. Will be cast to Ù£ƒjnp.float64ööÙ§a.€Ù°ƒelevelefloatÙ¹‚ƒÙ§x+Contour value to search for isosurfaces in Ù¢„fvolumeÙ „ööelocalfvolumeelocalõÙ§xF. If not given or None, the average of the min and max of vol is used.€Ù°ƒgspacingxlength-3 tuple of floatsÙ¹‚ƒÙ§xeVoxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in Ù¢„fvolumeÙ „ööelocalfvolumeelocalõÙ§a.€Ù°ƒrgradient_directionfstringÙ¹‚Ù§xôControls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒevertsl(V, 3) arrayÙ¹‚ƒÙ§xOSpatial coordinates for V unique mesh vertices. Coordinate order matches input Ù¢„fvolumeÙ „ööelocalfvolumeelocalõÙ§k (M, N, P).€Ù°ƒefacesl(F, 3) arrayÙ¹‚ƒÙ§x<Define triangular faces via referencing vertex indices from Ù¡evertsÙ§xX. This algorithm specifically outputs triangles, so each face has exactly three indices.€ögSummaryÙ¯‚Ù¹‚Ù§xHClassic marching cubes algorithm to find surfaces in 3d volumetric data.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummarypExtended SummaryjParametersgReturnseNotesjReferenceshSee Alsox+/skimage/measure/_marching_cubes_classic.pyr<class 'function'>x&skimage.measure.marching_cubes_classicÙ¯‚€ö‚Ù¼ƒÙ»ƒxskimage.measure.marching_cubesx6skimage.measure._marching_cubes_lewiner.marching_cubesõ€öÙ¼ƒÙ»ƒx!skimage.measure.mesh_surface_areax9skimage.measure._marching_cubes_classic.mesh_surface_areaõ€öf0.17.2Ù«xamarching_cubes_classic(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent')öx>skimage.measure._marching_cubes_classic.marching_cubes_classic€
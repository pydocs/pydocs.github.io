Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚…Ù¹‚Ù§y&This function implements a watershed algorithm   that apportions pixels into marked basins. The algorithm uses a priority queue to hold the pixels with the metric for the priority queue being pixel value, then the time of entry into the queue - this settles ties in favor of the closest marker.€Ù¹‚Ù§xœSome ideas taken from Soille, "Automated Basin Delineation from Digital Elevation Models Using Mathematical Morphology", Signal Processing 20 (1990) 171-182€Ù¹‚Ù§yThe most important insight in the paper is that entry time onto the queue solves two problems: a pixel should be assigned to the neighbor with the largest gradient or, if there is no gradient, pixels on a plateau should be split between markers on opposite sides.€Ù¹‚Ù§x|This implementation converts all arguments to specific, lowest common denominator types, then passes these to a C algorithm.€Ù¹‚Ù§xæMarkers can be determined manually, or automatically using for example the local minima of the gradient of the image, or the local maxima of the distance function to the background for separating overlapping objects (see example).€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‡Ù°ƒeimagex#ndarray (2-D, 3-D, ...) of integersÙ¹‚Ù§x;Data array where the lowest value points are labeled first.€Ù°ƒgmarkersx7int, or ndarray of int, same shape as `image`, optionalÙ¹‚ƒÙ§xThe desired number of markers, or an array marking the basins with the values to be assigned in the label matrix. Zero means not a marker. If Ù¡dNoneÙ§xG (no markers given), the local minima of the image are used as markers.€Ù°ƒlconnectivityqndarray, optionalÙ¹‚ƒÙ§x/An array with the same number of dimensions as Ù¢„eimageÙ „ööelocaleimageelocalõÙ§x› whose non-zero elements indicate neighbors for connection. Following the scipy convention, default is a one-connected array of the dimension of the image.€Ù°ƒfoffsetx(array_like of shape image.ndim, optionalÙ¹‚Ù§x5offset of the connectivity (one offset per dimension)€Ù°ƒdmaskx'ndarray of bools or 0s and 1s, optionalÙ¹‚ƒÙ§wArray of same shape as Ù¢„eimageÙ „ööelocaleimageelocalõÙ§x4. Only points at which mask == True will be labeled.€Ù°ƒkcompactnessofloat, optionalÙ¹‚Ù§xxUse compact watershed  with given compactness parameter. Higher values result in more regularly-shaped watershed basins.€Ù°ƒnwatershed_linenbool, optionalÙ¹‚Ù§x…If watershed_line is True, a one-pixel wide line separates the regions obtained by the watershed algorithm. The line has the label 0.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒcoutgndarrayÙ¹‚Ù§x6A labeled matrix of the same type and shape as markers€ögSummaryÙ¯‚Ù¹‚…Ù§xFind watershed basins in Ù¢„eimageÙ „ööelocaleimageelocalõÙ§t flooded from given Ù¢„gmarkersÙ „ööelocalgmarkerselocalõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnshSee AlsoeNotesjReferenceshExamplesx#/skimage/segmentation/_watershed.py^r<class 'function'>xskimage.segmentation.watershedÙ¯‚ˆÙ¹‚Ù§xBThe watershed algorithm is useful to separate overlapping objects.€Ù¹‚Ù§x@We first generate an initial image with two overlapping circles:€Ù´ƒ˜ŠÙ±‚`axÙ±‚`a,Ù±‚`a Ù±‚`ayÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„gindicesÙ „enumpyf1.22.3fmodulemnumpy.indicesfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmib80Ù±‚`a,Ù±‚`a Ù±‚bmib80Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bx1Ù±‚`a,Ù±‚`a Ù±‚`by1Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bx2Ù „gskimagef0.17.2fmodulex9skimage.feature.corner._image_orthogonal_matrix22_eigvalsfmoduleõÙ±‚`a,Ù±‚`a Ù±‚`by2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmib28Ù±‚`a,Ù±‚`a Ù±‚bmib28Ù±‚`a,Ù±‚`a Ù±‚bmib44Ù±‚`a,Ù±‚`a Ù±‚bmib52Ù±‚`a
Ù±‚`br1Ù±‚`a,Ù±‚`a Ù±‚`br2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚bmib16Ù±‚`a,Ù±‚`a Ù±‚bmiÙ¢„b20Ù „gskimagef0.17.2fmodulex&skimage.color.delta_e.deltaE_ciede2000fmoduleõÙ±‚`a
Ù±‚`lmask_circle1Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`bx1Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`a(Ù±‚`ayÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`by1Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoÙ¢„a<Ù „gskimagef0.17.2fmodulexJskimage.io.collection.imread_collection_wrapper.<locals>.imread_collectionfmoduleõÙ±‚`a Ù±‚`br1Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a
Ù±‚`lmask_circle2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a(Ù±‚`axÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`Ù¢„bx2Ù „gskimagef0.17.2fmodulex9skimage.feature.corner._image_orthogonal_matrix22_eigvalsfmoduleõÙ±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚`a(Ù±‚`ayÙ±‚`a Ù±‚aoa-Ù±‚`a Ù±‚`by2Ù±‚`a)Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a Ù±‚aoÙ¢„a<Ù „gskimagef0.17.2fmodulexJskimage.io.collection.imread_collection_wrapper.<locals>.imread_collectionfmoduleõÙ±‚`a Ù±‚`br2Ù±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a
Ù±‚`eimageÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`jlogical_orÙ±‚`a(Ù±‚`lmask_circle1Ù±‚`a,Ù±‚`a Ù±‚`lmask_circle2Ù±‚`a)`hcompiledÙ¹‚Ù§xoNext, we want to separate the two circles. We generate markers at the maxima of the distance to the background:€Ù´ƒ˜RÙ±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„escipyÙ „escipye1.8.0fmoduleescipyfmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`Ù¢„gndimageÙ „gskimagef0.17.2fmodulex-skimage.transform._geometric._to_ndimage_modefmoduleõÙ±‚`a Ù±‚akbasÙ±‚`a Ù±‚`cndiÙ±‚`a
Ù±‚`hdistanceÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cndiÙ±‚aoa.Ù±‚`vdistance_transform_edtÙ±‚`a(Ù±‚`eimageÙ±‚`a)Ù±‚`a
Ù±‚bkndfromÙ±‚`a Ù±‚bnnÙ¢„gskimageÙ „gskimagef0.17.2fmodulegskimagefmoduleõÙ±‚bnna.Ù±‚bnnÙ¢„gfeatureÙ „gskimagef0.17.2fmoduleoskimage.featurefmoduleõÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`npeak_local_maxÙ±‚`a
Ù±‚`jlocal_maxiÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`npeak_local_maxÙ±‚`a(Ù±‚`hdistanceÙ±‚`a,Ù±‚`a Ù±‚`flabelsÙ±‚aoa=Ù±‚`eimageÙ±‚`a,Ù±‚`a
Ù±‚`x                            Ù±‚`ifootprintÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„donesÙ „enumpyf1.22.3fmodulejnumpy.onesfmoduleõÙ±‚`a(Ù±‚`a(Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a)Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`x                            Ù±‚`gindicesÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`a
Ù±‚`gmarkersÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`cndiÙ±‚aoa.Ù±‚`Ù¢„elabelÙ „gskimagef0.17.2fmodulexskimage.measure._label.labelfmoduleõÙ±‚`a(Ù±‚`jlocal_maxiÙ±‚`a)Ù±‚`a[Ù±‚bmiÙ¢„a0Ù „gskimagef0.17.2fmodulex&skimage.color.delta_e.deltaE_ciede2000fmoduleõÙ±‚`a]`hcompiledÙ¹‚Ù§x7Finally, we run the watershed on the image and markers:€Ù´ƒ‘Ù±‚`flabelsÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„iwatershedÙ „gskimagef0.17.2fmodulex)skimage.segmentation._watershed.watershedfmoduleõÙ±‚`a(Ù±‚aoa-Ù±‚`hdistanceÙ±‚`a,Ù±‚`a Ù±‚`gmarkersÙ±‚`a,Ù±‚`a Ù±‚`dmaskÙ±‚aoa=Ù±‚`eimageÙ±‚`a)`hcompiledÙ¹‚Ù§xeThe algorithm works also for 3-D images, and can be used for example to separate overlapping spheres.€öÙ¼ƒÙ»ƒx"skimage.segmentation.random_walkerx=skimage.segmentation.random_walker_segmentation.random_walkerõÙ¹‚Ù§x´random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.€öf0.17.2Ù«xkwatershed(image, markers=None, connectivity=1, offset=None, mask=None, compactness=0, watershed_line=False)öx)skimage.segmentation._watershed.watershed€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§y?The filter is computed by applying the edge weights along one dimension and the smoothing weights along all other dimensions. If no axis is given, or a tuple of axes is given the filter is computed along all axes in turn, and the magnitude is computed as the square root of the average square magnitude of all the axes.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚†Ù°ƒeimageearrayÙ¹‚Ù§pThe input image.€Ù°ƒnsmooth_weightsnarray of floatÙ¹‚Ù§xbThe smoothing weights for the filter. These are applied to dimensions orthogonal to the edge axis.€Ù°ƒledge_weightsx1D array of float, optionalÙ¹‚Ù§x6The weights to compute the edge along the chosen axes.€Ù°ƒdaxisx int or sequence of int, optionalƒÙ¹‚Ù§xtCompute the edge filter along this axis. If not provided, the edge magnitude is computed. This is defined as::      €ÙÀx†edge_mag = np.sqrt(sum([_generic_edge_filter(image, ..., axis=i)**2
                        for i in range(image.ndim)]) / image.ndim)Ù¹‚Ù§x5The magnitude is also computed if axis is a sequence.€Ù°ƒdmodex str or sequence of str, optionalÙ¹‚ƒÙ§x+The boundary mode for the convolution. See Ù¢„vscipy.ndimage.convolveÙ „escipya*capixscipy.ndimage._filters.convolvefmoduleõÙ§xi for a description of the modes. This can be either a single boundary mode or one boundary mode per axis.€Ù°ƒdcvalofloat, optionalÙ¹‚…Ù§eWhen Ù¢„dmodeÙ „ööelocaldmodeelocalõÙ§d is Ù¡j'constant'Ù§xM, this is the constant used in values outside the boundary of the image data.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x+Apply a generic, n-dimensional edge filter.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryjParametersx/skimage/filters/edges.pyr<class 'function'>x*skimage.filters.edges._generic_edge_filterÙ¯‚€ö€f0.17.2Ù«xw_generic_edge_filter(image, *, smooth_weights, edge_weights=[1, 0, -1], axis=None, mode='reflect', cval=0.0, mask=None)öx*skimage.filters.edges._generic_edge_filter€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§x_References are often relative based on the current context (which object you are currently in).€Ù¹‚Ù§xGiven this informations and all the local (same document) and global (same library/all libraries) references, compute the Reference Info object.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒbqacstrÙ¹‚Ù§xifully qualified path of the current object (.valueTODO: this will be weird for non object, like example).€Ù°ƒjknown_refsolist of RefInfoÙ¹‚Ù§x:All the known objects we can refer to in current universe.€Ù°ƒjlocal_refsklist of strÙ¹‚Ù§x:All the current objects in current scope (same docstring).€Ù°ƒcrefcstrÙ¹‚Ù§c???€Ù°ƒkrev_aliases`Ù¹‚Ù§x¡Reverse alias map. As the import name of object may not be the fully qualified names, we may need a reverse alias map to resolve with respect to the import name.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xLGiven the current context (qa), and a str (ref), compute the RefInfo object.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummarypExtended SummaryjParameterso/papyri/tree.pyXr<class 'function'>tpapyri.tree.resolve_Ù¯‚€ö€e0.0.8Ù«x‰resolve_(qa: str, known_refs: FrozenSet[papyri.take2.RefInfo], local_refs: FrozenSet[str], ref: str, rev_aliases) -> papyri.take2.RefInfoötpapyri.tree.resolve_€
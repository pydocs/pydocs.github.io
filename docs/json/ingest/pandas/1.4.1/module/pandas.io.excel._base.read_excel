Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§iSupports Ù£ƒcxlsööÙ§b, Ù£ƒdxlsxööÙ§b, Ù£ƒdxlsmööÙ§b, Ù£ƒdxlsbööÙ§b, Ù£ƒcodfööÙ§b, Ù£ƒcodsööÙ§e and Ù£ƒcodtööÙ§xt file extensions read from a local filesystem or URL. Supports an option to read a single sheet or a list of sheets.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚˜Ù°ƒbioxBstr, bytes, ExcelFile, xlrd.Book, path object, or file-like objectƒÙ¹‚ƒÙ§x­Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: Ù¡x#file://localhost/path/to/table.xlsxÙ§a.€Ù¹‚ƒÙ§x9If you want to pass in a path object, pandas accepts any Ù¡kos.PathLikeÙ§a.€Ù¹‚‡Ù§x0By file-like object, we refer to objects with a Ù¡fread()Ù§x1 method, such as a file handle (e.g. via builtin Ù¡dopenÙ§n function) or Ù¡hStringIOÙ§a.€Ù°ƒjsheet_namex"str, int, list, or None, default 0ƒÙ¹‚Ù§xçStrings are used for sheet names. Integers are used in zero-indexed sheet positions (chart sheets do not count as a sheet position). Lists of strings/integers are used to request multiple sheets. Specify None to get all worksheets.€Ù¹‚Ù§pAvailable cases:€ÙÈ…Ù¹‚„Ù§lDefaults to Ù¡a0Ù§q: 1st sheet as a Ù£ƒiDataFrameöö€Ù¹‚ƒÙ¡a1Ù§q: 2nd sheet as a Ù£ƒiDataFrameöö€Ù¹‚‚Ù¡h"Sheet1"Ù§x: Load sheet with name "Sheet1"€Ù¹‚ƒÙ¡p[0, 1, "Sheet5"]Ù§x=: Load first, second and sheet named "Sheet5"   as a dict of Ù£ƒiDataFrameöö€Ù¹‚Ù§uNone: All worksheets.€Ù°ƒfheaderxint, list of int, default 0Ù¹‚ƒÙ§x’Row (0-indexed) to use for the column labels of the parsed DataFrame. If a list of integers is passed those row positions will be combined into a Ù¡jMultiIndexÙ§x!. Use None if there is no header.€Ù°ƒenamesxarray-like, default NoneÙ¹‚Ù§xiList of column names to use. If file contains no header row, then you should explicitly pass header=None.€Ù°ƒiindex_colxint, list of int, default NoneÙ¹‚…Ù§x Column (0-indexed) to use as the row labels of the DataFrame. Pass None if there is no such column.  If a list is passed, those columns will be combined into a Ù¡jMultiIndexÙ§x(.  If a subset of data is selected with Ù¡gusecolsÙ§x#, index_col is based on the subset.€Ù°ƒgusecolsx-int, str, list-like, or callable default None‚ÙÈ…Ù¹‚Ù§x If None, then parse all columns.€Ù¹‚Ù§x˜If str, then indicates comma separated list of Excel column letters   and column ranges (e.g. "A:E" or "A,C,E:F"). Ranges are inclusive of   both sides.€Ù¹‚Ù§xCIf list of int, then indicates list of column numbers to be parsed.€Ù¹‚Ù§xDIf list of string, then indicates list of column names to be parsed.€Ù¹‚ƒÙ§xfIf callable, then evaluate each column name against it and parse the   column if the callable returns Ù¡dTrueÙ§a.€Ù¹‚Ù§x<Returns a subset of the columns according to behavior above.€Ù°ƒgsqueezesbool, default False‚Ù¹‚Ù§xAIf the parsed data only contains one column then return a Series.€ÙÆƒjdeprecatede1.4.0Ù¹‚Ù§xWAppend ``.squeeze ( " columns " )`` to the call to ``read_excel`` to squeeze the data. €Ù°ƒedtypex1Type name or dict of column -> type, default NoneÙ¹‚ƒÙ§xIData type for data or columns. E.g. {'a': np.float64, 'b': np.int32} Use Ù£ƒfobjectööÙ§xŒ to preserve data as stored in Excel and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion.€Ù°ƒfengineqstr, default None„Ù¹‚Ù§xIf io is not a buffer or path, this must be set to identify io. Supported engines: "xlrd", "openpyxl", "odf", "pyxlsb". Engine compatibility :€ÙÈ„Ù¹‚Ù§x-"xlrd" supports old-style Excel files (.xls).€Ù¹‚Ù§x-"openpyxl" supports newer Excel file formats.€Ù¹‚Ù§x<"odf" supports OpenDocument file formats (.odf, .ods, .odt).€Ù¹‚Ù§x%"pyxlsb" supports Binary Excel files.€ÙÆƒnversionchangede1.2.0Ù¹‚Ù§xÆThe engine `xlrd < https : / / xlrd.readthedocs.io / en / latest / >`_ now only supports old - style ``.xls`` files. When ``engine=None``, the following logic will be used to determine the engine : €Ù·‹xE- If ``path_or_buffer`` is an OpenDocument format (.odf, .ods, .odt),x=  then `odf <https://pypi.org/project/odfpy/>`_ will be used.x3- Otherwise if ``path_or_buffer`` is an xls format,x  ``xlrd`` will be used.x4- Otherwise if ``path_or_buffer`` is in xlsb format,x  ``pyxlsb`` will be used.`x  .. versionadded:: 1.3.0x&- Otherwise ``openpyxl`` will be used.`x  .. versionchanged:: 1.3.0Ù°ƒjconvertersrdict, default NoneÙ¹‚Ù§xØDict of functions for converting values in certain columns. Keys can either be integers or column labels, values are functions that take one input argument, the Excel cell content, and return the transformed content.€Ù°ƒktrue_valuesrlist, default NoneÙ¹‚Ù§xValues to consider as True.€Ù°ƒlfalse_valuesrlist, default NoneÙ¹‚Ù§xValues to consider as False.€Ù°ƒhskiprowsx%list-like, int, or callable, optionalÙ¹‚ƒÙ§yLine numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be Ù¡ulambda
x: x in [0, 2]Ù§a.€Ù°ƒenrowsqint, default NoneÙ¹‚Ù§xNumber of rows to parse.€Ù°ƒina_valuesx-scalar, str, list-like, or dict, default NoneÙ¹‚Ù§y&Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. By default the following values are interpreted as NaN: '', '#N/A', '#N/A N/A', '#NA', '-1.#IND', '-1.#QNAN', '-NaN', '-nan', '1.#IND', '1.#QNAN', '<NA>', 'N/A', 'NA', 'NULL', 'NaN', 'n/a', 'nan', 'null'.€Ù°ƒokeep_default_narbool, default TrueƒÙ¹‚ƒÙ§x]Whether or not to include the default NaN values when parsing the data. Depending on whether Ù¢„ina_valuesÙ „ööelocalina_valueselocalõÙ§x* is passed in, the behavior is as follows:€ÙÈ„Ù¹‚‡Ù§cIf Ù£ƒokeep_default_naööÙ§n is True, and Ù£ƒina_valuesööÙ§p are specified, Ù£ƒina_valuesööÙ§x:   is appended to the default NaN values used for parsing.€Ù¹‚…Ù§cIf Ù£ƒokeep_default_naööÙ§n is True, and Ù£ƒina_valuesööÙ§xG are not specified, only   the default NaN values are used for parsing.€Ù¹‚‡Ù§cIf Ù£ƒokeep_default_naööÙ§o is False, and Ù£ƒina_valuesööÙ§x0 are specified, only   the NaN values specified Ù£ƒina_valuesööÙ§v are used for parsing.€Ù¹‚…Ù§cIf Ù£ƒokeep_default_naööÙ§o is False, and Ù£ƒina_valuesööÙ§x7 are not specified, no   strings will be parsed as NaN.€Ù¹‚‡Ù§mNote that if Ù¢„ina_filterÙ „ööelocalina_filterelocalõÙ§x is passed in as False, the Ù¢„okeep_default_naÙ „ööelocalokeep_default_naelocalõÙ§e and Ù¢„ina_valuesÙ „ööelocalina_valueselocalõÙ§x parameters will be ignored.€Ù°ƒina_filterrbool, default TrueÙ¹‚Ù§x®Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing na_filter=False can improve the performance of reading a large file.€Ù°ƒgverbosesbool, default FalseÙ¹‚Ù§x;Indicate number of NA values placed in non-numeric columns.€Ù°ƒkparse_datesx'bool, list-like, or dict, default FalseÙ¹‚Ù§xThe behavior is as follows:€Ù°ƒkdate_parserrfunction, optionalÙ¹‚Ù§xpFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses Ù¡vdateutil.parser.parserÙ§x/ to do the conversion. Pandas will try to call Ù¢„kdate_parserÙ „ööelocalkdate_parserelocalõÙ§xr in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by Ù¢„kparse_datesÙ „ööelocalkparse_dateselocalõÙ§xX) as arguments; 2) concatenate (row-wise) the string values from the columns defined by Ù¢„kparse_datesÙ „ööelocalkparse_dateselocalõÙ§x0 into a single array and pass that; and 3) call Ù¢„kdate_parserÙ „ööelocalkdate_parserelocalõÙ§xV once for each row using one or more strings (corresponding to the columns defined by Ù¢„kparse_datesÙ „ööelocalkparse_dateselocalõÙ§o) as arguments.€Ù°ƒithousandsqstr, default NoneÙ¹‚Ù§xÛThousands separator for parsing string columns to numeric.  Note that this parameter is only necessary for columns stored as TEXT in Excel, any numeric columns will automatically be parsed, regardless of display format.€Ù°ƒgdecimalpstr, default '.'‚Ù¹‚Ù§yCharacter to recognize as decimal point for parsing string columns to numeric. Note that this parameter is only necessary for columns stored as TEXT in Excel, any numeric columns will automatically be parsed, regardless of display format.(e.g. use ',' for European data).€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.4.0 €Ù°ƒgcommentqstr, default NoneÙ¹‚Ù§xÇComments out remainder of line. Pass a character or characters to this argument to indicate comments in the input file. Any data between the comment string and the end of the current line is ignored.€Ù°ƒjskipfooternint, default 0Ù¹‚Ù§x$Rows at the end to skip (0-indexed).€Ù°ƒmconvert_floatrbool, default True‚Ù¹‚Ù§x–Convert integral floats to int (i.e., 1.0 --> 1). If False, all numeric data will be read in as floats: Excel stores all numbers as floats internally.€ÙÆƒjdeprecatede1.3.0Ù¹‚Ù§x2convert_float will be removed in a future version €Ù°ƒpmangle_dupe_colsrbool, default TrueÙ¹‚Ù§x³Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than 'X'...'X'. Passing in False will cause data to be overwritten if there are duplicate names in the columns.€Ù°ƒostorage_optionsndict, optional‚Ù¹‚ƒÙ§x”Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc., if using a URL that will be parsed by Ù¡ffsspecÙ§xŞ, e.g., starting "s3://", "gcs://". An error will be raised if providing this argument with a local path or a file-like buffer. See the fsspec and backend storage implementation docs for the set of allowed keys and values.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.2.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`xDataFrame or dict of DataFramesÙ¹‚Ù§xˆDataFrame from the passed in Excel file. See notes in sheet_name argument for more information on when a dict of DataFrames is returned.€ögSummaryÙ¯‚Ù¹‚Ù§x+Read an Excel file into a pandas DataFrame.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshSee AlsohExamplesx/pandas/io/excel/_base.py¦r<class 'function'>qpandas.read_excelÙ¯‚‹Ù¹‚Ù§xJThe file can be read using the file name as string or an open file object:€Ù´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`iindex_colÙ±‚aoa=Ù±‚bmia0Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxK       Name  Value
0   string1      1
1   string2      2
2  #Comment      3hcompiledÙ´ƒ˜Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bnbÙ¢„dopenÙ „fpandase1.4.1fmodulex pandas.io.pytables.HDFStore.openfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1brbÙ±‚bs1a'Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`Ù¢„jsheet_nameÙ „fpandase1.4.1fmodulex1pandas.io.excel._base.ExcelWriter._get_sheet_namefmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fSheet3Ù±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx{   Unnamed: 0      Name  Value
0           0   string1      1
1           1   string2      2
2           2  #Comment      3hcompiledÙ¹‚…Ù§x*Index and header can be specified via the Ù¢„iindex_colÙ „ööelocaliindex_colelocalõÙ§e and Ù¢„fheaderÙ „ööelocalfheaderelocalõÙ§j arguments€Ù´ƒ”Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`iindex_colÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a,Ù±‚`a Ù±‚`fheaderÙ±‚aoa=Ù±‚bkcdNoneÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxw     0         1      2
0  NaN      Name  Value
1  0.0   string1      1
2  1.0   string2      2
3  2.0  #Comment      3hcompiledÙ¹‚Ù§x9Column types are inferred but can be explicitly specified€Ù´ƒ˜$Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`iindex_colÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`Ù¢„edtypeÙ „fpandase1.4.1fmodulexpandas.core.arrays.sparse.dtypefmoduleõÙ±‚aoa=Ù±‚`a{Ù±‚bs1a'Ù±‚bs1dNameÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bnbcstrÙ±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1eValueÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bnbefloatÙ±‚`a}Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxK       Name  Value
0   string1    1.0
1   string2    2.0
2  #Comment    3.0hcompiledÙ¹‚Ù§xªTrue, False, and NA values, and thousands separators have defaults, but can be explicitly specified, too. Supply the values you would like as strings or lists of strings!€Ù´ƒ˜Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`iindex_colÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a
Ù±‚`n              Ù±‚`ina_valuesÙ±‚aoa=Ù±‚`a[Ù±‚bs1a'Ù±‚bs1gstring1Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1gstring2Ù±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxK       Name  Value
0       NaN      1
1       NaN      2
2  #Comment      3hcompiledÙ¹‚ƒÙ§x?Comment lines in the excel input file can be skipped using the Ù¢„gcommentÙ „ööelocalgcommentelocalõÙ§f kwarg€Ù´ƒ–Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„jread_excelÙ „fpandase1.4.1fmodulex pandas.io.excel._base.read_excelfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1htmp.xlsxÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`iindex_colÙ±‚aoa=Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„gcommentÙ „fpandase1.4.1fmodulex<pandas.io.parsers.python_parser.PythonParser._check_commentsfmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1a#Ù±‚bs1a'Ù±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPxG      Name  Value
0  string1    1.0
1  string2    2.0
2     None    NaNhcompiledö„Ù¼ƒÙ»ƒpDataFrame.to_csvööÙ¹‚Ù§x7Write DataFrame to a comma-separated values (csv) file.€öÙ¼ƒÙ»ƒrDataFrame.to_excelööÙ¹‚Ù§x!Write DataFrame to an Excel file.€öÙ¼ƒÙ»ƒhread_csvx"pandas.io.parsers.readers.read_csvõÙ¹‚Ù§x8Read a comma-separated values (csv) file into DataFrame.€öÙ¼ƒÙ»ƒhread_fwfx"pandas.io.parsers.readers.read_fwfõÙ¹‚Ù§x;Read a table of fixed-width formatted lines into DataFrame.€öe1.4.1Ù«y¢read_excel(io, sheet_name: 'str | int | list[IntStrT] | None' = 0, header: 'int | Sequence[int] | None' = 0, names=None, index_col: 'int | Sequence[int] | None' = None, usecols=None, squeeze: 'bool | None' = None, dtype: 'DtypeArg | None' = None, engine: "Literal['xlrd', 'openpyxl', 'odf', 'pyxlsb'] | None" = None, converters=None, true_values: 'Iterable[Hashable] | None' = None, false_values: 'Iterable[Hashable] | None' = None, skiprows: 'Sequence[int] | int | Callable[[int], object] | None' = None, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, parse_dates=False, date_parser=None, thousands: 'str | None' = None, decimal: 'str' = '.', comment: 'str | None' = None, skipfooter: 'int' = 0, convert_float: 'bool | None' = None, mangle_dupe_cols: 'bool' = True, storage_options: 'StorageOptions' = None) -> 'DataFrame | dict[IntStrT, DataFrame]'öx pandas.io.excel._base.read_excel€
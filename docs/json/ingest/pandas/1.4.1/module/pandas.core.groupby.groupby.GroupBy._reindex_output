Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xThe method returns early without modifying the input if the number of groupings is less than 2, self.observed == True or none of the groupers are categorical.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒfoutputsSeries or DataFrameÙ¹‚Ù§x9Object resulting from grouping and applying an operation.€Ù°ƒjfill_valuevscalar, default np.NaNÙ¹‚Ù§xAValue to use for unobserved categories if self.observed is False.€Ù°ƒbqsx)np.ndarray[float64] or None, default NoneÙ¹‚Ù§x,quantile values, only relevant for quantile.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`sSeries or DataFrameÙ¹‚Ù§x?Object (potentially) re-indexed to include all possible groups.€ögSummaryÙ¯‚Ù¹‚Ù§yZIf we have categorical groupers, then we might want to make sure that we have a fully re-indexed output to the levels. This means expanding the output space to accommodate all values in the cartesian product of our groups, regardless of whether they were observed in the data or not. This will expand the output space if there are missing groups.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersgReturnsx/pandas/core/groupby/groupby.py	r<class 'function'>x+pandas.core.groupby.GroupBy._reindex_outputÙ¯‚€ö€e1.4.1Ù«x–_reindex_output(self, output: 'OutputFrameOrSeries', fill_value: 'Scalar' = nan, qs: 'npt.NDArray[np.float64] | None' = None) -> 'OutputFrameOrSeries'öx3pandas.core.groupby.groupby.GroupBy._reindex_output€
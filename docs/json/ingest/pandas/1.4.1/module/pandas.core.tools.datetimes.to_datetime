Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚…Ù§x-This function converts a scalar, array-like, Ù¢„fSeriesÙ „fpandase1.4.1fmodulexpandas.core.series.SeriesfmoduleõÙ§d or Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ§x'/dict-like to a pandas datetime object.€ögMethodsÙ¯‚€öeNotesÙ¯‚ˆÙ¹‚Ù§xCMany input types are supported, and lead to different output types:€ÙÈÙ¹‚ŒÙ©Ù§gscalarsÙ§x6 can be int, float, str, datetime object (from stdlib Ù£ƒhdatetimeöcmodÙ§m   module or Ù£ƒenumpyöcmodÙ§x). They are converted to Ù£ƒiTimestampöeclassÙ§x2 when   possible, otherwise they are converted to Ù£ƒqdatetime.datetimeöeclassÙ§x+.   None/NaN/null scalars are converted to Ù£ƒcNaTöeconstÙ§a.€ÙÈÙ¹‚ŒÙ©Ù§jarray-likeÙ§xH can contain int, float, str, datetime objects. They are   converted to Ù£ƒmDatetimeIndexöeclassÙ§x2 when possible, otherwise they are   converted to Ù£ƒeIndexöeclassÙ§f with Ù£ƒfobjectöeclassÙ§u dtype, containing   Ù£ƒqdatetime.datetimeöeclassÙ§x+. None/NaN/null entries are converted to   Ù£ƒcNaTöeconstÙ§o in both cases.€ÙÈÙ¹‚Ù©Ù§fSeriesÙ§r are converted to Ù£ƒfSeriesöeclassÙ§f with Ù£ƒjdatetime64öeclassÙ§x8   dtype when possible, otherwise they are converted to Ù£ƒfSeriesöeclassÙ§h with   Ù£ƒfobjectöeclassÙ§s dtype, containing Ù£ƒqdatetime.datetimeöeclassÙ§x+. None/NaN/null   entries are converted to Ù£ƒcNaTöeconstÙ§o in both cases.€ÙÈÙ¹‚†Ù©Ù§sDataFrame/dict-likeÙ§r are converted to Ù£ƒfSeriesöeclassÙ§h with   Ù£ƒjdatetime64öeclassÙ§y dtype. For each row a datetime is created from assembling   the various dataframe columns. Column keys can be common abbreviations   like [â€˜yearâ€™, â€˜monthâ€™, â€˜dayâ€™, â€˜minuteâ€™, â€˜secondâ€™, â€˜msâ€™, â€˜usâ€™, â€˜nsâ€™]) or   plurals of the same.€Ù¹‚‘Ù§x)The following causes are responsible for Ù¢„qdatetime.datetimeÙ „hdatetimea*capiqdatetime.datetimefmoduleõÙ§x, objects being returned (possibly inside an Ù¢„eIndexÙ „fpandase1.4.1fmodulexpandas.core.indexes.base.IndexfmoduleõÙ§f or a Ù¢„fSeriesÙ „fpandase1.4.1fmodulexpandas.core.series.SeriesfmoduleõÙ§f with Ù£ƒfobjectöeclassÙ§x4 dtype) instead of a proper pandas designated type (Ù¢„iTimestampÙ „fpandase1.4.1fmodulex(pandas._libs.tslibs.timestamps.TimestampfmoduleõÙ§b, Ù¢„mDatetimeIndexÙ „fpandase1.4.1fmodulex+pandas.core.indexes.datetimes.DatetimeIndexfmoduleõÙ§d or Ù¢„fSeriesÙ „fpandase1.4.1fmodulexpandas.core.series.SeriesfmoduleõÙ§f with Ù£ƒjdatetime64öeclassÙ§h dtype):€ÙÈÙ¹‚‡Ù§x!when any input element is before Ù£ƒmTimestamp.minöeconstÙ§l or after   Ù£ƒmTimestamp.maxöeconstÙ§f, see Ù£ƒx€timestamp limitations
  <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
  #timeseries-timestamp-limits>ööÙ§a.€ÙÈÙ¹‚‡Ù§ewhen Ù¡iutc=FalseÙ§x/ (default) and the input is an array-like or   Ù£ƒfSeriesöeclassÙ§xÛ containing mixed naive/aware datetime, or aware with mixed   time offsets. Note that this happens in the (quite frequent) situation when   the timezone has a daylight savings policy. In that case you may wish to   use Ù¡hutc=TrueÙ§a.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‹Ù°ƒcargxNint, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-likeÙ¹‚‰Ù§x*The object to convert to a datetime. If a Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ§xB is provided, the method expects minimally the following columns: Ù£ƒf"year"öeconstÙ§b, Ù£ƒg"month"öeconstÙ§b, Ù£ƒe"day"öeconstÙ§a.€Ù°ƒferrorsx.{'ignore', 'raise', 'coerce'}, default 'raise'ÙÈƒÙ¹‚ƒÙ§cIf Ù£ƒg'raise'öeconstÙ§x/, then invalid parsing will raise an exception.€Ù¹‚…Ù§cIf Ù£ƒh'coerce'öeconstÙ§x&, then invalid parsing will be set as Ù£ƒcNaTöeconstÙ§a.€Ù¹‚ƒÙ§cIf Ù£ƒh'ignore'öeconstÙ§x-, then invalid parsing will return the input.€Ù°ƒhdayfirstsbool, default False‚Ù¹‚‰Ù§xSpecify a date parse order if Ù¢„cargÙ „ööelocalcargelocalõÙ§x is str or is list-like. If Ù£ƒdTrueöeconstÙ§x(, parses dates with the day first, e.g. Ù£ƒj"10/11/12"öeconstÙ§n is parsed as Ù£ƒj2012-11-10öeconstÙ§a.€ÙÆƒgwarning`Ù¹‚Ù§xô``dayfirst=True`` is not strict, but will prefer to parse with day first. If a delimited date string cannot be parsed in accordance with the given `dayfirst` option, e.g. ``to_datetime ( [ ' 31 - 12 - 2021 ' ])``, then a warning will be shown. €Ù°ƒiyearfirstsbool, default FalseƒÙ¹‚ƒÙ§xSpecify a date parse order if Ù¢„cargÙ „ööelocalcargelocalõÙ§x is str or is list-like.€ÙÈ‚Ù¹‚‡Ù§cIf Ù£ƒdTrueöeconstÙ§x* parses dates with the year first, e.g.   Ù£ƒj"10/11/12"öeconstÙ§n is parsed as Ù£ƒj2010-11-12öeconstÙ§a.€Ù¹‚‹Ù§hIf both Ù£ƒhdayfirstööÙ§e and Ù£ƒiyearfirstööÙ§e are Ù£ƒdTrueöeconstÙ§b, Ù£ƒiyearfirstööÙ§x is   preceded (same as Ù£ƒhdateutilöcmodÙ§b).€ÙÆƒgwarning`Ù¹‚Ù§xL``yearfirst=True`` is not strict, but will prefer to parse with year first. €Ù°ƒcutcrbool, default None„Ù¹‚Ù§x>Control timezone-related parsing, localization and conversion.€ÙÈÙ¹‚Ù§cIf Ù£ƒdTrueöeconstÙ§o, the function Ù¨Ù§falwaysÙ§x* returns a timezone-aware   UTC-localized Ù£ƒiTimestampöeclassÙ§b, Ù£ƒfSeriesöeclassÙ§f or   Ù£ƒmDatetimeIndexöeclassÙ§x*. To do this, timezone-naive inputs are   Ù¨Ù§ilocalizedÙ§x) as UTC, while timezone-aware inputs are Ù¨Ù§iconvertedÙ§h to UTC.€ÙÈÙ¹‚…Ù§cIf Ù£ƒeFalseöeconstÙ§xİ (default), inputs will not be coerced to UTC.   Timezone-naive inputs will remain naive, while timezone-aware ones   will keep their time offsets. Limitations exist for mixed   offsets (typically, daylight savings), see Ù£ƒx$Examples
  <to_datetime_tz_examples>öcrefÙ§u section for details.€Ù¹‚ƒÙ§x-See also: pandas general documentation about ÙË‚x$timezone conversion and
localizationx[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
#time-zone-handlingÙ§a.€Ù°ƒfformatqstr, default NoneÙ¹‚‡Ù§x!The strftime to parse time, e.g. Ù£ƒj"%d/%m/%Y"öeconstÙ§l. Note that Ù£ƒd"%f"öeconstÙ§x/ will parse all the way up to nanoseconds. See ÙË‚vstrftime documentationxOhttps://docs.python.org/3/library/datetime.html
#strftime-and-strptime-behaviorÙ§x! for more information on choices.€Ù°ƒeexactrbool, default True‚Ù¹‚ƒÙ§lControl how Ù¢„fformatÙ „ööelocalfformatelocalõÙ§i is used:€ÙÈ‚Ù¹‚…Ù§cIf Ù£ƒdTrueöeconstÙ§s, require an exact Ù£ƒfformatööÙ§g match.€Ù¹‚…Ù§cIf Ù£ƒeFalseöeconstÙ§l, allow the Ù£ƒfformatööÙ§x* to match anywhere in the target   string.€Ù°ƒdunitqstr, default 'ns'Ù¹‚…Ù§xŠThe unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number. This will be based off the origin. Example, with Ù¡iunit='ms'Ù§e and Ù¡morigin='unix'Ù§xX (the default), this would calculate the number of milliseconds to the unix epoch start.€Ù°ƒuinfer_datetime_formatsbool, default FalseÙ¹‚…Ù§cIf Ù£ƒdTrueöeconstÙ§h and no Ù¢„fformatÙ „ööelocalfformatelocalõÙ§xå is given, attempt to infer the format of the datetime strings based on the first non-NaN element, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x.€Ù°ƒforiginvscalar, default 'unix'‚Ù¹‚ƒÙ§x]Define the reference date. The numeric values would be parsed as number of units (defined by Ù¢„dunitÙ „ööelocaldunitelocalõÙ§x) since this reference date.€ÙÈƒÙ¹‚ƒÙ§cIf Ù£ƒf'unix'öeconstÙ§x. (or POSIX) time; origin is set to 1970-01-01.€Ù¹‚‡Ù§cIf Ù£ƒh'julian'öeconstÙ§o, unit must be Ù£ƒc'D'öeconstÙ§xI, and origin is set to   beginning of Julian Calendar. Julian day number Ù£ƒa0öeconstÙ§xA is assigned   to the day starting at noon on January 1, 4713 BC.€Ù¹‚Ù§xLIf Timestamp convertible, origin is set to Timestamp identified by   origin.€Ù°ƒecacherbool, default True‚Ù¹‚ƒÙ§cIf Ù£ƒdTrueöeconstÙ§yP, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. The cache is only used when there are at least 50 values. The presence of out-of-bounds values will render the cache unusable and may slow down parsing.€ÙÆƒnversionchangedf0.25.0Ù¹‚Ù§xBchanged default value from : const : `False` to : const : `True`. €öfRaisesÙ¯‚‚Ù°ƒ`kParserErrorÙ¹‚Ù§x&When parsing a date from string fails.€Ù°ƒ`jValueErrorÙ¹‚‡Ù§xvWhen another datetime conversion error happens. For example when one of 'year', 'month', day' columns is missing in a Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ§x, or when a Timezone-aware Ù¢„qdatetime.datetimeÙ „hdatetimea*capiqdatetime.datetimefmoduleõÙ§x6 is found in an array-like of mixed time offsets, and Ù¡iutc=FalseÙ§a.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`hdatetime‚Ù¹‚Ù§x¤If parsing succeeded. Return type depends on input (types in parenthesis correspond to fallback in case of unsuccessful timezone or out-of-range timestamp parsing):€ÙÈ„Ù¹‚…Ù§hscalar: Ù£ƒiTimestampöeclassÙ§e (or Ù£ƒqdatetime.datetimeöeclassÙ§a)€Ù¹‚‰Ù§larray-like: Ù£ƒmDatetimeIndexöeclassÙ§e (or Ù£ƒfSeriesöeclassÙ§h with   Ù£ƒfobjectöeclassÙ§r dtype containing Ù£ƒqdatetime.datetimeöeclassÙ§a)€Ù¹‚‹Ù§hSeries: Ù£ƒfSeriesöeclassÙ§d of Ù£ƒjdatetime64öeclassÙ§m dtype (or   Ù£ƒfSeriesöeclassÙ§d of Ù£ƒfobjectöeclassÙ§t dtype containing   Ù£ƒqdatetime.datetimeöeclassÙ§a)€Ù¹‚‹Ù§kDataFrame: Ù£ƒfSeriesöeclassÙ§d of Ù£ƒjdatetime64öeclassÙ§m dtype (or   Ù£ƒfSeriesöeclassÙ§d of Ù£ƒfobjectöeclassÙ§t dtype containing   Ù£ƒqdatetime.datetimeöeclassÙ§a)€ögSummaryÙ¯‚Ù¹‚Ù§xConvert argument to datetime.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öˆgSummarypExtended SummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/pandas/core/tools/datetimes.py¦r<class 'function'>rpandas.to_datetimeÙ¯‚˜&Ù¹‚Ù©Ù§xHandling various input formats€Ù¹‚ƒÙ§x1Assembling a datetime from multiple columns of a Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ§x‚. The keys can be common abbreviations like ['year', 'month', 'day', 'minute', 'second', 'ms', 'us', 'ns']) or plurals of the same€Ù´ƒ˜9Ù±‚`bdfÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bs1a'Ù±‚bs1dyearÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚`a[Ù±‚bmid2015Ù±‚`a,Ù±‚`a Ù±‚bmid2016Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚bs1a'Ù±‚bs1emonthÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚`a[Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`s                   Ù±‚bs1a'Ù±‚bs1cdayÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚`a[Ù±‚bmia4Ù±‚`a,Ù±‚`a Ù±‚bmia5Ù±‚`a]Ù±‚`a}Ù±‚`a)Ù±‚`a
Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`bdfÙ±‚`a)x30   2015-02-04
1   2016-03-05
dtype: datetime64[ns]hcompiledÙ¹‚ƒÙ§hPassing Ù¡xinfer_datetime_format=TrueÙ§xa can often-times speedup a parsing if its not an ISO8601 format exactly, but in a regular format.€Ù´ƒ˜"Ù±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„fSeriesÙ „fpandase1.4.1fmodulexpandas.core.series.SeriesfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1i3/11/2000Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1i3/12/2000Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1i3/13/2000Ù±‚bs1a'Ù±‚`a]Ù±‚`a Ù±‚aoa*Ù±‚`a Ù±‚bmid1000Ù±‚`a)Ù±‚`a
Ù±‚`asÙ±‚aoa.Ù±‚`dheadÙ±‚`a(Ù±‚`a)xX0    3/11/2000
1    3/12/2000
2    3/13/2000
3    3/11/2000
4    3/12/2000
dtype: objecthcompiledÙ´ƒÙ±‚aoa%Ù±‚`ftimeitÙ±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚`uinfer_datetime_formatÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx&100 loops, best of 3: 10.4 ms per looplsyntax_errorÙ´ƒÙ±‚aoa%Ù±‚`ftimeitÙ±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`asÙ±‚`a,Ù±‚`a Ù±‚`uinfer_datetime_formatÙ±‚aoa=Ù±‚bkceFalseÙ±‚`a)Ù±‚`b  Ù±‚bc1p# doctest: +SKIPx"1 loop, best of 3: 471 ms per looplsyntax_errorÙ¹‚Ù§wUsing a unix epoch time€Ù´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚bmij1490195805Ù±‚`a,Ù±‚`a Ù±‚`dunitÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1asÙ±‚bs1a'Ù±‚`a)x Timestamp('2017-03-22 15:16:45')hcompiledÙ´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚bmis1490195805433502912Ù±‚`a,Ù±‚`a Ù±‚`dunitÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1bnsÙ±‚bs1a'Ù±‚`a)x*Timestamp('2017-03-22 15:16:45.433502912')hcompiledÙÆƒgwarningx:For float arg, precision rounding might happen. To preventÙ¹‚Ù§x4unexpected behavior use a fixed - width exact type. €Ù¹‚Ù§xUsing a non-unix epoch origin€Ù´ƒ˜"Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`dunitÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1aDÙ±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`Ù¢„foriginÙ „fpandase1.4.1fmodulex-pandas.core.tools.datetimes._adjust_to_originfmoduleõÙ±‚aoa=Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„iTimestampÙ „fpandase1.4.1fmodulex(pandas._libs.tslibs.timestamps.TimestampfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1j1960-01-01Ù±‚bs1a'Ù±‚`a)Ù±‚`a)xjDatetimeIndex(['1960-01-02', '1960-01-03', '1960-01-04'],
              dtype='datetime64[ns]', freq=None)hcompiledÙ¹‚Ù©Ù§xNon-convertible date/times€Ù¹‚…Ù§xIf a date does not meet the ÙË‚utimestamp limitationsxdhttps://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
#timeseries-timestamp-limitsÙ§j, passing Ù¡oerrors='ignore'Ù§xA will return the original input instead of raising any exception.€Ù¹‚‡Ù§hPassing Ù¡oerrors='coerce'Ù§x% will force an out-of-bounds date to Ù£ƒcNaTöeconstÙ§x?, in addition to forcing non-dates (or non-parseable dates) to Ù£ƒcNaTöeconstÙ§a.€Ù´ƒ˜Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1h13000101Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbfformatÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1a%Ù±‚bs1aYÙ±‚bs1a%Ù±‚bs1amÙ±‚bsib%dÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„ferrorsÙ „fpandase1.4.1fmodulempandas.errorsfmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fignoreÙ±‚bs1a'Ù±‚`a)x#datetime.datetime(1300, 1, 1, 0, 0)hcompiledÙ´ƒ˜Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1h13000101Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bnbfformatÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1a%Ù±‚bs1aYÙ±‚bs1a%Ù±‚bs1amÙ±‚bsib%dÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„ferrorsÙ „fpandase1.4.1fmodulempandas.errorsfmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fcoerceÙ±‚bs1a'Ù±‚`a)cNaThcompiledÙ²‚x.. _to_datetime_tz_examples:ftargetÙ¹‚Ù©Ù§xTimezones and time offsets€Ù¹‚ƒÙ§wThe default behaviour (Ù¡iutc=FalseÙ§p) is as follows:€ÙÈÙ¹‚ƒÙ§x6Timezone-naive inputs are converted to timezone-naive Ù£ƒmDatetimeIndexöeclassÙ§a:€Ù´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1p2018-10-26 12:00Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1s2018-10-26 13:00:15Ù±‚bs1a'Ù±‚`a]Ù±‚`a)xnDatetimeIndex(['2018-10-26 12:00:00', '2018-10-26 13:00:15'],
              dtype='datetime64[ns]', freq=None)hcompiledÙÈÙ¹‚…Ù§vTimezone-aware inputs Ù¨Ù§xwith constant time offsetÙ§x# are converted to   timezone-aware Ù£ƒmDatetimeIndexöeclassÙ§a:€Ù´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1v2018-10-26 12:00 -0500Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1v2018-10-26 13:00 -0500Ù±‚bs1a'Ù±‚`a]Ù±‚`a)x’DatetimeIndex(['2018-10-26 12:00:00-05:00', '2018-10-26 13:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)hcompiledÙÈÙ¹‚‹Ù§xHowever, timezone-aware inputs Ù¨Ù§wwith mixed time offsetsÙ§xZ (for example   issued from a timezone with daylight savings, such as Europe/Paris)   are Ù©Ù§xnot successfully convertedÙ§f to a Ù£ƒmDatetimeIndexöeclassÙ§u. Instead a   simple Ù£ƒeIndexöeclassÙ§l containing Ù£ƒqdatetime.datetimeöeclassÙ§w objects is   returned:€Ù´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1v2020-10-25 02:00 +0200Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1v2020-10-25 04:00 +0100Ù±‚bs1a'Ù±‚`a]Ù±‚`a)xSIndex([2020-10-25 02:00:00+02:00, 2020-10-25 04:00:00+01:00],
      dtype='object')hcompiledÙÈÙ¹‚ƒÙ§xUA mix of timezone-aware and timezone-naive inputs is converted to   a timezone-aware Ù£ƒmDatetimeIndexöeclassÙ§x5 if the offsets of the timezone-aware   are constant:€Ù´ƒ˜$Ù±‚bkndfromÙ±‚`a Ù±‚bnnhdatetimeÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`hdatetimeÙ±‚`a
Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs2a"Ù±‚bs2w2020-01-01 01:00 -01:00Ù±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`hdatetimeÙ±‚`a(Ù±‚bmid2020Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a)Ù±‚`a]Ù±‚`a)x‘DatetimeIndex(['2020-01-01 01:00:00-01:00', '2020-01-01 02:00:00-01:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-60)]', freq=None)hcompiledÙÈÙ¹‚ƒÙ§x+Finally, mixing timezone-aware strings and Ù£ƒqdatetime.datetimeöeclassÙ§xN always   raises an error, even if the elements all have the same time offset.€Ù´ƒ˜;Ù±‚bkndfromÙ±‚`a Ù±‚bnnhdatetimeÙ±‚`a Ù±‚bknfimportÙ±‚`a Ù±‚`hdatetimeÙ±‚`a,Ù±‚`a Ù±‚`htimezoneÙ±‚`a,Ù±‚`a Ù±‚`itimedeltaÙ±‚`a
Ù±‚`adÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`hdatetimeÙ±‚`a(Ù±‚bmid2020Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib18Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„ftzinfoÙ „fpandase1.4.1fmodulex*pandas._libs.tslibs.timezones.infer_tzinfofmoduleõÙ±‚aoa=Ù±‚`htimezoneÙ±‚`a(Ù±‚aoa-Ù±‚`itimedeltaÙ±‚`a(Ù±‚`ehoursÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a
Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs2a"Ù±‚bs2v2020-01-01 17:00 -0100Ù±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`adÙ±‚`a]Ù±‚`a)xTraceback (most recent call last):
    ...
ValueError: Tz-aware datetime.datetime cannot be converted to datetime64
            unless utc=TruehcompiledÙ¹‚ƒÙ§hSetting Ù¡hutc=TrueÙ§x! solves most of the above issues:€ÙÈÙ¹‚ƒÙ§xTimezone-naive inputs are Ù¨Ù§ilocalizedÙ§g as UTC€Ù´ƒ”Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1p2018-10-26 12:00Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1p2018-10-26 13:00Ù±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`cutcÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)xDatetimeIndex(['2018-10-26 12:00:00+00:00', '2018-10-26 13:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)hcompiledÙÈÙ¹‚…Ù§xTimezone-aware inputs are Ù¨Ù§iconvertedÙ§x^ to UTC (the output represents the   exact same datetime, but viewed from the UTC time offset Ù£ƒf+00:00ööÙ§b).€Ù´ƒ•Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1v2018-10-26 12:00 -0530Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1v2018-10-26 12:00 -0500Ù±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`cutcÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)xDatetimeIndex(['2018-10-26 17:30:00+00:00', '2018-10-26 17:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)hcompiledÙÈÙ¹‚Ù§xZInputs can contain both naive and aware, string or datetime, the above   rules still apply€Ù´ƒ˜DÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„kto_datetimeÙ „fpandase1.4.1fmodulex'pandas.core.tools.datetimes.to_datetimefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1p2018-10-26 12:00Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1v2018-10-26 12:00 -0530Ù±‚bs1a'Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`hdatetimeÙ±‚`a(Ù±‚bmid2020Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib18Ù±‚`a)Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`hdatetimeÙ±‚`a(Ù±‚bmid2020Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmib18Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`Ù¢„ftzinfoÙ „fpandase1.4.1fmodulex*pandas._libs.tslibs.timezones.infer_tzinfofmoduleõÙ±‚aoa=Ù±‚`htimezoneÙ±‚`a(Ù±‚aoa-Ù±‚`itimedeltaÙ±‚`a(Ù±‚`ehoursÙ±‚aoa=Ù±‚bmia1Ù±‚`a)Ù±‚`a)Ù±‚`a)Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`o               Ù±‚`cutcÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)xÈDatetimeIndex(['2018-10-26 12:00:00+00:00', '2018-10-26 17:30:00+00:00',
               '2020-01-01 18:00:00+00:00', '2020-01-01 19:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)hcompiledöƒÙ¼ƒÙ»ƒpDataFrame.astypeööÙ¹‚Ù§x#Cast argument to a specified dtype.€öÙ¼ƒÙ»ƒnconvert_dtypesööÙ¹‚Ù§oConvert dtypes.€öÙ¼ƒÙ»ƒlto_timedeltax)pandas.core.tools.timedeltas.to_timedeltaõÙ¹‚Ù§xConvert argument to timedelta.€öe1.4.1Ù«yuto_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None'öx'pandas.core.tools.datetimes.to_datetime€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xaThis method applies a function that accepts and returns a scalar to every element of a DataFrame.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒdfunchcallableÙ¹‚Ù§x<Python function, returns a single value from a single value.€Ù°ƒina_actionx{None, 'ignore'}, default None‚Ù¹‚Ù§xDIf â€˜ignoreâ€™, propagate NaN values, without passing them to func.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§d1.2 €Ù°ƒh**kwargs`‚Ù¹‚ƒÙ§x>Additional keyword arguments to pass as keywords arguments to Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§a.€ÙÆƒlversionaddeddTODOÙ¹‚Ù§f1.3.0 €öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`iDataFrameÙ¹‚Ù§vTransformed DataFrame.€ögSummaryÙ¯‚Ù¹‚Ù§x,Apply a function to a Dataframe elementwise.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshSee AlsohExamplesu/pandas/core/frame.py"ƒr<class 'function'>xpandas.DataFrame.applymapÙ¯‚ˆÙ´ƒ˜Ù±‚`bdfÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„iDataFrameÙ „fpandase1.4.1fmodulexpandas.core.frame.DataFramefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmfd2.12Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`a[Ù±‚bmfe3.356Ù±‚`a,Ù±‚`a Ù±‚bmfe4.567Ù±‚`a]Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`bdfx/       0      1
0  1.000  2.120
1  3.356  4.567hcompiledÙ´ƒ‘Ù±‚`bdfÙ±‚aoa.Ù±‚`Ù¢„happlymapÙ „fpandase1.4.1fmodulex$pandas.core.frame.DataFrame.applymapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚bnbclenÙ±‚`a(Ù±‚bnbcstrÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a)Ù±‚`a)w   0  1
0  3  4
1  5  5hcompiledÙ¹‚Ù§x*Like Series.map, NA values can be ignored:€Ù´ƒ˜2Ù±‚`gdf_copyÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bdfÙ±‚aoa.Ù±‚`dcopyÙ±‚`a(Ù±‚`a)Ù±‚`a
Ù±‚`gdf_copyÙ±‚aoa.Ù±‚`Ù¢„dilocÙ „fpandase1.4.1fmoduletpandas._testing.ilocfmoduleõÙ±‚`a[Ù±‚bmia0Ù±‚`a,Ù±‚`a Ù±‚bmia0Ù±‚`a]Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`bNAÙ±‚`a
Ù±‚`gdf_copyÙ±‚aoa.Ù±‚`Ù¢„happlymapÙ „fpandase1.4.1fmodulex$pandas.core.frame.DataFrame.applymapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚bnbclenÙ±‚`a(Ù±‚bnbcstrÙ±‚`a(Ù±‚`axÙ±‚`a)Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`ina_actionÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1fignoreÙ±‚bs1a'Ù±‚`a)x       0  1
0  <NA>  4
1     5  5hcompiledÙ¹‚ƒÙ§x"Note that a vectorized version of Ù¢„dfuncÙ „ööelocaldfuncelocalõÙ§xS often exists, which will be much faster. You could square each number elementwise.€Ù´ƒÙ±‚`bdfÙ±‚aoa.Ù±‚`Ù¢„happlymapÙ „fpandase1.4.1fmodulex$pandas.core.frame.DataFrame.applymapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚aoa*Ù±‚aoa*Ù±‚bmia2Ù±‚`a)xG           0          1
0   1.000000   4.494400
1  11.262736  20.857489hcompiledÙ¹‚Ù§x/But it's better to avoid applymap in that case.€Ù´ƒ†Ù±‚`bdfÙ±‚`a Ù±‚aoa*Ù±‚aoa*Ù±‚`a Ù±‚bmia2xG           0          1
0   1.000000   4.494400
1  11.262736  20.857489hcompiledöÙ¼ƒÙ»ƒoDataFrame.applyx!pandas.core.frame.DataFrame.applyõÙ¹‚Ù§x/Apply a function along input axis of DataFrame.€öe1.4.1Ù«x_applymap(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'DataFrame'öx$pandas.core.frame.DataFrame.applymap€
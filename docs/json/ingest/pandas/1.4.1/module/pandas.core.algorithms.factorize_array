Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚Ù¹‚Ù§xGThis doesn't do any coercion of types or unboxing before factorization.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒfvaluesgndarray€Ù°ƒkna_sentineloint, default -1€Ù°ƒisize_hintmint, optionalÙ¹‚Ù§x5Passed through to the hashtable's 'get_labels' method€Ù°ƒhna_valuepobject, optionalÙ¹‚ƒÙ§kA value in Ù¢„fvaluesÙ „ööelocalfvalueselocalõÙ§x» to consider missing. Note: only use this parameter when you know that you don't have any values pandas would consider missing in the array (NaN for float data, iNaT for datetimes, etc.).€Ù°ƒdmaskwndarray[bool], optionalÙ¹‚ƒÙ§xiIf not None, the mask is used as indicator for missing values (True = missing, False = valid) instead of Ù¢„hna_valueÙ „ööelocalhna_valueelocalõÙ§x or condition "val != val".€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒecodespndarray[np.intp]€Ù°ƒguniquesgndarray€ögSummaryÙ¯‚Ù¹‚Ù§x-Factorize a numpy array to codes and uniques.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersgReturnsx/pandas/core/algorithms.pyr<class 'function'>x&pandas.core.algorithms.factorize_arrayÙ¯‚€ö€e1.4.1Ù«x¼factorize_array(values: 'np.ndarray', na_sentinel: 'int' = -1, size_hint: 'int | None' = None, na_value=None, mask: 'np.ndarray | None' = None) -> 'tuple[npt.NDArray[np.intp], np.ndarray]'öx&pandas.core.algorithms.factorize_array€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚‹Ù¹‚…Ù§mOmitting the Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§xØ argument means pandas will attempt to infer the best array type from the values in the data. As new array types are added by pandas and 3rd party libraries, the "best" array type may change. We recommend specifying Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§o to ensure that€ÙÇ‚Ù¹‚Ù§x/the correct array type for the data is returned€Ù¹‚Ù§xnthe returned array type doesn't change as new extension types    are added by pandas and third-party libraries€Ù¹‚…Ù§xqAdditionally, if the underlying memory representation of the returned array matters, we recommend specifying the Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§xı as a concrete object rather than a string alias or allowing it to be inferred. For example, a future version of pandas or a 3rd-party library may include a dedicated ExtensionArray for string data. In this event, the following would no longer return a Ù£ƒrarrays.PandasArrayöeclassÙ§x backed by a NumPy array.€ÙÀxT>>> pd.array(['a', 'b'], dtype=str)
<PandasArray>
['a', 'b']
Length: 2, dtype: str32Ù¹‚Ù§x§This would instead return the new ExtensionArray dedicated for string data. If you really need the new array to be backed by a  NumPy array, specify that in the dtype.€ÙÀx`>>> pd.array(['a', 'b'], dtype=np.dtype("<U1"))
<PandasArray>
['a', 'b']
Length: 2, dtype: str32Ù¹‚Ù§x9Finally, Pandas has arrays that mostly overlap with NumPy€Ù·‚x* :class:`arrays.DatetimeArray`x * :class:`arrays.TimedeltaArray`Ù¹‚‹Ù§qWhen data with a Ù¡ndatetime64[ns]Ù§d or Ù¡otimedelta64[ns]Ù§x. dtype is passed, pandas will always return a Ù¡mDatetimeArrayÙ§d or Ù¡nTimedeltaArrayÙ§o rather than a Ù¡kPandasArrayÙ§xc. This is for symmetry with the case of timezone-aware data, which NumPy does not natively support.€ÙÀx–>>> pd.array(['2015', '2016'], dtype='datetime64[ns]')
<DatetimeArray>
['2015-01-01 00:00:00', '2016-01-01 00:00:00']
Length: 2, dtype: datetime64[ns]ÙÀx>>> pd.array(["1H", "2H"], dtype='timedelta64[ns]')
<TimedeltaArray>
['0 days 01:00:00', '0 days 02:00:00']
Length: 2, dtype: timedelta64[ns]öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒddatasSequence of objects‚Ù¹‚‡Ù§sThe scalars inside Ù¢„ddataÙ „ööelocalddataelocalõÙ§x, should be instances of the scalar type for Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§u. It's expected that Ù¢„ddataÙ „ööelocalddataelocalõÙ§x* represents a 1-dimensional array of data.€Ù¹‚…Ù§eWhen Ù¢„ddataÙ „ööelocalddataelocalõÙ§xD is an Index or Series, the underlying array will be extracted from Ù¢„ddataÙ „ööelocalddataelocalõÙ§a.€Ù°ƒedtypex*str, np.dtype, or ExtensionDtype, optionalŠÙ¹‚ƒÙ§xlThe dtype to use for the array. This may be a NumPy dtype or an extension type registered with pandas using Ù¢„x.pandas.api.extensions.register_extension_dtypeÙ „fpandasa*capix0pandas.core.dtypes.base.register_extension_dtypefmoduleõÙ§a.€Ù¹‚Ù§x.If not specified, there are two possibilities:€ÙÇ‚Ù¹‚‹Ù§eWhen Ù¢„ddataÙ „ööelocalddataelocalõÙ§f is a Ù¢„fSeriesÙ „fpandase1.4.1fmodulexpandas.core.series.SeriesfmoduleõÙ§b, Ù¢„eIndexÙ „fpandase1.4.1fmodulexpandas.core.indexes.base.IndexfmoduleõÙ§h, or    Ù¢„nExtensionArrayÙ „fpandase1.4.1fmodulex&pandas.core.arrays.base.ExtensionArrayfmoduleõÙ§f, the Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§x  will be taken    from the data.€Ù¹‚ƒÙ§x,Otherwise, pandas will attempt to infer the Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§r    from the data.€Ù¹‚‡Ù§oNote that when Ù¢„ddataÙ „ööelocalddataelocalõÙ§s is a NumPy array, Ù¡jdata.dtypeÙ§d is Ù¨Ù§cnotÙ§x† used for inferring the array type. This is because NumPy cannot represent all the types of data that can be held in extension arrays.€Ù¹‚Ù§x@Currently, pandas will infer an extension dtype for sequences of€Ù¹‚˜#Ù§x¸============================== ======================================= Scalar Type                    Array Type ============================== ======================================= Ù¢„opandas.IntervalÙ „fpandasa*capixpandas._libs.interval.IntervalfmoduleõÙ§g       Ù¢„xpandas.arrays.IntervalArrayÙ „fpandasa*capix)pandas.core.arrays.interval.IntervalArrayfmoduleõÙ§a Ù¢„mpandas.PeriodÙ „fpandasa*capix!pandas._libs.tslibs.period.PeriodfmoduleõÙ§i         Ù¢„xpandas.arrays.PeriodArrayÙ „fpandasa*capix%pandas.core.arrays.period.PeriodArrayfmoduleõÙ§a Ù¢„qdatetime.datetimeÙ „hdatetimea*capiqdatetime.datetimefmoduleõÙ§e     Ù¢„xpandas.arrays.DatetimeArrayÙ „fpandasa*capix*pandas.core.arrays.datetimes.DatetimeArrayfmoduleõÙ§a Ù¢„rdatetime.timedeltaÙ „hdatetimea*capirdatetime.timedeltafmoduleõÙ§d    Ù¢„xpandas.arrays.TimedeltaArrayÙ „fpandasa*capix,pandas.core.arrays.timedeltas.TimedeltaArrayfmoduleõÙ§a Ù£ƒcintöeclassÙ§s                   Ù¢„xpandas.arrays.IntegerArrayÙ „fpandasa*capix'pandas.core.arrays.integer.IntegerArrayfmoduleõÙ§a Ù£ƒefloatöeclassÙ§q                 Ù¢„xpandas.arrays.FloatingArrayÙ „fpandasa*capix)pandas.core.arrays.floating.FloatingArrayfmoduleõÙ§a Ù£ƒcströeclassÙ§s                   Ù¢„xpandas.arrays.StringArrayÙ „fpandasa*capix&pandas.core.arrays.string_.StringArrayfmoduleõÙ§x# or                                Ù¢„xpandas.arrays.ArrowStringArrayÙ „fpandasa*capix0pandas.core.arrays.string_arrow.ArrowStringArrayfmoduleõÙ§a Ù¢„dboolÙ „fpandase1.4.1fmodulex pandas.core.generic.NDFrame.boolfmoduleõÙ§r                  Ù¢„xpandas.arrays.BooleanArrayÙ „fpandasa*capix'pandas.core.arrays.boolean.BooleanArrayfmoduleõÙ§xG ============================== =======================================€Ù¹‚…Ù§x3The ExtensionArray created when the scalar type is Ù£ƒcströeclassÙ§r is determined by Ù¡xpd.options.mode.string_storageÙ§x& if the dtype is not explicitly given.€Ù¹‚Ù§x@For all other cases, NumPy's usual inference rules will be used.€ÙÆƒnversionchangede1.0.0Ù¹‚Ù§x†Pandas infers nullable - integer dtype for integer data, string dtype for string data, and nullable - boolean dtype for boolean data. €ÙÆƒnversionchangede1.2.0Ù¹‚Ù§xMPandas now also infers nullable - floating dtype for float - like input data €Ù°ƒdcopyrbool, default TrueÙ¹‚…Ù§xJWhether to copy the data, even if not necessary. Depending on the type of Ù¢„ddataÙ „ööelocalddataelocalõÙ§x;, creating the new array may require copying data, even if Ù¡jcopy=FalseÙ§a.€öfRaisesÙ¯‚Ù°ƒ`jValueErrorÙ¹‚ƒÙ§eWhen Ù¢„ddataÙ „ööelocalddataelocalõÙ§v is not 1-dimensional.€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`nExtensionArrayÙ¹‚Ù§xThe newly created array.€ögSummaryÙ¯‚Ù¹‚Ù§pCreate an array.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‡gSummaryjParametersgReturnsfRaiseshSee AlsoeNoteshExamplesx/pandas/core/construction.pyLr<class 'function'>lpandas.arrayÙ¯‚’Ù¹‚ƒÙ§xfIf a dtype is not specified, pandas will infer the best dtype from the values. See the description of Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§x! for the types pandas infers for.€Ù´ƒ‹Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a)x-<IntegerArray>
[1, 2]
Length: 2, dtype: Int64hcompiledÙ´ƒÙ±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`cnanÙ±‚`a]Ù±‚`a)x3<IntegerArray>
[1, 2, <NA>]
Length: 3, dtype: Int64hcompiledÙ´ƒ‹Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmfc1.1Ù±‚`a,Ù±‚`a Ù±‚bmfc2.2Ù±‚`a]Ù±‚`a)x4<FloatingArray>
[1.1, 2.2]
Length: 2, dtype: Float64hcompiledÙ´ƒ’Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs2a"Ù±‚bs2aaÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bkcdNoneÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2acÙ±‚bs2a"Ù±‚`a]Ù±‚`a)x7<StringArray>
['a', <NA>, 'c']
Length: 3, dtype: stringhcompiledÙ´ƒ˜(Ù±‚akdwithÙ±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„noption_contextÙ „fpandase1.4.1fmodulex$pandas._config.config.option_contextfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2nstring_storageÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2Ù¢„gpyarrowÙ „fpandase1.4.1fmoduleupandas.compat.pyarrowfmoduleõÙ±‚bs2a"Ù±‚`a)Ù±‚`a:Ù±‚`a
Ù±‚`d    Ù±‚`carrÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs2a"Ù±‚bs2aaÙ±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚bkcdNoneÙ±‚`a,Ù±‚`a Ù±‚bs2a"Ù±‚bs2acÙ±‚bs2a"Ù±‚`a]Ù±‚`a)c...hcompiledÙ´ƒÙ±‚`carrx<<ArrowStringArray>
['a', <NA>, 'c']
Length: 3, dtype: stringhcompiledÙ´ƒ˜'Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„fPeriodÙ „fpandase1.4.1fmodulex!pandas._libs.tslibs.period.PeriodfmoduleõÙ±‚`a(Ù±‚bs1a'Ù±‚bs1d2000Ù±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚`dfreqÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2aDÙ±‚bs2a"Ù±‚`a)Ù±‚`a,Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„fPeriodÙ „fpandase1.4.1fmodulex!pandas._libs.tslibs.period.PeriodfmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2d2000Ù±‚bs2a"Ù±‚`a,Ù±‚`a Ù±‚`dfreqÙ±‚aoa=Ù±‚bs2a"Ù±‚bs2aDÙ±‚bs2a"Ù±‚`a)Ù±‚`a]Ù±‚`a)xF<PeriodArray>
['2000-01-01', '2000-01-01']
Length: 2, dtype: period[D]hcompiledÙ¹‚‚Ù§x!You can use the string alias for Ù¢„edtypeÙ „ööelocaledtypeelocalõ€Ù´ƒ˜Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „fpandase1.4.1fmodulexpandas.core.arrays.sparse.dtypefmoduleõÙ±‚aoa=Ù±‚bs1a'Ù±‚bs1Ù¢„hcategoryÙ „fpandase1.4.1fmodulexpandas.core.indexes.categoryfmoduleõÙ±‚bs1a'Ù±‚`a)x2['a', 'b', 'a']
Categories (2, object): ['a', 'b']hcompiledÙ¹‚Ù§xOr specify the actual dtype€Ù´ƒ˜2Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a
Ù±‚`i         Ù±‚`Ù¢„edtypeÙ „fpandase1.4.1fmodulexpandas.core.arrays.sparse.dtypefmoduleõÙ±‚aoa=Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„pCategoricalDtypeÙ „fpandase1.4.1fmodulex*pandas.core.dtypes.dtypes.CategoricalDtypefmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gorderedÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a)x9['a', 'b', 'a']
Categories (3, object): ['a' < 'b' < 'c']hcompiledÙ¹‚ƒÙ§x6If pandas does not infer a dedicated extension type a Ù£ƒrarrays.PandasArrayöeclassÙ§m is returned.€Ù´ƒ•Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia1Ù±‚`ajÙ±‚`a,Ù±‚`a Ù±‚bmia3Ù±‚`a Ù±‚aoa+Ù±‚`a Ù±‚bmia2Ù±‚`ajÙ±‚`a]Ù±‚`a)x;<PandasArray>
[(1+1j), (3+2j)]
Length: 2, dtype: complex128hcompiledÙ¹‚…Ù§x£As mentioned in the "Notes" section, new extension types may be added in the future (by pandas or 3rd party libraries), causing the return value to no longer be a Ù£ƒrarrays.PandasArrayöeclassÙ§n. Specify the Ù¢„edtypeÙ „ööelocaledtypeelocalõÙ§xM as a NumPy dtype if you need to ensure there's no future change in behavior.€Ù´ƒ—Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bmia1Ù±‚`a,Ù±‚`a Ù±‚bmia2Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`Ù¢„edtypeÙ „fpandase1.4.1fmodulexpandas.core.arrays.sparse.dtypefmoduleõÙ±‚aoa=Ù±‚`Ù¢„bnpÙ „enumpyf1.22.3fmoduleenumpyfmoduleõÙ±‚aoa.Ù±‚`Ù¢„edtypeÙ „enumpyf1.22.3fmoduleknumpy.dtypefmoduleõÙ±‚`a(Ù±‚bs2a"Ù±‚bs2eint32Ù±‚bs2a"Ù±‚`a)Ù±‚`a)x,<PandasArray>
[1, 2]
Length: 2, dtype: int32hcompiledÙ¹‚‚Ù¢„ddataÙ „ööelocalddataelocalõÙ§x[ must be 1-dimensional. A ValueError is raised when the input has the wrong dimensionality.€Ù´ƒ†Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„earrayÙ „fpandase1.4.1fmodulexpandas.core.construction.arrayfmoduleõÙ±‚`a(Ù±‚bmia1Ù±‚`a)x^Traceback (most recent call last):
  ...
ValueError: Cannot pass scalar '1' to 'pandas.array'.hcompiledö…Ù¼ƒÙ»ƒeIndexxpandas.core.indexes.base.IndexõÙ¹‚Ù§xConstruct a pandas Index.€öÙ¼ƒÙ»ƒfSeriesxpandas.core.series.SeriesõÙ¹‚Ù§xConstruct a pandas Series.€öÙ¼ƒÙ»ƒlSeries.arrayööÙ¹‚Ù§x)Extract the array stored within a Series.€öÙ¼ƒÙ»ƒrarrays.PandasArrayööÙ¹‚Ù§x&ExtensionArray wrapping a NumPy array.€öÙ¼ƒÙ»ƒknumpy.arrayknumpy.arrayõÙ¹‚Ù§xConstruct a NumPy array.€öe1.4.1Ù«xuarray(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray'öxpandas.core.construction.array€
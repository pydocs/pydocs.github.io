Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚…Ù§nThe length of Ù¢„flabelsÙ „ööelocalflabelselocalõÙ§e and Ù¢„eshapeÙ „ööelocaleshapeelocalõÙ§s must be identical.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚„Ù°ƒflabelsrsequence of arraysÙ¹‚Ù§x,Integers identifying levels at each location€Ù°ƒeshapeotuple[int, ...]Ù¹‚Ù§x(Number of unique levels at each location€Ù°ƒdsortdboolÙ¹‚Ù§xAIf the ranks of returned ids should match lexical ranks of labels€Ù°ƒexnulldboolÙ¹‚Ù§xLIf true nulls are excluded. i.e. -1 values in the labels are passed through.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒ`xJAn array of type int64 where two elements are equal if their corresponding€Ù°ƒ`x!labels are equal at all location.€ögSummaryÙ¯‚Ù¹‚‡Ù§x¢For the particular label_list, gets the offsets into the hypothetical list representing the totally ordered cartesian product of all possible label combinations, Ù¨Ù§jas long asÙ§x‘ this space fits within int64 bounds; otherwise, though group indices identify unique combinations of labels, they cannot be deconstructed. - If Ù¢„dsortÙ „ööelocaldsortelocalõÙ§x}, rank of returned ids preserve lexical ranks of labels.   i.e. returned id's can be used to do lexical sort on labels; - If Ù¢„exnullÙ „ööelocalexnullelocalõÙ§x& nulls (-1 labels) are passed through.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummaryjParametersgReturnseNotesw/pandas/core/sorting.pydr<class 'function'>x!pandas.core.frame.get_group_indexÙ¯‚€ö€e1.4.1Ù«x_get_group_index(labels, shape: 'Shape', sort: 'bool', xnull: 'bool') -> 'npt.NDArray[np.int64]'öx#pandas.core.sorting.get_group_index€
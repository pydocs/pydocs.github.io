Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚…Ù§xMaps the values (their categories, not the codes) of the index to new categories. If the mapping correspondence is one-to-one the result is a Ù¢„pCategoricalIndexÙ „fpandasa*capix-pandas.core.indexes.category.CategoricalIndexfmoduleõÙ§xA which has the same order property as the original, otherwise an Ù¢„eIndexÙ „fpandasa*capixpandas.core.indexes.base.IndexfmoduleõÙ§m is returned.€Ù¹‚‰Ù§eIf a Ù£ƒddictööÙ§d or Ù¢„fSeriesÙ „fpandasa*capixpandas.core.series.SeriesfmoduleõÙ§x, is used any unmapped category is mapped to Ù¢„cNaNÙ „fpandase1.4.1fmodulex pandas.errors.IntCastingNaNErrorfmoduleõÙ§x. Note that if this happens an Ù¢„eIndexÙ „fpandasa*capixpandas.core.indexes.base.IndexfmoduleõÙ§r will be returned.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚Ù°ƒfmapperxfunction, dict, or SeriesÙ¹‚Ù§wMapping correspondence.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`x'pandas.CategoricalIndex or pandas.IndexÙ¹‚Ù§mMapped index.€ögSummaryÙ¯‚Ù¹‚Ù§x4Map values using input an input mapping or function.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnshSee AlsohExamplesx /pandas/core/indexes/category.pyûr<class 'function'>xpandas.CategoricalIndex.mapÙ¯‚ŠÙ´ƒ˜Ù±‚`cidxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„pCategoricalIndexÙ „fpandase1.4.1fmodulex-pandas.core.indexes.category.CategoricalIndexfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a]Ù±‚`a)Ù±‚`a
Ù±‚`cidxxpCategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],
                  ordered=False, dtype='category')hcompiledÙ´ƒÙ±‚`cidxÙ±‚aoa.Ù±‚`Ù¢„cmapÙ „fpandase1.4.1fmodulex1pandas.core.indexes.category.CategoricalIndex.mapfmoduleõÙ±‚`a(Ù±‚akflambdaÙ±‚`a Ù±‚`axÙ±‚`a:Ù±‚`a Ù±‚`axÙ±‚aoa.Ù±‚`Ù¢„eupperÙ „fpandase1.4.1fmodulex0pandas.core.strings.accessor.StringMethods.upperfmoduleõÙ±‚`a(Ù±‚`a)Ù±‚`a)xoCategoricalIndex(['A', 'B', 'C'], categories=['A', 'B', 'C'],
                 ordered=False, dtype='category')hcompiledÙ´ƒ˜#Ù±‚`cidxÙ±‚aoa.Ù±‚`Ù¢„cmapÙ „fpandase1.4.1fmodulex1pandas.core.indexes.category.CategoricalIndex.mapfmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1efirstÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1fsecondÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1ethirdÙ±‚bs1a'Ù±‚`a}Ù±‚`a)x‰CategoricalIndex(['first', 'second', 'third'], categories=['first',
                 'second', 'third'], ordered=False, dtype='category')hcompiledÙ¹‚Ù§xIIf the mapping is one-to-one the ordering of the categories is preserved:€Ù´ƒ˜Ù±‚`cidxÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`bpdÙ±‚aoa.Ù±‚`Ù¢„pCategoricalIndexÙ „fpandase1.4.1fmodulex-pandas.core.indexes.category.CategoricalIndexfmoduleõÙ±‚`a(Ù±‚`a[Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a]Ù±‚`a,Ù±‚`a Ù±‚`gorderedÙ±‚aoa=Ù±‚bkcdTrueÙ±‚`a)Ù±‚`a
Ù±‚`cidxxnCategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],
                 ordered=True, dtype='category')hcompiledÙ´ƒ˜Ù±‚`cidxÙ±‚aoa.Ù±‚`Ù¢„cmapÙ „fpandase1.4.1fmodulex1pandas.core.indexes.category.CategoricalIndex.mapfmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bmia3Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bmia2Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bmia1Ù±‚`a}Ù±‚`a)xbCategoricalIndex([3, 2, 1], categories=[3, 2, 1], ordered=True,
                 dtype='category')hcompiledÙ¹‚ƒÙ§x$If the mapping is not one-to-one an Ù¢„eIndexÙ „fpandasa*capixpandas.core.indexes.base.IndexfmoduleõÙ§m is returned:€Ù´ƒ˜#Ù±‚`cidxÙ±‚aoa.Ù±‚`Ù¢„cmapÙ „fpandase1.4.1fmodulex1pandas.core.indexes.category.CategoricalIndex.mapfmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1efirstÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1fsecondÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1acÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1efirstÙ±‚bs1a'Ù±‚`a}Ù±‚`a)x3Index(['first', 'second', 'first'], dtype='object')hcompiledÙ¹‚‡Ù§eIf a Ù£ƒddictööÙ§x0 is used, all unmapped categories are mapped to Ù¢„cNaNÙ „fpandase1.4.1fmodulex pandas.errors.IntCastingNaNErrorfmoduleõÙ§v and the result is an Ù¢„eIndexÙ „fpandasa*capixpandas.core.indexes.base.IndexfmoduleõÙ§a:€Ù´ƒ˜Ù±‚`cidxÙ±‚aoa.Ù±‚`Ù¢„cmapÙ „fpandase1.4.1fmodulex1pandas.core.indexes.category.CategoricalIndex.mapfmoduleõÙ±‚`a(Ù±‚`a{Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1efirstÙ±‚bs1a'Ù±‚`a,Ù±‚`a Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a:Ù±‚`a Ù±‚bs1a'Ù±‚bs1fsecondÙ±‚bs1a'Ù±‚`a}Ù±‚`a)x/Index(['first', 'second', nan], dtype='object')hcompiledöƒÙ¼ƒÙ»ƒiIndex.mapööÙ¹‚ƒÙ§x%Apply a mapping correspondence on an Ù£ƒm~pandas.IndexöeclassÙ§a.€öÙ¼ƒÙ»ƒlSeries.applyxpandas.core.series.Series.applyõÙ¹‚ƒÙ§x"Apply more complex functions on a Ù£ƒn~pandas.SeriesöeclassÙ§a.€öÙ¼ƒÙ»ƒjSeries.mapxpandas.core.series.Series.mapõÙ¹‚ƒÙ§x$Apply a mapping correspondence on a Ù£ƒn~pandas.SeriesöeclassÙ§a.€öe1.4.1Ù«qmap(self, mapper)öx1pandas.core.indexes.category.CategoricalIndex.map€
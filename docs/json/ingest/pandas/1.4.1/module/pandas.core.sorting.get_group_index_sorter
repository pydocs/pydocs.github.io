Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒkgroup_indexsnp.ndarray[np.intp]Ù¹‚Ù§tsigned integer dtype€Ù°ƒgngroupsxint or None, default None€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`snp.ndarray[np.intp]€ögSummaryÙ¯‚Ù¹‚…Ù§x#algos.groupsort_indexer implements Ù£ƒmcounting sortööÙ§ye and it is at least O(ngroups), where     ngroups = prod(shape)     shape = map(len, keys) that is, linear in the number of combinations (cartesian product) of unique values of groupby keys. This can be huge when doing multi-key groupby. np.argsort(kind='mergesort') is O(count x log(count)) where count is the length of the data-frame; Both algorithms are Ù£ƒfstableööÙ§x} sort and that is necessary for correctness of groupby operations. e.g. consider:     df.groupby(key)[col].transform('first')€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummaryjParametersgReturnsw/pandas/core/sorting.pyjr<class 'function'>x*pandas.core.sorting.get_group_index_sorterÙ¯‚€ö€e1.4.1Ù«xsget_group_index_sorter(group_index: 'npt.NDArray[np.intp]', ngroups: 'int | None' = None) -> 'npt.NDArray[np.intp]'öx*pandas.core.sorting.get_group_index_sorter€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚ŠÙ¹‚Ù§kUsage::    €ÙÀxXT = TypeVar('T')  # Can be anything
A = TypeVar('A', str, bytes)  # Must be str or bytesÙ¹‚Ù§yType variables exist primarily for the benefit of static type checkers.  They serve as the parameters for generic types as well as for generic function definitions.  See class Generic for more information on generic types.  Generic functions work as follows:€Ù·‡x$def repeat(x: T, n: int) -> List[T]:x5    '''Return a list containing n references to x.'''p    return [x]*n`xdef longest(x: A, y: A) -> A:x,    '''Return the longest of two strings.'''x'    return x if len(x) >= len(y) else yÙ¹‚Ù§xÛThe latter example's signature is essentially the overloading of (str, str) -> str and (bytes, bytes) -> bytes.  Also note that if the arguments are instances of some subclass of str, the return type is still plain str.€Ù¹‚Ù§xGAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.€Ù¹‚Ù§xİType variables defined with covariant=True or contravariant=True can be used to declare covariant or contravariant generic types. See PEP 484 for more details. By default generic types are invariant in all type variables.€Ù¹‚Ù§x)Type variables can be introspected. e.g.:€Ù·…qT.__name__ == 'T'wT.__constraints__ == ()xT.__covariant__ == FalsexT.__contravariant__ = Falsex!A.__constraints__ == (str, bytes)Ù¹‚Ù§xENote that only type variables defined in global scope can be pickled.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§nType variable.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryx//miniforge3/envs/papyri/lib/python3.9/typing.pyöx<class 'typing.TypeVar'>wpandas._typing.NDFrameTÙ¯‚€ö€e1.4.1Ù«ööwpandas._typing.NDFrameT€
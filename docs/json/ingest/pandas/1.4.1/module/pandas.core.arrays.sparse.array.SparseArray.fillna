Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚ƒÙ¹‚‡Ù§eWhen Ù¢„evalueÙ „ööelocalevalueelocalõÙ§x is specified, the result's Ù¡jfill_valueÙ§l depends on Ù¡oself.fill_valueÙ§x). The goal is to maintain low-memory use.€Ù¹‚…Ù§cIf Ù¡oself.fill_valueÙ§x! is NA, the result dtype will be Ù¡x)SparseDtype(self.dtype, fill_value=value)Ù§xD. This will preserve amount of memory used before and after filling.€Ù¹‚…Ù§eWhen Ù¡oself.fill_valueÙ§x% is not NA, the result dtype will be Ù¡jself.dtypeÙ§x2. Again, this preserves the amount of memory used.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒevaluepscalar, optional€Ù°ƒfmethodmstr, optionalÙÆƒgwarning`Ù¹‚Ù§xyUsing ' method ' will result in high memory use, as all `fill_value` methods will be converted to an in - memory ndarray €Ù°ƒelimitmint, optional€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`kSparseArray€ögSummaryÙ¯‚Ù¹‚ƒÙ§xFill missing values with Ù¢„evalueÙ „ööelocalevalueelocalõÙ§a.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummaryjParametersgReturnseNotesx#/pandas/core/arrays/sparse/array.pyÙr<class 'function'>x pandas.arrays.SparseArray.fillnaÙ¯‚€ö€e1.4.1Ù«x}fillna(self: 'SparseArrayT', value=None, method: 'FillnaOptions | None' = None, limit: 'int | None' = None) -> 'SparseArrayT'öx2pandas.core.arrays.sparse.array.SparseArray.fillna€
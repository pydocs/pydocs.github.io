Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚„Ù¹‚Ù§x—This function will compute a mask iff it is necessary. Otherwise, return the provided mask (potentially None) when a mask does not need to be computed.€Ù¹‚Ù§xùA mask is never necessary if the values array is of boolean or integer dtypes, as these are incapable of storing NaNs. If passing a NaN-capable dtype that is interpretable as either boolean or integer data (eg, timedelta64), a mask must be provided.€Ù¹‚Ù§xBIf the skipna parameter is False, a new mask will not be computed.€Ù¹‚Ù§xjThe mask is computed using isna() by default. Setting invert=True selects notna() as the masking function.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒfvaluesgndarrayÙ¹‚Ù§x+input array to potentially compute mask for€Ù°ƒfskipnadboolÙ¹‚Ù§x*boolean for whether NaNs should be skipped€Ù°ƒdmaskqOptional[ndarray]Ù¹‚Ù§qnan-mask if known€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚Ù°ƒ`xOptional[np.ndarray[bool]]€ögSummaryÙ¯‚Ù¹‚Ù§x(Compute a mask if and only if necessary.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„gSummarypExtended SummaryjParametersgReturnsv/pandas/core/nanops.pyÕr<class 'function'>x"pandas.core.nanops._maybe_get_maskÙ¯‚€ö€e1.4.1Ù«x}_maybe_get_mask(values: 'np.ndarray', skipna: 'bool', mask: 'npt.NDArray[np.bool_] | None') -> 'npt.NDArray[np.bool_] | None'öx"pandas.core.nanops._maybe_get_mask€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚ƒÙ§sThis is similar to Ù£ƒfupdateödmethÙ§xµ, but much more flexible. First, a dict is made from data+key=value pairs. When merging this dict with the Struct S, the optional dictionary 'conflict' is used to decide what to do.€Ù¹‚ƒÙ§xuIf conflict is not given, the default behavior is to preserve any keys with their current value (the opposite of the Ù£ƒfupdateödmethÙ§t method's behavior).€ögMethodsÙ¯‚€öeNotesÙ¯‚‹Ù¹‚ƒÙ§dThe Ù¢„p__conflict_solveÙ „ööelocalp__conflict_solveelocalõÙ§xp dict is a dictionary of binary functions which will be used to solve key conflicts.  Here is an example::      €ÙÀxG__conflict_solve = dict(
    func1=['a','b','c'],
    func2=['d','e']
)Ù¹‚…Ù§xIn this case, the function Ù£ƒefunc1ödfuncÙ§x@ will be used to resolve keys 'a', 'b' and 'c' and the function Ù£ƒefunc2ödfuncÙ§xJ will be used for keys 'd' and 'e'.  This could also be written as::      €ÙÀx2__conflict_solve = dict(func1='a b c',func2='d e')Ù¹‚Ù§xOThese functions will be called for each key they apply to with the form::      €ÙÀxfunc1(self['a'], other['a'])Ù¹‚Ù§x3The return value is used as the final merged value.€Ù¹‚Ù§x»As a convenience, merge() provides five (the most commonly needed) pre-defined policies: preserve, update, add, add_flip and add_s. The easiest explanation is their implementation::      €ÙÀxÜpreserve = lambda old,new: old
update   = lambda old,new: new
add      = lambda old,new: old + new
add_flip = lambda old,new: new + old  # note change of order!
add_s    = lambda old,new: old + ' ' + new  # only for str!Ù¹‚Ù§x You can use those four words (as strings) as keys instead of defining them as functions, and the merge method will substitute the appropriate functions for you.€Ù¹‚Ù§xbFor more complicated conflict resolution policies, you still need to construct your own functions.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚ƒÙ°ƒl__loc_data__ldict, StructÙ¹‚Ù§xThe data to merge into self€Ù°ƒp__conflict_solveddictÙ¹‚Ù§yThe conflict policy dict.  The keys are binary functions used to resolve the conflict and the values are lists of strings naming the keys the conflict resolution function applies to.  Instead of a list of strings a space separated string can be used, like 'a b c'.€Ù°ƒd**kwddictÙ¹‚Ù§x'Additional key, value pairs to merge in€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x8Merge two Structs with customizable conflict resolution.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö…gSummarypExtended SummaryjParameterseNoteshExamplesx&/dev/ipython/IPython/utils/ipstruct.pyr<class 'function'>x*IPython.core.interactiveshell.Struct.mergeÙ¯‚„Ù¹‚Ù§xThis show the default policy:€Ù´ƒ˜-Ù±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fStructÙ „gIPythoni8.2.0.devfmodulexIPython.utils.ipstruct.StructfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚aoa=Ù±‚bmib10Ù±‚`a,Ù±‚`abÙ±‚aoa=Ù±‚bmib30Ù±‚`a)Ù±‚`a
Ù±‚`bs2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fStructÙ „gIPythoni8.2.0.devfmodulexIPython.utils.ipstruct.StructfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚aoa=Ù±‚bmib20Ù±‚`a,Ù±‚`acÙ±‚aoa=Ù±‚bmib40Ù±‚`a)Ù±‚`a
Ù±‚`asÙ±‚aoa.Ù±‚`Ù¢„emergeÙ „gIPythoni8.2.0.devfmodulex#IPython.utils.ipstruct.Struct.mergefmoduleõÙ±‚`a(Ù±‚`bs2Ù±‚`a)Ù±‚`a
Ù±‚bnbÙ¢„fsortedÙ „gIPythoni8.2.0.devfmodulex%IPython.lib.pretty._sorted_for_pprintfmoduleõÙ±‚`a(Ù±‚`asÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)x![('a', 10), ('b', 30), ('c', 40)]fexecedÙ¹‚Ù§x)Now, show how to specify a conflict dict:€Ù´ƒ˜EÙ±‚`asÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fStructÙ „gIPythoni8.2.0.devfmodulexIPython.utils.ipstruct.StructfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚aoa=Ù±‚bmib10Ù±‚`a,Ù±‚`abÙ±‚aoa=Ù±‚bmib30Ù±‚`a)Ù±‚`a
Ù±‚`bs2Ù±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`Ù¢„fStructÙ „gIPythoni8.2.0.devfmodulexIPython.utils.ipstruct.StructfmoduleõÙ±‚`a(Ù±‚`aaÙ±‚aoa=Ù±‚bmib20Ù±‚`a,Ù±‚`abÙ±‚aoa=Ù±‚bmib40Ù±‚`a)Ù±‚`a
Ù±‚`hconflictÙ±‚`a Ù±‚aoa=Ù±‚`a Ù±‚`a{Ù±‚bs1a'Ù±‚bs1fupdateÙ±‚bs1a'Ù±‚`a:Ù±‚bs1a'Ù±‚bs1aaÙ±‚bs1a'Ù±‚`a,Ù±‚bs1a'Ù±‚bs1caddÙ±‚bs1a'Ù±‚`a:Ù±‚bs1a'Ù±‚bs1abÙ±‚bs1a'Ù±‚`a}Ù±‚`a
Ù±‚`asÙ±‚aoa.Ù±‚`Ù¢„emergeÙ „gIPythoni8.2.0.devfmodulex#IPython.utils.ipstruct.Struct.mergefmoduleõÙ±‚`a(Ù±‚`bs2Ù±‚`a,Ù±‚`hconflictÙ±‚`a)Ù±‚`a
Ù±‚bnbÙ¢„fsortedÙ „gIPythoni8.2.0.devfmodulex%IPython.lib.pretty._sorted_for_pprintfmoduleõÙ±‚`a(Ù±‚`asÙ±‚aoa.Ù±‚`eitemsÙ±‚`a(Ù±‚`a)Ù±‚`a)v[('a', 20), ('b', 70)]fexecedö€i8.2.0.devÙ«xBmerge(self, __loc_data__=None, _Struct__conflict_solve=None, **kw)öx#IPython.utils.ipstruct.Struct.merge€
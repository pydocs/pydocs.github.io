Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚Ù¹‚Ù§xÌWARNING: by putting in your own exception handler into IPython's main execution loop, you run a very good chance of nasty crashes.  This facility should only be used if you really know what you are doing.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‚Ù°ƒiexc_tuplextuple of exception classes‚Ù¹‚ƒÙ§bA Ù¨Ù§etupleÙ§xş of exception classes, for which to call the defined handler.  It is very important that you use a tuple, and NOT A LIST here, because of the way Python's except statement works.  If you only want to trap a single exception, use a singleton tuple::      €ÙÀx!exc_tuple == (MyCustomException,)Ù°ƒghandlerhcallable…Ù¹‚Ù§x1handler must have the following signature::      €ÙÀx_def my_handler(self, etype, value, tb, tb_offset=None):
    ...
    return structured_tracebackÙ¹‚Ù§xMYour handler must return a structured traceback (a list of strings), or None.€Ù¹‚Ù§xûThis will be made into an instance method (via types.MethodType) of IPython itself, and it will be called if any of the exceptions listed in the exc_tuple are caught. If the handler is None, an internal basic one is used, which just prints basic info.€Ù¹‚Ù§xˆTo protect IPython from crashes, if your handler ever raises an exception or returns an invalid result, it will be immediately disabled.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xšSet a custom exception handler, which will be called if any of the exceptions in exc_tuple occur in the mainloop (specifically, in the run_code() method).€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö„iSignaturegSummaryjParameterseNotesx-/dev/ipython/IPython/core/interactiveshell.pyçr<class 'function'>x'IPython.InteractiveShell.set_custom_excÙ¯‚€ö€i8.2.0.devÙ«x"set_custom_exc(exc_tuple, handler)öx=IPython.core.interactiveshell.InteractiveShell.set_custom_exc€
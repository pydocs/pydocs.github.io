Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒbgcv`.GraphicsContextBase`Ù¹‚Ù§x-A graphics context with clipping information.€Ù°ƒaxfscalarÙ¹‚Ù§x\The distance in physical units (i.e., dots or pixels) from the left hand side of the canvas.€Ù°ƒayfscalarÙ¹‚Ù§xYThe distance in physical units (i.e., dots or pixels) from the bottom side of the canvas.€Ù°ƒbimx (N, M, 4) array-like of np.uint8Ù¹‚Ù§xAn array of RGBA pixels.€Ù°ƒitransformx$`matplotlib.transforms.Affine2DBase`Ù¹‚˜Ù§x9If and only if the concrete backend is written such that Ù¢„roption_scale_imageÙ „jmatplotlibe3.5.1fmodulex8matplotlib.backend_bases.RendererBase.option_scale_imagefmoduleõÙ§i returns Ù¡dTrueÙ§x%, an affine transformation (i.e., an Ù¢„m.Affine2DBaseÙ „jmatplotlibe3.5.1fmodulex"matplotlib.transforms.Affine2DBasefmoduleõÙ§b) Ù¨Ù§cmayÙ§n be passed to Ù¢„jdraw_imageÙ „jmatplotlibe3.5.1fmodulex0matplotlib.backend_bases.RendererBase.draw_imagefmoduleõÙ§x’.  The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override Ù¨Ù§axÙ§e and Ù¨Ù§ayÙ§x, and has to be applied Ù¨Ù§fbeforeÙ§x translating the result by Ù¨Ù§axÙ§e and Ù¨Ù§ayÙ§x% (this can be accomplished by adding Ù¨Ù§axÙ§e and Ù¨Ù§ayÙ§x& to the translation vector defined by Ù¨Ù§itransformÙ§b).€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§sDraw an RGBA image.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummaryjParametersx/matplotlib/backend_bases.pyÌr<class 'function'>x0matplotlib.backend_bases.RendererBase.draw_imageÙ¯‚€ö€e3.5.1Ù«x.draw_image(self, gc, x, y, im, transform=None)öx0matplotlib.backend_bases.RendererBase.draw_image€
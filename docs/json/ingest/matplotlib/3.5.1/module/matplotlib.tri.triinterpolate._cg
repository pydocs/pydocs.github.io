Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒaAr_Sparse_Matrix_cooÙ¹‚‚Ù¨Ù§aAÙ§xI must have been compressed before by compress_csc or compress_csr method.€Ù°ƒabearrayÙ¹‚Ù§x%Right hand side of the linear system.€Ù°ƒbx0oarray, optionalÙ¹‚Ù§x=Starting guess for the solution. Defaults to the zero vector.€Ù°ƒctolofloat, optionalÙ¹‚Ù§xiTolerance to achieve. The algorithm terminates when the relative residual is below tol. Default is 1e-10.€Ù°ƒgmaxitermint, optionalÙ¹‚ƒÙ§x9Maximum number of iterations.  Iteration will stop after Ù¨Ù§gmaxiterÙ§xO steps even if the specified tolerance has not been achieved. Defaults to 1000.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒaxearrayÙ¹‚Ù§wThe converged solution.€Ù°ƒcerrefloatÙ¹‚Ù§x/The absolute error np.linalg.norm(A.dot(x) - b)€ögSummaryÙ¯‚Ù¹‚Ù§xtUse Preconditioned Conjugate Gradient iteration to solve A x = b A simple Jacobi (diagonal) preconditionner is used.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€öƒgSummaryjParametersgReturnsx!/matplotlib/tri/triinterpolate.pyr<class 'function'>x!matplotlib.tri.triinterpolate._cgÙ¯‚€ö€e3.5.1Ù«x+_cg(A, b, x0=None, tol=1e-10, maxiter=1000)öx!matplotlib.tri.triinterpolate._cg€
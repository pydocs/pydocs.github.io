{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Transforms are composed into trees of "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "TransformNode",
                  "reference": {
                    "module": "matplotlib",
                    "version": "3.5.1",
                    "kind": "module",
                    "path": "matplotlib.transforms.TransformNode"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " objects whose actual value depends on their children.  When the contents of children change, their parents are automatically invalidated.  The next time an invalidated transform is accessed, it is recomputed to reflect those changes.  This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "For example, here is a graph of the transform tree used to plot data to the graph:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "image",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": ".. / _static / transforms.png "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The framework can be used for both affine and non-affine transformations.  However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data.  The affine is always assumed to occur after the non-affine.  For any transform::    "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "full transform == non-affine part + affine part"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The backends are not expected to handle non-affine transformations themselves."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "matplotlib",
      "version": "3.5.1",
      "kind": "module",
      "path": "matplotlib.transforms.TransformNode"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/matplotlib/transforms.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "aliases": [
    "matplotlib.transforms"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "3.5.1",
  "signature": null,
  "references": null,
  "logo": "logo.png",
  "qa": "matplotlib.transforms",
  "arbitrary": [
    {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Transforms are composed into trees of "
                }
              },
              {
                "type": "Link",
                "data": {
                  "value": "TransformNode",
                  "reference": {
                    "module": "matplotlib",
                    "version": "3.5.1",
                    "kind": "module",
                    "path": "matplotlib.transforms.TransformNode"
                  },
                  "kind": "module",
                  "exists": true
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " objects whose actual value depends on their children.  When the contents of children change, their parents are automatically invalidated.  The next time an invalidated transform is accessed, it is recomputed to reflect those changes.  This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "For example, here is a graph of the transform tree used to plot data to the graph:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "directive_name": "image",
            "args0": [],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": ".. / _static / transforms.png "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The framework can be used for both affine and non-affine transformations.  However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data.  The affine is always assumed to occur after the non-affine.  For any transform::    "
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "value": "full transform == non-affine part + affine part"
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The backends are not expected to handle non-affine transformations themselves."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    }
  ]
}
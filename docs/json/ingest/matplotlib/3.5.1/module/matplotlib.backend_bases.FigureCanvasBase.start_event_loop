Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚…Ù¹‚…Ù§x=Such an event loop is used by interactive functions, such as Ù¢„o~.Figure.ginputÙ „jmatplotlibe3.5.1fmodulexmatplotlib.figure.Figure.ginputfmoduleõÙ§e and Ù¢„x~.Figure.waitforbuttonpressÙ „jmatplotlibe3.5.1fmodulex+matplotlib.figure.Figure.waitforbuttonpressfmoduleõÙ§u, to wait for events.€Ù¹‚…Ù§x9The event loop blocks until a callback function triggers Ù¢„ostop_event_loopÙ „jmatplotlibe3.5.1fmodulex9matplotlib.backend_bases.FigureCanvasBase.stop_event_loopfmoduleõÙ§e, or Ù¨Ù§gtimeoutÙ§l is reached.€Ù¹‚ƒÙ§cIf Ù¨Ù§gtimeoutÙ§x! is 0 or negative, never timeout.€Ù¹‚ƒÙ§xKOnly interactive backends need to reimplement this method and it relies on Ù¢„lflush_eventsÙ „jmatplotlibe3.5.1fmodulex6matplotlib.backend_bases.FigureCanvasBase.flush_eventsfmoduleõÙ§x being properly implemented.€Ù¹‚Ù§x@Interactive backends should implement this in a more native way.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§xStart a blocking event loop.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö‚gSummarypExtended Summaryx/matplotlib/backend_bases.py	¾r<class 'function'>x2matplotlib.image.FigureCanvasBase.start_event_loopÙ¯‚€ö€e3.5.1Ù«x!start_event_loop(self, timeout=0)öx:matplotlib.backend_bases.FigureCanvasBase.start_event_loop€
Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚Ù§y"In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2D inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node.€Ù¹‚Ù§yFThe CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)€ögMethodsÙ¯‚‚Ù°ƒq`__call__` (x, y)x-Returns interpolated values at (x, y) points.€Ù°ƒq`gradient` (x, y)x2Returns interpolated derivatives at (x, y) points.€öeNotesÙ¯‚…Ù¹‚Ù§xQThis note is a bit technical and details how the cubic interpolation is computed.€Ù¹‚ƒÙ§xHThe interpolation is based on a Clough-Tocher subdivision scheme of the Ù¨Ù§mtriangulationÙ§y9 mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in . The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges).€Ù¹‚ƒÙ§uIn the default case (Ù¨Ù§dkindÙ§yG ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from  - PCG sparse solver):€Ù·‡i.. math::`x+    E(z) = \frac{1}{2} \int_{\Omega} \left(x>        \left( \frac{\partial^2{z}}{\partial{x}^2} \right)^2 +x>        \left( \frac{\partial^2{z}}{\partial{y}^2} \right)^2 +xF        2\left( \frac{\partial^2{z}}{\partial{y}\partial{x}} \right)^2r    \right) dx\,dyÙ¹‚ƒÙ§lIf the case Ù¨Ù§dkindÙ§xª ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids.€öpOther ParametersÙ¯‚€öjParametersÙ¯‚…Ù°ƒmtriangulationx`~matplotlib.tri.Triangulation`Ù¹‚Ù§x&The triangulation to interpolate over.€Ù°ƒazu(npoints,) array-likeÙ¹‚Ù§x@Array of values, defined at grid points, to interpolate between.€Ù°ƒdkindx#{'min_E', 'geom', 'user'}, optional‚Ù¹‚Ù§xiChoice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):€ÙÈƒÙ¹‚Ù§x^if 'min_E': (default) The derivatives at each node is computed   to minimize a bending energy.€Ù¹‚Ù§xœif 'geom': The derivatives at each node is computed as a   weighted average of relevant triangle normals. To be used for   speed optimization (large grids).€Ù¹‚ƒÙ§x*if 'user': The user provides the argument Ù¨Ù§bdzÙ§x#, no computation   is hence needed.€Ù°ƒitrifinderx%`~matplotlib.tri.TriFinder`, optionalÙ¹‚ƒÙ§xPIf not specified, the Triangulation's default TriFinder will be used by calling Ù¢„x.Triangulation.get_trifinderÙ „jmatplotlibe3.5.1fmodulex8matplotlib.tri.triangulation.Triangulation.get_trifinderfmoduleõÙ§a.€Ù°ƒbdzx+tuple of array-likes (dzdx, dzdy), optionalÙ¹‚‰Ù§nUsed only if  Ù¨Ù§dkindÙ§w ='user'. In this case Ù¨Ù§bdzÙ§xS must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as Ù¨Ù§azÙ§x2 and are the interpolant first derivatives at the Ù¨Ù§mtriangulationÙ§h points.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚€ögSummaryÙ¯‚Ù¹‚Ù§x(Cubic interpolator on a triangular grid.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgMethodseNotesjReferencesx!/matplotlib/tri/triinterpolate.pyn<class 'type'>x#matplotlib.tri.CubicTriInterpolatorÙ¯‚€ö€e3.5.1Ù«ööx2matplotlib.tri.triinterpolate.CubicTriInterpolator€
{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This method is also referred to as the improved Euler's method, or Heun's method. This method is favored over higher-order methods because:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "EnumeratedList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "To get decent looking trajectories and to sample every mask cell    on the trajectory we need a small timestep, so a lower order    solver doesn't hurt us unless the data is "
                      }
                    },
                    {
                      "type": "Emph",
                      "data": {
                        "value": {
                          "value": "very"
                        }
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " high resolution.    In fact, for cases where the user inputs    data smaller or of similar grid size to the mask grid, the higher    order corrections are negligible because of the very fast linear    interpolation used in "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": "interpgrid",
                        "reference": {
                          "module": "matplotlib",
                          "version": "3.5.1",
                          "kind": "module",
                          "path": "matplotlib.streamplot.interpgrid"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "EnumeratedList",
          "data": {
            "value": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "For high resolution input data (i.e. beyond the mask    resolution), we must reduce the timestep. Therefore, an adaptive    timestep is more suited to the problem as this would be very hard    to judge automatically otherwise."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using similar Python implementations) in most setups."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "2nd-order Runge-Kutta algorithm with adaptive step size."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "matplotlib",
      "version": "3.5.1",
      "kind": "module",
      "path": "matplotlib.streamplot.interpgrid"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/matplotlib/streamplot.py",
  "item_line": 511,
  "item_type": "<class 'function'>",
  "aliases": [
    "matplotlib.streamplot._integrate_rk12"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "3.5.1",
  "signature": "_integrate_rk12(x0, y0, dmap, f, maxlength)",
  "references": null,
  "logo": "logo.png",
  "qa": "matplotlib.streamplot._integrate_rk12",
  "arbitrary": []
}
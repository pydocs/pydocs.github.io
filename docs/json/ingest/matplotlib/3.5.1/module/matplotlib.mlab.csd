Ùª­jAttributesÙ¯‚€öpExtended SummaryÙ¯‚‚Ù¹‚•Ù§xThe cross spectral density Ù¥fP_{xy}Ù§x5 by Welch's average periodogram method.  The vectors Ù¨Ù§axÙ§e and Ù¨Ù§ayÙ§r are divided into Ù¨Ù§dNFFTÙ§x9 length segments.  Each segment is detrended by function Ù¨Ù§gdetrendÙ§x and windowed by function Ù¨Ù§fwindowÙ§c.  Ù¨Ù§hnoverlapÙ§xV gives the length of the overlap between segments.  The product of the direct FFTs of Ù¨Ù§axÙ§e and Ù¨Ù§ayÙ§x+ are averaged over each segment to compute Ù¥fP_{xy}Ù§x<, with a scaling to correct for power loss due to windowing.€Ù¹‚‹Ù§gIf len(Ù¨Ù§axÙ§d) < Ù¨Ù§dNFFTÙ§h or len(Ù¨Ù§ayÙ§d) < Ù¨Ù§dNFFTÙ§x, they will be zero padded to Ù¨Ù§dNFFTÙ§a.€ögMethodsÙ¯‚€öeNotesÙ¯‚€öpOther ParametersÙ¯‚€öjParametersÙ¯‚‰Ù°ƒdx, yw1-D arrays or sequencesÙ¹‚Ù§x'Arrays or sequences containing the data€Ù°ƒbFsqfloat, default: 2Ù¹‚ƒÙ§xbThe sampling frequency (samples per time unit).  It is used to calculate the Fourier frequencies, Ù¨Ù§efreqsÙ§x, in cycles per time unit.€Ù°ƒfwindowx/callable or ndarray, default: `.window_hanning`Ù¹‚‘Ù§x!A function or a vector of length Ù¨Ù§dNFFTÙ§x .  To create window vectors see Ù¢„o.window_hanningÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.window_hanningfmoduleõÙ§b, Ù¢„l.window_noneÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.window_nonefmoduleõÙ§b, Ù¢„nnumpy.blackmanÙ „enumpya*capinnumpy.blackmanfmoduleõÙ§b, Ù¢„mnumpy.hammingÙ „enumpya*capimnumpy.hammingfmoduleõÙ§b, Ù¢„nnumpy.bartlettÙ „enumpya*capinnumpy.bartlettfmoduleõÙ§b, Ù¢„lscipy.signalÙ „escipya*capilscipy.signalfmoduleõÙ§b, Ù¢„wscipy.signal.get_windowÙ „escipya*capix(scipy.signal.windows._windows.get_windowfmoduleõÙ§x‹, etc.  If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.€Ù°ƒesidesx-{'default', 'onesided', 'twosided'}, optionalÙ¹‚Ù§xÄWhich sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.€Ù°ƒfpad_tomint, optionalÙ¹‚ˆÙ§xnThe number of points to which the data segment is padded when performing the FFT.  This can be different from Ù¨Ù§dNFFTÙ§xø, which specifies the number of data points used.  While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the Ù¨Ù§anÙ§xA parameter in the call to fft(). The default is None, which sets Ù¨Ù§fpad_toÙ§j equal to Ù¨Ù§dNFFT€Ù°ƒdNFFTqint, default: 256Ù¹‚…Ù§xeThe number of data points used in each block for the FFT.  A power 2 is most efficient.  This should Ù¨Ù§cNOTÙ§xR be used to get zero padding, or the scaling of the result will be incorrect; use Ù¨Ù§fpad_toÙ§r for this instead.€Ù°ƒgdetrendx7{'none', 'mean', 'linear'} or callable, default: 'none'Ù¹‚‘Ù§xThe function applied to each segment before fft-ing, designed to remove the mean or linear trend.  Unlike in MATLAB, where the Ù¨Ù§gdetrendÙ§x= parameter is a vector, in Matplotlib it is a function.  The Ù¢„p~matplotlib.mlabÙ „jmatplotlibe3.5.1fmoduleomatplotlib.mlabfmoduleõÙ§p module defines Ù¢„m.detrend_noneÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_nonefmoduleõÙ§b, Ù¢„m.detrend_meanÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_meanfmoduleõÙ§f, and Ù¢„o.detrend_linearÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_linearfmoduleõÙ§xu, but you can use a custom function as well.  You can also use a string to choose one of the functions: 'none' calls Ù¢„m.detrend_noneÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_nonefmoduleõÙ§o. 'mean' calls Ù¢„m.detrend_meanÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_meanfmoduleõÙ§q. 'linear' calls Ù¢„o.detrend_linearÙ „jmatplotlibe3.5.1fmodulexmatplotlib.mlab.detrend_linearfmoduleõÙ§a.€Ù°ƒmscale_by_freqsbool, default: TrueÙ¹‚Ù§xæWhether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1.  This allows for integration over the returned frequency values.  The default is True for MATLAB compatibility.€Ù°ƒhnoverlapxint, default: 0 (no overlap)Ù¹‚Ù§x1The number of points of overlap between segments.€öfRaisesÙ¯‚€öhReceivesÙ¯‚€ögReturnsÙ¯‚‚Ù°ƒcPxyi1-D arrayÙ¹‚ƒÙ§x"The values for the cross spectrum Ù¥fP_{xy}Ù§x before scaling (real valued)€Ù°ƒefreqsi1-D arrayÙ¹‚‚Ù§x1The frequencies corresponding to the elements in Ù¨Ù§cPxy€ögSummaryÙ¯‚Ù¹‚Ù§x#Compute the cross-spectral density.€öhWarningsÙ¯‚€öeWarnsÙ¯‚€öfYieldsÙ¯‚€ö†gSummarypExtended SummaryjParametersgReturnsjReferenceshSee Alsos/matplotlib/mlab.pyEr<class 'function'>smatplotlib.mlab.csdÙ¯‚€öÙ¼ƒÙ»ƒcpsdsmatplotlib.mlab.psdõÙ¹‚ƒÙ§vequivalent to setting Ù¡ey = xÙ§a.€öe3.5.1Ù«xtcsd(x, y, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)ösmatplotlib.mlab.csd€
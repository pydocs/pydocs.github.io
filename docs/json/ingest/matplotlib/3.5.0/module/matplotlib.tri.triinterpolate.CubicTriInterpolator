{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2D inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Methods": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "`__call__` (x, y)",
            "type_": "Returns interpolated values at (x, y) points.",
            "desc": []
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "`gradient` (x, y)",
            "type_": "Returns interpolated derivatives at (x, y) points.",
            "desc": []
          }
        }
      ],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This note is a bit technical and details how the cubic interpolation is computed."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The interpolation is based on a Clough-Tocher subdivision scheme of the "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "triangulation"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in . The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges)."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In the default case ("
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "kind"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from  - PCG sparse solver):"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockQuote",
          "data": {
            "value": [
              ".. math::",
              "",
              "    E(z) = \\frac{1}{2} \\int_{\\Omega} \\left(",
              "        \\left( \\frac{\\partial^2{z}}{\\partial{x}^2} \\right)^2 +",
              "        \\left( \\frac{\\partial^2{z}}{\\partial{y}^2} \\right)^2 +",
              "        2\\left( \\frac{\\partial^2{z}}{\\partial{y}\\partial{x}} \\right)^2",
              "    \\right) dx\\,dy"
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "If the case "
                }
              },
              {
                "type": "Emph",
                "data": {
                  "value": {
                    "value": "kind"
                  }
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "triangulation",
            "type_": "`~matplotlib.tri.Triangulation`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The triangulation to interpolate over."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "z",
            "type_": "(npoints,) array-like",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Array of values, defined at grid points, to interpolate between."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "kind",
            "type_": "{'min_E', 'geom', 'user'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Choice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BulletList",
                "data": {
                  "value": [
                    {
                      "type": "Paragraph",
                      "data": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "if 'min_E': (default) The derivatives at each node is computed   to minimize a bending energy."
                            }
                          }
                        ],
                        "inner": []
                      }
                    },
                    {
                      "type": "Paragraph",
                      "data": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "if 'geom': The derivatives at each node is computed as a   weighted average of relevant triangle normals. To be used for   speed optimization (large grids)."
                            }
                          }
                        ],
                        "inner": []
                      }
                    },
                    {
                      "type": "Paragraph",
                      "data": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "if 'user': The user provides the argument "
                            }
                          },
                          {
                            "type": "Emph",
                            "data": {
                              "value": {
                                "value": "dz"
                              }
                            }
                          },
                          {
                            "type": "Words",
                            "data": {
                              "value": ", no computation   is hence needed."
                            }
                          }
                        ],
                        "inner": []
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "trifinder",
            "type_": "`~matplotlib.tri.TriFinder`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If not specified, the Triangulation's default TriFinder will be used by calling "
                      }
                    },
                    {
                      "type": "Link",
                      "data": {
                        "value": ".Triangulation.get_trifinder",
                        "reference": {
                          "module": "matplotlib",
                          "version": "3.5.0",
                          "kind": "module",
                          "path": "matplotlib.tri.triangulation.Triangulation.get_trifinder"
                        },
                        "kind": "module",
                        "exists": true
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "dz",
            "type_": "tuple of array-likes (dzdx, dzdy), optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Used only if  "
                      }
                    },
                    {
                      "type": "Emph",
                      "data": {
                        "value": {
                          "value": "kind"
                        }
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " ='user'. In this case "
                      }
                    },
                    {
                      "type": "Emph",
                      "data": {
                        "value": {
                          "value": "dz"
                        }
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as "
                      }
                    },
                    {
                      "type": "Emph",
                      "data": {
                        "value": {
                          "value": "z"
                        }
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and are the interpolant first derivatives at the "
                      }
                    },
                    {
                      "type": "Emph",
                      "data": {
                        "value": {
                          "value": "triangulation"
                        }
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " points."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Cubic interpolator on a triangular grid."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    {
      "module": "matplotlib",
      "version": "3.5.0",
      "kind": "module",
      "path": "matplotlib.tri.triangulation.Triangulation.get_trifinder"
    }
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Methods",
    "Notes",
    "References"
  ],
  "item_file": "/matplotlib/tri/triinterpolate.py",
  "item_line": 287,
  "item_type": "<class 'type'>",
  "aliases": [
    "matplotlib.tri.CubicTriInterpolator"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "version": "3.5.0",
  "signature": "CubicTriInterpolator(triangulation, z, kind='min_E', trifinder=None, dz=None)",
  "references": null,
  "logo": "logo.png",
  "qa": "matplotlib.tri.triinterpolate.CubicTriInterpolator",
  "arbitrary": []
}